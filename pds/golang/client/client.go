// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
  util  "github.com/alibabacloud-go/tea-utils/service"
  roautil  "github.com/alibabacloud-go/tea-roa-utils/service"
  credential  "github.com/aliyun/credentials-go/credentials"
  accesstokencredential  "github.com/alibabacloud-go/pds-credentials/service"
  "github.com/alibabacloud-go/tea/tea"
)

type RuntimeOptions struct {
  // whether to try again
  Autoretry *bool `json:"autoretry,omitempty" xml:"autoretry,omitempty"`
  // ignore SSL validation
  IgnoreSSL *bool `json:"ignoreSSL,omitempty" xml:"ignoreSSL,omitempty"`
  // maximum number of retries
  MaxAttempts *int `json:"maxAttempts,omitempty" xml:"maxAttempts,omitempty"`
  // backoff policy
  BackoffPolicy *string `json:"backoffPolicy,omitempty" xml:"backoffPolicy,omitempty"`
  // backoff period
  BackoffPeriod *int `json:"backoffPeriod,omitempty" xml:"backoffPeriod,omitempty"`
  // read timeout
  ReadTimeout *int `json:"readTimeout,omitempty" xml:"readTimeout,omitempty"`
  // connect timeout
  ConnectTimeout *int `json:"connectTimeout,omitempty" xml:"connectTimeout,omitempty"`
  // http proxy url
  HttpProxy *string `json:"httpProxy,omitempty" xml:"httpProxy,omitempty"`
  // https Proxy url
  HttpsProxy *string `json:"httpsProxy,omitempty" xml:"httpsProxy,omitempty"`
  // agent blacklist
  NoProxy *string `json:"noProxy,omitempty" xml:"noProxy,omitempty"`
  // maximum number of connections
  MaxIdleConns *int `json:"maxIdleConns,omitempty" xml:"maxIdleConns,omitempty"`
  // local addr
  LocalAddr *string `json:"localAddr,omitempty" xml:"localAddr,omitempty"`
  // SOCKS5 proxy
  Socks5Proxy *string `json:"socks5Proxy,omitempty" xml:"socks5Proxy,omitempty"`
  // SOCKS5 netWork
  Socks5NetWork *string `json:"socks5NetWork,omitempty" xml:"socks5NetWork,omitempty"`
}

func (s RuntimeOptions) String() string {
  return tea.Prettify(s)
}

func (s RuntimeOptions) GoString() string {
  return s.String()
}

func (s *RuntimeOptions) SetAutoretry(v bool) *RuntimeOptions {
  s.Autoretry = &v
  return s
}

func (s *RuntimeOptions) SetIgnoreSSL(v bool) *RuntimeOptions {
  s.IgnoreSSL = &v
  return s
}

func (s *RuntimeOptions) SetMaxAttempts(v int) *RuntimeOptions {
  s.MaxAttempts = &v
  return s
}

func (s *RuntimeOptions) SetBackoffPolicy(v string) *RuntimeOptions {
  s.BackoffPolicy = &v
  return s
}

func (s *RuntimeOptions) SetBackoffPeriod(v int) *RuntimeOptions {
  s.BackoffPeriod = &v
  return s
}

func (s *RuntimeOptions) SetReadTimeout(v int) *RuntimeOptions {
  s.ReadTimeout = &v
  return s
}

func (s *RuntimeOptions) SetConnectTimeout(v int) *RuntimeOptions {
  s.ConnectTimeout = &v
  return s
}

func (s *RuntimeOptions) SetHttpProxy(v string) *RuntimeOptions {
  s.HttpProxy = &v
  return s
}

func (s *RuntimeOptions) SetHttpsProxy(v string) *RuntimeOptions {
  s.HttpsProxy = &v
  return s
}

func (s *RuntimeOptions) SetNoProxy(v string) *RuntimeOptions {
  s.NoProxy = &v
  return s
}

func (s *RuntimeOptions) SetMaxIdleConns(v int) *RuntimeOptions {
  s.MaxIdleConns = &v
  return s
}

func (s *RuntimeOptions) SetLocalAddr(v string) *RuntimeOptions {
  s.LocalAddr = &v
  return s
}

func (s *RuntimeOptions) SetSocks5Proxy(v string) *RuntimeOptions {
  s.Socks5Proxy = &v
  return s
}

func (s *RuntimeOptions) SetSocks5NetWork(v string) *RuntimeOptions {
  s.Socks5NetWork = &v
  return s
}

type Config struct {
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
  DomainId *string `json:"domainId,omitempty" xml:"domainId,omitempty" pattern:"^[a-zA-Z0-9_-]+$"`
  ClientId *string `json:"clientId,omitempty" xml:"clientId,omitempty"`
  RefreshToken *string `json:"refreshToken,omitempty" xml:"refreshToken,omitempty"`
  ClientSecret *string `json:"clientSecret,omitempty" xml:"clientSecret,omitempty"`
  AccessToken *string `json:"accessToken,omitempty" xml:"accessToken,omitempty"`
  ExpireTime *string `json:"expireTime,omitempty" xml:"expireTime,omitempty"`
  Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  SecurityToken *string `json:"securityToken,omitempty" xml:"securityToken,omitempty"`
  AccessKeyId *string `json:"accessKeyId,omitempty" xml:"accessKeyId,omitempty"`
  AccessKeySecret *string `json:"accessKeySecret,omitempty" xml:"accessKeySecret,omitempty"`
  Nickname *string `json:"nickname,omitempty" xml:"nickname,omitempty"`
  UserAgent *string `json:"userAgent,omitempty" xml:"userAgent,omitempty"`
}

func (s Config) String() string {
  return tea.Prettify(s)
}

func (s Config) GoString() string {
  return s.String()
}

func (s *Config) SetEndpoint(v string) *Config {
  s.Endpoint = &v
  return s
}

func (s *Config) SetDomainId(v string) *Config {
  s.DomainId = &v
  return s
}

func (s *Config) SetClientId(v string) *Config {
  s.ClientId = &v
  return s
}

func (s *Config) SetRefreshToken(v string) *Config {
  s.RefreshToken = &v
  return s
}

func (s *Config) SetClientSecret(v string) *Config {
  s.ClientSecret = &v
  return s
}

func (s *Config) SetAccessToken(v string) *Config {
  s.AccessToken = &v
  return s
}

func (s *Config) SetExpireTime(v string) *Config {
  s.ExpireTime = &v
  return s
}

func (s *Config) SetProtocol(v string) *Config {
  s.Protocol = &v
  return s
}

func (s *Config) SetType(v string) *Config {
  s.Type = &v
  return s
}

func (s *Config) SetSecurityToken(v string) *Config {
  s.SecurityToken = &v
  return s
}

func (s *Config) SetAccessKeyId(v string) *Config {
  s.AccessKeyId = &v
  return s
}

func (s *Config) SetAccessKeySecret(v string) *Config {
  s.AccessKeySecret = &v
  return s
}

func (s *Config) SetNickname(v string) *Config {
  s.Nickname = &v
  return s
}

func (s *Config) SetUserAgent(v string) *Config {
  s.UserAgent = &v
  return s
}

type CancelLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelLinkModel) String() string {
  return tea.Prettify(s)
}

func (s CancelLinkModel) GoString() string {
  return s.String()
}

func (s *CancelLinkModel) SetHeaders(v map[string]*string) *CancelLinkModel {
  s.Headers = v
  return s
}

func (s *CancelLinkModel) SetBody(v *AccountAccessTokenResponse) *CancelLinkModel {
  s.Body = v
  return s
}

type ConfirmLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfirmLinkModel) String() string {
  return tea.Prettify(s)
}

func (s ConfirmLinkModel) GoString() string {
  return s.String()
}

func (s *ConfirmLinkModel) SetHeaders(v map[string]*string) *ConfirmLinkModel {
  s.Headers = v
  return s
}

func (s *ConfirmLinkModel) SetBody(v *AccountAccessTokenResponse) *ConfirmLinkModel {
  s.Body = v
  return s
}

type ChangePasswordModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangePasswordModel) String() string {
  return tea.Prettify(s)
}

func (s ChangePasswordModel) GoString() string {
  return s.String()
}

func (s *ChangePasswordModel) SetHeaders(v map[string]*string) *ChangePasswordModel {
  s.Headers = v
  return s
}

func (s *ChangePasswordModel) SetBody(v *AccountAccessTokenResponse) *ChangePasswordModel {
  s.Body = v
  return s
}

type SetPasswordModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s SetPasswordModel) String() string {
  return tea.Prettify(s)
}

func (s SetPasswordModel) GoString() string {
  return s.String()
}

func (s *SetPasswordModel) SetHeaders(v map[string]*string) *SetPasswordModel {
  s.Headers = v
  return s
}

type VerifyCodeModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *VerifyCodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyCodeModel) String() string {
  return tea.Prettify(s)
}

func (s VerifyCodeModel) GoString() string {
  return s.String()
}

func (s *VerifyCodeModel) SetHeaders(v map[string]*string) *VerifyCodeModel {
  s.Headers = v
  return s
}

func (s *VerifyCodeModel) SetBody(v *VerifyCodeResponse) *VerifyCodeModel {
  s.Body = v
  return s
}

type GetAccessTokenByLinkInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAccessTokenByLinkInfoModel) String() string {
  return tea.Prettify(s)
}

func (s GetAccessTokenByLinkInfoModel) GoString() string {
  return s.String()
}

func (s *GetAccessTokenByLinkInfoModel) SetHeaders(v map[string]*string) *GetAccessTokenByLinkInfoModel {
  s.Headers = v
  return s
}

func (s *GetAccessTokenByLinkInfoModel) SetBody(v *AccountAccessTokenResponse) *GetAccessTokenByLinkInfoModel {
  s.Body = v
  return s
}

type GetLinkInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *LinkInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLinkInfoModel) String() string {
  return tea.Prettify(s)
}

func (s GetLinkInfoModel) GoString() string {
  return s.String()
}

func (s *GetLinkInfoModel) SetHeaders(v map[string]*string) *GetLinkInfoModel {
  s.Headers = v
  return s
}

func (s *GetLinkInfoModel) SetBody(v *LinkInfoResponse) *GetLinkInfoModel {
  s.Body = v
  return s
}

type GetLinkInfoByUserIdModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *LinkInfoListResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLinkInfoByUserIdModel) String() string {
  return tea.Prettify(s)
}

func (s GetLinkInfoByUserIdModel) GoString() string {
  return s.String()
}

func (s *GetLinkInfoByUserIdModel) SetHeaders(v map[string]*string) *GetLinkInfoByUserIdModel {
  s.Headers = v
  return s
}

func (s *GetLinkInfoByUserIdModel) SetBody(v *LinkInfoListResponse) *GetLinkInfoByUserIdModel {
  s.Body = v
  return s
}

type GetPublicKeyModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetPublicKeyResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPublicKeyModel) String() string {
  return tea.Prettify(s)
}

func (s GetPublicKeyModel) GoString() string {
  return s.String()
}

func (s *GetPublicKeyModel) SetHeaders(v map[string]*string) *GetPublicKeyModel {
  s.Headers = v
  return s
}

func (s *GetPublicKeyModel) SetBody(v *GetPublicKeyResponse) *GetPublicKeyModel {
  s.Body = v
  return s
}

type LinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LinkModel) String() string {
  return tea.Prettify(s)
}

func (s LinkModel) GoString() string {
  return s.String()
}

func (s *LinkModel) SetHeaders(v map[string]*string) *LinkModel {
  s.Headers = v
  return s
}

func (s *LinkModel) SetBody(v *AccountAccessTokenResponse) *LinkModel {
  s.Body = v
  return s
}

type CheckExistModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *MobileCheckExistResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckExistModel) String() string {
  return tea.Prettify(s)
}

func (s CheckExistModel) GoString() string {
  return s.String()
}

func (s *CheckExistModel) SetHeaders(v map[string]*string) *CheckExistModel {
  s.Headers = v
  return s
}

func (s *CheckExistModel) SetBody(v *MobileCheckExistResponse) *CheckExistModel {
  s.Body = v
  return s
}

type LoginModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LoginModel) String() string {
  return tea.Prettify(s)
}

func (s LoginModel) GoString() string {
  return s.String()
}

func (s *LoginModel) SetHeaders(v map[string]*string) *LoginModel {
  s.Headers = v
  return s
}

func (s *LoginModel) SetBody(v *AccountAccessTokenResponse) *LoginModel {
  s.Body = v
  return s
}

type RegisterModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterModel) String() string {
  return tea.Prettify(s)
}

func (s RegisterModel) GoString() string {
  return s.String()
}

func (s *RegisterModel) SetHeaders(v map[string]*string) *RegisterModel {
  s.Headers = v
  return s
}

func (s *RegisterModel) SetBody(v *AccountAccessTokenResponse) *RegisterModel {
  s.Body = v
  return s
}

type MobileSendSmsCodeModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *MobileSendSmsCodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MobileSendSmsCodeModel) String() string {
  return tea.Prettify(s)
}

func (s MobileSendSmsCodeModel) GoString() string {
  return s.String()
}

func (s *MobileSendSmsCodeModel) SetHeaders(v map[string]*string) *MobileSendSmsCodeModel {
  s.Headers = v
  return s
}

func (s *MobileSendSmsCodeModel) SetBody(v *MobileSendSmsCodeResponse) *MobileSendSmsCodeModel {
  s.Body = v
  return s
}

type AccountRevokeModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AccountRevokeModel) String() string {
  return tea.Prettify(s)
}

func (s AccountRevokeModel) GoString() string {
  return s.String()
}

func (s *AccountRevokeModel) SetHeaders(v map[string]*string) *AccountRevokeModel {
  s.Headers = v
  return s
}

type AccountTokenModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AccountTokenModel) String() string {
  return tea.Prettify(s)
}

func (s AccountTokenModel) GoString() string {
  return s.String()
}

func (s *AccountTokenModel) SetHeaders(v map[string]*string) *AccountTokenModel {
  s.Headers = v
  return s
}

func (s *AccountTokenModel) SetBody(v *AccountAccessTokenResponse) *AccountTokenModel {
  s.Body = v
  return s
}

type AdminListStoresModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListStoresResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AdminListStoresModel) String() string {
  return tea.Prettify(s)
}

func (s AdminListStoresModel) GoString() string {
  return s.String()
}

func (s *AdminListStoresModel) SetHeaders(v map[string]*string) *AdminListStoresModel {
  s.Headers = v
  return s
}

func (s *AdminListStoresModel) SetBody(v *ListStoresResponse) *AdminListStoresModel {
  s.Body = v
  return s
}

type CreateSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s CreateSubdomainModel) GoString() string {
  return s.String()
}

func (s *CreateSubdomainModel) SetHeaders(v map[string]*string) *CreateSubdomainModel {
  s.Headers = v
  return s
}

func (s *CreateSubdomainModel) SetBody(v *CreateSubdomainResponse) *CreateSubdomainModel {
  s.Body = v
  return s
}

type DeleteSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *DeleteSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteSubdomainModel) GoString() string {
  return s.String()
}

func (s *DeleteSubdomainModel) SetHeaders(v map[string]*string) *DeleteSubdomainModel {
  s.Headers = v
  return s
}

func (s *DeleteSubdomainModel) SetBody(v *DeleteSubdomainResponse) *DeleteSubdomainModel {
  s.Body = v
  return s
}

type GetSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s GetSubdomainModel) GoString() string {
  return s.String()
}

func (s *GetSubdomainModel) SetHeaders(v map[string]*string) *GetSubdomainModel {
  s.Headers = v
  return s
}

func (s *GetSubdomainModel) SetBody(v *GetSubdomainResponse) *GetSubdomainModel {
  s.Body = v
  return s
}

type ListSubdomainsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListSubdomainsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSubdomainsModel) String() string {
  return tea.Prettify(s)
}

func (s ListSubdomainsModel) GoString() string {
  return s.String()
}

func (s *ListSubdomainsModel) SetHeaders(v map[string]*string) *ListSubdomainsModel {
  s.Headers = v
  return s
}

func (s *ListSubdomainsModel) SetBody(v *ListSubdomainsResponse) *ListSubdomainsModel {
  s.Body = v
  return s
}

type UpdateSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateSubdomainModel) GoString() string {
  return s.String()
}

func (s *UpdateSubdomainModel) SetHeaders(v map[string]*string) *UpdateSubdomainModel {
  s.Headers = v
  return s
}

func (s *UpdateSubdomainModel) SetBody(v *UpdateSubdomainResponse) *UpdateSubdomainModel {
  s.Body = v
  return s
}

type GetUserAccessTokenModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetUserAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserAccessTokenModel) String() string {
  return tea.Prettify(s)
}

func (s GetUserAccessTokenModel) GoString() string {
  return s.String()
}

func (s *GetUserAccessTokenModel) SetHeaders(v map[string]*string) *GetUserAccessTokenModel {
  s.Headers = v
  return s
}

func (s *GetUserAccessTokenModel) SetBody(v *GetUserAccessTokenResponse) *GetUserAccessTokenModel {
  s.Body = v
  return s
}

type GetAsyncTaskInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetAsyncTaskResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAsyncTaskInfoModel) String() string {
  return tea.Prettify(s)
}

func (s GetAsyncTaskInfoModel) GoString() string {
  return s.String()
}

func (s *GetAsyncTaskInfoModel) SetHeaders(v map[string]*string) *GetAsyncTaskInfoModel {
  s.Headers = v
  return s
}

func (s *GetAsyncTaskInfoModel) SetBody(v *GetAsyncTaskResponse) *GetAsyncTaskInfoModel {
  s.Body = v
  return s
}

type BatchOperationModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *BatchResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchOperationModel) String() string {
  return tea.Prettify(s)
}

func (s BatchOperationModel) GoString() string {
  return s.String()
}

func (s *BatchOperationModel) SetHeaders(v map[string]*string) *BatchOperationModel {
  s.Headers = v
  return s
}

func (s *BatchOperationModel) SetBody(v *BatchResponse) *BatchOperationModel {
  s.Body = v
  return s
}

type CreateDriveModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDriveModel) String() string {
  return tea.Prettify(s)
}

func (s CreateDriveModel) GoString() string {
  return s.String()
}

func (s *CreateDriveModel) SetHeaders(v map[string]*string) *CreateDriveModel {
  s.Headers = v
  return s
}

func (s *CreateDriveModel) SetBody(v *CreateDriveResponse) *CreateDriveModel {
  s.Body = v
  return s
}

type DeleteDriveModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteDriveModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteDriveModel) GoString() string {
  return s.String()
}

func (s *DeleteDriveModel) SetHeaders(v map[string]*string) *DeleteDriveModel {
  s.Headers = v
  return s
}

type GetDriveModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDriveModel) String() string {
  return tea.Prettify(s)
}

func (s GetDriveModel) GoString() string {
  return s.String()
}

func (s *GetDriveModel) SetHeaders(v map[string]*string) *GetDriveModel {
  s.Headers = v
  return s
}

func (s *GetDriveModel) SetBody(v *GetDriveResponse) *GetDriveModel {
  s.Body = v
  return s
}

type GetDefaultDriveModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDefaultDriveModel) String() string {
  return tea.Prettify(s)
}

func (s GetDefaultDriveModel) GoString() string {
  return s.String()
}

func (s *GetDefaultDriveModel) SetHeaders(v map[string]*string) *GetDefaultDriveModel {
  s.Headers = v
  return s
}

func (s *GetDefaultDriveModel) SetBody(v *GetDriveResponse) *GetDefaultDriveModel {
  s.Body = v
  return s
}

type ListDrivesModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDrivesModel) String() string {
  return tea.Prettify(s)
}

func (s ListDrivesModel) GoString() string {
  return s.String()
}

func (s *ListDrivesModel) SetHeaders(v map[string]*string) *ListDrivesModel {
  s.Headers = v
  return s
}

func (s *ListDrivesModel) SetBody(v *ListDriveResponse) *ListDrivesModel {
  s.Body = v
  return s
}

type ListMyDrivesModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListMyDrivesModel) String() string {
  return tea.Prettify(s)
}

func (s ListMyDrivesModel) GoString() string {
  return s.String()
}

func (s *ListMyDrivesModel) SetHeaders(v map[string]*string) *ListMyDrivesModel {
  s.Headers = v
  return s
}

func (s *ListMyDrivesModel) SetBody(v *ListDriveResponse) *ListMyDrivesModel {
  s.Body = v
  return s
}

type UpdateDriveModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDriveModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateDriveModel) GoString() string {
  return s.String()
}

func (s *UpdateDriveModel) SetHeaders(v map[string]*string) *UpdateDriveModel {
  s.Headers = v
  return s
}

func (s *UpdateDriveModel) SetBody(v *UpdateDriveResponse) *UpdateDriveModel {
  s.Body = v
  return s
}

type ArchiveFilesModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CCPArchiveFilesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ArchiveFilesModel) String() string {
  return tea.Prettify(s)
}

func (s ArchiveFilesModel) GoString() string {
  return s.String()
}

func (s *ArchiveFilesModel) SetHeaders(v map[string]*string) *ArchiveFilesModel {
  s.Headers = v
  return s
}

func (s *ArchiveFilesModel) SetBody(v *CCPArchiveFilesResponse) *ArchiveFilesModel {
  s.Body = v
  return s
}

type CompleteFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CompleteFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteFileModel) String() string {
  return tea.Prettify(s)
}

func (s CompleteFileModel) GoString() string {
  return s.String()
}

func (s *CompleteFileModel) SetHeaders(v map[string]*string) *CompleteFileModel {
  s.Headers = v
  return s
}

func (s *CompleteFileModel) SetBody(v *CompleteFileResponse) *CompleteFileModel {
  s.Body = v
  return s
}

type CopyFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CopyFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyFileModel) String() string {
  return tea.Prettify(s)
}

func (s CopyFileModel) GoString() string {
  return s.String()
}

func (s *CopyFileModel) SetHeaders(v map[string]*string) *CopyFileModel {
  s.Headers = v
  return s
}

func (s *CopyFileModel) SetBody(v *CopyFileResponse) *CopyFileModel {
  s.Body = v
  return s
}

type CreateFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFileModel) String() string {
  return tea.Prettify(s)
}

func (s CreateFileModel) GoString() string {
  return s.String()
}

func (s *CreateFileModel) SetHeaders(v map[string]*string) *CreateFileModel {
  s.Headers = v
  return s
}

func (s *CreateFileModel) SetBody(v *CreateFileResponse) *CreateFileModel {
  s.Body = v
  return s
}

type CreateFileWithProofModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFileWithProofModel) String() string {
  return tea.Prettify(s)
}

func (s CreateFileWithProofModel) GoString() string {
  return s.String()
}

func (s *CreateFileWithProofModel) SetHeaders(v map[string]*string) *CreateFileWithProofModel {
  s.Headers = v
  return s
}

func (s *CreateFileWithProofModel) SetBody(v *CreateFileResponse) *CreateFileWithProofModel {
  s.Body = v
  return s
}

type DeleteFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *DeleteFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFileModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteFileModel) GoString() string {
  return s.String()
}

func (s *DeleteFileModel) SetHeaders(v map[string]*string) *DeleteFileModel {
  s.Headers = v
  return s
}

func (s *DeleteFileModel) SetBody(v *DeleteFileResponse) *DeleteFileModel {
  s.Body = v
  return s
}

type GetFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileModel) String() string {
  return tea.Prettify(s)
}

func (s GetFileModel) GoString() string {
  return s.String()
}

func (s *GetFileModel) SetHeaders(v map[string]*string) *GetFileModel {
  s.Headers = v
  return s
}

func (s *GetFileModel) SetBody(v *GetFileResponse) *GetFileModel {
  s.Body = v
  return s
}

type GetFileByPathModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetFileByPathResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileByPathModel) String() string {
  return tea.Prettify(s)
}

func (s GetFileByPathModel) GoString() string {
  return s.String()
}

func (s *GetFileByPathModel) SetHeaders(v map[string]*string) *GetFileByPathModel {
  s.Headers = v
  return s
}

func (s *GetFileByPathModel) SetBody(v *GetFileByPathResponse) *GetFileByPathModel {
  s.Body = v
  return s
}

type GetDownloadUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetDownloadUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDownloadUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetDownloadUrlModel) GoString() string {
  return s.String()
}

func (s *GetDownloadUrlModel) SetHeaders(v map[string]*string) *GetDownloadUrlModel {
  s.Headers = v
  return s
}

func (s *GetDownloadUrlModel) SetBody(v *GetDownloadUrlResponse) *GetDownloadUrlModel {
  s.Body = v
  return s
}

type GetLastCursorModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetLastCursorResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLastCursorModel) String() string {
  return tea.Prettify(s)
}

func (s GetLastCursorModel) GoString() string {
  return s.String()
}

func (s *GetLastCursorModel) SetHeaders(v map[string]*string) *GetLastCursorModel {
  s.Headers = v
  return s
}

func (s *GetLastCursorModel) SetBody(v *GetLastCursorResponse) *GetLastCursorModel {
  s.Body = v
  return s
}

type GetMediaPlayUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetMediaPlayURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaPlayUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetMediaPlayUrlModel) GoString() string {
  return s.String()
}

func (s *GetMediaPlayUrlModel) SetHeaders(v map[string]*string) *GetMediaPlayUrlModel {
  s.Headers = v
  return s
}

func (s *GetMediaPlayUrlModel) SetBody(v *GetMediaPlayURLResponse) *GetMediaPlayUrlModel {
  s.Body = v
  return s
}

type GetOfficeEditUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetOfficeEditUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOfficeEditUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetOfficeEditUrlModel) GoString() string {
  return s.String()
}

func (s *GetOfficeEditUrlModel) SetHeaders(v map[string]*string) *GetOfficeEditUrlModel {
  s.Headers = v
  return s
}

func (s *GetOfficeEditUrlModel) SetBody(v *GetOfficeEditUrlResponse) *GetOfficeEditUrlModel {
  s.Body = v
  return s
}

type GetOfficePreviewUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetOfficePreviewUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOfficePreviewUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetOfficePreviewUrlModel) GoString() string {
  return s.String()
}

func (s *GetOfficePreviewUrlModel) SetHeaders(v map[string]*string) *GetOfficePreviewUrlModel {
  s.Headers = v
  return s
}

func (s *GetOfficePreviewUrlModel) SetBody(v *GetOfficePreviewUrlResponse) *GetOfficePreviewUrlModel {
  s.Body = v
  return s
}

type GetShareLinkDownloadUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetShareLinkDownloadURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkDownloadUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkDownloadUrlModel) GoString() string {
  return s.String()
}

func (s *GetShareLinkDownloadUrlModel) SetHeaders(v map[string]*string) *GetShareLinkDownloadUrlModel {
  s.Headers = v
  return s
}

func (s *GetShareLinkDownloadUrlModel) SetBody(v *GetShareLinkDownloadURLResponse) *GetShareLinkDownloadUrlModel {
  s.Body = v
  return s
}

type GetShareLinkVideoPreviewPlayInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CCPGetShareLinkVideoPreviewPlayInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkVideoPreviewPlayInfoModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkVideoPreviewPlayInfoModel) GoString() string {
  return s.String()
}

func (s *GetShareLinkVideoPreviewPlayInfoModel) SetHeaders(v map[string]*string) *GetShareLinkVideoPreviewPlayInfoModel {
  s.Headers = v
  return s
}

func (s *GetShareLinkVideoPreviewPlayInfoModel) SetBody(v *CCPGetShareLinkVideoPreviewPlayInfoResponse) *GetShareLinkVideoPreviewPlayInfoModel {
  s.Body = v
  return s
}

type GetUploadUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetUploadUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUploadUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetUploadUrlModel) GoString() string {
  return s.String()
}

func (s *GetUploadUrlModel) SetHeaders(v map[string]*string) *GetUploadUrlModel {
  s.Headers = v
  return s
}

func (s *GetUploadUrlModel) SetBody(v *GetUploadUrlResponse) *GetUploadUrlModel {
  s.Body = v
  return s
}

type GetVideoPreviewPlayInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CCPGetVideoPreviewPlayInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewPlayInfoModel) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewPlayInfoModel) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewPlayInfoModel) SetHeaders(v map[string]*string) *GetVideoPreviewPlayInfoModel {
  s.Headers = v
  return s
}

func (s *GetVideoPreviewPlayInfoModel) SetBody(v *CCPGetVideoPreviewPlayInfoResponse) *GetVideoPreviewPlayInfoModel {
  s.Body = v
  return s
}

type GetVideoPreviewSpriteUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetVideoPreviewSpriteURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewSpriteUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteUrlModel) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewSpriteUrlModel) SetHeaders(v map[string]*string) *GetVideoPreviewSpriteUrlModel {
  s.Headers = v
  return s
}

func (s *GetVideoPreviewSpriteUrlModel) SetBody(v *GetVideoPreviewSpriteURLResponse) *GetVideoPreviewSpriteUrlModel {
  s.Body = v
  return s
}

type GetVideoPreviewUrlModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetVideoPreviewURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewUrlModel) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewUrlModel) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewUrlModel) SetHeaders(v map[string]*string) *GetVideoPreviewUrlModel {
  s.Headers = v
  return s
}

func (s *GetVideoPreviewUrlModel) SetBody(v *GetVideoPreviewURLResponse) *GetVideoPreviewUrlModel {
  s.Body = v
  return s
}

type ListFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileModel) String() string {
  return tea.Prettify(s)
}

func (s ListFileModel) GoString() string {
  return s.String()
}

func (s *ListFileModel) SetHeaders(v map[string]*string) *ListFileModel {
  s.Headers = v
  return s
}

func (s *ListFileModel) SetBody(v *ListFileResponse) *ListFileModel {
  s.Body = v
  return s
}

type ListFileActivityModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListFileActivityResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileActivityModel) String() string {
  return tea.Prettify(s)
}

func (s ListFileActivityModel) GoString() string {
  return s.String()
}

func (s *ListFileActivityModel) SetHeaders(v map[string]*string) *ListFileActivityModel {
  s.Headers = v
  return s
}

func (s *ListFileActivityModel) SetBody(v *ListFileActivityResponse) *ListFileActivityModel {
  s.Body = v
  return s
}

type ListFileByAnonymousModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListByAnonymousResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileByAnonymousModel) String() string {
  return tea.Prettify(s)
}

func (s ListFileByAnonymousModel) GoString() string {
  return s.String()
}

func (s *ListFileByAnonymousModel) SetHeaders(v map[string]*string) *ListFileByAnonymousModel {
  s.Headers = v
  return s
}

func (s *ListFileByAnonymousModel) SetBody(v *ListByAnonymousResponse) *ListFileByAnonymousModel {
  s.Body = v
  return s
}

type ListFileByCustomIndexKeyModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileByCustomIndexKeyModel) String() string {
  return tea.Prettify(s)
}

func (s ListFileByCustomIndexKeyModel) GoString() string {
  return s.String()
}

func (s *ListFileByCustomIndexKeyModel) SetHeaders(v map[string]*string) *ListFileByCustomIndexKeyModel {
  s.Headers = v
  return s
}

func (s *ListFileByCustomIndexKeyModel) SetBody(v *ListFileResponse) *ListFileByCustomIndexKeyModel {
  s.Body = v
  return s
}

type ListFileDeltaModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListFileDeltaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileDeltaModel) String() string {
  return tea.Prettify(s)
}

func (s ListFileDeltaModel) GoString() string {
  return s.String()
}

func (s *ListFileDeltaModel) SetHeaders(v map[string]*string) *ListFileDeltaModel {
  s.Headers = v
  return s
}

func (s *ListFileDeltaModel) SetBody(v *ListFileDeltaResponse) *ListFileDeltaModel {
  s.Body = v
  return s
}

type ListUploadedPartsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListUploadedPartResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUploadedPartsModel) String() string {
  return tea.Prettify(s)
}

func (s ListUploadedPartsModel) GoString() string {
  return s.String()
}

func (s *ListUploadedPartsModel) SetHeaders(v map[string]*string) *ListUploadedPartsModel {
  s.Headers = v
  return s
}

func (s *ListUploadedPartsModel) SetBody(v *ListUploadedPartResponse) *ListUploadedPartsModel {
  s.Body = v
  return s
}

type LiveTranscodeModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CCPLiveTranscodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LiveTranscodeModel) String() string {
  return tea.Prettify(s)
}

func (s LiveTranscodeModel) GoString() string {
  return s.String()
}

func (s *LiveTranscodeModel) SetHeaders(v map[string]*string) *LiveTranscodeModel {
  s.Headers = v
  return s
}

func (s *LiveTranscodeModel) SetBody(v *CCPLiveTranscodeResponse) *LiveTranscodeModel {
  s.Body = v
  return s
}

type MoveFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *MoveFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveFileModel) String() string {
  return tea.Prettify(s)
}

func (s MoveFileModel) GoString() string {
  return s.String()
}

func (s *MoveFileModel) SetHeaders(v map[string]*string) *MoveFileModel {
  s.Headers = v
  return s
}

func (s *MoveFileModel) SetBody(v *MoveFileResponse) *MoveFileModel {
  s.Body = v
  return s
}

type TokenModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *RefreshOfficeEditTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TokenModel) String() string {
  return tea.Prettify(s)
}

func (s TokenModel) GoString() string {
  return s.String()
}

func (s *TokenModel) SetHeaders(v map[string]*string) *TokenModel {
  s.Headers = v
  return s
}

func (s *TokenModel) SetBody(v *RefreshOfficeEditTokenResponse) *TokenModel {
  s.Body = v
  return s
}

type ScanFileMetaModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ScanFileMetaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ScanFileMetaModel) String() string {
  return tea.Prettify(s)
}

func (s ScanFileMetaModel) GoString() string {
  return s.String()
}

func (s *ScanFileMetaModel) SetHeaders(v map[string]*string) *ScanFileMetaModel {
  s.Headers = v
  return s
}

func (s *ScanFileMetaModel) SetBody(v *ScanFileMetaResponse) *ScanFileMetaModel {
  s.Body = v
  return s
}

type SearchFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *SearchFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchFileModel) String() string {
  return tea.Prettify(s)
}

func (s SearchFileModel) GoString() string {
  return s.String()
}

func (s *SearchFileModel) SetHeaders(v map[string]*string) *SearchFileModel {
  s.Headers = v
  return s
}

func (s *SearchFileModel) SetBody(v *SearchFileResponse) *SearchFileModel {
  s.Body = v
  return s
}

type UpdateFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateFileMetaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFileModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateFileModel) GoString() string {
  return s.String()
}

func (s *UpdateFileModel) SetHeaders(v map[string]*string) *UpdateFileModel {
  s.Headers = v
  return s
}

func (s *UpdateFileModel) SetBody(v *UpdateFileMetaResponse) *UpdateFileModel {
  s.Body = v
  return s
}

type WalkFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CCPWalkFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s WalkFileModel) String() string {
  return tea.Prettify(s)
}

func (s WalkFileModel) GoString() string {
  return s.String()
}

func (s *WalkFileModel) SetHeaders(v map[string]*string) *WalkFileModel {
  s.Headers = v
  return s
}

func (s *WalkFileModel) SetBody(v *CCPWalkFileResponse) *WalkFileModel {
  s.Body = v
  return s
}

type ClearRecyclebinModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ClearRecycleBinResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClearRecyclebinModel) String() string {
  return tea.Prettify(s)
}

func (s ClearRecyclebinModel) GoString() string {
  return s.String()
}

func (s *ClearRecyclebinModel) SetHeaders(v map[string]*string) *ClearRecyclebinModel {
  s.Headers = v
  return s
}

func (s *ClearRecyclebinModel) SetBody(v *ClearRecycleBinResponse) *ClearRecyclebinModel {
  s.Body = v
  return s
}

type ListRecyclebinModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRecyclebinModel) String() string {
  return tea.Prettify(s)
}

func (s ListRecyclebinModel) GoString() string {
  return s.String()
}

func (s *ListRecyclebinModel) SetHeaders(v map[string]*string) *ListRecyclebinModel {
  s.Headers = v
  return s
}

func (s *ListRecyclebinModel) SetBody(v *ListFileResponse) *ListRecyclebinModel {
  s.Body = v
  return s
}

type RestoreFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *RestoreFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestoreFileModel) String() string {
  return tea.Prettify(s)
}

func (s RestoreFileModel) GoString() string {
  return s.String()
}

func (s *RestoreFileModel) SetHeaders(v map[string]*string) *RestoreFileModel {
  s.Headers = v
  return s
}

func (s *RestoreFileModel) SetBody(v *RestoreFileResponse) *RestoreFileModel {
  s.Body = v
  return s
}

type TrashFileModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *TrashFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TrashFileModel) String() string {
  return tea.Prettify(s)
}

func (s TrashFileModel) GoString() string {
  return s.String()
}

func (s *TrashFileModel) SetHeaders(v map[string]*string) *TrashFileModel {
  s.Headers = v
  return s
}

func (s *TrashFileModel) SetBody(v *TrashFileResponse) *TrashFileModel {
  s.Body = v
  return s
}

type ReportEventModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ReportEventResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReportEventModel) String() string {
  return tea.Prettify(s)
}

func (s ReportEventModel) GoString() string {
  return s.String()
}

func (s *ReportEventModel) SetHeaders(v map[string]*string) *ReportEventModel {
  s.Headers = v
  return s
}

func (s *ReportEventModel) SetBody(v *ReportEventResponse) *ReportEventModel {
  s.Body = v
  return s
}

type CreateShareModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateShareModel) String() string {
  return tea.Prettify(s)
}

func (s CreateShareModel) GoString() string {
  return s.String()
}

func (s *CreateShareModel) SetHeaders(v map[string]*string) *CreateShareModel {
  s.Headers = v
  return s
}

func (s *CreateShareModel) SetBody(v *CreateShareResponse) *CreateShareModel {
  s.Body = v
  return s
}

type DeleteShareModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteShareModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteShareModel) GoString() string {
  return s.String()
}

func (s *DeleteShareModel) SetHeaders(v map[string]*string) *DeleteShareModel {
  s.Headers = v
  return s
}

type GetShareModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareModel) GoString() string {
  return s.String()
}

func (s *GetShareModel) SetHeaders(v map[string]*string) *GetShareModel {
  s.Headers = v
  return s
}

func (s *GetShareModel) SetBody(v *GetShareResponse) *GetShareModel {
  s.Body = v
  return s
}

type ListShareModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListShareModel) String() string {
  return tea.Prettify(s)
}

func (s ListShareModel) GoString() string {
  return s.String()
}

func (s *ListShareModel) SetHeaders(v map[string]*string) *ListShareModel {
  s.Headers = v
  return s
}

func (s *ListShareModel) SetBody(v *ListShareResponse) *ListShareModel {
  s.Body = v
  return s
}

type UpdateShareModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateShareModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareModel) GoString() string {
  return s.String()
}

func (s *UpdateShareModel) SetHeaders(v map[string]*string) *UpdateShareModel {
  s.Headers = v
  return s
}

func (s *UpdateShareModel) SetBody(v *UpdateShareResponse) *UpdateShareModel {
  s.Body = v
  return s
}

type CancelShareLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s CancelShareLinkModel) String() string {
  return tea.Prettify(s)
}

func (s CancelShareLinkModel) GoString() string {
  return s.String()
}

func (s *CancelShareLinkModel) SetHeaders(v map[string]*string) *CancelShareLinkModel {
  s.Headers = v
  return s
}

type CreateShareLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateShareLinkModel) String() string {
  return tea.Prettify(s)
}

func (s CreateShareLinkModel) GoString() string {
  return s.String()
}

func (s *CreateShareLinkModel) SetHeaders(v map[string]*string) *CreateShareLinkModel {
  s.Headers = v
  return s
}

func (s *CreateShareLinkModel) SetBody(v *CreateShareLinkResponse) *CreateShareLinkModel {
  s.Body = v
  return s
}

type GetShareLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *BaseShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkModel) GoString() string {
  return s.String()
}

func (s *GetShareLinkModel) SetHeaders(v map[string]*string) *GetShareLinkModel {
  s.Headers = v
  return s
}

func (s *GetShareLinkModel) SetBody(v *BaseShareLinkResponse) *GetShareLinkModel {
  s.Body = v
  return s
}

type GetShareByAnonymousModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetShareLinkByAnonymousResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareByAnonymousModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareByAnonymousModel) GoString() string {
  return s.String()
}

func (s *GetShareByAnonymousModel) SetHeaders(v map[string]*string) *GetShareByAnonymousModel {
  s.Headers = v
  return s
}

func (s *GetShareByAnonymousModel) SetBody(v *GetShareLinkByAnonymousResponse) *GetShareByAnonymousModel {
  s.Body = v
  return s
}

type GetShareIdModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetShareLinkIDResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareIdModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareIdModel) GoString() string {
  return s.String()
}

func (s *GetShareIdModel) SetHeaders(v map[string]*string) *GetShareIdModel {
  s.Headers = v
  return s
}

func (s *GetShareIdModel) SetBody(v *GetShareLinkIDResponse) *GetShareIdModel {
  s.Body = v
  return s
}

type GetShareTokenModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetShareLinkTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareTokenModel) String() string {
  return tea.Prettify(s)
}

func (s GetShareTokenModel) GoString() string {
  return s.String()
}

func (s *GetShareTokenModel) SetHeaders(v map[string]*string) *GetShareTokenModel {
  s.Headers = v
  return s
}

func (s *GetShareTokenModel) SetBody(v *GetShareLinkTokenResponse) *GetShareTokenModel {
  s.Body = v
  return s
}

type ListShareLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListShareLinkModel) String() string {
  return tea.Prettify(s)
}

func (s ListShareLinkModel) GoString() string {
  return s.String()
}

func (s *ListShareLinkModel) SetHeaders(v map[string]*string) *ListShareLinkModel {
  s.Headers = v
  return s
}

func (s *ListShareLinkModel) SetBody(v *ListShareLinkResponse) *ListShareLinkModel {
  s.Body = v
  return s
}

type UpdateShareLinkModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateShareLinkModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareLinkModel) GoString() string {
  return s.String()
}

func (s *UpdateShareLinkModel) SetHeaders(v map[string]*string) *UpdateShareLinkModel {
  s.Headers = v
  return s
}

func (s *UpdateShareLinkModel) SetBody(v *UpdateShareLinkResponse) *UpdateShareLinkModel {
  s.Body = v
  return s
}

type CreateGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGroupModel) String() string {
  return tea.Prettify(s)
}

func (s CreateGroupModel) GoString() string {
  return s.String()
}

func (s *CreateGroupModel) SetHeaders(v map[string]*string) *CreateGroupModel {
  s.Headers = v
  return s
}

func (s *CreateGroupModel) SetBody(v *CreateGroupResponse) *CreateGroupModel {
  s.Body = v
  return s
}

type DeleteGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *DeleteGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGroupModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteGroupModel) GoString() string {
  return s.String()
}

func (s *DeleteGroupModel) SetHeaders(v map[string]*string) *DeleteGroupModel {
  s.Headers = v
  return s
}

func (s *DeleteGroupModel) SetBody(v *DeleteGroupResponse) *DeleteGroupModel {
  s.Body = v
  return s
}

type GetGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGroupModel) String() string {
  return tea.Prettify(s)
}

func (s GetGroupModel) GoString() string {
  return s.String()
}

func (s *GetGroupModel) SetHeaders(v map[string]*string) *GetGroupModel {
  s.Headers = v
  return s
}

func (s *GetGroupModel) SetBody(v *GetGroupResponse) *GetGroupModel {
  s.Body = v
  return s
}

type ListGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGroupModel) String() string {
  return tea.Prettify(s)
}

func (s ListGroupModel) GoString() string {
  return s.String()
}

func (s *ListGroupModel) SetHeaders(v map[string]*string) *ListGroupModel {
  s.Headers = v
  return s
}

func (s *ListGroupModel) SetBody(v *ListGroupResponse) *ListGroupModel {
  s.Body = v
  return s
}

type SearchGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *SearchGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchGroupModel) String() string {
  return tea.Prettify(s)
}

func (s SearchGroupModel) GoString() string {
  return s.String()
}

func (s *SearchGroupModel) SetHeaders(v map[string]*string) *SearchGroupModel {
  s.Headers = v
  return s
}

func (s *SearchGroupModel) SetBody(v *SearchGroupResponse) *SearchGroupModel {
  s.Body = v
  return s
}

type UpdateGroupModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGroupModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateGroupModel) GoString() string {
  return s.String()
}

func (s *UpdateGroupModel) SetHeaders(v map[string]*string) *UpdateGroupModel {
  s.Headers = v
  return s
}

func (s *UpdateGroupModel) SetBody(v *UpdateGroupResponse) *UpdateGroupModel {
  s.Body = v
  return s
}

type CreateMembershipModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMembershipModel) String() string {
  return tea.Prettify(s)
}

func (s CreateMembershipModel) GoString() string {
  return s.String()
}

func (s *CreateMembershipModel) SetHeaders(v map[string]*string) *CreateMembershipModel {
  s.Headers = v
  return s
}

func (s *CreateMembershipModel) SetBody(v *CreateMembershipResponse) *CreateMembershipModel {
  s.Body = v
  return s
}

type DeleteMembershipModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *DeleteMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMembershipModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteMembershipModel) GoString() string {
  return s.String()
}

func (s *DeleteMembershipModel) SetHeaders(v map[string]*string) *DeleteMembershipModel {
  s.Headers = v
  return s
}

func (s *DeleteMembershipModel) SetBody(v *DeleteMembershipResponse) *DeleteMembershipModel {
  s.Body = v
  return s
}

type GetMembershipModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMembershipModel) String() string {
  return tea.Prettify(s)
}

func (s GetMembershipModel) GoString() string {
  return s.String()
}

func (s *GetMembershipModel) SetHeaders(v map[string]*string) *GetMembershipModel {
  s.Headers = v
  return s
}

func (s *GetMembershipModel) SetBody(v *GetMembershipResponse) *GetMembershipModel {
  s.Body = v
  return s
}

type HasMemberModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *HasMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s HasMemberModel) String() string {
  return tea.Prettify(s)
}

func (s HasMemberModel) GoString() string {
  return s.String()
}

func (s *HasMemberModel) SetHeaders(v map[string]*string) *HasMemberModel {
  s.Headers = v
  return s
}

func (s *HasMemberModel) SetBody(v *HasMembershipResponse) *HasMemberModel {
  s.Body = v
  return s
}

type ListDirectChildMembershipsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListDirectChildMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectChildMembershipsModel) String() string {
  return tea.Prettify(s)
}

func (s ListDirectChildMembershipsModel) GoString() string {
  return s.String()
}

func (s *ListDirectChildMembershipsModel) SetHeaders(v map[string]*string) *ListDirectChildMembershipsModel {
  s.Headers = v
  return s
}

func (s *ListDirectChildMembershipsModel) SetBody(v *ListDirectChildMembershipsResponse) *ListDirectChildMembershipsModel {
  s.Body = v
  return s
}

type ListDirectMembershipsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListDirectParentMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectMembershipsModel) String() string {
  return tea.Prettify(s)
}

func (s ListDirectMembershipsModel) GoString() string {
  return s.String()
}

func (s *ListDirectMembershipsModel) SetHeaders(v map[string]*string) *ListDirectMembershipsModel {
  s.Headers = v
  return s
}

func (s *ListDirectMembershipsModel) SetBody(v *ListDirectParentMembershipsResponse) *ListDirectMembershipsModel {
  s.Body = v
  return s
}

type ListDirectParentMembershipsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListDirectParentMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectParentMembershipsModel) String() string {
  return tea.Prettify(s)
}

func (s ListDirectParentMembershipsModel) GoString() string {
  return s.String()
}

func (s *ListDirectParentMembershipsModel) SetHeaders(v map[string]*string) *ListDirectParentMembershipsModel {
  s.Headers = v
  return s
}

func (s *ListDirectParentMembershipsModel) SetBody(v *ListDirectParentMembershipsResponse) *ListDirectParentMembershipsModel {
  s.Body = v
  return s
}

type UpdateMembershipModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMembershipModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateMembershipModel) GoString() string {
  return s.String()
}

func (s *UpdateMembershipModel) SetHeaders(v map[string]*string) *UpdateMembershipModel {
  s.Headers = v
  return s
}

func (s *UpdateMembershipModel) SetBody(v *UpdateMembershipResponse) *UpdateMembershipModel {
  s.Body = v
  return s
}

type AddUserToSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AddUserToSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s AddUserToSubdomainModel) GoString() string {
  return s.String()
}

func (s *AddUserToSubdomainModel) SetHeaders(v map[string]*string) *AddUserToSubdomainModel {
  s.Headers = v
  return s
}

type CreateUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUserModel) String() string {
  return tea.Prettify(s)
}

func (s CreateUserModel) GoString() string {
  return s.String()
}

func (s *CreateUserModel) SetHeaders(v map[string]*string) *CreateUserModel {
  s.Headers = v
  return s
}

func (s *CreateUserModel) SetBody(v *CreateUserResponse) *CreateUserModel {
  s.Body = v
  return s
}

type DeleteUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteUserModel) String() string {
  return tea.Prettify(s)
}

func (s DeleteUserModel) GoString() string {
  return s.String()
}

func (s *DeleteUserModel) SetHeaders(v map[string]*string) *DeleteUserModel {
  s.Headers = v
  return s
}

type GetUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserModel) String() string {
  return tea.Prettify(s)
}

func (s GetUserModel) GoString() string {
  return s.String()
}

func (s *GetUserModel) SetHeaders(v map[string]*string) *GetUserModel {
  s.Headers = v
  return s
}

func (s *GetUserModel) SetBody(v *GetUserResponse) *GetUserModel {
  s.Body = v
  return s
}

type ImportUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *BaseUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportUserModel) String() string {
  return tea.Prettify(s)
}

func (s ImportUserModel) GoString() string {
  return s.String()
}

func (s *ImportUserModel) SetHeaders(v map[string]*string) *ImportUserModel {
  s.Headers = v
  return s
}

func (s *ImportUserModel) SetBody(v *BaseUserResponse) *ImportUserModel {
  s.Body = v
  return s
}

type ListUsersModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUsersModel) String() string {
  return tea.Prettify(s)
}

func (s ListUsersModel) GoString() string {
  return s.String()
}

func (s *ListUsersModel) SetHeaders(v map[string]*string) *ListUsersModel {
  s.Headers = v
  return s
}

func (s *ListUsersModel) SetBody(v *ListUserResponse) *ListUsersModel {
  s.Body = v
  return s
}

type RemoveUserFromSubdomainModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s RemoveUserFromSubdomainModel) String() string {
  return tea.Prettify(s)
}

func (s RemoveUserFromSubdomainModel) GoString() string {
  return s.String()
}

func (s *RemoveUserFromSubdomainModel) SetHeaders(v map[string]*string) *RemoveUserFromSubdomainModel {
  s.Headers = v
  return s
}

type SearchUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchUserModel) String() string {
  return tea.Prettify(s)
}

func (s SearchUserModel) GoString() string {
  return s.String()
}

func (s *SearchUserModel) SetHeaders(v map[string]*string) *SearchUserModel {
  s.Headers = v
  return s
}

func (s *SearchUserModel) SetBody(v *ListUserResponse) *SearchUserModel {
  s.Body = v
  return s
}

type UpdateUserModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateUserModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateUserModel) GoString() string {
  return s.String()
}

func (s *UpdateUserModel) SetHeaders(v map[string]*string) *UpdateUserModel {
  s.Headers = v
  return s
}

func (s *UpdateUserModel) SetBody(v *UpdateUserResponse) *UpdateUserModel {
  s.Body = v
  return s
}

type MergeModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *MergeFaceGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MergeModel) String() string {
  return tea.Prettify(s)
}

func (s MergeModel) GoString() string {
  return s.String()
}

func (s *MergeModel) SetHeaders(v map[string]*string) *MergeModel {
  s.Headers = v
  return s
}

func (s *MergeModel) SetBody(v *MergeFaceGroupResponse) *MergeModel {
  s.Body = v
  return s
}

type UnassignFacegroupItemModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s UnassignFacegroupItemModel) String() string {
  return tea.Prettify(s)
}

func (s UnassignFacegroupItemModel) GoString() string {
  return s.String()
}

func (s *UnassignFacegroupItemModel) SetHeaders(v map[string]*string) *UnassignFacegroupItemModel {
  s.Headers = v
  return s
}

type CreateStoryModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *CreateStoryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateStoryModel) String() string {
  return tea.Prettify(s)
}

func (s CreateStoryModel) GoString() string {
  return s.String()
}

func (s *CreateStoryModel) SetHeaders(v map[string]*string) *CreateStoryModel {
  s.Headers = v
  return s
}

func (s *CreateStoryModel) SetBody(v *CreateStoryResponse) *CreateStoryModel {
  s.Body = v
  return s
}

type FindStoriesModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *FindStoriesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s FindStoriesModel) String() string {
  return tea.Prettify(s)
}

func (s FindStoriesModel) GoString() string {
  return s.String()
}

func (s *FindStoriesModel) SetHeaders(v map[string]*string) *FindStoriesModel {
  s.Headers = v
  return s
}

func (s *FindStoriesModel) SetBody(v *FindStoriesResponse) *FindStoriesModel {
  s.Body = v
  return s
}

type GetPhotoCountModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetImageCountResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPhotoCountModel) String() string {
  return tea.Prettify(s)
}

func (s GetPhotoCountModel) GoString() string {
  return s.String()
}

func (s *GetPhotoCountModel) SetHeaders(v map[string]*string) *GetPhotoCountModel {
  s.Headers = v
  return s
}

func (s *GetPhotoCountModel) SetBody(v *GetImageCountResponse) *GetPhotoCountModel {
  s.Body = v
  return s
}

type GetStoryModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *GetStoryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStoryModel) String() string {
  return tea.Prettify(s)
}

func (s GetStoryModel) GoString() string {
  return s.String()
}

func (s *GetStoryModel) SetHeaders(v map[string]*string) *GetStoryModel {
  s.Headers = v
  return s
}

func (s *GetStoryModel) SetBody(v *GetStoryResponse) *GetStoryModel {
  s.Body = v
  return s
}

type ListAddressGroupsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListImageAddressGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAddressGroupsModel) String() string {
  return tea.Prettify(s)
}

func (s ListAddressGroupsModel) GoString() string {
  return s.String()
}

func (s *ListAddressGroupsModel) SetHeaders(v map[string]*string) *ListAddressGroupsModel {
  s.Headers = v
  return s
}

func (s *ListAddressGroupsModel) SetBody(v *ListImageAddressGroupsResponse) *ListAddressGroupsModel {
  s.Body = v
  return s
}

type ListFacegroupsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListImageFaceGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFacegroupsModel) String() string {
  return tea.Prettify(s)
}

func (s ListFacegroupsModel) GoString() string {
  return s.String()
}

func (s *ListFacegroupsModel) SetHeaders(v map[string]*string) *ListFacegroupsModel {
  s.Headers = v
  return s
}

func (s *ListFacegroupsModel) SetBody(v *ListImageFaceGroupsResponse) *ListFacegroupsModel {
  s.Body = v
  return s
}

type ListTagsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ListImageTagsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagsModel) String() string {
  return tea.Prettify(s)
}

func (s ListTagsModel) GoString() string {
  return s.String()
}

func (s *ListTagsModel) SetHeaders(v map[string]*string) *ListTagsModel {
  s.Headers = v
  return s
}

func (s *ListTagsModel) SetBody(v *ListImageTagsResponse) *ListTagsModel {
  s.Body = v
  return s
}

type ParseKeywordsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *ParseKeywordsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ParseKeywordsModel) String() string {
  return tea.Prettify(s)
}

func (s ParseKeywordsModel) GoString() string {
  return s.String()
}

func (s *ParseKeywordsModel) SetHeaders(v map[string]*string) *ParseKeywordsModel {
  s.Headers = v
  return s
}

func (s *ParseKeywordsModel) SetBody(v *ParseKeywordsResponse) *ParseKeywordsModel {
  s.Body = v
  return s
}

type SearchAddressGroupsModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *SearchImageAddressGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAddressGroupsModel) String() string {
  return tea.Prettify(s)
}

func (s SearchAddressGroupsModel) GoString() string {
  return s.String()
}

func (s *SearchAddressGroupsModel) SetHeaders(v map[string]*string) *SearchAddressGroupsModel {
  s.Headers = v
  return s
}

func (s *SearchAddressGroupsModel) SetBody(v *SearchImageAddressGroupsResponse) *SearchAddressGroupsModel {
  s.Body = v
  return s
}

type UpdateFacegroupInfoModel struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Body *UpdateFaceGroupInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFacegroupInfoModel) String() string {
  return tea.Prettify(s)
}

func (s UpdateFacegroupInfoModel) GoString() string {
  return s.String()
}

func (s *UpdateFacegroupInfoModel) SetHeaders(v map[string]*string) *UpdateFacegroupInfoModel {
  s.Headers = v
  return s
}

func (s *UpdateFacegroupInfoModel) SetBody(v *UpdateFaceGroupInfoResponse) *UpdateFacegroupInfoModel {
  s.Body = v
  return s
}

/**
 * 
 */
type AccountAccessTokenResponse struct {
  // accessToken
  AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty" require:"true"`
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // Default Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
  // Default Sbox Drive ID
  DefaultSboxDriveId *string `json:"default_sbox_drive_id,omitempty" xml:"default_sbox_drive_id,omitempty"`
  // device_id device flow ID
  DeviceId *string `json:"device_id,omitempty" xml:"device_id,omitempty"`
  // device_name device flow 
  DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
  // 
  ExistLink []*LinkInfo `json:"exist_link,omitempty" xml:"exist_link,omitempty" type:"Repeated"`
  // accessTokenISO
  ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  // accessToken
  ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty"`
  // 
  IsFirstLogin *bool `json:"is_first_login,omitempty" xml:"is_first_login,omitempty"`
  // 
  NeedLink *bool `json:"need_link,omitempty" xml:"need_link,omitempty" require:"true"`
  // 
  NeedRpVerify *bool `json:"need_rp_verify,omitempty" xml:"need_rp_verify,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  PinSetup *bool `json:"pin_setup,omitempty" xml:"pin_setup,omitempty"`
  // accessToken
  RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  State *string `json:"state,omitempty" xml:"state,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // subdomain_id subdomain_id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // accessTokenBearer
  TokenType *string `json:"token_type,omitempty" xml:"token_type,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  // ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s AccountAccessTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s AccountAccessTokenResponse) GoString() string {
  return s.String()
}

func (s *AccountAccessTokenResponse) SetAccessToken(v string) *AccountAccessTokenResponse {
  s.AccessToken = &v
  return s
}

func (s *AccountAccessTokenResponse) SetAvatar(v string) *AccountAccessTokenResponse {
  s.Avatar = &v
  return s
}

func (s *AccountAccessTokenResponse) SetDefaultDriveId(v string) *AccountAccessTokenResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *AccountAccessTokenResponse) SetDefaultSboxDriveId(v string) *AccountAccessTokenResponse {
  s.DefaultSboxDriveId = &v
  return s
}

func (s *AccountAccessTokenResponse) SetDeviceId(v string) *AccountAccessTokenResponse {
  s.DeviceId = &v
  return s
}

func (s *AccountAccessTokenResponse) SetDeviceName(v string) *AccountAccessTokenResponse {
  s.DeviceName = &v
  return s
}

func (s *AccountAccessTokenResponse) SetExistLink(v []*LinkInfo) *AccountAccessTokenResponse {
  s.ExistLink = v
  return s
}

func (s *AccountAccessTokenResponse) SetExpireTime(v string) *AccountAccessTokenResponse {
  s.ExpireTime = &v
  return s
}

func (s *AccountAccessTokenResponse) SetExpiresIn(v int64) *AccountAccessTokenResponse {
  s.ExpiresIn = &v
  return s
}

func (s *AccountAccessTokenResponse) SetIsFirstLogin(v bool) *AccountAccessTokenResponse {
  s.IsFirstLogin = &v
  return s
}

func (s *AccountAccessTokenResponse) SetNeedLink(v bool) *AccountAccessTokenResponse {
  s.NeedLink = &v
  return s
}

func (s *AccountAccessTokenResponse) SetNeedRpVerify(v bool) *AccountAccessTokenResponse {
  s.NeedRpVerify = &v
  return s
}

func (s *AccountAccessTokenResponse) SetNickName(v string) *AccountAccessTokenResponse {
  s.NickName = &v
  return s
}

func (s *AccountAccessTokenResponse) SetPinSetup(v bool) *AccountAccessTokenResponse {
  s.PinSetup = &v
  return s
}

func (s *AccountAccessTokenResponse) SetRefreshToken(v string) *AccountAccessTokenResponse {
  s.RefreshToken = &v
  return s
}

func (s *AccountAccessTokenResponse) SetRole(v string) *AccountAccessTokenResponse {
  s.Role = &v
  return s
}

func (s *AccountAccessTokenResponse) SetState(v string) *AccountAccessTokenResponse {
  s.State = &v
  return s
}

func (s *AccountAccessTokenResponse) SetStatus(v string) *AccountAccessTokenResponse {
  s.Status = &v
  return s
}

func (s *AccountAccessTokenResponse) SetSubdomainId(v string) *AccountAccessTokenResponse {
  s.SubdomainId = &v
  return s
}

func (s *AccountAccessTokenResponse) SetTokenType(v string) *AccountAccessTokenResponse {
  s.TokenType = &v
  return s
}

func (s *AccountAccessTokenResponse) SetUserData(v map[string]interface{}) *AccountAccessTokenResponse {
  s.UserData = v
  return s
}

func (s *AccountAccessTokenResponse) SetUserId(v string) *AccountAccessTokenResponse {
  s.UserId = &v
  return s
}

func (s *AccountAccessTokenResponse) SetUserName(v string) *AccountAccessTokenResponse {
  s.UserName = &v
  return s
}

/**
 * 
 */
type AccountLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Detail *string `json:"detail,omitempty" xml:"detail,omitempty"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // 
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
  // user_id
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s AccountLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s AccountLinkRequest) GoString() string {
  return s.String()
}

func (s *AccountLinkRequest) SetHeaders(v map[string]*string) *AccountLinkRequest {
  s.Headers = v
  return s
}

func (s *AccountLinkRequest) SetDetail(v string) *AccountLinkRequest {
  s.Detail = &v
  return s
}

func (s *AccountLinkRequest) SetExtra(v string) *AccountLinkRequest {
  s.Extra = &v
  return s
}

func (s *AccountLinkRequest) SetIdentity(v string) *AccountLinkRequest {
  s.Identity = &v
  return s
}

func (s *AccountLinkRequest) SetStatus(v string) *AccountLinkRequest {
  s.Status = &v
  return s
}

func (s *AccountLinkRequest) SetType(v string) *AccountLinkRequest {
  s.Type = &v
  return s
}

func (s *AccountLinkRequest) SetUserId(v string) *AccountLinkRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type AccountTokenRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // refresh_token
  GrantType *string `json:"grant_type,omitempty" xml:"grant_type,omitempty" require:"true"`
  // refresh token, 
  RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty" require:"true"`
}

func (s AccountTokenRequest) String() string {
  return tea.Prettify(s)
}

func (s AccountTokenRequest) GoString() string {
  return s.String()
}

func (s *AccountTokenRequest) SetHeaders(v map[string]*string) *AccountTokenRequest {
  s.Headers = v
  return s
}

func (s *AccountTokenRequest) SetAdditionData(v map[string]interface{}) *AccountTokenRequest {
  s.AdditionData = v
  return s
}

func (s *AccountTokenRequest) SetAppId(v string) *AccountTokenRequest {
  s.AppId = &v
  return s
}

func (s *AccountTokenRequest) SetGrantType(v string) *AccountTokenRequest {
  s.GrantType = &v
  return s
}

func (s *AccountTokenRequest) SetRefreshToken(v string) *AccountTokenRequest {
  s.RefreshToken = &v
  return s
}

/**
 * 
 */
type ActionDetail struct {
  Create *CreateDetail `json:"create,omitempty" xml:"create,omitempty"`
  Delete *DeleteDetail `json:"delete,omitempty" xml:"delete,omitempty"`
  Edit *EditDetail `json:"edit,omitempty" xml:"edit,omitempty"`
  Move *MoveDetail `json:"move,omitempty" xml:"move,omitempty"`
  Rename *RenameDetail `json:"rename,omitempty" xml:"rename,omitempty"`
  Restore *RestoreDetail `json:"restore,omitempty" xml:"restore,omitempty"`
  Trash *TrashDetail `json:"trash,omitempty" xml:"trash,omitempty"`
}

func (s ActionDetail) String() string {
  return tea.Prettify(s)
}

func (s ActionDetail) GoString() string {
  return s.String()
}

func (s *ActionDetail) SetCreate(v *CreateDetail) *ActionDetail {
  s.Create = v
  return s
}

func (s *ActionDetail) SetDelete(v *DeleteDetail) *ActionDetail {
  s.Delete = v
  return s
}

func (s *ActionDetail) SetEdit(v *EditDetail) *ActionDetail {
  s.Edit = v
  return s
}

func (s *ActionDetail) SetMove(v *MoveDetail) *ActionDetail {
  s.Move = v
  return s
}

func (s *ActionDetail) SetRename(v *RenameDetail) *ActionDetail {
  s.Rename = v
  return s
}

func (s *ActionDetail) SetRestore(v *RestoreDetail) *ActionDetail {
  s.Restore = v
  return s
}

func (s *ActionDetail) SetTrash(v *TrashDetail) *ActionDetail {
  s.Trash = v
  return s
}

/**
 * 
 */
type Actor struct {
  AliUser *ActorAliUser `json:"ali_user,omitempty" xml:"ali_user,omitempty"`
  AnonymousUser *ActorAnonymousUser `json:"anonymous_user,omitempty" xml:"anonymous_user,omitempty"`
  System *ActorSystem `json:"system,omitempty" xml:"system,omitempty"`
  User *ActorUser `json:"user,omitempty" xml:"user,omitempty"`
}

func (s Actor) String() string {
  return tea.Prettify(s)
}

func (s Actor) GoString() string {
  return s.String()
}

func (s *Actor) SetAliUser(v *ActorAliUser) *Actor {
  s.AliUser = v
  return s
}

func (s *Actor) SetAnonymousUser(v *ActorAnonymousUser) *Actor {
  s.AnonymousUser = v
  return s
}

func (s *Actor) SetSystem(v *ActorSystem) *Actor {
  s.System = v
  return s
}

func (s *Actor) SetUser(v *ActorUser) *Actor {
  s.User = v
  return s
}

/**
 * 
 */
type ActorAliUser struct {
  // AliUserID
  AliUserId *string `json:"ali_user_id,omitempty" xml:"ali_user_id,omitempty"`
  // AliUserType
  AliUserType *string `json:"ali_user_type,omitempty" xml:"ali_user_type,omitempty"`
}

func (s ActorAliUser) String() string {
  return tea.Prettify(s)
}

func (s ActorAliUser) GoString() string {
  return s.String()
}

func (s *ActorAliUser) SetAliUserId(v string) *ActorAliUser {
  s.AliUserId = &v
  return s
}

func (s *ActorAliUser) SetAliUserType(v string) *ActorAliUser {
  s.AliUserType = &v
  return s
}

/**
 * 
 */
type ActorAnonymousUser struct {
}

func (s ActorAnonymousUser) String() string {
  return tea.Prettify(s)
}

func (s ActorAnonymousUser) GoString() string {
  return s.String()
}

/**
 * 
 */
type ActorSystem struct {
  // EventType
  EventType *string `json:"event_type,omitempty" xml:"event_type,omitempty"`
}

func (s ActorSystem) String() string {
  return tea.Prettify(s)
}

func (s ActorSystem) GoString() string {
  return s.String()
}

func (s *ActorSystem) SetEventType(v string) *ActorSystem {
  s.EventType = &v
  return s
}

/**
 * 
 */
type ActorUser struct {
  // UserID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // UserName
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s ActorUser) String() string {
  return tea.Prettify(s)
}

func (s ActorUser) GoString() string {
  return s.String()
}

func (s *ActorUser) SetUserId(v string) *ActorUser {
  s.UserId = &v
  return s
}

func (s *ActorUser) SetUserName(v string) *ActorUser {
  s.UserName = &v
  return s
}

/**
 * 
 */
type AddStoreRequest struct {
  // 
  BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
  // bucket
  Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // 
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
  // systemcustom
  Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty"`
  // BucketARN
  RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
  // oss
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s AddStoreRequest) String() string {
  return tea.Prettify(s)
}

func (s AddStoreRequest) GoString() string {
  return s.String()
}

func (s *AddStoreRequest) SetBasePath(v string) *AddStoreRequest {
  s.BasePath = &v
  return s
}

func (s *AddStoreRequest) SetBucket(v string) *AddStoreRequest {
  s.Bucket = &v
  return s
}

func (s *AddStoreRequest) SetDomainId(v string) *AddStoreRequest {
  s.DomainId = &v
  return s
}

func (s *AddStoreRequest) SetEndpoint(v string) *AddStoreRequest {
  s.Endpoint = &v
  return s
}

func (s *AddStoreRequest) SetOwnership(v string) *AddStoreRequest {
  s.Ownership = &v
  return s
}

func (s *AddStoreRequest) SetRoleArn(v string) *AddStoreRequest {
  s.RoleArn = &v
  return s
}

func (s *AddStoreRequest) SetType(v string) *AddStoreRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type AppAccessStrategy struct {
  Effect *string `json:"effect,omitempty" xml:"effect,omitempty"`
  ExceptAppIdList []*string `json:"except_app_id_list,omitempty" xml:"except_app_id_list,omitempty" type:"Repeated"`
}

func (s AppAccessStrategy) String() string {
  return tea.Prettify(s)
}

func (s AppAccessStrategy) GoString() string {
  return s.String()
}

func (s *AppAccessStrategy) SetEffect(v string) *AppAccessStrategy {
  s.Effect = &v
  return s
}

func (s *AppAccessStrategy) SetExceptAppIdList(v []*string) *AppAccessStrategy {
  s.ExceptAppIdList = v
  return s
}

/**
 * 
 */
type ArchiveListRequest struct {
  RequestID *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
  ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // TODO ShareID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  Password *string `json:"password,omitempty" xml:"password,omitempty"`
}

func (s ArchiveListRequest) String() string {
  return tea.Prettify(s)
}

func (s ArchiveListRequest) GoString() string {
  return s.String()
}

func (s *ArchiveListRequest) SetRequestID(v string) *ArchiveListRequest {
  s.RequestID = &v
  return s
}

func (s *ArchiveListRequest) SetArchiveType(v string) *ArchiveListRequest {
  s.ArchiveType = &v
  return s
}

func (s *ArchiveListRequest) SetDomainId(v string) *ArchiveListRequest {
  s.DomainId = &v
  return s
}

func (s *ArchiveListRequest) SetDriveId(v string) *ArchiveListRequest {
  s.DriveId = &v
  return s
}

func (s *ArchiveListRequest) SetFileId(v string) *ArchiveListRequest {
  s.FileId = &v
  return s
}

func (s *ArchiveListRequest) SetPassword(v string) *ArchiveListRequest {
  s.Password = &v
  return s
}

/**
 *  response
 */
type ArchiveListResponse struct {
  FileList map[string]interface{} `json:"file_list,omitempty" xml:"file_list,omitempty"`
  State *string `json:"state,omitempty" xml:"state,omitempty"`
  TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveListResponse) String() string {
  return tea.Prettify(s)
}

func (s ArchiveListResponse) GoString() string {
  return s.String()
}

func (s *ArchiveListResponse) SetFileList(v map[string]interface{}) *ArchiveListResponse {
  s.FileList = v
  return s
}

func (s *ArchiveListResponse) SetState(v string) *ArchiveListResponse {
  s.State = &v
  return s
}

func (s *ArchiveListResponse) SetTaskId(v string) *ArchiveListResponse {
  s.TaskId = &v
  return s
}

/**
 * ArchiveStatusResponse response
 */
type ArchiveStatusResponse struct {
  FileList map[string]interface{} `json:"file_list,omitempty" xml:"file_list,omitempty"`
  Progress *int64 `json:"progress,omitempty" xml:"progress,omitempty"`
  State *string `json:"state,omitempty" xml:"state,omitempty"`
  TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveStatusResponse) String() string {
  return tea.Prettify(s)
}

func (s ArchiveStatusResponse) GoString() string {
  return s.String()
}

func (s *ArchiveStatusResponse) SetFileList(v map[string]interface{}) *ArchiveStatusResponse {
  s.FileList = v
  return s
}

func (s *ArchiveStatusResponse) SetProgress(v int64) *ArchiveStatusResponse {
  s.Progress = &v
  return s
}

func (s *ArchiveStatusResponse) SetState(v string) *ArchiveStatusResponse {
  s.State = &v
  return s
}

func (s *ArchiveStatusResponse) SetTaskId(v string) *ArchiveStatusResponse {
  s.TaskId = &v
  return s
}

/**
 * 
 */
type ArchiveUncompressRequest struct {
  RequestID *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
  ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // TODO ShareID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  FileList []*string `json:"file_list,omitempty" xml:"file_list,omitempty" type:"Repeated"`
  Password *string `json:"password,omitempty" xml:"password,omitempty"`
  TargetDriveId *string `json:"target_drive_id,omitempty" xml:"target_drive_id,omitempty"`
  TargetFileId *string `json:"target_file_id,omitempty" xml:"target_file_id,omitempty"`
}

func (s ArchiveUncompressRequest) String() string {
  return tea.Prettify(s)
}

func (s ArchiveUncompressRequest) GoString() string {
  return s.String()
}

func (s *ArchiveUncompressRequest) SetRequestID(v string) *ArchiveUncompressRequest {
  s.RequestID = &v
  return s
}

func (s *ArchiveUncompressRequest) SetArchiveType(v string) *ArchiveUncompressRequest {
  s.ArchiveType = &v
  return s
}

func (s *ArchiveUncompressRequest) SetDomainId(v string) *ArchiveUncompressRequest {
  s.DomainId = &v
  return s
}

func (s *ArchiveUncompressRequest) SetDriveId(v string) *ArchiveUncompressRequest {
  s.DriveId = &v
  return s
}

func (s *ArchiveUncompressRequest) SetFileId(v string) *ArchiveUncompressRequest {
  s.FileId = &v
  return s
}

func (s *ArchiveUncompressRequest) SetFileList(v []*string) *ArchiveUncompressRequest {
  s.FileList = v
  return s
}

func (s *ArchiveUncompressRequest) SetPassword(v string) *ArchiveUncompressRequest {
  s.Password = &v
  return s
}

func (s *ArchiveUncompressRequest) SetTargetDriveId(v string) *ArchiveUncompressRequest {
  s.TargetDriveId = &v
  return s
}

func (s *ArchiveUncompressRequest) SetTargetFileId(v string) *ArchiveUncompressRequest {
  s.TargetFileId = &v
  return s
}

/**
 *  response
 */
type ArchiveUncompressResponse struct {
  State *string `json:"state,omitempty" xml:"state,omitempty"`
  TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveUncompressResponse) String() string {
  return tea.Prettify(s)
}

func (s ArchiveUncompressResponse) GoString() string {
  return s.String()
}

func (s *ArchiveUncompressResponse) SetState(v string) *ArchiveUncompressResponse {
  s.State = &v
  return s
}

func (s *ArchiveUncompressResponse) SetTaskId(v string) *ArchiveUncompressResponse {
  s.TaskId = &v
  return s
}

/**
 * 
 */
type AuthConfig struct {
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
  AppSecret *string `json:"app_secret,omitempty" xml:"app_secret,omitempty"`
  CallbackSecurity *bool `json:"callback_security,omitempty" xml:"callback_security,omitempty"`
  Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
  EnterpriseId *string `json:"enterprise_id,omitempty" xml:"enterprise_id,omitempty"`
  LdapConfig *LdapConfig `json:"ldap_config,omitempty" xml:"ldap_config,omitempty"`
  LoginPageHeaders map[string]interface{} `json:"login_page_headers,omitempty" xml:"login_page_headers,omitempty"`
  LoginPageTemplate *string `json:"login_page_template,omitempty" xml:"login_page_template,omitempty"`
  LoginPageVars map[string]interface{} `json:"login_page_vars,omitempty" xml:"login_page_vars,omitempty"`
  WhiteListConfig map[string]interface{} `json:"white_list_config,omitempty" xml:"white_list_config,omitempty"`
  WhiteListEnable *bool `json:"white_list_enable,omitempty" xml:"white_list_enable,omitempty"`
}

func (s AuthConfig) String() string {
  return tea.Prettify(s)
}

func (s AuthConfig) GoString() string {
  return s.String()
}

func (s *AuthConfig) SetAppId(v string) *AuthConfig {
  s.AppId = &v
  return s
}

func (s *AuthConfig) SetAppSecret(v string) *AuthConfig {
  s.AppSecret = &v
  return s
}

func (s *AuthConfig) SetCallbackSecurity(v bool) *AuthConfig {
  s.CallbackSecurity = &v
  return s
}

func (s *AuthConfig) SetEnable(v bool) *AuthConfig {
  s.Enable = &v
  return s
}

func (s *AuthConfig) SetEndpoint(v string) *AuthConfig {
  s.Endpoint = &v
  return s
}

func (s *AuthConfig) SetEnterpriseId(v string) *AuthConfig {
  s.EnterpriseId = &v
  return s
}

func (s *AuthConfig) SetLdapConfig(v *LdapConfig) *AuthConfig {
  s.LdapConfig = v
  return s
}

func (s *AuthConfig) SetLoginPageHeaders(v map[string]interface{}) *AuthConfig {
  s.LoginPageHeaders = v
  return s
}

func (s *AuthConfig) SetLoginPageTemplate(v string) *AuthConfig {
  s.LoginPageTemplate = &v
  return s
}

func (s *AuthConfig) SetLoginPageVars(v map[string]interface{}) *AuthConfig {
  s.LoginPageVars = v
  return s
}

func (s *AuthConfig) SetWhiteListConfig(v map[string]interface{}) *AuthConfig {
  s.WhiteListConfig = v
  return s
}

func (s *AuthConfig) SetWhiteListEnable(v bool) *AuthConfig {
  s.WhiteListEnable = &v
  return s
}

/**
 * 
 */
type AuthorizeRequest struct {
  // Client ID, AppAppID
  ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
  // 
  DomainID *string `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
  // ding,ram
  LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
  // , App
  RedirectUri *string `json:"RedirectUri,omitempty" xml:"RedirectUri,omitempty" require:"true"`
  // , code
  ResponseType *string `json:"ResponseType,omitempty" xml:"ResponseType,omitempty" require:"true"`
  // , 
  Scope []*string `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Repeated"`
  // callback
  State *string `json:"State,omitempty" xml:"State,omitempty"`
  // 
  UserCode *string `json:"UserCode,omitempty" xml:"UserCode,omitempty"`
}

func (s AuthorizeRequest) String() string {
  return tea.Prettify(s)
}

func (s AuthorizeRequest) GoString() string {
  return s.String()
}

func (s *AuthorizeRequest) SetClientID(v string) *AuthorizeRequest {
  s.ClientID = &v
  return s
}

func (s *AuthorizeRequest) SetDomainID(v string) *AuthorizeRequest {
  s.DomainID = &v
  return s
}

func (s *AuthorizeRequest) SetLoginType(v string) *AuthorizeRequest {
  s.LoginType = &v
  return s
}

func (s *AuthorizeRequest) SetRedirectUri(v string) *AuthorizeRequest {
  s.RedirectUri = &v
  return s
}

func (s *AuthorizeRequest) SetResponseType(v string) *AuthorizeRequest {
  s.ResponseType = &v
  return s
}

func (s *AuthorizeRequest) SetScope(v []*string) *AuthorizeRequest {
  s.Scope = v
  return s
}

func (s *AuthorizeRequest) SetState(v string) *AuthorizeRequest {
  s.State = &v
  return s
}

func (s *AuthorizeRequest) SetUserCode(v string) *AuthorizeRequest {
  s.UserCode = &v
  return s
}

/**
 * 
 */
type BackUpConfig struct {
  // folder_id
  FolderId *string `json:"folder_id,omitempty" xml:"folder_id,omitempty"`
  // photo_folder_id
  PhotoFolderId *string `json:"photo_folder_id,omitempty" xml:"photo_folder_id,omitempty"`
  // sub_folder
  SubFolder map[string]interface{} `json:"sub_folder,omitempty" xml:"sub_folder,omitempty"`
  // video_folder_id
  VideoFolderId *string `json:"video_folder_id,omitempty" xml:"video_folder_id,omitempty"`
}

func (s BackUpConfig) String() string {
  return tea.Prettify(s)
}

func (s BackUpConfig) GoString() string {
  return s.String()
}

func (s *BackUpConfig) SetFolderId(v string) *BackUpConfig {
  s.FolderId = &v
  return s
}

func (s *BackUpConfig) SetPhotoFolderId(v string) *BackUpConfig {
  s.PhotoFolderId = &v
  return s
}

func (s *BackUpConfig) SetSubFolder(v map[string]interface{}) *BackUpConfig {
  s.SubFolder = v
  return s
}

func (s *BackUpConfig) SetVideoFolderId(v string) *BackUpConfig {
  s.VideoFolderId = &v
  return s
}

/**
 * 
 */
type BaseAdditionDataRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
}

func (s BaseAdditionDataRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseAdditionDataRequest) GoString() string {
  return s.String()
}

func (s *BaseAdditionDataRequest) SetAdditionData(v map[string]interface{}) *BaseAdditionDataRequest {
  s.AdditionData = v
  return s
}

/**
 * Base file response
 */
type BaseCCPFileResponse struct {
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s BaseCCPFileResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseCCPFileResponse) GoString() string {
  return s.String()
}

func (s *BaseCCPFileResponse) SetCategory(v string) *BaseCCPFileResponse {
  s.Category = &v
  return s
}

func (s *BaseCCPFileResponse) SetCharacteristicHash(v string) *BaseCCPFileResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *BaseCCPFileResponse) SetContentHash(v string) *BaseCCPFileResponse {
  s.ContentHash = &v
  return s
}

func (s *BaseCCPFileResponse) SetContentHashName(v string) *BaseCCPFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *BaseCCPFileResponse) SetContentType(v string) *BaseCCPFileResponse {
  s.ContentType = &v
  return s
}

func (s *BaseCCPFileResponse) SetCrc64Hash(v string) *BaseCCPFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *BaseCCPFileResponse) SetCreatedAt(v string) *BaseCCPFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseCCPFileResponse) SetDescription(v string) *BaseCCPFileResponse {
  s.Description = &v
  return s
}

func (s *BaseCCPFileResponse) SetDomainId(v string) *BaseCCPFileResponse {
  s.DomainId = &v
  return s
}

func (s *BaseCCPFileResponse) SetDownloadUrl(v string) *BaseCCPFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *BaseCCPFileResponse) SetDriveId(v string) *BaseCCPFileResponse {
  s.DriveId = &v
  return s
}

func (s *BaseCCPFileResponse) SetEncryptMode(v string) *BaseCCPFileResponse {
  s.EncryptMode = &v
  return s
}

func (s *BaseCCPFileResponse) SetFileExtension(v string) *BaseCCPFileResponse {
  s.FileExtension = &v
  return s
}

func (s *BaseCCPFileResponse) SetFileId(v string) *BaseCCPFileResponse {
  s.FileId = &v
  return s
}

func (s *BaseCCPFileResponse) SetHidden(v bool) *BaseCCPFileResponse {
  s.Hidden = &v
  return s
}

func (s *BaseCCPFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *BaseCCPFileResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *BaseCCPFileResponse) SetLabels(v []*string) *BaseCCPFileResponse {
  s.Labels = v
  return s
}

func (s *BaseCCPFileResponse) SetLastModifierId(v string) *BaseCCPFileResponse {
  s.LastModifierId = &v
  return s
}

func (s *BaseCCPFileResponse) SetLastModifierName(v string) *BaseCCPFileResponse {
  s.LastModifierName = &v
  return s
}

func (s *BaseCCPFileResponse) SetLastModifierType(v string) *BaseCCPFileResponse {
  s.LastModifierType = &v
  return s
}

func (s *BaseCCPFileResponse) SetMeta(v string) *BaseCCPFileResponse {
  s.Meta = &v
  return s
}

func (s *BaseCCPFileResponse) SetName(v string) *BaseCCPFileResponse {
  s.Name = &v
  return s
}

func (s *BaseCCPFileResponse) SetParentFileId(v string) *BaseCCPFileResponse {
  s.ParentFileId = &v
  return s
}

func (s *BaseCCPFileResponse) SetPunishFlag(v int64) *BaseCCPFileResponse {
  s.PunishFlag = &v
  return s
}

func (s *BaseCCPFileResponse) SetShareId(v string) *BaseCCPFileResponse {
  s.ShareId = &v
  return s
}

func (s *BaseCCPFileResponse) SetSize(v int64) *BaseCCPFileResponse {
  s.Size = &v
  return s
}

func (s *BaseCCPFileResponse) SetStarred(v bool) *BaseCCPFileResponse {
  s.Starred = &v
  return s
}

func (s *BaseCCPFileResponse) SetStatus(v string) *BaseCCPFileResponse {
  s.Status = &v
  return s
}

func (s *BaseCCPFileResponse) SetStreamsInfo(v map[string]interface{}) *BaseCCPFileResponse {
  s.StreamsInfo = v
  return s
}

func (s *BaseCCPFileResponse) SetThumbnail(v string) *BaseCCPFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *BaseCCPFileResponse) SetTrashedAt(v string) *BaseCCPFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *BaseCCPFileResponse) SetType(v string) *BaseCCPFileResponse {
  s.Type = &v
  return s
}

func (s *BaseCCPFileResponse) SetUpdatedAt(v string) *BaseCCPFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseCCPFileResponse) SetUploadId(v string) *BaseCCPFileResponse {
  s.UploadId = &v
  return s
}

func (s *BaseCCPFileResponse) SetUrl(v string) *BaseCCPFileResponse {
  s.Url = &v
  return s
}

func (s *BaseCCPFileResponse) SetUserMeta(v string) *BaseCCPFileResponse {
  s.UserMeta = &v
  return s
}

func (s *BaseCCPFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *BaseCCPFileResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *BaseCCPFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *BaseCCPFileResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * complete file request
 */
type BaseCompleteFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s BaseCompleteFileRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseCompleteFileRequest) GoString() string {
  return s.String()
}

func (s *BaseCompleteFileRequest) SetAdditionData(v map[string]interface{}) *BaseCompleteFileRequest {
  s.AdditionData = v
  return s
}

func (s *BaseCompleteFileRequest) SetDriveId(v string) *BaseCompleteFileRequest {
  s.DriveId = &v
  return s
}

func (s *BaseCompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *BaseCompleteFileRequest {
  s.PartInfoList = v
  return s
}

func (s *BaseCompleteFileRequest) SetShareId(v string) *BaseCompleteFileRequest {
  s.ShareId = &v
  return s
}

func (s *BaseCompleteFileRequest) SetUploadId(v string) *BaseCompleteFileRequest {
  s.UploadId = &v
  return s
}

/**
 * create file request
 */
type BaseCreateFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // ContentMd5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
  // ContentType
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // Name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // Type
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s BaseCreateFileRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseCreateFileRequest) GoString() string {
  return s.String()
}

func (s *BaseCreateFileRequest) SetAdditionData(v map[string]interface{}) *BaseCreateFileRequest {
  s.AdditionData = v
  return s
}

func (s *BaseCreateFileRequest) SetContentMd5(v string) *BaseCreateFileRequest {
  s.ContentMd5 = &v
  return s
}

func (s *BaseCreateFileRequest) SetContentType(v string) *BaseCreateFileRequest {
  s.ContentType = &v
  return s
}

func (s *BaseCreateFileRequest) SetName(v string) *BaseCreateFileRequest {
  s.Name = &v
  return s
}

func (s *BaseCreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *BaseCreateFileRequest {
  s.PartInfoList = v
  return s
}

func (s *BaseCreateFileRequest) SetSize(v int64) *BaseCreateFileRequest {
  s.Size = &v
  return s
}

func (s *BaseCreateFileRequest) SetType(v string) *BaseCreateFileRequest {
  s.Type = &v
  return s
}

/**
 * Base drive response
 */
type BaseDriveResponse struct {
  // Drive 
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // Drive 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // Drive 
  DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
  // Drive 
  DriveType *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
  EncryptDataAccess *bool `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // Drive 
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // Drive 
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // DrivestoredomainPathTypeOSSPath
  RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
  // Drive 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  //  ID, domainPathTypeOSSPath
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  // Drive 
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
  // Drive 
  UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s BaseDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseDriveResponse) GoString() string {
  return s.String()
}

func (s *BaseDriveResponse) SetCreator(v string) *BaseDriveResponse {
  s.Creator = &v
  return s
}

func (s *BaseDriveResponse) SetDescription(v string) *BaseDriveResponse {
  s.Description = &v
  return s
}

func (s *BaseDriveResponse) SetDomainId(v string) *BaseDriveResponse {
  s.DomainId = &v
  return s
}

func (s *BaseDriveResponse) SetDriveId(v string) *BaseDriveResponse {
  s.DriveId = &v
  return s
}

func (s *BaseDriveResponse) SetDriveName(v string) *BaseDriveResponse {
  s.DriveName = &v
  return s
}

func (s *BaseDriveResponse) SetDriveType(v string) *BaseDriveResponse {
  s.DriveType = &v
  return s
}

func (s *BaseDriveResponse) SetEncryptDataAccess(v bool) *BaseDriveResponse {
  s.EncryptDataAccess = &v
  return s
}

func (s *BaseDriveResponse) SetEncryptMode(v string) *BaseDriveResponse {
  s.EncryptMode = &v
  return s
}

func (s *BaseDriveResponse) SetOwner(v string) *BaseDriveResponse {
  s.Owner = &v
  return s
}

func (s *BaseDriveResponse) SetOwnerType(v string) *BaseDriveResponse {
  s.OwnerType = &v
  return s
}

func (s *BaseDriveResponse) SetRelativePath(v string) *BaseDriveResponse {
  s.RelativePath = &v
  return s
}

func (s *BaseDriveResponse) SetStatus(v string) *BaseDriveResponse {
  s.Status = &v
  return s
}

func (s *BaseDriveResponse) SetStoreId(v string) *BaseDriveResponse {
  s.StoreId = &v
  return s
}

func (s *BaseDriveResponse) SetTotalSize(v int64) *BaseDriveResponse {
  s.TotalSize = &v
  return s
}

func (s *BaseDriveResponse) SetUsedSize(v int64) *BaseDriveResponse {
  s.UsedSize = &v
  return s
}

/**
 * list_file_by_anonymous base response
 */
type BaseFileAnonymousResponse struct {
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // size, type=file
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseFileAnonymousResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseFileAnonymousResponse) GoString() string {
  return s.String()
}

func (s *BaseFileAnonymousResponse) SetFileId(v string) *BaseFileAnonymousResponse {
  s.FileId = &v
  return s
}

func (s *BaseFileAnonymousResponse) SetName(v string) *BaseFileAnonymousResponse {
  s.Name = &v
  return s
}

func (s *BaseFileAnonymousResponse) SetSize(v int64) *BaseFileAnonymousResponse {
  s.Size = &v
  return s
}

func (s *BaseFileAnonymousResponse) SetThumbnail(v string) *BaseFileAnonymousResponse {
  s.Thumbnail = &v
  return s
}

func (s *BaseFileAnonymousResponse) SetType(v string) *BaseFileAnonymousResponse {
  s.Type = &v
  return s
}

func (s *BaseFileAnonymousResponse) SetUpdatedAt(v string) *BaseFileAnonymousResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type BaseFileProcessRequest struct {
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseFileProcessRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseFileProcessRequest) GoString() string {
  return s.String()
}

func (s *BaseFileProcessRequest) SetImageCroppingAspectRatios(v []*string) *BaseFileProcessRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *BaseFileProcessRequest) SetImageThumbnailProcess(v string) *BaseFileProcessRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *BaseFileProcessRequest) SetImageUrlProcess(v string) *BaseFileProcessRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *BaseFileProcessRequest) SetOfficeThumbnailProcess(v string) *BaseFileProcessRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *BaseFileProcessRequest) SetVideoThumbnailProcess(v string) *BaseFileProcessRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * URL
 */
type BaseGetUploadUrlRequest struct {
  // content_md5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // upload_part_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s BaseGetUploadUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseGetUploadUrlRequest) GoString() string {
  return s.String()
}

func (s *BaseGetUploadUrlRequest) SetContentMd5(v string) *BaseGetUploadUrlRequest {
  s.ContentMd5 = &v
  return s
}

func (s *BaseGetUploadUrlRequest) SetDriveId(v string) *BaseGetUploadUrlRequest {
  s.DriveId = &v
  return s
}

func (s *BaseGetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *BaseGetUploadUrlRequest {
  s.PartInfoList = v
  return s
}

func (s *BaseGetUploadUrlRequest) SetShareId(v string) *BaseGetUploadUrlRequest {
  s.ShareId = &v
  return s
}

func (s *BaseGetUploadUrlRequest) SetUploadId(v string) *BaseGetUploadUrlRequest {
  s.UploadId = &v
  return s
}

/**
 * Base file response
 */
type BaseHostingFileResponse struct {
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s BaseHostingFileResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseHostingFileResponse) GoString() string {
  return s.String()
}

func (s *BaseHostingFileResponse) SetContentHash(v string) *BaseHostingFileResponse {
  s.ContentHash = &v
  return s
}

func (s *BaseHostingFileResponse) SetContentHashName(v string) *BaseHostingFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *BaseHostingFileResponse) SetContentType(v string) *BaseHostingFileResponse {
  s.ContentType = &v
  return s
}

func (s *BaseHostingFileResponse) SetCrc64Hash(v string) *BaseHostingFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *BaseHostingFileResponse) SetCreatedAt(v string) *BaseHostingFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseHostingFileResponse) SetDescription(v string) *BaseHostingFileResponse {
  s.Description = &v
  return s
}

func (s *BaseHostingFileResponse) SetDomainId(v string) *BaseHostingFileResponse {
  s.DomainId = &v
  return s
}

func (s *BaseHostingFileResponse) SetDownloadUrl(v string) *BaseHostingFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *BaseHostingFileResponse) SetDriveId(v string) *BaseHostingFileResponse {
  s.DriveId = &v
  return s
}

func (s *BaseHostingFileResponse) SetFileExtension(v string) *BaseHostingFileResponse {
  s.FileExtension = &v
  return s
}

func (s *BaseHostingFileResponse) SetFilePath(v string) *BaseHostingFileResponse {
  s.FilePath = &v
  return s
}

func (s *BaseHostingFileResponse) SetName(v string) *BaseHostingFileResponse {
  s.Name = &v
  return s
}

func (s *BaseHostingFileResponse) SetParentFilePath(v string) *BaseHostingFileResponse {
  s.ParentFilePath = &v
  return s
}

func (s *BaseHostingFileResponse) SetShareId(v string) *BaseHostingFileResponse {
  s.ShareId = &v
  return s
}

func (s *BaseHostingFileResponse) SetSize(v int64) *BaseHostingFileResponse {
  s.Size = &v
  return s
}

func (s *BaseHostingFileResponse) SetStatus(v string) *BaseHostingFileResponse {
  s.Status = &v
  return s
}

func (s *BaseHostingFileResponse) SetThumbnail(v string) *BaseHostingFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *BaseHostingFileResponse) SetTrashedAt(v string) *BaseHostingFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *BaseHostingFileResponse) SetType(v string) *BaseHostingFileResponse {
  s.Type = &v
  return s
}

func (s *BaseHostingFileResponse) SetUpdatedAt(v string) *BaseHostingFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseHostingFileResponse) SetUploadId(v string) *BaseHostingFileResponse {
  s.UploadId = &v
  return s
}

func (s *BaseHostingFileResponse) SetUrl(v string) *BaseHostingFileResponse {
  s.Url = &v
  return s
}

/**
 * Base image process
 */
type BaseImageProcessRequest struct {
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseImageProcessRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseImageProcessRequest) GoString() string {
  return s.String()
}

func (s *BaseImageProcessRequest) SetImageThumbnailProcess(v string) *BaseImageProcessRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *BaseImageProcessRequest) SetImageUrlProcess(v string) *BaseImageProcessRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *BaseImageProcessRequest) SetOfficeThumbnailProcess(v string) *BaseImageProcessRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *BaseImageProcessRequest) SetVideoThumbnailProcess(v string) *BaseImageProcessRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * list file request
 */
type BaseListFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseListFileRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseListFileRequest) GoString() string {
  return s.String()
}

func (s *BaseListFileRequest) SetAdditionData(v map[string]interface{}) *BaseListFileRequest {
  s.AdditionData = v
  return s
}

func (s *BaseListFileRequest) SetDriveId(v string) *BaseListFileRequest {
  s.DriveId = &v
  return s
}

func (s *BaseListFileRequest) SetImageCroppingAspectRatios(v []*string) *BaseListFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *BaseListFileRequest) SetImageThumbnailProcess(v string) *BaseListFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *BaseListFileRequest) SetImageUrlProcess(v string) *BaseListFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *BaseListFileRequest) SetLimit(v int64) *BaseListFileRequest {
  s.Limit = &v
  return s
}

func (s *BaseListFileRequest) SetMarker(v string) *BaseListFileRequest {
  s.Marker = &v
  return s
}

func (s *BaseListFileRequest) SetOfficeThumbnailProcess(v string) *BaseListFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *BaseListFileRequest) SetReferer(v string) *BaseListFileRequest {
  s.Referer = &v
  return s
}

func (s *BaseListFileRequest) SetShareId(v string) *BaseListFileRequest {
  s.ShareId = &v
  return s
}

func (s *BaseListFileRequest) SetSignToken(v string) *BaseListFileRequest {
  s.SignToken = &v
  return s
}

func (s *BaseListFileRequest) SetVideoThumbnailProcess(v string) *BaseListFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type BaseMediaResponse struct {
  // address_line
  AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
  // city
  City *string `json:"city,omitempty" xml:"city,omitempty"`
  // country
  Country *string `json:"country,omitempty" xml:"country,omitempty"`
  // district
  District *string `json:"district,omitempty" xml:"district,omitempty"`
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  // system_tags
  ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // province
  Province *string `json:"province,omitempty" xml:"province,omitempty"`
  // time
  Time *string `json:"time,omitempty" xml:"time,omitempty"`
  // township
  Township *string `json:"township,omitempty" xml:"township,omitempty"`
  // width
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s BaseMediaResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseMediaResponse) GoString() string {
  return s.String()
}

func (s *BaseMediaResponse) SetAddressLine(v string) *BaseMediaResponse {
  s.AddressLine = &v
  return s
}

func (s *BaseMediaResponse) SetCity(v string) *BaseMediaResponse {
  s.City = &v
  return s
}

func (s *BaseMediaResponse) SetCountry(v string) *BaseMediaResponse {
  s.Country = &v
  return s
}

func (s *BaseMediaResponse) SetDistrict(v string) *BaseMediaResponse {
  s.District = &v
  return s
}

func (s *BaseMediaResponse) SetHeight(v int64) *BaseMediaResponse {
  s.Height = &v
  return s
}

func (s *BaseMediaResponse) SetImageTags(v []*SystemTag) *BaseMediaResponse {
  s.ImageTags = v
  return s
}

func (s *BaseMediaResponse) SetLocation(v string) *BaseMediaResponse {
  s.Location = &v
  return s
}

func (s *BaseMediaResponse) SetProvince(v string) *BaseMediaResponse {
  s.Province = &v
  return s
}

func (s *BaseMediaResponse) SetTime(v string) *BaseMediaResponse {
  s.Time = &v
  return s
}

func (s *BaseMediaResponse) SetTownship(v string) *BaseMediaResponse {
  s.Township = &v
  return s
}

func (s *BaseMediaResponse) SetWidth(v int64) *BaseMediaResponse {
  s.Width = &v
  return s
}

/**
 * 
 */
type BaseMoveFileRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // new_name
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s BaseMoveFileRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseMoveFileRequest) GoString() string {
  return s.String()
}

func (s *BaseMoveFileRequest) SetDriveId(v string) *BaseMoveFileRequest {
  s.DriveId = &v
  return s
}

func (s *BaseMoveFileRequest) SetNewName(v string) *BaseMoveFileRequest {
  s.NewName = &v
  return s
}

func (s *BaseMoveFileRequest) SetShareId(v string) *BaseMoveFileRequest {
  s.ShareId = &v
  return s
}

/**
 * list_share_link response
 */
type BaseShareLinkResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // file_id_list
  FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
  // file_id_list
  FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
  // preview_count
  PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
  // 
  SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_msg
  ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_policy
  SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
  // share_url
  ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseShareLinkResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseShareLinkResponse) GoString() string {
  return s.String()
}

func (s *BaseShareLinkResponse) SetCreatedAt(v string) *BaseShareLinkResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseShareLinkResponse) SetCreator(v string) *BaseShareLinkResponse {
  s.Creator = &v
  return s
}

func (s *BaseShareLinkResponse) SetDescription(v string) *BaseShareLinkResponse {
  s.Description = &v
  return s
}

func (s *BaseShareLinkResponse) SetDownloadCount(v int64) *BaseShareLinkResponse {
  s.DownloadCount = &v
  return s
}

func (s *BaseShareLinkResponse) SetDriveId(v string) *BaseShareLinkResponse {
  s.DriveId = &v
  return s
}

func (s *BaseShareLinkResponse) SetExpiration(v string) *BaseShareLinkResponse {
  s.Expiration = &v
  return s
}

func (s *BaseShareLinkResponse) SetExpired(v bool) *BaseShareLinkResponse {
  s.Expired = &v
  return s
}

func (s *BaseShareLinkResponse) SetFileId(v string) *BaseShareLinkResponse {
  s.FileId = &v
  return s
}

func (s *BaseShareLinkResponse) SetFileIdList(v []*string) *BaseShareLinkResponse {
  s.FileIdList = v
  return s
}

func (s *BaseShareLinkResponse) SetFilePathList(v []*string) *BaseShareLinkResponse {
  s.FilePathList = v
  return s
}

func (s *BaseShareLinkResponse) SetPreviewCount(v int64) *BaseShareLinkResponse {
  s.PreviewCount = &v
  return s
}

func (s *BaseShareLinkResponse) SetSaveCount(v int64) *BaseShareLinkResponse {
  s.SaveCount = &v
  return s
}

func (s *BaseShareLinkResponse) SetShareId(v string) *BaseShareLinkResponse {
  s.ShareId = &v
  return s
}

func (s *BaseShareLinkResponse) SetShareMsg(v string) *BaseShareLinkResponse {
  s.ShareMsg = &v
  return s
}

func (s *BaseShareLinkResponse) SetShareName(v string) *BaseShareLinkResponse {
  s.ShareName = &v
  return s
}

func (s *BaseShareLinkResponse) SetSharePolicy(v string) *BaseShareLinkResponse {
  s.SharePolicy = &v
  return s
}

func (s *BaseShareLinkResponse) SetSharePwd(v string) *BaseShareLinkResponse {
  s.SharePwd = &v
  return s
}

func (s *BaseShareLinkResponse) SetShareUrl(v string) *BaseShareLinkResponse {
  s.ShareUrl = &v
  return s
}

func (s *BaseShareLinkResponse) SetStatus(v string) *BaseShareLinkResponse {
  s.Status = &v
  return s
}

func (s *BaseShareLinkResponse) SetUpdatedAt(v string) *BaseShareLinkResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * List share response
 */
type BaseShareResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // owner
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // owner
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // permissions
  Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
  // share_file_id
  ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
  // share_path
  ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseShareResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseShareResponse) GoString() string {
  return s.String()
}

func (s *BaseShareResponse) SetCreatedAt(v string) *BaseShareResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseShareResponse) SetCreator(v string) *BaseShareResponse {
  s.Creator = &v
  return s
}

func (s *BaseShareResponse) SetDescription(v string) *BaseShareResponse {
  s.Description = &v
  return s
}

func (s *BaseShareResponse) SetDomainId(v string) *BaseShareResponse {
  s.DomainId = &v
  return s
}

func (s *BaseShareResponse) SetDriveId(v string) *BaseShareResponse {
  s.DriveId = &v
  return s
}

func (s *BaseShareResponse) SetExpiration(v string) *BaseShareResponse {
  s.Expiration = &v
  return s
}

func (s *BaseShareResponse) SetExpired(v bool) *BaseShareResponse {
  s.Expired = &v
  return s
}

func (s *BaseShareResponse) SetOwner(v string) *BaseShareResponse {
  s.Owner = &v
  return s
}

func (s *BaseShareResponse) SetOwnerType(v string) *BaseShareResponse {
  s.OwnerType = &v
  return s
}

func (s *BaseShareResponse) SetPermissions(v []*string) *BaseShareResponse {
  s.Permissions = v
  return s
}

func (s *BaseShareResponse) SetShareFileId(v string) *BaseShareResponse {
  s.ShareFileId = &v
  return s
}

func (s *BaseShareResponse) SetShareFilePath(v string) *BaseShareResponse {
  s.ShareFilePath = &v
  return s
}

func (s *BaseShareResponse) SetShareId(v string) *BaseShareResponse {
  s.ShareId = &v
  return s
}

func (s *BaseShareResponse) SetShareName(v string) *BaseShareResponse {
  s.ShareName = &v
  return s
}

func (s *BaseShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *BaseShareResponse {
  s.SharePolicy = v
  return s
}

func (s *BaseShareResponse) SetStatus(v string) *BaseShareResponse {
  s.Status = &v
  return s
}

func (s *BaseShareResponse) SetUpdatedAt(v string) *BaseShareResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type BatchRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // Requests 
  Requests []*BatchSubRequest `json:"requests,omitempty" xml:"requests,omitempty" require:"true" type:"Repeated"`
  // 
  Resource *string `json:"resource,omitempty" xml:"resource,omitempty" require:"true"`
}

func (s BatchRequest) String() string {
  return tea.Prettify(s)
}

func (s BatchRequest) GoString() string {
  return s.String()
}

func (s *BatchRequest) SetHeaders(v map[string]*string) *BatchRequest {
  s.Headers = v
  return s
}

func (s *BatchRequest) SetRequests(v []*BatchSubRequest) *BatchRequest {
  s.Requests = v
  return s
}

func (s *BatchRequest) SetResource(v string) *BatchRequest {
  s.Resource = &v
  return s
}

/**
 * batch operation response
 */
type BatchResponse struct {
  // responses 
  Responses []*BatchSubResponse `json:"responses,omitempty" xml:"responses,omitempty" type:"Repeated"`
}

func (s BatchResponse) String() string {
  return tea.Prettify(s)
}

func (s BatchResponse) GoString() string {
  return s.String()
}

func (s *BatchResponse) SetResponses(v []*BatchSubResponse) *BatchResponse {
  s.Responses = v
  return s
}

/**
 * 
 */
type BatchSubRequest struct {
  // body  json , body headers  "Content-Type" "application/json"
  Body map[string]interface{} `json:"body,omitempty" xml:"body,omitempty"`
  // headers body
  Headers map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
  // id request  response 
  Id *string `json:"id,omitempty" xml:"id,omitempty" require:"true"`
  // method
  Method *string `json:"method,omitempty" xml:"method,omitempty" require:"true"`
  // url api path 
  Url *string `json:"url,omitempty" xml:"url,omitempty" require:"true"`
}

func (s BatchSubRequest) String() string {
  return tea.Prettify(s)
}

func (s BatchSubRequest) GoString() string {
  return s.String()
}

func (s *BatchSubRequest) SetBody(v map[string]interface{}) *BatchSubRequest {
  s.Body = v
  return s
}

func (s *BatchSubRequest) SetHeaders(v map[string]interface{}) *BatchSubRequest {
  s.Headers = v
  return s
}

func (s *BatchSubRequest) SetId(v string) *BatchSubRequest {
  s.Id = &v
  return s
}

func (s *BatchSubRequest) SetMethod(v string) *BatchSubRequest {
  s.Method = &v
  return s
}

func (s *BatchSubRequest) SetUrl(v string) *BatchSubRequest {
  s.Url = &v
  return s
}

/**
 * 
 */
type BatchSubResponse struct {
  // body  json 
  Body map[string]interface{} `json:"body,omitempty" xml:"body,omitempty"`
  // id id,  request 
  Id *string `json:"id,omitempty" xml:"id,omitempty"`
  // status 
  Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
}

func (s BatchSubResponse) String() string {
  return tea.Prettify(s)
}

func (s BatchSubResponse) GoString() string {
  return s.String()
}

func (s *BatchSubResponse) SetBody(v map[string]interface{}) *BatchSubResponse {
  s.Body = v
  return s
}

func (s *BatchSubResponse) SetId(v string) *BatchSubResponse {
  s.Id = &v
  return s
}

func (s *BatchSubResponse) SetStatus(v int64) *BatchSubResponse {
  s.Status = &v
  return s
}

/**
 * 
 */
type CCPArchiveFilesRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  Files []*FileInfo `json:"files,omitempty" xml:"files,omitempty" type:"Repeated"`
  // file_name
  Name *string `json:"name,omitempty" xml:"name,omitempty" maxLength:"1024" minLength:"1"`
}

func (s CCPArchiveFilesRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPArchiveFilesRequest) GoString() string {
  return s.String()
}

func (s *CCPArchiveFilesRequest) SetHeaders(v map[string]*string) *CCPArchiveFilesRequest {
  s.Headers = v
  return s
}

func (s *CCPArchiveFilesRequest) SetAdditionData(v map[string]interface{}) *CCPArchiveFilesRequest {
  s.AdditionData = v
  return s
}

func (s *CCPArchiveFilesRequest) SetDriveId(v string) *CCPArchiveFilesRequest {
  s.DriveId = &v
  return s
}

func (s *CCPArchiveFilesRequest) SetFiles(v []*FileInfo) *CCPArchiveFilesRequest {
  s.Files = v
  return s
}

func (s *CCPArchiveFilesRequest) SetName(v string) *CCPArchiveFilesRequest {
  s.Name = &v
  return s
}

/**
 * response
 */
type CCPArchiveFilesResponse struct {
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s CCPArchiveFilesResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPArchiveFilesResponse) GoString() string {
  return s.String()
}

func (s *CCPArchiveFilesResponse) SetAsyncTaskId(v string) *CCPArchiveFilesResponse {
  s.AsyncTaskId = &v
  return s
}

/**
 * 
 */
type CCPArchiveRequest struct {
  RequestID *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
  ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // TODO ShareID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  Password *string `json:"password,omitempty" xml:"password,omitempty"`
}

func (s CCPArchiveRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPArchiveRequest) GoString() string {
  return s.String()
}

func (s *CCPArchiveRequest) SetRequestID(v string) *CCPArchiveRequest {
  s.RequestID = &v
  return s
}

func (s *CCPArchiveRequest) SetArchiveType(v string) *CCPArchiveRequest {
  s.ArchiveType = &v
  return s
}

func (s *CCPArchiveRequest) SetDomainId(v string) *CCPArchiveRequest {
  s.DomainId = &v
  return s
}

func (s *CCPArchiveRequest) SetDriveId(v string) *CCPArchiveRequest {
  s.DriveId = &v
  return s
}

func (s *CCPArchiveRequest) SetFileId(v string) *CCPArchiveRequest {
  s.FileId = &v
  return s
}

func (s *CCPArchiveRequest) SetPassword(v string) *CCPArchiveRequest {
  s.Password = &v
  return s
}

/**
 * 
 */
type CCPArchiveResponse struct {
  State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s CCPArchiveResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPArchiveResponse) GoString() string {
  return s.String()
}

func (s *CCPArchiveResponse) SetState(v string) *CCPArchiveResponse {
  s.State = &v
  return s
}

/**
 * size
 */
type CCPGetDirSizeInfoRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CCPGetDirSizeInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPGetDirSizeInfoRequest) GoString() string {
  return s.String()
}

func (s *CCPGetDirSizeInfoRequest) SetDriveId(v string) *CCPGetDirSizeInfoRequest {
  s.DriveId = &v
  return s
}

func (s *CCPGetDirSizeInfoRequest) SetFileId(v string) *CCPGetDirSizeInfoRequest {
  s.FileId = &v
  return s
}

func (s *CCPGetDirSizeInfoRequest) SetShareId(v string) *CCPGetDirSizeInfoRequest {
  s.ShareId = &v
  return s
}

/**
 * body
 */
type CCPGetShareLinkVideoPreviewPlayInfoRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"600" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s CCPGetShareLinkVideoPreviewPlayInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPGetShareLinkVideoPreviewPlayInfoRequest) GoString() string {
  return s.String()
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetHeaders(v map[string]*string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.Headers = v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetAdditionData(v map[string]interface{}) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.AdditionData = v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetCategory(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.Category = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetFileId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.FileId = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetFileIdPath(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.FileIdPath = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetImageThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetImageUrlProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetLocation(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.Location = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetOfficeThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetReferer(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.Referer = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetShareId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.ShareId = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetSignToken(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.SignToken = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetTemplateId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.TemplateId = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetUrlExpireSec(v int64) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetVideoThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type CCPGetShareLinkVideoPreviewPlayInfoResponse struct {
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  VideoPreviewPlayInfo *VideoPreviewPlayInfoResponse `json:"video_preview_play_info,omitempty" xml:"video_preview_play_info,omitempty"`
}

func (s CCPGetShareLinkVideoPreviewPlayInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPGetShareLinkVideoPreviewPlayInfoResponse) GoString() string {
  return s.String()
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetFileId(v string) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
  s.FileId = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetShareId(v string) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
  s.ShareId = &v
  return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetVideoPreviewPlayInfo(v *VideoPreviewPlayInfoResponse) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
  s.VideoPreviewPlayInfo = v
  return s
}

/**
 * 
 */
type CCPGetVideoPreviewPlayInfoRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
}

func (s CCPGetVideoPreviewPlayInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPGetVideoPreviewPlayInfoRequest) GoString() string {
  return s.String()
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetHeaders(v map[string]*string) *CCPGetVideoPreviewPlayInfoRequest {
  s.Headers = v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetAdditionData(v map[string]interface{}) *CCPGetVideoPreviewPlayInfoRequest {
  s.AdditionData = v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetCategory(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.Category = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetDriveId(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.DriveId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetFileId(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.FileId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetFileIdPath(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.FileIdPath = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetLocation(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.Location = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetReferer(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.Referer = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetShareId(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.ShareId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetSignToken(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.SignToken = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetTemplateId(v string) *CCPGetVideoPreviewPlayInfoRequest {
  s.TemplateId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetUrlExpireSec(v int64) *CCPGetVideoPreviewPlayInfoRequest {
  s.UrlExpireSec = &v
  return s
}

/**
 * 
 */
type CCPGetVideoPreviewPlayInfoResponse struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  VideoPreviewPlayInfo *VideoPreviewPlayInfoResponse `json:"video_preview_play_info,omitempty" xml:"video_preview_play_info,omitempty"`
}

func (s CCPGetVideoPreviewPlayInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPGetVideoPreviewPlayInfoResponse) GoString() string {
  return s.String()
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetDomainId(v string) *CCPGetVideoPreviewPlayInfoResponse {
  s.DomainId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetDriveId(v string) *CCPGetVideoPreviewPlayInfoResponse {
  s.DriveId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetFileId(v string) *CCPGetVideoPreviewPlayInfoResponse {
  s.FileId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetShareId(v string) *CCPGetVideoPreviewPlayInfoResponse {
  s.ShareId = &v
  return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetVideoPreviewPlayInfo(v *VideoPreviewPlayInfoResponse) *CCPGetVideoPreviewPlayInfoResponse {
  s.VideoPreviewPlayInfo = v
  return s
}

/**
 * 
 */
type CCPLiveTranscodeRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // object_path
  ObjectPath *string `json:"object_path,omitempty" xml:"object_path,omitempty"`
}

func (s CCPLiveTranscodeRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPLiveTranscodeRequest) GoString() string {
  return s.String()
}

func (s *CCPLiveTranscodeRequest) SetHeaders(v map[string]*string) *CCPLiveTranscodeRequest {
  s.Headers = v
  return s
}

func (s *CCPLiveTranscodeRequest) SetAdditionData(v map[string]interface{}) *CCPLiveTranscodeRequest {
  s.AdditionData = v
  return s
}

func (s *CCPLiveTranscodeRequest) SetObjectPath(v string) *CCPLiveTranscodeRequest {
  s.ObjectPath = &v
  return s
}

/**
 * CCPLiveTranscodeResponse
 */
type CCPLiveTranscodeResponse struct {
}

func (s CCPLiveTranscodeResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPLiveTranscodeResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type CCPWalkFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // all
  All *bool `json:"all,omitempty" xml:"all,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // fields
  Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // order_by
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
  // order_direction
  OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
  // ParentFileID
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
  ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // starred
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s CCPWalkFileRequest) String() string {
  return tea.Prettify(s)
}

func (s CCPWalkFileRequest) GoString() string {
  return s.String()
}

func (s *CCPWalkFileRequest) SetHeaders(v map[string]*string) *CCPWalkFileRequest {
  s.Headers = v
  return s
}

func (s *CCPWalkFileRequest) SetAdditionData(v map[string]interface{}) *CCPWalkFileRequest {
  s.AdditionData = v
  return s
}

func (s *CCPWalkFileRequest) SetAll(v bool) *CCPWalkFileRequest {
  s.All = &v
  return s
}

func (s *CCPWalkFileRequest) SetCategory(v string) *CCPWalkFileRequest {
  s.Category = &v
  return s
}

func (s *CCPWalkFileRequest) SetDriveId(v string) *CCPWalkFileRequest {
  s.DriveId = &v
  return s
}

func (s *CCPWalkFileRequest) SetFields(v string) *CCPWalkFileRequest {
  s.Fields = &v
  return s
}

func (s *CCPWalkFileRequest) SetImageCroppingAspectRatios(v []*string) *CCPWalkFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *CCPWalkFileRequest) SetImageThumbnailProcess(v string) *CCPWalkFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *CCPWalkFileRequest) SetImageUrlProcess(v string) *CCPWalkFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *CCPWalkFileRequest) SetLimit(v int64) *CCPWalkFileRequest {
  s.Limit = &v
  return s
}

func (s *CCPWalkFileRequest) SetLocation(v string) *CCPWalkFileRequest {
  s.Location = &v
  return s
}

func (s *CCPWalkFileRequest) SetMarker(v string) *CCPWalkFileRequest {
  s.Marker = &v
  return s
}

func (s *CCPWalkFileRequest) SetOfficeThumbnailProcess(v string) *CCPWalkFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *CCPWalkFileRequest) SetOrderBy(v string) *CCPWalkFileRequest {
  s.OrderBy = &v
  return s
}

func (s *CCPWalkFileRequest) SetOrderDirection(v string) *CCPWalkFileRequest {
  s.OrderDirection = &v
  return s
}

func (s *CCPWalkFileRequest) SetParentFileId(v string) *CCPWalkFileRequest {
  s.ParentFileId = &v
  return s
}

func (s *CCPWalkFileRequest) SetParentFileIdPath(v string) *CCPWalkFileRequest {
  s.ParentFileIdPath = &v
  return s
}

func (s *CCPWalkFileRequest) SetReferer(v string) *CCPWalkFileRequest {
  s.Referer = &v
  return s
}

func (s *CCPWalkFileRequest) SetShareId(v string) *CCPWalkFileRequest {
  s.ShareId = &v
  return s
}

func (s *CCPWalkFileRequest) SetSignToken(v string) *CCPWalkFileRequest {
  s.SignToken = &v
  return s
}

func (s *CCPWalkFileRequest) SetStarred(v bool) *CCPWalkFileRequest {
  s.Starred = &v
  return s
}

func (s *CCPWalkFileRequest) SetStatus(v string) *CCPWalkFileRequest {
  s.Status = &v
  return s
}

func (s *CCPWalkFileRequest) SetType(v string) *CCPWalkFileRequest {
  s.Type = &v
  return s
}

func (s *CCPWalkFileRequest) SetUrlExpireSec(v int64) *CCPWalkFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *CCPWalkFileRequest) SetVideoThumbnailProcess(v string) *CCPWalkFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type CCPWalkFileResponse struct {
  // items
  Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s CCPWalkFileResponse) String() string {
  return tea.Prettify(s)
}

func (s CCPWalkFileResponse) GoString() string {
  return s.String()
}

func (s *CCPWalkFileResponse) SetItems(v []*BaseCCPFileResponse) *CCPWalkFileResponse {
  s.Items = v
  return s
}

func (s *CCPWalkFileResponse) SetNextMarker(v string) *CCPWalkFileResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type CancelLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // tokentoken
  TemporaryToken *string `json:"temporary_token,omitempty" xml:"temporary_token,omitempty" require:"true"`
}

func (s CancelLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s CancelLinkRequest) GoString() string {
  return s.String()
}

func (s *CancelLinkRequest) SetHeaders(v map[string]*string) *CancelLinkRequest {
  s.Headers = v
  return s
}

func (s *CancelLinkRequest) SetTemporaryToken(v string) *CancelLinkRequest {
  s.TemporaryToken = &v
  return s
}

/**
 * cancel_share_link request
 */
type CancelShareLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CancelShareLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s CancelShareLinkRequest) GoString() string {
  return s.String()
}

func (s *CancelShareLinkRequest) SetHeaders(v map[string]*string) *CancelShareLinkRequest {
  s.Headers = v
  return s
}

func (s *CancelShareLinkRequest) SetShareId(v string) *CancelShareLinkRequest {
  s.ShareId = &v
  return s
}

/**
 * 
 */
type Captcha struct {
  // base64
  Captcha *string `json:"captcha,omitempty" xml:"captcha,omitempty" require:"true"`
  // 
  CaptchaFormat *string `json:"captcha_format,omitempty" xml:"captcha_format,omitempty" require:"true"`
  // ID
  CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty" require:"true"`
}

func (s Captcha) String() string {
  return tea.Prettify(s)
}

func (s Captcha) GoString() string {
  return s.String()
}

func (s *Captcha) SetCaptcha(v string) *Captcha {
  s.Captcha = &v
  return s
}

func (s *Captcha) SetCaptchaFormat(v string) *Captcha {
  s.CaptchaFormat = &v
  return s
}

func (s *Captcha) SetCaptchaId(v string) *Captcha {
  s.CaptchaId = &v
  return s
}

/**
 * 
 */
type CertInfo struct {
  CertID *string `json:"CertID,omitempty" xml:"CertID,omitempty"`
  // cert body
  CertBody *string `json:"cert_body,omitempty" xml:"cert_body,omitempty" require:"true"`
  // cert name
  CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty" require:"true"`
  // cert privatekey
  CertPrivatekey *string `json:"cert_privatekey,omitempty" xml:"cert_privatekey,omitempty" require:"true"`
}

func (s CertInfo) String() string {
  return tea.Prettify(s)
}

func (s CertInfo) GoString() string {
  return s.String()
}

func (s *CertInfo) SetCertID(v string) *CertInfo {
  s.CertID = &v
  return s
}

func (s *CertInfo) SetCertBody(v string) *CertInfo {
  s.CertBody = &v
  return s
}

func (s *CertInfo) SetCertName(v string) *CertInfo {
  s.CertName = &v
  return s
}

func (s *CertInfo) SetCertPrivatekey(v string) *CertInfo {
  s.CertPrivatekey = &v
  return s
}

/**
 * 
 */
type ClearRecycleBinRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
}

func (s ClearRecycleBinRequest) String() string {
  return tea.Prettify(s)
}

func (s ClearRecycleBinRequest) GoString() string {
  return s.String()
}

func (s *ClearRecycleBinRequest) SetHeaders(v map[string]*string) *ClearRecycleBinRequest {
  s.Headers = v
  return s
}

func (s *ClearRecycleBinRequest) SetDriveId(v string) *ClearRecycleBinRequest {
  s.DriveId = &v
  return s
}

/**
 * ClearRecycleBinResponse
 */
type ClearRecycleBinResponse struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // task_id
  TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ClearRecycleBinResponse) String() string {
  return tea.Prettify(s)
}

func (s ClearRecycleBinResponse) GoString() string {
  return s.String()
}

func (s *ClearRecycleBinResponse) SetDomainId(v string) *ClearRecycleBinResponse {
  s.DomainId = &v
  return s
}

func (s *ClearRecycleBinResponse) SetDriveId(v string) *ClearRecycleBinResponse {
  s.DriveId = &v
  return s
}

func (s *ClearRecycleBinResponse) SetTaskId(v string) *ClearRecycleBinResponse {
  s.TaskId = &v
  return s
}

/**
 * 
 */
type CompleteFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s CompleteFileRequest) String() string {
  return tea.Prettify(s)
}

func (s CompleteFileRequest) GoString() string {
  return s.String()
}

func (s *CompleteFileRequest) SetHeaders(v map[string]*string) *CompleteFileRequest {
  s.Headers = v
  return s
}

func (s *CompleteFileRequest) SetAdditionData(v map[string]interface{}) *CompleteFileRequest {
  s.AdditionData = v
  return s
}

func (s *CompleteFileRequest) SetDriveId(v string) *CompleteFileRequest {
  s.DriveId = &v
  return s
}

func (s *CompleteFileRequest) SetFileId(v string) *CompleteFileRequest {
  s.FileId = &v
  return s
}

func (s *CompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *CompleteFileRequest {
  s.PartInfoList = v
  return s
}

func (s *CompleteFileRequest) SetShareId(v string) *CompleteFileRequest {
  s.ShareId = &v
  return s
}

func (s *CompleteFileRequest) SetUploadId(v string) *CompleteFileRequest {
  s.UploadId = &v
  return s
}

/**
 * complete file response
 */
type CompleteFileResponse struct {
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  StreamLocations map[string]interface{} `json:"stream_locations,omitempty" xml:"stream_locations,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s CompleteFileResponse) String() string {
  return tea.Prettify(s)
}

func (s CompleteFileResponse) GoString() string {
  return s.String()
}

func (s *CompleteFileResponse) SetCategory(v string) *CompleteFileResponse {
  s.Category = &v
  return s
}

func (s *CompleteFileResponse) SetCharacteristicHash(v string) *CompleteFileResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *CompleteFileResponse) SetContentHash(v string) *CompleteFileResponse {
  s.ContentHash = &v
  return s
}

func (s *CompleteFileResponse) SetContentHashName(v string) *CompleteFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *CompleteFileResponse) SetContentType(v string) *CompleteFileResponse {
  s.ContentType = &v
  return s
}

func (s *CompleteFileResponse) SetCrc64Hash(v string) *CompleteFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *CompleteFileResponse) SetCreatedAt(v string) *CompleteFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *CompleteFileResponse) SetDescription(v string) *CompleteFileResponse {
  s.Description = &v
  return s
}

func (s *CompleteFileResponse) SetDomainId(v string) *CompleteFileResponse {
  s.DomainId = &v
  return s
}

func (s *CompleteFileResponse) SetDownloadUrl(v string) *CompleteFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *CompleteFileResponse) SetDriveId(v string) *CompleteFileResponse {
  s.DriveId = &v
  return s
}

func (s *CompleteFileResponse) SetEncryptMode(v string) *CompleteFileResponse {
  s.EncryptMode = &v
  return s
}

func (s *CompleteFileResponse) SetFileExtension(v string) *CompleteFileResponse {
  s.FileExtension = &v
  return s
}

func (s *CompleteFileResponse) SetFileId(v string) *CompleteFileResponse {
  s.FileId = &v
  return s
}

func (s *CompleteFileResponse) SetHidden(v bool) *CompleteFileResponse {
  s.Hidden = &v
  return s
}

func (s *CompleteFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *CompleteFileResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *CompleteFileResponse) SetLabels(v []*string) *CompleteFileResponse {
  s.Labels = v
  return s
}

func (s *CompleteFileResponse) SetLastModifierId(v string) *CompleteFileResponse {
  s.LastModifierId = &v
  return s
}

func (s *CompleteFileResponse) SetLastModifierName(v string) *CompleteFileResponse {
  s.LastModifierName = &v
  return s
}

func (s *CompleteFileResponse) SetLastModifierType(v string) *CompleteFileResponse {
  s.LastModifierType = &v
  return s
}

func (s *CompleteFileResponse) SetLocation(v string) *CompleteFileResponse {
  s.Location = &v
  return s
}

func (s *CompleteFileResponse) SetMeta(v string) *CompleteFileResponse {
  s.Meta = &v
  return s
}

func (s *CompleteFileResponse) SetName(v string) *CompleteFileResponse {
  s.Name = &v
  return s
}

func (s *CompleteFileResponse) SetParentFileId(v string) *CompleteFileResponse {
  s.ParentFileId = &v
  return s
}

func (s *CompleteFileResponse) SetPunishFlag(v int64) *CompleteFileResponse {
  s.PunishFlag = &v
  return s
}

func (s *CompleteFileResponse) SetShareId(v string) *CompleteFileResponse {
  s.ShareId = &v
  return s
}

func (s *CompleteFileResponse) SetSize(v int64) *CompleteFileResponse {
  s.Size = &v
  return s
}

func (s *CompleteFileResponse) SetStarred(v bool) *CompleteFileResponse {
  s.Starred = &v
  return s
}

func (s *CompleteFileResponse) SetStatus(v string) *CompleteFileResponse {
  s.Status = &v
  return s
}

func (s *CompleteFileResponse) SetStreamLocations(v map[string]interface{}) *CompleteFileResponse {
  s.StreamLocations = v
  return s
}

func (s *CompleteFileResponse) SetStreamsInfo(v map[string]interface{}) *CompleteFileResponse {
  s.StreamsInfo = v
  return s
}

func (s *CompleteFileResponse) SetThumbnail(v string) *CompleteFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *CompleteFileResponse) SetTrashedAt(v string) *CompleteFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *CompleteFileResponse) SetType(v string) *CompleteFileResponse {
  s.Type = &v
  return s
}

func (s *CompleteFileResponse) SetUpdatedAt(v string) *CompleteFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *CompleteFileResponse) SetUploadId(v string) *CompleteFileResponse {
  s.UploadId = &v
  return s
}

func (s *CompleteFileResponse) SetUrl(v string) *CompleteFileResponse {
  s.Url = &v
  return s
}

func (s *CompleteFileResponse) SetUserMeta(v string) *CompleteFileResponse {
  s.UserMeta = &v
  return s
}

func (s *CompleteFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *CompleteFileResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *CompleteFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *CompleteFileResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * 
 */
type ConfirmLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // tokentoken
  TemporaryToken *string `json:"temporary_token,omitempty" xml:"temporary_token,omitempty" require:"true"`
}

func (s ConfirmLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s ConfirmLinkRequest) GoString() string {
  return s.String()
}

func (s *ConfirmLinkRequest) SetHeaders(v map[string]*string) *ConfirmLinkRequest {
  s.Headers = v
  return s
}

func (s *ConfirmLinkRequest) SetTemporaryToken(v string) *ConfirmLinkRequest {
  s.TemporaryToken = &v
  return s
}

/**
 * 
 */
type CopyFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // auto_rename
  // type: boolean
  AutoRename *bool `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
  BatchId *string `json:"batch_id,omitempty" xml:"batch_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // new_name
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // to_drive_id
  ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
  // to_parent_file_id
  ToParentFileId *string `json:"to_parent_file_id,omitempty" xml:"to_parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
  // to_drive_id
  ToShareId *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty" pattern:"[0-9]+"`
}

func (s CopyFileRequest) String() string {
  return tea.Prettify(s)
}

func (s CopyFileRequest) GoString() string {
  return s.String()
}

func (s *CopyFileRequest) SetHeaders(v map[string]*string) *CopyFileRequest {
  s.Headers = v
  return s
}

func (s *CopyFileRequest) SetAdditionData(v map[string]interface{}) *CopyFileRequest {
  s.AdditionData = v
  return s
}

func (s *CopyFileRequest) SetAutoRename(v bool) *CopyFileRequest {
  s.AutoRename = &v
  return s
}

func (s *CopyFileRequest) SetBatchId(v string) *CopyFileRequest {
  s.BatchId = &v
  return s
}

func (s *CopyFileRequest) SetDriveId(v string) *CopyFileRequest {
  s.DriveId = &v
  return s
}

func (s *CopyFileRequest) SetFileId(v string) *CopyFileRequest {
  s.FileId = &v
  return s
}

func (s *CopyFileRequest) SetFileIdPath(v string) *CopyFileRequest {
  s.FileIdPath = &v
  return s
}

func (s *CopyFileRequest) SetNewName(v string) *CopyFileRequest {
  s.NewName = &v
  return s
}

func (s *CopyFileRequest) SetReferer(v string) *CopyFileRequest {
  s.Referer = &v
  return s
}

func (s *CopyFileRequest) SetShareId(v string) *CopyFileRequest {
  s.ShareId = &v
  return s
}

func (s *CopyFileRequest) SetToDriveId(v string) *CopyFileRequest {
  s.ToDriveId = &v
  return s
}

func (s *CopyFileRequest) SetToParentFileId(v string) *CopyFileRequest {
  s.ToParentFileId = &v
  return s
}

func (s *CopyFileRequest) SetToShareId(v string) *CopyFileRequest {
  s.ToShareId = &v
  return s
}

/**
 *  response
 */
type CopyFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s CopyFileResponse) String() string {
  return tea.Prettify(s)
}

func (s CopyFileResponse) GoString() string {
  return s.String()
}

func (s *CopyFileResponse) SetAsyncTaskId(v string) *CopyFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *CopyFileResponse) SetDomainId(v string) *CopyFileResponse {
  s.DomainId = &v
  return s
}

func (s *CopyFileResponse) SetDriveId(v string) *CopyFileResponse {
  s.DriveId = &v
  return s
}

func (s *CopyFileResponse) SetFileId(v string) *CopyFileResponse {
  s.FileId = &v
  return s
}

/**
 * 
 */
type CorsRule struct {
  // AllowedHeader
  AllowedHeader []*string `json:"allowed_header,omitempty" xml:"allowed_header,omitempty" type:"Repeated"`
  // AllowedMethod
  AllowedMethod []*string `json:"allowed_method,omitempty" xml:"allowed_method,omitempty" type:"Repeated"`
  // AllowedOrigin
  AllowedOrigin []*string `json:"allowed_origin,omitempty" xml:"allowed_origin,omitempty" type:"Repeated"`
  // ExposeHeader
  ExposeHeader []*string `json:"expose_header,omitempty" xml:"expose_header,omitempty" type:"Repeated"`
  // MaxAgeSeconds
  MaxAgeSeconds *int64 `json:"max_age_seconds,omitempty" xml:"max_age_seconds,omitempty"`
}

func (s CorsRule) String() string {
  return tea.Prettify(s)
}

func (s CorsRule) GoString() string {
  return s.String()
}

func (s *CorsRule) SetAllowedHeader(v []*string) *CorsRule {
  s.AllowedHeader = v
  return s
}

func (s *CorsRule) SetAllowedMethod(v []*string) *CorsRule {
  s.AllowedMethod = v
  return s
}

func (s *CorsRule) SetAllowedOrigin(v []*string) *CorsRule {
  s.AllowedOrigin = v
  return s
}

func (s *CorsRule) SetExposeHeader(v []*string) *CorsRule {
  s.ExposeHeader = v
  return s
}

func (s *CorsRule) SetMaxAgeSeconds(v int64) *CorsRule {
  s.MaxAgeSeconds = &v
  return s
}

/**
 * 
 */
type CreateAppRequest struct {
  // App
  AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" require:"true" maxLength:"128" minLength:"1"`
  // App
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"128" minLength:"0"`
  // domainApp
  IsThirdParty *bool `json:"is_third_party,omitempty" xml:"is_third_party,omitempty"`
  // App
  Logo *string `json:"logo,omitempty" xml:"logo,omitempty" require:"true"`
  // RSA, PEM
  PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
  // App
  RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
  // App
  Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" require:"true" type:"Repeated"`
  // App
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s CreateAppRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateAppRequest) GoString() string {
  return s.String()
}

func (s *CreateAppRequest) SetAppName(v string) *CreateAppRequest {
  s.AppName = &v
  return s
}

func (s *CreateAppRequest) SetDescription(v string) *CreateAppRequest {
  s.Description = &v
  return s
}

func (s *CreateAppRequest) SetIsThirdParty(v bool) *CreateAppRequest {
  s.IsThirdParty = &v
  return s
}

func (s *CreateAppRequest) SetLogo(v string) *CreateAppRequest {
  s.Logo = &v
  return s
}

func (s *CreateAppRequest) SetPublicKey(v string) *CreateAppRequest {
  s.PublicKey = &v
  return s
}

func (s *CreateAppRequest) SetRedirectUri(v string) *CreateAppRequest {
  s.RedirectUri = &v
  return s
}

func (s *CreateAppRequest) SetScope(v []*string) *CreateAppRequest {
  s.Scope = v
  return s
}

func (s *CreateAppRequest) SetType(v string) *CreateAppRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type CreateDetail struct {
  // CreateType
  CreateType *string `json:"create_type,omitempty" xml:"create_type,omitempty"`
  // SrcFileID
  SrcFileId *string `json:"src_file_id,omitempty" xml:"src_file_id,omitempty"`
}

func (s CreateDetail) String() string {
  return tea.Prettify(s)
}

func (s CreateDetail) GoString() string {
  return s.String()
}

func (s *CreateDetail) SetCreateType(v string) *CreateDetail {
  s.CreateType = &v
  return s
}

func (s *CreateDetail) SetSrcFileId(v string) *CreateDetail {
  s.SrcFileId = &v
  return s
}

/**
 * create domain request
 */
type CreateDomainRequest struct {
  // 
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty" require:"true"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  // Domain 
  Mode *string `json:"mode,omitempty" xml:"mode,omitempty" require:"true"`
  // Domain 
  PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
  // 
  StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
  //  Region 
  StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" require:"true" type:"Repeated"`
}

func (s CreateDomainRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateDomainRequest) GoString() string {
  return s.String()
}

func (s *CreateDomainRequest) SetAuthConfig(v map[string]interface{}) *CreateDomainRequest {
  s.AuthConfig = v
  return s
}

func (s *CreateDomainRequest) SetAuthDingdingAppId(v string) *CreateDomainRequest {
  s.AuthDingdingAppId = &v
  return s
}

func (s *CreateDomainRequest) SetAuthDingdingAppSecret(v string) *CreateDomainRequest {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *CreateDomainRequest) SetAuthDingdingEnable(v bool) *CreateDomainRequest {
  s.AuthDingdingEnable = &v
  return s
}

func (s *CreateDomainRequest) SetAuthEndpointEnable(v bool) *CreateDomainRequest {
  s.AuthEndpointEnable = &v
  return s
}

func (s *CreateDomainRequest) SetAuthRamAppId(v string) *CreateDomainRequest {
  s.AuthRamAppId = &v
  return s
}

func (s *CreateDomainRequest) SetAuthRamAppSecret(v string) *CreateDomainRequest {
  s.AuthRamAppSecret = &v
  return s
}

func (s *CreateDomainRequest) SetAuthRamEnable(v bool) *CreateDomainRequest {
  s.AuthRamEnable = &v
  return s
}

func (s *CreateDomainRequest) SetDataHashName(v string) *CreateDomainRequest {
  s.DataHashName = &v
  return s
}

func (s *CreateDomainRequest) SetDescription(v string) *CreateDomainRequest {
  s.Description = &v
  return s
}

func (s *CreateDomainRequest) SetDomainName(v string) *CreateDomainRequest {
  s.DomainName = &v
  return s
}

func (s *CreateDomainRequest) SetEventFilenameMatches(v string) *CreateDomainRequest {
  s.EventFilenameMatches = &v
  return s
}

func (s *CreateDomainRequest) SetEventMnsEndpoint(v string) *CreateDomainRequest {
  s.EventMnsEndpoint = &v
  return s
}

func (s *CreateDomainRequest) SetEventMnsTopic(v string) *CreateDomainRequest {
  s.EventMnsTopic = &v
  return s
}

func (s *CreateDomainRequest) SetEventNames(v []*string) *CreateDomainRequest {
  s.EventNames = v
  return s
}

func (s *CreateDomainRequest) SetEventRoleArn(v string) *CreateDomainRequest {
  s.EventRoleArn = &v
  return s
}

func (s *CreateDomainRequest) SetInitDriveEnable(v bool) *CreateDomainRequest {
  s.InitDriveEnable = &v
  return s
}

func (s *CreateDomainRequest) SetInitDriveSize(v int64) *CreateDomainRequest {
  s.InitDriveSize = &v
  return s
}

func (s *CreateDomainRequest) SetMode(v string) *CreateDomainRequest {
  s.Mode = &v
  return s
}

func (s *CreateDomainRequest) SetPathType(v string) *CreateDomainRequest {
  s.PathType = &v
  return s
}

func (s *CreateDomainRequest) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *CreateDomainRequest {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *CreateDomainRequest) SetSharable(v bool) *CreateDomainRequest {
  s.Sharable = &v
  return s
}

func (s *CreateDomainRequest) SetStoreLevel(v string) *CreateDomainRequest {
  s.StoreLevel = &v
  return s
}

func (s *CreateDomainRequest) SetStoreRegionList(v []*string) *CreateDomainRequest {
  s.StoreRegionList = v
  return s
}

/**
 * create drive request
 */
type CreateDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive, drive
  Default *bool `json:"default,omitempty" xml:"default,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // Drive 
  DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty" require:"true" maxLength:"1024"`
  // Drive
  DriveType *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // 
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
  // 
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty" require:"true"`
  // domainPathTypeOSSPath Drivestore
  RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // StoreID , domainPathTypeOSSPath
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // ,Byte [ -1 ]
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
}

func (s CreateDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateDriveRequest) GoString() string {
  return s.String()
}

func (s *CreateDriveRequest) SetHeaders(v map[string]*string) *CreateDriveRequest {
  s.Headers = v
  return s
}

func (s *CreateDriveRequest) SetDefault(v bool) *CreateDriveRequest {
  s.Default = &v
  return s
}

func (s *CreateDriveRequest) SetDescription(v string) *CreateDriveRequest {
  s.Description = &v
  return s
}

func (s *CreateDriveRequest) SetDriveName(v string) *CreateDriveRequest {
  s.DriveName = &v
  return s
}

func (s *CreateDriveRequest) SetDriveType(v string) *CreateDriveRequest {
  s.DriveType = &v
  return s
}

func (s *CreateDriveRequest) SetEncryptMode(v string) *CreateDriveRequest {
  s.EncryptMode = &v
  return s
}

func (s *CreateDriveRequest) SetLocation(v string) *CreateDriveRequest {
  s.Location = &v
  return s
}

func (s *CreateDriveRequest) SetOwner(v string) *CreateDriveRequest {
  s.Owner = &v
  return s
}

func (s *CreateDriveRequest) SetOwnerType(v string) *CreateDriveRequest {
  s.OwnerType = &v
  return s
}

func (s *CreateDriveRequest) SetRelativePath(v string) *CreateDriveRequest {
  s.RelativePath = &v
  return s
}

func (s *CreateDriveRequest) SetStatus(v string) *CreateDriveRequest {
  s.Status = &v
  return s
}

func (s *CreateDriveRequest) SetStoreId(v string) *CreateDriveRequest {
  s.StoreId = &v
  return s
}

func (s *CreateDriveRequest) SetSubdomainId(v string) *CreateDriveRequest {
  s.SubdomainId = &v
  return s
}

func (s *CreateDriveRequest) SetTotalSize(v int64) *CreateDriveRequest {
  s.TotalSize = &v
  return s
}

/**
 * Create drive response
 */
type CreateDriveResponse struct {
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
}

func (s CreateDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateDriveResponse) GoString() string {
  return s.String()
}

func (s *CreateDriveResponse) SetDomainId(v string) *CreateDriveResponse {
  s.DomainId = &v
  return s
}

func (s *CreateDriveResponse) SetDriveId(v string) *CreateDriveResponse {
  s.DriveId = &v
  return s
}

/**
 * 
 */
type CreateFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  AutoRename *bool `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
  // check_name_mode
  CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
  // content_hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // ContentMd5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
  // ContentType
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024" minLength:"0"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // force_upload_to_location
  ForceUploadToLocation *bool `json:"force_upload_to_location,omitempty" xml:"force_upload_to_location,omitempty"`
  // hidden
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaMetadata `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_updated_at
  LastUpdatedAt *string `json:"last_updated_at,omitempty" xml:"last_updated_at,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // Name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
  ParallelUpload *bool `json:"parallel_upload,omitempty" xml:"parallel_upload,omitempty"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9]{1,50}"`
  ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // pre_hash
  PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
  // proof_code
  ProofCode *string `json:"proof_code,omitempty" xml:"proof_code,omitempty"`
  // proof_version
  ProofVersion *string `json:"proof_version,omitempty" xml:"proof_version,omitempty"`
  // share_id
  // example
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // streams_info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // Type
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaMetadata `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
}

func (s CreateFileRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateFileRequest) GoString() string {
  return s.String()
}

func (s *CreateFileRequest) SetHeaders(v map[string]*string) *CreateFileRequest {
  s.Headers = v
  return s
}

func (s *CreateFileRequest) SetAdditionData(v map[string]interface{}) *CreateFileRequest {
  s.AdditionData = v
  return s
}

func (s *CreateFileRequest) SetAutoRename(v bool) *CreateFileRequest {
  s.AutoRename = &v
  return s
}

func (s *CreateFileRequest) SetCheckNameMode(v string) *CreateFileRequest {
  s.CheckNameMode = &v
  return s
}

func (s *CreateFileRequest) SetContentHash(v string) *CreateFileRequest {
  s.ContentHash = &v
  return s
}

func (s *CreateFileRequest) SetContentHashName(v string) *CreateFileRequest {
  s.ContentHashName = &v
  return s
}

func (s *CreateFileRequest) SetContentMd5(v string) *CreateFileRequest {
  s.ContentMd5 = &v
  return s
}

func (s *CreateFileRequest) SetContentType(v string) *CreateFileRequest {
  s.ContentType = &v
  return s
}

func (s *CreateFileRequest) SetDescription(v string) *CreateFileRequest {
  s.Description = &v
  return s
}

func (s *CreateFileRequest) SetDriveId(v string) *CreateFileRequest {
  s.DriveId = &v
  return s
}

func (s *CreateFileRequest) SetEncryptMode(v string) *CreateFileRequest {
  s.EncryptMode = &v
  return s
}

func (s *CreateFileRequest) SetFileId(v string) *CreateFileRequest {
  s.FileId = &v
  return s
}

func (s *CreateFileRequest) SetForceUploadToLocation(v bool) *CreateFileRequest {
  s.ForceUploadToLocation = &v
  return s
}

func (s *CreateFileRequest) SetHidden(v bool) *CreateFileRequest {
  s.Hidden = &v
  return s
}

func (s *CreateFileRequest) SetImageMediaMetadata(v *ImageMediaMetadata) *CreateFileRequest {
  s.ImageMediaMetadata = v
  return s
}

func (s *CreateFileRequest) SetLabels(v []*string) *CreateFileRequest {
  s.Labels = v
  return s
}

func (s *CreateFileRequest) SetLastUpdatedAt(v string) *CreateFileRequest {
  s.LastUpdatedAt = &v
  return s
}

func (s *CreateFileRequest) SetLocation(v string) *CreateFileRequest {
  s.Location = &v
  return s
}

func (s *CreateFileRequest) SetMeta(v string) *CreateFileRequest {
  s.Meta = &v
  return s
}

func (s *CreateFileRequest) SetName(v string) *CreateFileRequest {
  s.Name = &v
  return s
}

func (s *CreateFileRequest) SetParallelUpload(v bool) *CreateFileRequest {
  s.ParallelUpload = &v
  return s
}

func (s *CreateFileRequest) SetParentFileId(v string) *CreateFileRequest {
  s.ParentFileId = &v
  return s
}

func (s *CreateFileRequest) SetParentFileIdPath(v string) *CreateFileRequest {
  s.ParentFileIdPath = &v
  return s
}

func (s *CreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *CreateFileRequest {
  s.PartInfoList = v
  return s
}

func (s *CreateFileRequest) SetPreHash(v string) *CreateFileRequest {
  s.PreHash = &v
  return s
}

func (s *CreateFileRequest) SetProofCode(v string) *CreateFileRequest {
  s.ProofCode = &v
  return s
}

func (s *CreateFileRequest) SetProofVersion(v string) *CreateFileRequest {
  s.ProofVersion = &v
  return s
}

func (s *CreateFileRequest) SetShareId(v string) *CreateFileRequest {
  s.ShareId = &v
  return s
}

func (s *CreateFileRequest) SetSize(v int64) *CreateFileRequest {
  s.Size = &v
  return s
}

func (s *CreateFileRequest) SetStreamsInfo(v map[string]interface{}) *CreateFileRequest {
  s.StreamsInfo = v
  return s
}

func (s *CreateFileRequest) SetType(v string) *CreateFileRequest {
  s.Type = &v
  return s
}

func (s *CreateFileRequest) SetUserMeta(v string) *CreateFileRequest {
  s.UserMeta = &v
  return s
}

func (s *CreateFileRequest) SetVideoMediaMetadata(v *VideoMediaMetadata) *CreateFileRequest {
  s.VideoMediaMetadata = v
  return s
}

/**
 * Create file response
 */
type CreateFileResponse struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // exist
  // type: boolean
  Exist *bool `json:"exist,omitempty" xml:"exist,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // file_name
  FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty" maxLength:"255" minLength:"1"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // rapid_upload
  // type: boolean
  RapidUpload *bool `json:"rapid_upload,omitempty" xml:"rapid_upload,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // streams_upload_info
  StreamsUploadInfo map[string]interface{} `json:"streams_upload_info,omitempty" xml:"streams_upload_info,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s CreateFileResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateFileResponse) GoString() string {
  return s.String()
}

func (s *CreateFileResponse) SetDomainId(v string) *CreateFileResponse {
  s.DomainId = &v
  return s
}

func (s *CreateFileResponse) SetDriveId(v string) *CreateFileResponse {
  s.DriveId = &v
  return s
}

func (s *CreateFileResponse) SetEncryptMode(v string) *CreateFileResponse {
  s.EncryptMode = &v
  return s
}

func (s *CreateFileResponse) SetExist(v bool) *CreateFileResponse {
  s.Exist = &v
  return s
}

func (s *CreateFileResponse) SetFileId(v string) *CreateFileResponse {
  s.FileId = &v
  return s
}

func (s *CreateFileResponse) SetFileName(v string) *CreateFileResponse {
  s.FileName = &v
  return s
}

func (s *CreateFileResponse) SetLocation(v string) *CreateFileResponse {
  s.Location = &v
  return s
}

func (s *CreateFileResponse) SetParentFileId(v string) *CreateFileResponse {
  s.ParentFileId = &v
  return s
}

func (s *CreateFileResponse) SetPartInfoList(v []*UploadPartInfo) *CreateFileResponse {
  s.PartInfoList = v
  return s
}

func (s *CreateFileResponse) SetRapidUpload(v bool) *CreateFileResponse {
  s.RapidUpload = &v
  return s
}

func (s *CreateFileResponse) SetStatus(v string) *CreateFileResponse {
  s.Status = &v
  return s
}

func (s *CreateFileResponse) SetStreamsUploadInfo(v map[string]interface{}) *CreateFileResponse {
  s.StreamsUploadInfo = v
  return s
}

func (s *CreateFileResponse) SetType(v string) *CreateFileResponse {
  s.Type = &v
  return s
}

func (s *CreateFileResponse) SetUploadId(v string) *CreateFileResponse {
  s.UploadId = &v
  return s
}

/**
 * create_share_link request
 */
type CreateShareLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // file_id_list
  FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" maximum:"100" minimum:"1" type:"Repeated"`
  // file_path_list
  FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" maximum:"100" minimum:"1" type:"Repeated"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty" maximum:"64" minimum:"0"`
}

func (s CreateShareLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateShareLinkRequest) GoString() string {
  return s.String()
}

func (s *CreateShareLinkRequest) SetHeaders(v map[string]*string) *CreateShareLinkRequest {
  s.Headers = v
  return s
}

func (s *CreateShareLinkRequest) SetAdditionData(v map[string]interface{}) *CreateShareLinkRequest {
  s.AdditionData = v
  return s
}

func (s *CreateShareLinkRequest) SetDescription(v string) *CreateShareLinkRequest {
  s.Description = &v
  return s
}

func (s *CreateShareLinkRequest) SetDriveId(v string) *CreateShareLinkRequest {
  s.DriveId = &v
  return s
}

func (s *CreateShareLinkRequest) SetExpiration(v string) *CreateShareLinkRequest {
  s.Expiration = &v
  return s
}

func (s *CreateShareLinkRequest) SetFileId(v string) *CreateShareLinkRequest {
  s.FileId = &v
  return s
}

func (s *CreateShareLinkRequest) SetFileIdList(v []*string) *CreateShareLinkRequest {
  s.FileIdList = v
  return s
}

func (s *CreateShareLinkRequest) SetFilePathList(v []*string) *CreateShareLinkRequest {
  s.FilePathList = v
  return s
}

func (s *CreateShareLinkRequest) SetReferer(v string) *CreateShareLinkRequest {
  s.Referer = &v
  return s
}

func (s *CreateShareLinkRequest) SetShareName(v string) *CreateShareLinkRequest {
  s.ShareName = &v
  return s
}

func (s *CreateShareLinkRequest) SetSharePwd(v string) *CreateShareLinkRequest {
  s.SharePwd = &v
  return s
}

/**
 * create_share_link response
 */
type CreateShareLinkResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // file_id_list
  FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
  // file_id_list
  FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
  // preview_count
  PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
  // 
  SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_msg
  ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_policy
  SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
  // share_url
  ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s CreateShareLinkResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateShareLinkResponse) GoString() string {
  return s.String()
}

func (s *CreateShareLinkResponse) SetCreatedAt(v string) *CreateShareLinkResponse {
  s.CreatedAt = &v
  return s
}

func (s *CreateShareLinkResponse) SetCreator(v string) *CreateShareLinkResponse {
  s.Creator = &v
  return s
}

func (s *CreateShareLinkResponse) SetDescription(v string) *CreateShareLinkResponse {
  s.Description = &v
  return s
}

func (s *CreateShareLinkResponse) SetDownloadCount(v int64) *CreateShareLinkResponse {
  s.DownloadCount = &v
  return s
}

func (s *CreateShareLinkResponse) SetDriveId(v string) *CreateShareLinkResponse {
  s.DriveId = &v
  return s
}

func (s *CreateShareLinkResponse) SetExpiration(v string) *CreateShareLinkResponse {
  s.Expiration = &v
  return s
}

func (s *CreateShareLinkResponse) SetExpired(v bool) *CreateShareLinkResponse {
  s.Expired = &v
  return s
}

func (s *CreateShareLinkResponse) SetFileId(v string) *CreateShareLinkResponse {
  s.FileId = &v
  return s
}

func (s *CreateShareLinkResponse) SetFileIdList(v []*string) *CreateShareLinkResponse {
  s.FileIdList = v
  return s
}

func (s *CreateShareLinkResponse) SetFilePathList(v []*string) *CreateShareLinkResponse {
  s.FilePathList = v
  return s
}

func (s *CreateShareLinkResponse) SetPreviewCount(v int64) *CreateShareLinkResponse {
  s.PreviewCount = &v
  return s
}

func (s *CreateShareLinkResponse) SetSaveCount(v int64) *CreateShareLinkResponse {
  s.SaveCount = &v
  return s
}

func (s *CreateShareLinkResponse) SetShareId(v string) *CreateShareLinkResponse {
  s.ShareId = &v
  return s
}

func (s *CreateShareLinkResponse) SetShareMsg(v string) *CreateShareLinkResponse {
  s.ShareMsg = &v
  return s
}

func (s *CreateShareLinkResponse) SetShareName(v string) *CreateShareLinkResponse {
  s.ShareName = &v
  return s
}

func (s *CreateShareLinkResponse) SetSharePolicy(v string) *CreateShareLinkResponse {
  s.SharePolicy = &v
  return s
}

func (s *CreateShareLinkResponse) SetSharePwd(v string) *CreateShareLinkResponse {
  s.SharePwd = &v
  return s
}

func (s *CreateShareLinkResponse) SetShareUrl(v string) *CreateShareLinkResponse {
  s.ShareUrl = &v
  return s
}

func (s *CreateShareLinkResponse) SetStatus(v string) *CreateShareLinkResponse {
  s.Status = &v
  return s
}

func (s *CreateShareLinkResponse) SetUpdatedAt(v string) *CreateShareLinkResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * create share request
 */
type CreateShareRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // owner
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
  // owner_type
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // permissions
  Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
  // share_file_id
  ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
  // share_file_path
  ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share create policy
  // 
  // share_policy
  SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s CreateShareRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateShareRequest) GoString() string {
  return s.String()
}

func (s *CreateShareRequest) SetHeaders(v map[string]*string) *CreateShareRequest {
  s.Headers = v
  return s
}

func (s *CreateShareRequest) SetDescription(v string) *CreateShareRequest {
  s.Description = &v
  return s
}

func (s *CreateShareRequest) SetDriveId(v string) *CreateShareRequest {
  s.DriveId = &v
  return s
}

func (s *CreateShareRequest) SetExpiration(v string) *CreateShareRequest {
  s.Expiration = &v
  return s
}

func (s *CreateShareRequest) SetOwner(v string) *CreateShareRequest {
  s.Owner = &v
  return s
}

func (s *CreateShareRequest) SetOwnerType(v string) *CreateShareRequest {
  s.OwnerType = &v
  return s
}

func (s *CreateShareRequest) SetPermissions(v []*string) *CreateShareRequest {
  s.Permissions = v
  return s
}

func (s *CreateShareRequest) SetShareFileId(v string) *CreateShareRequest {
  s.ShareFileId = &v
  return s
}

func (s *CreateShareRequest) SetShareFilePath(v string) *CreateShareRequest {
  s.ShareFilePath = &v
  return s
}

func (s *CreateShareRequest) SetShareName(v string) *CreateShareRequest {
  s.ShareName = &v
  return s
}

func (s *CreateShareRequest) SetSharePolicy(v []*SharePermissionPolicy) *CreateShareRequest {
  s.SharePolicy = v
  return s
}

func (s *CreateShareRequest) SetStatus(v string) *CreateShareRequest {
  s.Status = &v
  return s
}

/**
 * Create share response
 */
type CreateShareResponse struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CreateShareResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateShareResponse) GoString() string {
  return s.String()
}

func (s *CreateShareResponse) SetDomainId(v string) *CreateShareResponse {
  s.DomainId = &v
  return s
}

func (s *CreateShareResponse) SetShareId(v string) *CreateShareResponse {
  s.ShareId = &v
  return s
}

/**
 * 
 */
type CroppingBoundary struct {
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  Left *int64 `json:"left,omitempty" xml:"left,omitempty"`
  Top *int64 `json:"top,omitempty" xml:"top,omitempty"`
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s CroppingBoundary) String() string {
  return tea.Prettify(s)
}

func (s CroppingBoundary) GoString() string {
  return s.String()
}

func (s *CroppingBoundary) SetHeight(v int64) *CroppingBoundary {
  s.Height = &v
  return s
}

func (s *CroppingBoundary) SetLeft(v int64) *CroppingBoundary {
  s.Left = &v
  return s
}

func (s *CroppingBoundary) SetTop(v int64) *CroppingBoundary {
  s.Top = &v
  return s
}

func (s *CroppingBoundary) SetWidth(v int64) *CroppingBoundary {
  s.Width = &v
  return s
}

/**
 * 
 */
type CroppingSuggestionItem struct {
  AspectRatio *string `json:"aspect_ratio,omitempty" xml:"aspect_ratio,omitempty"`
  CroppingBoundary *CroppingBoundary `json:"cropping_boundary,omitempty" xml:"cropping_boundary,omitempty"`
  Score *float64 `json:"score,omitempty" xml:"score,omitempty"`
}

func (s CroppingSuggestionItem) String() string {
  return tea.Prettify(s)
}

func (s CroppingSuggestionItem) GoString() string {
  return s.String()
}

func (s *CroppingSuggestionItem) SetAspectRatio(v string) *CroppingSuggestionItem {
  s.AspectRatio = &v
  return s
}

func (s *CroppingSuggestionItem) SetCroppingBoundary(v *CroppingBoundary) *CroppingSuggestionItem {
  s.CroppingBoundary = v
  return s
}

func (s *CroppingSuggestionItem) SetScore(v float64) *CroppingSuggestionItem {
  s.Score = &v
  return s
}

/**
 * 
 */
type CustomBenefitMetaRequest struct {
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s CustomBenefitMetaRequest) String() string {
  return tea.Prettify(s)
}

func (s CustomBenefitMetaRequest) GoString() string {
  return s.String()
}

func (s *CustomBenefitMetaRequest) SetEnabled(v bool) *CustomBenefitMetaRequest {
  s.Enabled = &v
  return s
}

/**
 * 
 */
type DataBoxPrivileges struct {
  // feature_attr_id
  FeatureAttrId *string `json:"feature_attr_id,omitempty" xml:"feature_attr_id,omitempty"`
  // feature_id
  FeatureId *string `json:"feature_id,omitempty" xml:"feature_id,omitempty"`
  // quota
  Quota *int64 `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s DataBoxPrivileges) String() string {
  return tea.Prettify(s)
}

func (s DataBoxPrivileges) GoString() string {
  return s.String()
}

func (s *DataBoxPrivileges) SetFeatureAttrId(v string) *DataBoxPrivileges {
  s.FeatureAttrId = &v
  return s
}

func (s *DataBoxPrivileges) SetFeatureId(v string) *DataBoxPrivileges {
  s.FeatureId = &v
  return s
}

func (s *DataBoxPrivileges) SetQuota(v int64) *DataBoxPrivileges {
  s.Quota = &v
  return s
}

/**
 * 
 */
type DefaultChangePasswordRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // AES-256App
  EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty" require:"true"`
  // 8-20
  NewPassword *string `json:"new_password,omitempty" xml:"new_password,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  // 
  State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s DefaultChangePasswordRequest) String() string {
  return tea.Prettify(s)
}

func (s DefaultChangePasswordRequest) GoString() string {
  return s.String()
}

func (s *DefaultChangePasswordRequest) SetHeaders(v map[string]*string) *DefaultChangePasswordRequest {
  s.Headers = v
  return s
}

func (s *DefaultChangePasswordRequest) SetAppId(v string) *DefaultChangePasswordRequest {
  s.AppId = &v
  return s
}

func (s *DefaultChangePasswordRequest) SetEncryptedKey(v string) *DefaultChangePasswordRequest {
  s.EncryptedKey = &v
  return s
}

func (s *DefaultChangePasswordRequest) SetNewPassword(v string) *DefaultChangePasswordRequest {
  s.NewPassword = &v
  return s
}

func (s *DefaultChangePasswordRequest) SetPhoneNumber(v string) *DefaultChangePasswordRequest {
  s.PhoneNumber = &v
  return s
}

func (s *DefaultChangePasswordRequest) SetPhoneRegion(v string) *DefaultChangePasswordRequest {
  s.PhoneRegion = &v
  return s
}

func (s *DefaultChangePasswordRequest) SetState(v string) *DefaultChangePasswordRequest {
  s.State = &v
  return s
}

/**
 * 
 */
type DefaultSetPasswordRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // AES-256App
  EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty" require:"true"`
  // 8-20AES-256CBC, PKCS7Paddingbase64
  NewPassword *string `json:"new_password,omitempty" xml:"new_password,omitempty" require:"true"`
  // 
  State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s DefaultSetPasswordRequest) String() string {
  return tea.Prettify(s)
}

func (s DefaultSetPasswordRequest) GoString() string {
  return s.String()
}

func (s *DefaultSetPasswordRequest) SetHeaders(v map[string]*string) *DefaultSetPasswordRequest {
  s.Headers = v
  return s
}

func (s *DefaultSetPasswordRequest) SetAppId(v string) *DefaultSetPasswordRequest {
  s.AppId = &v
  return s
}

func (s *DefaultSetPasswordRequest) SetEncryptedKey(v string) *DefaultSetPasswordRequest {
  s.EncryptedKey = &v
  return s
}

func (s *DefaultSetPasswordRequest) SetNewPassword(v string) *DefaultSetPasswordRequest {
  s.NewPassword = &v
  return s
}

func (s *DefaultSetPasswordRequest) SetState(v string) *DefaultSetPasswordRequest {
  s.State = &v
  return s
}

/**
 * 
 */
type DeleteAppRequest struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s DeleteAppRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteAppRequest) GoString() string {
  return s.String()
}

func (s *DeleteAppRequest) SetAppId(v string) *DeleteAppRequest {
  s.AppId = &v
  return s
}

/**
 * 
 */
type DeleteBizCNameAndCertRequest struct {
  // api cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s DeleteBizCNameAndCertRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteBizCNameAndCertRequest) GoString() string {
  return s.String()
}

func (s *DeleteBizCNameAndCertRequest) SetBizCname(v string) *DeleteBizCNameAndCertRequest {
  s.BizCname = &v
  return s
}

func (s *DeleteBizCNameAndCertRequest) SetCnameType(v string) *DeleteBizCNameAndCertRequest {
  s.CnameType = &v
  return s
}

func (s *DeleteBizCNameAndCertRequest) SetDomainId(v string) *DeleteBizCNameAndCertRequest {
  s.DomainId = &v
  return s
}

func (s *DeleteBizCNameAndCertRequest) SetIsVpc(v bool) *DeleteBizCNameAndCertRequest {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type DeleteBizCNameCertRequest struct {
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  // cert id
  CertId *string `json:"cert_id,omitempty" xml:"cert_id,omitempty"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // is vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s DeleteBizCNameCertRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteBizCNameCertRequest) GoString() string {
  return s.String()
}

func (s *DeleteBizCNameCertRequest) SetBizCname(v string) *DeleteBizCNameCertRequest {
  s.BizCname = &v
  return s
}

func (s *DeleteBizCNameCertRequest) SetCertId(v string) *DeleteBizCNameCertRequest {
  s.CertId = &v
  return s
}

func (s *DeleteBizCNameCertRequest) SetCnameType(v string) *DeleteBizCNameCertRequest {
  s.CnameType = &v
  return s
}

func (s *DeleteBizCNameCertRequest) SetDomainId(v string) *DeleteBizCNameCertRequest {
  s.DomainId = &v
  return s
}

func (s *DeleteBizCNameCertRequest) SetIsVpc(v bool) *DeleteBizCNameCertRequest {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type DeleteDataCNameAndCertRequest struct {
  // cn-shanghai data cname
  DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s DeleteDataCNameAndCertRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteDataCNameAndCertRequest) GoString() string {
  return s.String()
}

func (s *DeleteDataCNameAndCertRequest) SetDataCname(v string) *DeleteDataCNameAndCertRequest {
  s.DataCname = &v
  return s
}

func (s *DeleteDataCNameAndCertRequest) SetDomainId(v string) *DeleteDataCNameAndCertRequest {
  s.DomainId = &v
  return s
}

func (s *DeleteDataCNameAndCertRequest) SetLocation(v string) *DeleteDataCNameAndCertRequest {
  s.Location = &v
  return s
}

/**
 * 
 */
type DeleteDetail struct {
}

func (s DeleteDetail) String() string {
  return tea.Prettify(s)
}

func (s DeleteDetail) GoString() string {
  return s.String()
}

/**
 * delete domain request
 */
type DeleteDomainRequest struct {
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s DeleteDomainRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteDomainRequest) GoString() string {
  return s.String()
}

func (s *DeleteDomainRequest) SetDomainId(v string) *DeleteDomainRequest {
  s.DomainId = &v
  return s
}

/**
 * Delete drive request
 */
type DeleteDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s DeleteDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteDriveRequest) GoString() string {
  return s.String()
}

func (s *DeleteDriveRequest) SetHeaders(v map[string]*string) *DeleteDriveRequest {
  s.Headers = v
  return s
}

func (s *DeleteDriveRequest) SetDriveId(v string) *DeleteDriveRequest {
  s.DriveId = &v
  return s
}

func (s *DeleteDriveRequest) SetSubdomainId(v string) *DeleteDriveRequest {
  s.SubdomainId = &v
  return s
}

/**
 * delete drive response
 */
type DeleteDriveResponse struct {
}

func (s DeleteDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteDriveResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type DeleteFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // permanently
  // type: false
  Permanently *bool `json:"permanently,omitempty" xml:"permanently,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s DeleteFileRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteFileRequest) GoString() string {
  return s.String()
}

func (s *DeleteFileRequest) SetHeaders(v map[string]*string) *DeleteFileRequest {
  s.Headers = v
  return s
}

func (s *DeleteFileRequest) SetDriveId(v string) *DeleteFileRequest {
  s.DriveId = &v
  return s
}

func (s *DeleteFileRequest) SetFileId(v string) *DeleteFileRequest {
  s.FileId = &v
  return s
}

func (s *DeleteFileRequest) SetFileIdPath(v string) *DeleteFileRequest {
  s.FileIdPath = &v
  return s
}

func (s *DeleteFileRequest) SetPermanently(v bool) *DeleteFileRequest {
  s.Permanently = &v
  return s
}

func (s *DeleteFileRequest) SetShareId(v string) *DeleteFileRequest {
  s.ShareId = &v
  return s
}

/**
 *  response
 */
type DeleteFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s DeleteFileResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteFileResponse) GoString() string {
  return s.String()
}

func (s *DeleteFileResponse) SetAsyncTaskId(v string) *DeleteFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *DeleteFileResponse) SetDomainId(v string) *DeleteFileResponse {
  s.DomainId = &v
  return s
}

func (s *DeleteFileResponse) SetDriveId(v string) *DeleteFileResponse {
  s.DriveId = &v
  return s
}

func (s *DeleteFileResponse) SetFileId(v string) *DeleteFileResponse {
  s.FileId = &v
  return s
}

/**
 * 
 */
type DeleteFilesRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id_list
  FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" require:"true" type:"Repeated"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s DeleteFilesRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteFilesRequest) GoString() string {
  return s.String()
}

func (s *DeleteFilesRequest) SetDriveId(v string) *DeleteFilesRequest {
  s.DriveId = &v
  return s
}

func (s *DeleteFilesRequest) SetFileIdList(v []*string) *DeleteFilesRequest {
  s.FileIdList = v
  return s
}

func (s *DeleteFilesRequest) SetShareId(v string) *DeleteFilesRequest {
  s.ShareId = &v
  return s
}

/**
 *  response
 */
type DeleteFilesResponse struct {
  // deleted_file_id_list
  DeletedFileIdList []*string `json:"deleted_file_id_list,omitempty" xml:"deleted_file_id_list,omitempty" type:"Repeated"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
}

func (s DeleteFilesResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteFilesResponse) GoString() string {
  return s.String()
}

func (s *DeleteFilesResponse) SetDeletedFileIdList(v []*string) *DeleteFilesResponse {
  s.DeletedFileIdList = v
  return s
}

func (s *DeleteFilesResponse) SetDomainId(v string) *DeleteFilesResponse {
  s.DomainId = &v
  return s
}

func (s *DeleteFilesResponse) SetDriveId(v string) *DeleteFilesResponse {
  s.DriveId = &v
  return s
}

/**
 * delete share request
 */
type DeleteShareRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
}

func (s DeleteShareRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteShareRequest) GoString() string {
  return s.String()
}

func (s *DeleteShareRequest) SetHeaders(v map[string]*string) *DeleteShareRequest {
  s.Headers = v
  return s
}

func (s *DeleteShareRequest) SetShareId(v string) *DeleteShareRequest {
  s.ShareId = &v
  return s
}

/**
 * 
 */
type DeviceAuthorizeRequest struct {
  // Client ID, AppAppID
  ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
  // 
  DeviceInfo *string `json:"DeviceInfo,omitempty" xml:"DeviceInfo,omitempty"`
  // +
  DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" require:"true"`
  // ding,ram
  LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
  // , 
  Scope []*string `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Repeated"`
}

func (s DeviceAuthorizeRequest) String() string {
  return tea.Prettify(s)
}

func (s DeviceAuthorizeRequest) GoString() string {
  return s.String()
}

func (s *DeviceAuthorizeRequest) SetClientID(v string) *DeviceAuthorizeRequest {
  s.ClientID = &v
  return s
}

func (s *DeviceAuthorizeRequest) SetDeviceInfo(v string) *DeviceAuthorizeRequest {
  s.DeviceInfo = &v
  return s
}

func (s *DeviceAuthorizeRequest) SetDeviceName(v string) *DeviceAuthorizeRequest {
  s.DeviceName = &v
  return s
}

func (s *DeviceAuthorizeRequest) SetLoginType(v string) *DeviceAuthorizeRequest {
  s.LoginType = &v
  return s
}

func (s *DeviceAuthorizeRequest) SetScope(v []*string) *DeviceAuthorizeRequest {
  s.Scope = v
  return s
}

/**
 * domain update name request
 */
type DomainUpdateNameRequest struct {
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // Domain 
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
}

func (s DomainUpdateNameRequest) String() string {
  return tea.Prettify(s)
}

func (s DomainUpdateNameRequest) GoString() string {
  return s.String()
}

func (s *DomainUpdateNameRequest) SetDomainId(v string) *DomainUpdateNameRequest {
  s.DomainId = &v
  return s
}

func (s *DomainUpdateNameRequest) SetName(v string) *DomainUpdateNameRequest {
  s.Name = &v
  return s
}

/**
 * body
 */
type DownloadRequest struct {
  // drive id
  DriveID *string `json:"DriveID,omitempty" xml:"DriveID,omitempty"`
  // file id
  FileID *string `json:"FileID,omitempty" xml:"FileID,omitempty" require:"true"`
  // in: query
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"ImageThumbnailProcess,omitempty" xml:"ImageThumbnailProcess,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"OfficeThumbnailProcess,omitempty" xml:"OfficeThumbnailProcess,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareID *string `json:"ShareID,omitempty" xml:"ShareID,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"VideoThumbnailProcess,omitempty" xml:"VideoThumbnailProcess,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s DownloadRequest) String() string {
  return tea.Prettify(s)
}

func (s DownloadRequest) GoString() string {
  return s.String()
}

func (s *DownloadRequest) SetDriveID(v string) *DownloadRequest {
  s.DriveID = &v
  return s
}

func (s *DownloadRequest) SetFileID(v string) *DownloadRequest {
  s.FileID = &v
  return s
}

func (s *DownloadRequest) SetImageThumbnailProcess(v string) *DownloadRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *DownloadRequest) SetOfficeThumbnailProcess(v string) *DownloadRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *DownloadRequest) SetShareID(v string) *DownloadRequest {
  s.ShareID = &v
  return s
}

func (s *DownloadRequest) SetVideoThumbnailProcess(v string) *DownloadRequest {
  s.VideoThumbnailProcess = &v
  return s
}

func (s *DownloadRequest) SetAdditionData(v map[string]interface{}) *DownloadRequest {
  s.AdditionData = v
  return s
}

func (s *DownloadRequest) SetFileIdPath(v string) *DownloadRequest {
  s.FileIdPath = &v
  return s
}

func (s *DownloadRequest) SetLocation(v string) *DownloadRequest {
  s.Location = &v
  return s
}

func (s *DownloadRequest) SetReferer(v string) *DownloadRequest {
  s.Referer = &v
  return s
}

func (s *DownloadRequest) SetSignToken(v string) *DownloadRequest {
  s.SignToken = &v
  return s
}

/**
 * 
 */
type EditDetail struct {
}

func (s EditDetail) String() string {
  return tea.Prettify(s)
}

func (s EditDetail) GoString() string {
  return s.String()
}

/**
 * 
 */
type FaceThumbnail struct {
  FaceGroupId *string `json:"face_group_id,omitempty" xml:"face_group_id,omitempty"`
  FaceId *string `json:"face_id,omitempty" xml:"face_id,omitempty"`
  FaceThumbnail *string `json:"face_thumbnail,omitempty" xml:"face_thumbnail,omitempty"`
}

func (s FaceThumbnail) String() string {
  return tea.Prettify(s)
}

func (s FaceThumbnail) GoString() string {
  return s.String()
}

func (s *FaceThumbnail) SetFaceGroupId(v string) *FaceThumbnail {
  s.FaceGroupId = &v
  return s
}

func (s *FaceThumbnail) SetFaceId(v string) *FaceThumbnail {
  s.FaceId = &v
  return s
}

func (s *FaceThumbnail) SetFaceThumbnail(v string) *FaceThumbnail {
  s.FaceThumbnail = &v
  return s
}

/**
 * 
 */
type FileActivity struct {
  // Actors
  Actors []*Actor `json:"actors,omitempty" xml:"actors,omitempty" type:"Repeated"`
  PrimaryActionDetail *ActionDetail `json:"primary_action_detail,omitempty" xml:"primary_action_detail,omitempty"`
  // Targets
  Targets []*Target `json:"targets,omitempty" xml:"targets,omitempty" type:"Repeated"`
  TimeRange *TimeRange `json:"time_range,omitempty" xml:"time_range,omitempty"`
  // Timestamp
  Timestamp *string `json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

func (s FileActivity) String() string {
  return tea.Prettify(s)
}

func (s FileActivity) GoString() string {
  return s.String()
}

func (s *FileActivity) SetActors(v []*Actor) *FileActivity {
  s.Actors = v
  return s
}

func (s *FileActivity) SetPrimaryActionDetail(v *ActionDetail) *FileActivity {
  s.PrimaryActionDetail = v
  return s
}

func (s *FileActivity) SetTargets(v []*Target) *FileActivity {
  s.Targets = v
  return s
}

func (s *FileActivity) SetTimeRange(v *TimeRange) *FileActivity {
  s.TimeRange = v
  return s
}

func (s *FileActivity) SetTimestamp(v string) *FileActivity {
  s.Timestamp = &v
  return s
}

/**
 * the file op info
 */
type FileDeltaResponse struct {
  CurrentCategory *string `json:"current_category,omitempty" xml:"current_category,omitempty"`
  File *BaseCCPFileResponse `json:"file,omitempty" xml:"file,omitempty"`
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  Op *string `json:"op,omitempty" xml:"op,omitempty"`
}

func (s FileDeltaResponse) String() string {
  return tea.Prettify(s)
}

func (s FileDeltaResponse) GoString() string {
  return s.String()
}

func (s *FileDeltaResponse) SetCurrentCategory(v string) *FileDeltaResponse {
  s.CurrentCategory = &v
  return s
}

func (s *FileDeltaResponse) SetFile(v *BaseCCPFileResponse) *FileDeltaResponse {
  s.File = v
  return s
}

func (s *FileDeltaResponse) SetFileId(v string) *FileDeltaResponse {
  s.FileId = &v
  return s
}

func (s *FileDeltaResponse) SetOp(v string) *FileDeltaResponse {
  s.Op = &v
  return s
}

/**
 * 
 */
type FileInfo struct {
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s FileInfo) String() string {
  return tea.Prettify(s)
}

func (s FileInfo) GoString() string {
  return s.String()
}

func (s *FileInfo) SetFileId(v string) *FileInfo {
  s.FileId = &v
  return s
}

/**
 * 
 */
type FileStreamInfo struct {
  // content_hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // ContentMd5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" require:"true"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // pre_hash
  PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
  // proof_code
  ProofCode *string `json:"proof_code,omitempty" xml:"proof_code,omitempty"`
  // proof_version
  ProofVersion *string `json:"proof_version,omitempty" xml:"proof_version,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" require:"true" maximum:"53687091200" minimum:"0"`
}

func (s FileStreamInfo) String() string {
  return tea.Prettify(s)
}

func (s FileStreamInfo) GoString() string {
  return s.String()
}

func (s *FileStreamInfo) SetContentHash(v string) *FileStreamInfo {
  s.ContentHash = &v
  return s
}

func (s *FileStreamInfo) SetContentHashName(v string) *FileStreamInfo {
  s.ContentHashName = &v
  return s
}

func (s *FileStreamInfo) SetContentMd5(v string) *FileStreamInfo {
  s.ContentMd5 = &v
  return s
}

func (s *FileStreamInfo) SetPartInfoList(v []*UploadPartInfo) *FileStreamInfo {
  s.PartInfoList = v
  return s
}

func (s *FileStreamInfo) SetPreHash(v string) *FileStreamInfo {
  s.PreHash = &v
  return s
}

func (s *FileStreamInfo) SetProofCode(v string) *FileStreamInfo {
  s.ProofCode = &v
  return s
}

func (s *FileStreamInfo) SetProofVersion(v string) *FileStreamInfo {
  s.ProofVersion = &v
  return s
}

func (s *FileStreamInfo) SetSize(v int64) *FileStreamInfo {
  s.Size = &v
  return s
}

/**
 * 
 */
type GetAccessTokenByLinkInfoRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
  // 
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s GetAccessTokenByLinkInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s GetAccessTokenByLinkInfoRequest) GoString() string {
  return s.String()
}

func (s *GetAccessTokenByLinkInfoRequest) SetHeaders(v map[string]*string) *GetAccessTokenByLinkInfoRequest {
  s.Headers = v
  return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetExtra(v string) *GetAccessTokenByLinkInfoRequest {
  s.Extra = &v
  return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetIdentity(v string) *GetAccessTokenByLinkInfoRequest {
  s.Identity = &v
  return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetType(v string) *GetAccessTokenByLinkInfoRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type GetAppPublicKeyRequest struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetAppPublicKeyRequest) String() string {
  return tea.Prettify(s)
}

func (s GetAppPublicKeyRequest) GoString() string {
  return s.String()
}

func (s *GetAppPublicKeyRequest) SetAppId(v string) *GetAppPublicKeyRequest {
  s.AppId = &v
  return s
}

/**
 * 
 */
type GetAppRequest struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetAppRequest) String() string {
  return tea.Prettify(s)
}

func (s GetAppRequest) GoString() string {
  return s.String()
}

func (s *GetAppRequest) SetAppId(v string) *GetAppRequest {
  s.AppId = &v
  return s
}

/**
 * 
 */
type GetAsyncTaskRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // async_task_id
  // type:string
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s GetAsyncTaskRequest) String() string {
  return tea.Prettify(s)
}

func (s GetAsyncTaskRequest) GoString() string {
  return s.String()
}

func (s *GetAsyncTaskRequest) SetHeaders(v map[string]*string) *GetAsyncTaskRequest {
  s.Headers = v
  return s
}

func (s *GetAsyncTaskRequest) SetAsyncTaskId(v string) *GetAsyncTaskRequest {
  s.AsyncTaskId = &v
  return s
}

/**
 * Get AsyncTask Response
 */
type GetAsyncTaskResponse struct {
  // async_task_id
  // type:string
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // consumed_process
  ConsumedProcess *int64 `json:"consumed_process,omitempty" xml:"consumed_process,omitempty"`
  // err_code
  ErrCode *int64 `json:"err_code,omitempty" xml:"err_code,omitempty"`
  // message
  Message *string `json:"message,omitempty" xml:"message,omitempty"`
  // state
  State *string `json:"state,omitempty" xml:"state,omitempty"`
  // total_process
  TotalProcess *int64 `json:"total_process,omitempty" xml:"total_process,omitempty"`
  // download_url
  // example
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetAsyncTaskResponse) String() string {
  return tea.Prettify(s)
}

func (s GetAsyncTaskResponse) GoString() string {
  return s.String()
}

func (s *GetAsyncTaskResponse) SetAsyncTaskId(v string) *GetAsyncTaskResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *GetAsyncTaskResponse) SetConsumedProcess(v int64) *GetAsyncTaskResponse {
  s.ConsumedProcess = &v
  return s
}

func (s *GetAsyncTaskResponse) SetErrCode(v int64) *GetAsyncTaskResponse {
  s.ErrCode = &v
  return s
}

func (s *GetAsyncTaskResponse) SetMessage(v string) *GetAsyncTaskResponse {
  s.Message = &v
  return s
}

func (s *GetAsyncTaskResponse) SetState(v string) *GetAsyncTaskResponse {
  s.State = &v
  return s
}

func (s *GetAsyncTaskResponse) SetTotalProcess(v int64) *GetAsyncTaskResponse {
  s.TotalProcess = &v
  return s
}

func (s *GetAsyncTaskResponse) SetUrl(v string) *GetAsyncTaskResponse {
  s.Url = &v
  return s
}

/**
 * 
 */
type GetBizCNameInfoRequest struct {
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // is vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s GetBizCNameInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s GetBizCNameInfoRequest) GoString() string {
  return s.String()
}

func (s *GetBizCNameInfoRequest) SetCnameType(v string) *GetBizCNameInfoRequest {
  s.CnameType = &v
  return s
}

func (s *GetBizCNameInfoRequest) SetDomainId(v string) *GetBizCNameInfoRequest {
  s.DomainId = &v
  return s
}

func (s *GetBizCNameInfoRequest) SetIsVpc(v bool) *GetBizCNameInfoRequest {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type GetByLinkInfoRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
  // 
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s GetByLinkInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s GetByLinkInfoRequest) GoString() string {
  return s.String()
}

func (s *GetByLinkInfoRequest) SetHeaders(v map[string]*string) *GetByLinkInfoRequest {
  s.Headers = v
  return s
}

func (s *GetByLinkInfoRequest) SetExtra(v string) *GetByLinkInfoRequest {
  s.Extra = &v
  return s
}

func (s *GetByLinkInfoRequest) SetIdentity(v string) *GetByLinkInfoRequest {
  s.Identity = &v
  return s
}

func (s *GetByLinkInfoRequest) SetType(v string) *GetByLinkInfoRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type GetCaptchaRequest struct {
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetCaptchaRequest) String() string {
  return tea.Prettify(s)
}

func (s GetCaptchaRequest) GoString() string {
  return s.String()
}

func (s *GetCaptchaRequest) SetAppId(v string) *GetCaptchaRequest {
  s.AppId = &v
  return s
}

/**
 * 
 */
type GetCorsRuleListRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s GetCorsRuleListRequest) String() string {
  return tea.Prettify(s)
}

func (s GetCorsRuleListRequest) GoString() string {
  return s.String()
}

func (s *GetCorsRuleListRequest) SetDomainId(v string) *GetCorsRuleListRequest {
  s.DomainId = &v
  return s
}

/**
 * 
 */
type GetDataCNameInfoRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s GetDataCNameInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s GetDataCNameInfoRequest) GoString() string {
  return s.String()
}

func (s *GetDataCNameInfoRequest) SetDomainId(v string) *GetDataCNameInfoRequest {
  s.DomainId = &v
  return s
}

/**
 * Get default drive request
 */
type GetDefaultDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetDefaultDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s GetDefaultDriveRequest) GoString() string {
  return s.String()
}

func (s *GetDefaultDriveRequest) SetHeaders(v map[string]*string) *GetDefaultDriveRequest {
  s.Headers = v
  return s
}

func (s *GetDefaultDriveRequest) SetSubdomainId(v string) *GetDefaultDriveRequest {
  s.SubdomainId = &v
  return s
}

func (s *GetDefaultDriveRequest) SetUserId(v string) *GetDefaultDriveRequest {
  s.UserId = &v
  return s
}

/**
 * size
 */
type GetDirSizeInfoResponse struct {
  // dir_count
  DirCount *int64 `json:"dir_count,omitempty" xml:"dir_count,omitempty"`
  // file_count
  FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
  // size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s GetDirSizeInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s GetDirSizeInfoResponse) GoString() string {
  return s.String()
}

func (s *GetDirSizeInfoResponse) SetDirCount(v int64) *GetDirSizeInfoResponse {
  s.DirCount = &v
  return s
}

func (s *GetDirSizeInfoResponse) SetFileCount(v int64) *GetDirSizeInfoResponse {
  s.FileCount = &v
  return s
}

func (s *GetDirSizeInfoResponse) SetSize(v int64) *GetDirSizeInfoResponse {
  s.Size = &v
  return s
}

/**
 * get domain request
 */
type GetDomainRequest struct {
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  GetBenefit *bool `json:"get_benefit,omitempty" xml:"get_benefit,omitempty"`
}

func (s GetDomainRequest) String() string {
  return tea.Prettify(s)
}

func (s GetDomainRequest) GoString() string {
  return s.String()
}

func (s *GetDomainRequest) SetDomainId(v string) *GetDomainRequest {
  s.DomainId = &v
  return s
}

func (s *GetDomainRequest) SetGetBenefit(v bool) *GetDomainRequest {
  s.GetBenefit = &v
  return s
}

/**
 * body
 */
type GetDownloadUrlRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"115200" minimum:"1"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // file_name
  FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty" maxLength:"1024" minLength:"1"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s GetDownloadUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s GetDownloadUrlRequest) GoString() string {
  return s.String()
}

func (s *GetDownloadUrlRequest) SetHeaders(v map[string]*string) *GetDownloadUrlRequest {
  s.Headers = v
  return s
}

func (s *GetDownloadUrlRequest) SetAdditionData(v map[string]interface{}) *GetDownloadUrlRequest {
  s.AdditionData = v
  return s
}

func (s *GetDownloadUrlRequest) SetDriveId(v string) *GetDownloadUrlRequest {
  s.DriveId = &v
  return s
}

func (s *GetDownloadUrlRequest) SetExpireSec(v int64) *GetDownloadUrlRequest {
  s.ExpireSec = &v
  return s
}

func (s *GetDownloadUrlRequest) SetFileId(v string) *GetDownloadUrlRequest {
  s.FileId = &v
  return s
}

func (s *GetDownloadUrlRequest) SetFileIdPath(v string) *GetDownloadUrlRequest {
  s.FileIdPath = &v
  return s
}

func (s *GetDownloadUrlRequest) SetFileName(v string) *GetDownloadUrlRequest {
  s.FileName = &v
  return s
}

func (s *GetDownloadUrlRequest) SetLocation(v string) *GetDownloadUrlRequest {
  s.Location = &v
  return s
}

func (s *GetDownloadUrlRequest) SetReferer(v string) *GetDownloadUrlRequest {
  s.Referer = &v
  return s
}

func (s *GetDownloadUrlRequest) SetShareId(v string) *GetDownloadUrlRequest {
  s.ShareId = &v
  return s
}

func (s *GetDownloadUrlRequest) SetSignToken(v string) *GetDownloadUrlRequest {
  s.SignToken = &v
  return s
}

/**
 * download url response
 */
type GetDownloadUrlResponse struct {
  // cdn_url
  CdnUrl *string `json:"cdn_url,omitempty" xml:"cdn_url,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // internal_url
  InternalUrl *string `json:"internal_url,omitempty" xml:"internal_url,omitempty"`
  // method
  Method *string `json:"method,omitempty" xml:"method,omitempty"`
  Ratelimit *RateLimit `json:"ratelimit,omitempty" xml:"ratelimit,omitempty"`
  // size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
  // streams url info
  StreamsUrl map[string]interface{} `json:"streams_url,omitempty" xml:"streams_url,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetDownloadUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s GetDownloadUrlResponse) GoString() string {
  return s.String()
}

func (s *GetDownloadUrlResponse) SetCdnUrl(v string) *GetDownloadUrlResponse {
  s.CdnUrl = &v
  return s
}

func (s *GetDownloadUrlResponse) SetExpiration(v string) *GetDownloadUrlResponse {
  s.Expiration = &v
  return s
}

func (s *GetDownloadUrlResponse) SetInternalUrl(v string) *GetDownloadUrlResponse {
  s.InternalUrl = &v
  return s
}

func (s *GetDownloadUrlResponse) SetMethod(v string) *GetDownloadUrlResponse {
  s.Method = &v
  return s
}

func (s *GetDownloadUrlResponse) SetRatelimit(v *RateLimit) *GetDownloadUrlResponse {
  s.Ratelimit = v
  return s
}

func (s *GetDownloadUrlResponse) SetSize(v int64) *GetDownloadUrlResponse {
  s.Size = &v
  return s
}

func (s *GetDownloadUrlResponse) SetStreamsUrl(v map[string]interface{}) *GetDownloadUrlResponse {
  s.StreamsUrl = v
  return s
}

func (s *GetDownloadUrlResponse) SetUrl(v string) *GetDownloadUrlResponse {
  s.Url = &v
  return s
}

/**
 * Get drive request
 */
type GetDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s GetDriveRequest) GoString() string {
  return s.String()
}

func (s *GetDriveRequest) SetHeaders(v map[string]*string) *GetDriveRequest {
  s.Headers = v
  return s
}

func (s *GetDriveRequest) SetDriveId(v string) *GetDriveRequest {
  s.DriveId = &v
  return s
}

func (s *GetDriveRequest) SetSubdomainId(v string) *GetDriveRequest {
  s.SubdomainId = &v
  return s
}

/**
 * Get drive response
 */
type GetDriveResponse struct {
  // Drive 
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // Drive 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // Drive 
  DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
  // Drive 
  DriveType *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
  EncryptDataAccess *bool `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // Drive 
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // Drive 
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // DrivestoredomainPathTypeOSSPath
  RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
  // Drive 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  //  ID, domainPathTypeOSSPath
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  // Drive 
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
  // Drive 
  UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s GetDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s GetDriveResponse) GoString() string {
  return s.String()
}

func (s *GetDriveResponse) SetCreator(v string) *GetDriveResponse {
  s.Creator = &v
  return s
}

func (s *GetDriveResponse) SetDescription(v string) *GetDriveResponse {
  s.Description = &v
  return s
}

func (s *GetDriveResponse) SetDomainId(v string) *GetDriveResponse {
  s.DomainId = &v
  return s
}

func (s *GetDriveResponse) SetDriveId(v string) *GetDriveResponse {
  s.DriveId = &v
  return s
}

func (s *GetDriveResponse) SetDriveName(v string) *GetDriveResponse {
  s.DriveName = &v
  return s
}

func (s *GetDriveResponse) SetDriveType(v string) *GetDriveResponse {
  s.DriveType = &v
  return s
}

func (s *GetDriveResponse) SetEncryptDataAccess(v bool) *GetDriveResponse {
  s.EncryptDataAccess = &v
  return s
}

func (s *GetDriveResponse) SetEncryptMode(v string) *GetDriveResponse {
  s.EncryptMode = &v
  return s
}

func (s *GetDriveResponse) SetOwner(v string) *GetDriveResponse {
  s.Owner = &v
  return s
}

func (s *GetDriveResponse) SetOwnerType(v string) *GetDriveResponse {
  s.OwnerType = &v
  return s
}

func (s *GetDriveResponse) SetRelativePath(v string) *GetDriveResponse {
  s.RelativePath = &v
  return s
}

func (s *GetDriveResponse) SetStatus(v string) *GetDriveResponse {
  s.Status = &v
  return s
}

func (s *GetDriveResponse) SetStoreId(v string) *GetDriveResponse {
  s.StoreId = &v
  return s
}

func (s *GetDriveResponse) SetTotalSize(v int64) *GetDriveResponse {
  s.TotalSize = &v
  return s
}

func (s *GetDriveResponse) SetUsedSize(v int64) *GetDriveResponse {
  s.UsedSize = &v
  return s
}

/**
 *  File  body
 */
type GetFileByPathRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetFileByPathRequest) String() string {
  return tea.Prettify(s)
}

func (s GetFileByPathRequest) GoString() string {
  return s.String()
}

func (s *GetFileByPathRequest) SetHeaders(v map[string]*string) *GetFileByPathRequest {
  s.Headers = v
  return s
}

func (s *GetFileByPathRequest) SetAdditionData(v map[string]interface{}) *GetFileByPathRequest {
  s.AdditionData = v
  return s
}

func (s *GetFileByPathRequest) SetDriveId(v string) *GetFileByPathRequest {
  s.DriveId = &v
  return s
}

func (s *GetFileByPathRequest) SetFilePath(v string) *GetFileByPathRequest {
  s.FilePath = &v
  return s
}

func (s *GetFileByPathRequest) SetImageCroppingAspectRatios(v []*string) *GetFileByPathRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *GetFileByPathRequest) SetImageThumbnailProcess(v string) *GetFileByPathRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *GetFileByPathRequest) SetImageUrlProcess(v string) *GetFileByPathRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *GetFileByPathRequest) SetOfficeThumbnailProcess(v string) *GetFileByPathRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *GetFileByPathRequest) SetReferer(v string) *GetFileByPathRequest {
  s.Referer = &v
  return s
}

func (s *GetFileByPathRequest) SetSignToken(v string) *GetFileByPathRequest {
  s.SignToken = &v
  return s
}

func (s *GetFileByPathRequest) SetUrlExpireSec(v int64) *GetFileByPathRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *GetFileByPathRequest) SetVideoThumbnailProcess(v string) *GetFileByPathRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type GetFileByPathResponse struct {
  // auto_delete_left_sec
  AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // TODO APIfile_path_typeedmpath typePDS
  FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // Trashed
  // type: boolean
  Trashed *bool `json:"trashed,omitempty" xml:"trashed,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s GetFileByPathResponse) String() string {
  return tea.Prettify(s)
}

func (s GetFileByPathResponse) GoString() string {
  return s.String()
}

func (s *GetFileByPathResponse) SetAutoDeleteLeftSec(v int64) *GetFileByPathResponse {
  s.AutoDeleteLeftSec = &v
  return s
}

func (s *GetFileByPathResponse) SetCategory(v string) *GetFileByPathResponse {
  s.Category = &v
  return s
}

func (s *GetFileByPathResponse) SetCharacteristicHash(v string) *GetFileByPathResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *GetFileByPathResponse) SetContentHash(v string) *GetFileByPathResponse {
  s.ContentHash = &v
  return s
}

func (s *GetFileByPathResponse) SetContentHashName(v string) *GetFileByPathResponse {
  s.ContentHashName = &v
  return s
}

func (s *GetFileByPathResponse) SetContentType(v string) *GetFileByPathResponse {
  s.ContentType = &v
  return s
}

func (s *GetFileByPathResponse) SetCrc64Hash(v string) *GetFileByPathResponse {
  s.Crc64Hash = &v
  return s
}

func (s *GetFileByPathResponse) SetCreatedAt(v string) *GetFileByPathResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetFileByPathResponse) SetDescription(v string) *GetFileByPathResponse {
  s.Description = &v
  return s
}

func (s *GetFileByPathResponse) SetDomainId(v string) *GetFileByPathResponse {
  s.DomainId = &v
  return s
}

func (s *GetFileByPathResponse) SetDownloadUrl(v string) *GetFileByPathResponse {
  s.DownloadUrl = &v
  return s
}

func (s *GetFileByPathResponse) SetDriveId(v string) *GetFileByPathResponse {
  s.DriveId = &v
  return s
}

func (s *GetFileByPathResponse) SetEncryptMode(v string) *GetFileByPathResponse {
  s.EncryptMode = &v
  return s
}

func (s *GetFileByPathResponse) SetFileExtension(v string) *GetFileByPathResponse {
  s.FileExtension = &v
  return s
}

func (s *GetFileByPathResponse) SetFileId(v string) *GetFileByPathResponse {
  s.FileId = &v
  return s
}

func (s *GetFileByPathResponse) SetFilePathType(v string) *GetFileByPathResponse {
  s.FilePathType = &v
  return s
}

func (s *GetFileByPathResponse) SetHidden(v bool) *GetFileByPathResponse {
  s.Hidden = &v
  return s
}

func (s *GetFileByPathResponse) SetImageMediaMetadata(v *ImageMediaResponse) *GetFileByPathResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *GetFileByPathResponse) SetLabels(v []*string) *GetFileByPathResponse {
  s.Labels = v
  return s
}

func (s *GetFileByPathResponse) SetLastModifierId(v string) *GetFileByPathResponse {
  s.LastModifierId = &v
  return s
}

func (s *GetFileByPathResponse) SetLastModifierName(v string) *GetFileByPathResponse {
  s.LastModifierName = &v
  return s
}

func (s *GetFileByPathResponse) SetLastModifierType(v string) *GetFileByPathResponse {
  s.LastModifierType = &v
  return s
}

func (s *GetFileByPathResponse) SetMeta(v string) *GetFileByPathResponse {
  s.Meta = &v
  return s
}

func (s *GetFileByPathResponse) SetName(v string) *GetFileByPathResponse {
  s.Name = &v
  return s
}

func (s *GetFileByPathResponse) SetParentFileId(v string) *GetFileByPathResponse {
  s.ParentFileId = &v
  return s
}

func (s *GetFileByPathResponse) SetPunishFlag(v int64) *GetFileByPathResponse {
  s.PunishFlag = &v
  return s
}

func (s *GetFileByPathResponse) SetShareId(v string) *GetFileByPathResponse {
  s.ShareId = &v
  return s
}

func (s *GetFileByPathResponse) SetSize(v int64) *GetFileByPathResponse {
  s.Size = &v
  return s
}

func (s *GetFileByPathResponse) SetStarred(v bool) *GetFileByPathResponse {
  s.Starred = &v
  return s
}

func (s *GetFileByPathResponse) SetStatus(v string) *GetFileByPathResponse {
  s.Status = &v
  return s
}

func (s *GetFileByPathResponse) SetStreamsInfo(v map[string]interface{}) *GetFileByPathResponse {
  s.StreamsInfo = v
  return s
}

func (s *GetFileByPathResponse) SetThumbnail(v string) *GetFileByPathResponse {
  s.Thumbnail = &v
  return s
}

func (s *GetFileByPathResponse) SetTrashed(v bool) *GetFileByPathResponse {
  s.Trashed = &v
  return s
}

func (s *GetFileByPathResponse) SetTrashedAt(v string) *GetFileByPathResponse {
  s.TrashedAt = &v
  return s
}

func (s *GetFileByPathResponse) SetType(v string) *GetFileByPathResponse {
  s.Type = &v
  return s
}

func (s *GetFileByPathResponse) SetUpdatedAt(v string) *GetFileByPathResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetFileByPathResponse) SetUploadId(v string) *GetFileByPathResponse {
  s.UploadId = &v
  return s
}

func (s *GetFileByPathResponse) SetUrl(v string) *GetFileByPathResponse {
  s.Url = &v
  return s
}

func (s *GetFileByPathResponse) SetUserMeta(v string) *GetFileByPathResponse {
  s.UserMeta = &v
  return s
}

func (s *GetFileByPathResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *GetFileByPathResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *GetFileByPathResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *GetFileByPathResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * 
 */
type GetFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // fields
  Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetFileRequest) String() string {
  return tea.Prettify(s)
}

func (s GetFileRequest) GoString() string {
  return s.String()
}

func (s *GetFileRequest) SetHeaders(v map[string]*string) *GetFileRequest {
  s.Headers = v
  return s
}

func (s *GetFileRequest) SetAdditionData(v map[string]interface{}) *GetFileRequest {
  s.AdditionData = v
  return s
}

func (s *GetFileRequest) SetDriveId(v string) *GetFileRequest {
  s.DriveId = &v
  return s
}

func (s *GetFileRequest) SetFields(v string) *GetFileRequest {
  s.Fields = &v
  return s
}

func (s *GetFileRequest) SetFileId(v string) *GetFileRequest {
  s.FileId = &v
  return s
}

func (s *GetFileRequest) SetFileIdPath(v string) *GetFileRequest {
  s.FileIdPath = &v
  return s
}

func (s *GetFileRequest) SetImageCroppingAspectRatios(v []*string) *GetFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *GetFileRequest) SetImageThumbnailProcess(v string) *GetFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *GetFileRequest) SetImageUrlProcess(v string) *GetFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *GetFileRequest) SetLocation(v string) *GetFileRequest {
  s.Location = &v
  return s
}

func (s *GetFileRequest) SetOfficeThumbnailProcess(v string) *GetFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *GetFileRequest) SetReferer(v string) *GetFileRequest {
  s.Referer = &v
  return s
}

func (s *GetFileRequest) SetShareId(v string) *GetFileRequest {
  s.ShareId = &v
  return s
}

func (s *GetFileRequest) SetSignToken(v string) *GetFileRequest {
  s.SignToken = &v
  return s
}

func (s *GetFileRequest) SetUrlExpireSec(v int64) *GetFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *GetFileRequest) SetVideoThumbnailProcess(v string) *GetFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type GetFileResponse struct {
  // auto_delete_left_sec
  AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // TODO APIfile_path_typeedmpath typePDS
  FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // Trashed
  // type: boolean
  Trashed *bool `json:"trashed,omitempty" xml:"trashed,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s GetFileResponse) String() string {
  return tea.Prettify(s)
}

func (s GetFileResponse) GoString() string {
  return s.String()
}

func (s *GetFileResponse) SetAutoDeleteLeftSec(v int64) *GetFileResponse {
  s.AutoDeleteLeftSec = &v
  return s
}

func (s *GetFileResponse) SetCategory(v string) *GetFileResponse {
  s.Category = &v
  return s
}

func (s *GetFileResponse) SetCharacteristicHash(v string) *GetFileResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *GetFileResponse) SetContentHash(v string) *GetFileResponse {
  s.ContentHash = &v
  return s
}

func (s *GetFileResponse) SetContentHashName(v string) *GetFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *GetFileResponse) SetContentType(v string) *GetFileResponse {
  s.ContentType = &v
  return s
}

func (s *GetFileResponse) SetCrc64Hash(v string) *GetFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *GetFileResponse) SetCreatedAt(v string) *GetFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetFileResponse) SetDescription(v string) *GetFileResponse {
  s.Description = &v
  return s
}

func (s *GetFileResponse) SetDomainId(v string) *GetFileResponse {
  s.DomainId = &v
  return s
}

func (s *GetFileResponse) SetDownloadUrl(v string) *GetFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *GetFileResponse) SetDriveId(v string) *GetFileResponse {
  s.DriveId = &v
  return s
}

func (s *GetFileResponse) SetEncryptMode(v string) *GetFileResponse {
  s.EncryptMode = &v
  return s
}

func (s *GetFileResponse) SetFileExtension(v string) *GetFileResponse {
  s.FileExtension = &v
  return s
}

func (s *GetFileResponse) SetFileId(v string) *GetFileResponse {
  s.FileId = &v
  return s
}

func (s *GetFileResponse) SetFilePathType(v string) *GetFileResponse {
  s.FilePathType = &v
  return s
}

func (s *GetFileResponse) SetHidden(v bool) *GetFileResponse {
  s.Hidden = &v
  return s
}

func (s *GetFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *GetFileResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *GetFileResponse) SetLabels(v []*string) *GetFileResponse {
  s.Labels = v
  return s
}

func (s *GetFileResponse) SetLastModifierId(v string) *GetFileResponse {
  s.LastModifierId = &v
  return s
}

func (s *GetFileResponse) SetLastModifierName(v string) *GetFileResponse {
  s.LastModifierName = &v
  return s
}

func (s *GetFileResponse) SetLastModifierType(v string) *GetFileResponse {
  s.LastModifierType = &v
  return s
}

func (s *GetFileResponse) SetMeta(v string) *GetFileResponse {
  s.Meta = &v
  return s
}

func (s *GetFileResponse) SetName(v string) *GetFileResponse {
  s.Name = &v
  return s
}

func (s *GetFileResponse) SetParentFileId(v string) *GetFileResponse {
  s.ParentFileId = &v
  return s
}

func (s *GetFileResponse) SetPunishFlag(v int64) *GetFileResponse {
  s.PunishFlag = &v
  return s
}

func (s *GetFileResponse) SetShareId(v string) *GetFileResponse {
  s.ShareId = &v
  return s
}

func (s *GetFileResponse) SetSize(v int64) *GetFileResponse {
  s.Size = &v
  return s
}

func (s *GetFileResponse) SetStarred(v bool) *GetFileResponse {
  s.Starred = &v
  return s
}

func (s *GetFileResponse) SetStatus(v string) *GetFileResponse {
  s.Status = &v
  return s
}

func (s *GetFileResponse) SetStreamsInfo(v map[string]interface{}) *GetFileResponse {
  s.StreamsInfo = v
  return s
}

func (s *GetFileResponse) SetThumbnail(v string) *GetFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *GetFileResponse) SetTrashed(v bool) *GetFileResponse {
  s.Trashed = &v
  return s
}

func (s *GetFileResponse) SetTrashedAt(v string) *GetFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *GetFileResponse) SetType(v string) *GetFileResponse {
  s.Type = &v
  return s
}

func (s *GetFileResponse) SetUpdatedAt(v string) *GetFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetFileResponse) SetUploadId(v string) *GetFileResponse {
  s.UploadId = &v
  return s
}

func (s *GetFileResponse) SetUrl(v string) *GetFileResponse {
  s.Url = &v
  return s
}

func (s *GetFileResponse) SetUserMeta(v string) *GetFileResponse {
  s.UserMeta = &v
  return s
}

func (s *GetFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *GetFileResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *GetFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *GetFileResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * 
 */
type GetLastCursorRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
}

func (s GetLastCursorRequest) String() string {
  return tea.Prettify(s)
}

func (s GetLastCursorRequest) GoString() string {
  return s.String()
}

func (s *GetLastCursorRequest) SetHeaders(v map[string]*string) *GetLastCursorRequest {
  s.Headers = v
  return s
}

func (s *GetLastCursorRequest) SetDriveId(v string) *GetLastCursorRequest {
  s.DriveId = &v
  return s
}

/**
 * get last file op cursor response
 */
type GetLastCursorResponse struct {
  Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
}

func (s GetLastCursorResponse) String() string {
  return tea.Prettify(s)
}

func (s GetLastCursorResponse) GoString() string {
  return s.String()
}

func (s *GetLastCursorResponse) SetCursor(v string) *GetLastCursorResponse {
  s.Cursor = &v
  return s
}

/**
 * 
 */
type GetLinkInfoByUserIDRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // user ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetLinkInfoByUserIDRequest) String() string {
  return tea.Prettify(s)
}

func (s GetLinkInfoByUserIDRequest) GoString() string {
  return s.String()
}

func (s *GetLinkInfoByUserIDRequest) SetHeaders(v map[string]*string) *GetLinkInfoByUserIDRequest {
  s.Headers = v
  return s
}

func (s *GetLinkInfoByUserIDRequest) SetUserId(v string) *GetLinkInfoByUserIDRequest {
  s.UserId = &v
  return s
}

/**
 * get_media_play_url request
 */
type GetMediaPlayURLRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
}

func (s GetMediaPlayURLRequest) String() string {
  return tea.Prettify(s)
}

func (s GetMediaPlayURLRequest) GoString() string {
  return s.String()
}

func (s *GetMediaPlayURLRequest) SetHeaders(v map[string]*string) *GetMediaPlayURLRequest {
  s.Headers = v
  return s
}

func (s *GetMediaPlayURLRequest) SetDriveId(v string) *GetMediaPlayURLRequest {
  s.DriveId = &v
  return s
}

func (s *GetMediaPlayURLRequest) SetFileId(v string) *GetMediaPlayURLRequest {
  s.FileId = &v
  return s
}

/**
 * get_media_play_url response
 */
type GetMediaPlayURLResponse struct {
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetMediaPlayURLResponse) String() string {
  return tea.Prettify(s)
}

func (s GetMediaPlayURLResponse) GoString() string {
  return s.String()
}

func (s *GetMediaPlayURLResponse) SetUrl(v string) *GetMediaPlayURLResponse {
  s.Url = &v
  return s
}

/**
 * GetOfficeEditUrlOption 
 */
type GetOfficeEditUrlOption struct {
  // Copy
  Copy *bool `json:"copy,omitempty" xml:"copy,omitempty"`
  Readonly *bool `json:"readonly,omitempty" xml:"readonly,omitempty"`
}

func (s GetOfficeEditUrlOption) String() string {
  return tea.Prettify(s)
}

func (s GetOfficeEditUrlOption) GoString() string {
  return s.String()
}

func (s *GetOfficeEditUrlOption) SetCopy(v bool) *GetOfficeEditUrlOption {
  s.Copy = &v
  return s
}

func (s *GetOfficeEditUrlOption) SetReadonly(v bool) *GetOfficeEditUrlOption {
  s.Readonly = &v
  return s
}

/**
 * office
 */
type GetOfficeEditUrlRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  Option *GetOfficeEditUrlOption `json:"option,omitempty" xml:"option,omitempty"`
  Watermark *GetOfficeEditUrlWatermark `json:"watermark,omitempty" xml:"watermark,omitempty"`
}

func (s GetOfficeEditUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s GetOfficeEditUrlRequest) GoString() string {
  return s.String()
}

func (s *GetOfficeEditUrlRequest) SetHeaders(v map[string]*string) *GetOfficeEditUrlRequest {
  s.Headers = v
  return s
}

func (s *GetOfficeEditUrlRequest) SetAdditionData(v map[string]interface{}) *GetOfficeEditUrlRequest {
  s.AdditionData = v
  return s
}

func (s *GetOfficeEditUrlRequest) SetDriveId(v string) *GetOfficeEditUrlRequest {
  s.DriveId = &v
  return s
}

func (s *GetOfficeEditUrlRequest) SetFileId(v string) *GetOfficeEditUrlRequest {
  s.FileId = &v
  return s
}

func (s *GetOfficeEditUrlRequest) SetOption(v *GetOfficeEditUrlOption) *GetOfficeEditUrlRequest {
  s.Option = v
  return s
}

func (s *GetOfficeEditUrlRequest) SetWatermark(v *GetOfficeEditUrlWatermark) *GetOfficeEditUrlRequest {
  s.Watermark = v
  return s
}

/**
 * office response
 */
type GetOfficeEditUrlResponse struct {
  // EditUrl
  EditUrl *string `json:"edit_url,omitempty" xml:"edit_url,omitempty"`
  // AccessToken
  OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty"`
  // RefreshToken
  OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty"`
}

func (s GetOfficeEditUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s GetOfficeEditUrlResponse) GoString() string {
  return s.String()
}

func (s *GetOfficeEditUrlResponse) SetEditUrl(v string) *GetOfficeEditUrlResponse {
  s.EditUrl = &v
  return s
}

func (s *GetOfficeEditUrlResponse) SetOfficeAccessToken(v string) *GetOfficeEditUrlResponse {
  s.OfficeAccessToken = &v
  return s
}

func (s *GetOfficeEditUrlResponse) SetOfficeRefreshToken(v string) *GetOfficeEditUrlResponse {
  s.OfficeRefreshToken = &v
  return s
}

/**
 * GetOfficeEditUrlWatermark 
 */
type GetOfficeEditUrlWatermark struct {
  // FillStyle
  Fillstyle *string `json:"fillstyle,omitempty" xml:"fillstyle,omitempty"`
  // Font
  Font *string `json:"font,omitempty" xml:"font,omitempty"`
  // Horizontal
  Horizontal *int64 `json:"horizontal,omitempty" xml:"horizontal,omitempty"`
  // Rotate
  Rotate *float64 `json:"rotate,omitempty" xml:"rotate,omitempty"`
  // Type
  Type *int32 `json:"type,omitempty" xml:"type,omitempty"`
  // Value
  Value *string `json:"value,omitempty" xml:"value,omitempty"`
  // Vertical
  Vertical *int64 `json:"vertical,omitempty" xml:"vertical,omitempty"`
}

func (s GetOfficeEditUrlWatermark) String() string {
  return tea.Prettify(s)
}

func (s GetOfficeEditUrlWatermark) GoString() string {
  return s.String()
}

func (s *GetOfficeEditUrlWatermark) SetFillstyle(v string) *GetOfficeEditUrlWatermark {
  s.Fillstyle = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetFont(v string) *GetOfficeEditUrlWatermark {
  s.Font = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetHorizontal(v int64) *GetOfficeEditUrlWatermark {
  s.Horizontal = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetRotate(v float64) *GetOfficeEditUrlWatermark {
  s.Rotate = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetType(v int32) *GetOfficeEditUrlWatermark {
  s.Type = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetValue(v string) *GetOfficeEditUrlWatermark {
  s.Value = &v
  return s
}

func (s *GetOfficeEditUrlWatermark) SetVertical(v int64) *GetOfficeEditUrlWatermark {
  s.Vertical = &v
  return s
}

/**
 * office
 */
type GetOfficePreviewUrlRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetOfficePreviewUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s GetOfficePreviewUrlRequest) GoString() string {
  return s.String()
}

func (s *GetOfficePreviewUrlRequest) SetHeaders(v map[string]*string) *GetOfficePreviewUrlRequest {
  s.Headers = v
  return s
}

func (s *GetOfficePreviewUrlRequest) SetAdditionData(v map[string]interface{}) *GetOfficePreviewUrlRequest {
  s.AdditionData = v
  return s
}

func (s *GetOfficePreviewUrlRequest) SetDriveId(v string) *GetOfficePreviewUrlRequest {
  s.DriveId = &v
  return s
}

func (s *GetOfficePreviewUrlRequest) SetFileId(v string) *GetOfficePreviewUrlRequest {
  s.FileId = &v
  return s
}

func (s *GetOfficePreviewUrlRequest) SetReferer(v string) *GetOfficePreviewUrlRequest {
  s.Referer = &v
  return s
}

func (s *GetOfficePreviewUrlRequest) SetShareId(v string) *GetOfficePreviewUrlRequest {
  s.ShareId = &v
  return s
}

/**
 *  response
 */
type GetOfficePreviewUrlResponse struct {
  // AccessToken
  AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty"`
  // preview_url
  PreviewUrl *string `json:"preview_url,omitempty" xml:"preview_url,omitempty"`
}

func (s GetOfficePreviewUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s GetOfficePreviewUrlResponse) GoString() string {
  return s.String()
}

func (s *GetOfficePreviewUrlResponse) SetAccessToken(v string) *GetOfficePreviewUrlResponse {
  s.AccessToken = &v
  return s
}

func (s *GetOfficePreviewUrlResponse) SetPreviewUrl(v string) *GetOfficePreviewUrlResponse {
  s.PreviewUrl = &v
  return s
}

/**
 * 
 */
type GetPublicKeyRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
}

func (s GetPublicKeyRequest) String() string {
  return tea.Prettify(s)
}

func (s GetPublicKeyRequest) GoString() string {
  return s.String()
}

func (s *GetPublicKeyRequest) SetHeaders(v map[string]*string) *GetPublicKeyRequest {
  s.Headers = v
  return s
}

func (s *GetPublicKeyRequest) SetAppId(v string) *GetPublicKeyRequest {
  s.AppId = &v
  return s
}

/**
 * 
 */
type GetPublicKeyResponse struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  KeyPairId *string `json:"key_pair_id,omitempty" xml:"key_pair_id,omitempty"`
  // RSA, PEM
  PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s GetPublicKeyResponse) String() string {
  return tea.Prettify(s)
}

func (s GetPublicKeyResponse) GoString() string {
  return s.String()
}

func (s *GetPublicKeyResponse) SetAppId(v string) *GetPublicKeyResponse {
  s.AppId = &v
  return s
}

func (s *GetPublicKeyResponse) SetKeyPairId(v string) *GetPublicKeyResponse {
  s.KeyPairId = &v
  return s
}

func (s *GetPublicKeyResponse) SetPublicKey(v string) *GetPublicKeyResponse {
  s.PublicKey = &v
  return s
}

/**
 * 
 */
type GetRPVerifyResultRequest struct {
  // During Verify Process, 
  DuringVerifyProcess *bool `json:"during_verify_process,omitempty" xml:"during_verify_process,omitempty"`
  // User ID, 
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetRPVerifyResultRequest) String() string {
  return tea.Prettify(s)
}

func (s GetRPVerifyResultRequest) GoString() string {
  return s.String()
}

func (s *GetRPVerifyResultRequest) SetDuringVerifyProcess(v bool) *GetRPVerifyResultRequest {
  s.DuringVerifyProcess = &v
  return s
}

func (s *GetRPVerifyResultRequest) SetUserId(v string) *GetRPVerifyResultRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type GetRPVerifyTokenRequest struct {
  // User ID, 
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetRPVerifyTokenRequest) String() string {
  return tea.Prettify(s)
}

func (s GetRPVerifyTokenRequest) GoString() string {
  return s.String()
}

func (s *GetRPVerifyTokenRequest) SetUserId(v string) *GetRPVerifyTokenRequest {
  s.UserId = &v
  return s
}

/**
 * get_share_link_by_anonymous request
 */
type GetShareLinkByAnonymousRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareLinkByAnonymousRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkByAnonymousRequest) GoString() string {
  return s.String()
}

func (s *GetShareLinkByAnonymousRequest) SetHeaders(v map[string]*string) *GetShareLinkByAnonymousRequest {
  s.Headers = v
  return s
}

func (s *GetShareLinkByAnonymousRequest) SetShareId(v string) *GetShareLinkByAnonymousRequest {
  s.ShareId = &v
  return s
}

/**
 * get_share_link_by_anonymous response
 */
type GetShareLinkByAnonymousResponse struct {
  // avatar
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // creator_id
  CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
  // creator_name
  CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
  // creator_phone
  CreatorPhone *string `json:"creator_phone,omitempty" xml:"creator_phone,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // file_count
  FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetShareLinkByAnonymousResponse) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkByAnonymousResponse) GoString() string {
  return s.String()
}

func (s *GetShareLinkByAnonymousResponse) SetAvatar(v string) *GetShareLinkByAnonymousResponse {
  s.Avatar = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorId(v string) *GetShareLinkByAnonymousResponse {
  s.CreatorId = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorName(v string) *GetShareLinkByAnonymousResponse {
  s.CreatorName = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorPhone(v string) *GetShareLinkByAnonymousResponse {
  s.CreatorPhone = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetExpiration(v string) *GetShareLinkByAnonymousResponse {
  s.Expiration = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetFileCount(v int64) *GetShareLinkByAnonymousResponse {
  s.FileCount = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetShareName(v string) *GetShareLinkByAnonymousResponse {
  s.ShareName = &v
  return s
}

func (s *GetShareLinkByAnonymousResponse) SetUpdatedAt(v string) *GetShareLinkByAnonymousResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * body
 */
type GetShareLinkDownloadURLRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"600" minimum:"1"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // get_audio_play_info
  GetAudioPlayInfo *bool `json:"get_audio_play_info,omitempty" xml:"get_audio_play_info,omitempty"`
  // get_video_play_info
  GetVideoPlayInfo *bool `json:"get_video_play_info,omitempty" xml:"get_video_play_info,omitempty"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetShareLinkDownloadURLRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkDownloadURLRequest) GoString() string {
  return s.String()
}

func (s *GetShareLinkDownloadURLRequest) SetHeaders(v map[string]*string) *GetShareLinkDownloadURLRequest {
  s.Headers = v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetAdditionData(v map[string]interface{}) *GetShareLinkDownloadURLRequest {
  s.AdditionData = v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetExpireSec(v int64) *GetShareLinkDownloadURLRequest {
  s.ExpireSec = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetFileId(v string) *GetShareLinkDownloadURLRequest {
  s.FileId = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetFileIdPath(v string) *GetShareLinkDownloadURLRequest {
  s.FileIdPath = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetGetAudioPlayInfo(v bool) *GetShareLinkDownloadURLRequest {
  s.GetAudioPlayInfo = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetGetVideoPlayInfo(v bool) *GetShareLinkDownloadURLRequest {
  s.GetVideoPlayInfo = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetImageThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetImageUrlProcess(v string) *GetShareLinkDownloadURLRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetLocation(v string) *GetShareLinkDownloadURLRequest {
  s.Location = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetOfficeThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetReferer(v string) *GetShareLinkDownloadURLRequest {
  s.Referer = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetShareId(v string) *GetShareLinkDownloadURLRequest {
  s.ShareId = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetSignToken(v string) *GetShareLinkDownloadURLRequest {
  s.SignToken = &v
  return s
}

func (s *GetShareLinkDownloadURLRequest) SetVideoThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type GetShareLinkDownloadURLResponse struct {
  // audio_template_list
  AudioTemplateList []*MediaPlayInfoTemplate `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // video_template_list
  VideoTemplateList []*MediaPlayInfoTemplate `json:"video_template_list,omitempty" xml:"video_template_list,omitempty" type:"Repeated"`
}

func (s GetShareLinkDownloadURLResponse) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkDownloadURLResponse) GoString() string {
  return s.String()
}

func (s *GetShareLinkDownloadURLResponse) SetAudioTemplateList(v []*MediaPlayInfoTemplate) *GetShareLinkDownloadURLResponse {
  s.AudioTemplateList = v
  return s
}

func (s *GetShareLinkDownloadURLResponse) SetDownloadUrl(v string) *GetShareLinkDownloadURLResponse {
  s.DownloadUrl = &v
  return s
}

func (s *GetShareLinkDownloadURLResponse) SetStreamsInfo(v map[string]interface{}) *GetShareLinkDownloadURLResponse {
  s.StreamsInfo = v
  return s
}

func (s *GetShareLinkDownloadURLResponse) SetThumbnail(v string) *GetShareLinkDownloadURLResponse {
  s.Thumbnail = &v
  return s
}

func (s *GetShareLinkDownloadURLResponse) SetUrl(v string) *GetShareLinkDownloadURLResponse {
  s.Url = &v
  return s
}

func (s *GetShareLinkDownloadURLResponse) SetVideoTemplateList(v []*MediaPlayInfoTemplate) *GetShareLinkDownloadURLResponse {
  s.VideoTemplateList = v
  return s
}

/**
 * get_share_id request
 */
type GetShareLinkIDRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_msg
  ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
}

func (s GetShareLinkIDRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkIDRequest) GoString() string {
  return s.String()
}

func (s *GetShareLinkIDRequest) SetHeaders(v map[string]*string) *GetShareLinkIDRequest {
  s.Headers = v
  return s
}

func (s *GetShareLinkIDRequest) SetShareMsg(v string) *GetShareLinkIDRequest {
  s.ShareMsg = &v
  return s
}

/**
 * get_share_id response
 */
type GetShareLinkIDResponse struct {
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
}

func (s GetShareLinkIDResponse) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkIDResponse) GoString() string {
  return s.String()
}

func (s *GetShareLinkIDResponse) SetShareId(v string) *GetShareLinkIDResponse {
  s.ShareId = &v
  return s
}

func (s *GetShareLinkIDResponse) SetSharePwd(v string) *GetShareLinkIDResponse {
  s.SharePwd = &v
  return s
}

/**
 * get_share request
 */
type GetShareLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkRequest) GoString() string {
  return s.String()
}

func (s *GetShareLinkRequest) SetHeaders(v map[string]*string) *GetShareLinkRequest {
  s.Headers = v
  return s
}

func (s *GetShareLinkRequest) SetShareId(v string) *GetShareLinkRequest {
  s.ShareId = &v
  return s
}

/**
 * get_share_token request
 */
type GetShareLinkTokenRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"7200" minimum:"0"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
}

func (s GetShareLinkTokenRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkTokenRequest) GoString() string {
  return s.String()
}

func (s *GetShareLinkTokenRequest) SetHeaders(v map[string]*string) *GetShareLinkTokenRequest {
  s.Headers = v
  return s
}

func (s *GetShareLinkTokenRequest) SetAdditionData(v map[string]interface{}) *GetShareLinkTokenRequest {
  s.AdditionData = v
  return s
}

func (s *GetShareLinkTokenRequest) SetExpireSec(v int64) *GetShareLinkTokenRequest {
  s.ExpireSec = &v
  return s
}

func (s *GetShareLinkTokenRequest) SetReferer(v string) *GetShareLinkTokenRequest {
  s.Referer = &v
  return s
}

func (s *GetShareLinkTokenRequest) SetShareId(v string) *GetShareLinkTokenRequest {
  s.ShareId = &v
  return s
}

func (s *GetShareLinkTokenRequest) SetSharePwd(v string) *GetShareLinkTokenRequest {
  s.SharePwd = &v
  return s
}

/**
 * get_share_token response
 */
type GetShareLinkTokenResponse struct {
  // expire_time
  ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
  // expires_in
  ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty" require:"true"`
  // share_token
  ShareToken *string `json:"share_token,omitempty" xml:"share_token,omitempty" require:"true"`
}

func (s GetShareLinkTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s GetShareLinkTokenResponse) GoString() string {
  return s.String()
}

func (s *GetShareLinkTokenResponse) SetExpireTime(v string) *GetShareLinkTokenResponse {
  s.ExpireTime = &v
  return s
}

func (s *GetShareLinkTokenResponse) SetExpiresIn(v int64) *GetShareLinkTokenResponse {
  s.ExpiresIn = &v
  return s
}

func (s *GetShareLinkTokenResponse) SetShareToken(v string) *GetShareLinkTokenResponse {
  s.ShareToken = &v
  return s
}

/**
 * get share request
 */
type GetShareRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareRequest) String() string {
  return tea.Prettify(s)
}

func (s GetShareRequest) GoString() string {
  return s.String()
}

func (s *GetShareRequest) SetHeaders(v map[string]*string) *GetShareRequest {
  s.Headers = v
  return s
}

func (s *GetShareRequest) SetShareId(v string) *GetShareRequest {
  s.ShareId = &v
  return s
}

/**
 * Get share response
 */
type GetShareResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // owner
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // owner
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // permissions
  Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
  // share_file_id
  ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
  // share_path
  ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetShareResponse) String() string {
  return tea.Prettify(s)
}

func (s GetShareResponse) GoString() string {
  return s.String()
}

func (s *GetShareResponse) SetCreatedAt(v string) *GetShareResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetShareResponse) SetCreator(v string) *GetShareResponse {
  s.Creator = &v
  return s
}

func (s *GetShareResponse) SetDescription(v string) *GetShareResponse {
  s.Description = &v
  return s
}

func (s *GetShareResponse) SetDomainId(v string) *GetShareResponse {
  s.DomainId = &v
  return s
}

func (s *GetShareResponse) SetDriveId(v string) *GetShareResponse {
  s.DriveId = &v
  return s
}

func (s *GetShareResponse) SetExpiration(v string) *GetShareResponse {
  s.Expiration = &v
  return s
}

func (s *GetShareResponse) SetExpired(v bool) *GetShareResponse {
  s.Expired = &v
  return s
}

func (s *GetShareResponse) SetOwner(v string) *GetShareResponse {
  s.Owner = &v
  return s
}

func (s *GetShareResponse) SetOwnerType(v string) *GetShareResponse {
  s.OwnerType = &v
  return s
}

func (s *GetShareResponse) SetPermissions(v []*string) *GetShareResponse {
  s.Permissions = v
  return s
}

func (s *GetShareResponse) SetShareFileId(v string) *GetShareResponse {
  s.ShareFileId = &v
  return s
}

func (s *GetShareResponse) SetShareFilePath(v string) *GetShareResponse {
  s.ShareFilePath = &v
  return s
}

func (s *GetShareResponse) SetShareId(v string) *GetShareResponse {
  s.ShareId = &v
  return s
}

func (s *GetShareResponse) SetShareName(v string) *GetShareResponse {
  s.ShareName = &v
  return s
}

func (s *GetShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *GetShareResponse {
  s.SharePolicy = v
  return s
}

func (s *GetShareResponse) SetStatus(v string) *GetShareResponse {
  s.Status = &v
  return s
}

func (s *GetShareResponse) SetUpdatedAt(v string) *GetShareResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * URL
 */
type GetUploadUrlRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // content_md5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // upload_part_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s GetUploadUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s GetUploadUrlRequest) GoString() string {
  return s.String()
}

func (s *GetUploadUrlRequest) SetHeaders(v map[string]*string) *GetUploadUrlRequest {
  s.Headers = v
  return s
}

func (s *GetUploadUrlRequest) SetContentMd5(v string) *GetUploadUrlRequest {
  s.ContentMd5 = &v
  return s
}

func (s *GetUploadUrlRequest) SetDriveId(v string) *GetUploadUrlRequest {
  s.DriveId = &v
  return s
}

func (s *GetUploadUrlRequest) SetFileId(v string) *GetUploadUrlRequest {
  s.FileId = &v
  return s
}

func (s *GetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *GetUploadUrlRequest {
  s.PartInfoList = v
  return s
}

func (s *GetUploadUrlRequest) SetShareId(v string) *GetUploadUrlRequest {
  s.ShareId = &v
  return s
}

func (s *GetUploadUrlRequest) SetUploadId(v string) *GetUploadUrlRequest {
  s.UploadId = &v
  return s
}

/**
 * Get UploadUrl Response
 */
type GetUploadUrlResponse struct {
  // created_at
  CreateAt *string `json:"create_at,omitempty" xml:"create_at,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s GetUploadUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s GetUploadUrlResponse) GoString() string {
  return s.String()
}

func (s *GetUploadUrlResponse) SetCreateAt(v string) *GetUploadUrlResponse {
  s.CreateAt = &v
  return s
}

func (s *GetUploadUrlResponse) SetDomainId(v string) *GetUploadUrlResponse {
  s.DomainId = &v
  return s
}

func (s *GetUploadUrlResponse) SetDriveId(v string) *GetUploadUrlResponse {
  s.DriveId = &v
  return s
}

func (s *GetUploadUrlResponse) SetFileId(v string) *GetUploadUrlResponse {
  s.FileId = &v
  return s
}

func (s *GetUploadUrlResponse) SetPartInfoList(v []*UploadPartInfo) *GetUploadUrlResponse {
  s.PartInfoList = v
  return s
}

func (s *GetUploadUrlResponse) SetUploadId(v string) *GetUploadUrlResponse {
  s.UploadId = &v
  return s
}

/**
 * body
 */
type GetVideoPreviewSpriteURLRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"14400" minimum:"1"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s GetVideoPreviewSpriteURLRequest) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteURLRequest) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewSpriteURLRequest) SetHeaders(v map[string]*string) *GetVideoPreviewSpriteURLRequest {
  s.Headers = v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetAdditionData(v map[string]interface{}) *GetVideoPreviewSpriteURLRequest {
  s.AdditionData = v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetDriveId(v string) *GetVideoPreviewSpriteURLRequest {
  s.DriveId = &v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetExpireSec(v int64) *GetVideoPreviewSpriteURLRequest {
  s.ExpireSec = &v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetFileId(v string) *GetVideoPreviewSpriteURLRequest {
  s.FileId = &v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetReferer(v string) *GetVideoPreviewSpriteURLRequest {
  s.Referer = &v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetShareId(v string) *GetVideoPreviewSpriteURLRequest {
  s.ShareId = &v
  return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetSignToken(v string) *GetVideoPreviewSpriteURLRequest {
  s.SignToken = &v
  return s
}

/**
 *  url response
 */
type GetVideoPreviewSpriteURLResponse struct {
  // col
  Col *int64 `json:"col,omitempty" xml:"col,omitempty"`
  // count
  Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
  // frame_count
  FrameCount *int64 `json:"frame_count,omitempty" xml:"frame_count,omitempty"`
  // frame_height
  FrameHeight *int64 `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
  // frame_width
  FrameWidth *int64 `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
  // row
  Row *int64 `json:"row,omitempty" xml:"row,omitempty"`
  // sprite_url_list
  SpriteUrlList []*string `json:"sprite_url_list,omitempty" xml:"sprite_url_list,omitempty" type:"Repeated"`
}

func (s GetVideoPreviewSpriteURLResponse) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteURLResponse) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewSpriteURLResponse) SetCol(v int64) *GetVideoPreviewSpriteURLResponse {
  s.Col = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetCount(v int64) *GetVideoPreviewSpriteURLResponse {
  s.Count = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameCount(v int64) *GetVideoPreviewSpriteURLResponse {
  s.FrameCount = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameHeight(v int64) *GetVideoPreviewSpriteURLResponse {
  s.FrameHeight = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameWidth(v int64) *GetVideoPreviewSpriteURLResponse {
  s.FrameWidth = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetRow(v int64) *GetVideoPreviewSpriteURLResponse {
  s.Row = &v
  return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetSpriteUrlList(v []*string) *GetVideoPreviewSpriteURLResponse {
  s.SpriteUrlList = v
  return s
}

/**
 * body
 */
type GetVideoPreviewURLRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // audio_template_id
  AudioTemplateId *string `json:"audio_template_id,omitempty" xml:"audio_template_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"14400" minimum:"1"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
}

func (s GetVideoPreviewURLRequest) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewURLRequest) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewURLRequest) SetHeaders(v map[string]*string) *GetVideoPreviewURLRequest {
  s.Headers = v
  return s
}

func (s *GetVideoPreviewURLRequest) SetAdditionData(v map[string]interface{}) *GetVideoPreviewURLRequest {
  s.AdditionData = v
  return s
}

func (s *GetVideoPreviewURLRequest) SetAudioTemplateId(v string) *GetVideoPreviewURLRequest {
  s.AudioTemplateId = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetDriveId(v string) *GetVideoPreviewURLRequest {
  s.DriveId = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetExpireSec(v int64) *GetVideoPreviewURLRequest {
  s.ExpireSec = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetFileId(v string) *GetVideoPreviewURLRequest {
  s.FileId = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetReferer(v string) *GetVideoPreviewURLRequest {
  s.Referer = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetShareId(v string) *GetVideoPreviewURLRequest {
  s.ShareId = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetSignToken(v string) *GetVideoPreviewURLRequest {
  s.SignToken = &v
  return s
}

func (s *GetVideoPreviewURLRequest) SetTemplateId(v string) *GetVideoPreviewURLRequest {
  s.TemplateId = &v
  return s
}

/**
 *  url response
 */
type GetVideoPreviewURLResponse struct {
  // preview_url
  PreviewUrl *string `json:"preview_url,omitempty" xml:"preview_url,omitempty"`
}

func (s GetVideoPreviewURLResponse) String() string {
  return tea.Prettify(s)
}

func (s GetVideoPreviewURLResponse) GoString() string {
  return s.String()
}

func (s *GetVideoPreviewURLResponse) SetPreviewUrl(v string) *GetVideoPreviewURLResponse {
  s.PreviewUrl = &v
  return s
}

/**
 * complete file request
 */
type HostingCompleteFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // forbid_overwrite
  // type: boolean
  ForbidOverwrite *bool `json:"forbid_overwrite,omitempty" xml:"forbid_overwrite,omitempty"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingCompleteFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingCompleteFileRequest) GoString() string {
  return s.String()
}

func (s *HostingCompleteFileRequest) SetAdditionData(v map[string]interface{}) *HostingCompleteFileRequest {
  s.AdditionData = v
  return s
}

func (s *HostingCompleteFileRequest) SetDriveId(v string) *HostingCompleteFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingCompleteFileRequest) SetFilePath(v string) *HostingCompleteFileRequest {
  s.FilePath = &v
  return s
}

func (s *HostingCompleteFileRequest) SetForbidOverwrite(v bool) *HostingCompleteFileRequest {
  s.ForbidOverwrite = &v
  return s
}

func (s *HostingCompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *HostingCompleteFileRequest {
  s.PartInfoList = v
  return s
}

func (s *HostingCompleteFileRequest) SetShareId(v string) *HostingCompleteFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingCompleteFileRequest) SetUploadId(v string) *HostingCompleteFileRequest {
  s.UploadId = &v
  return s
}

/**
 * complete file response
 */
type HostingCompleteFileResponse struct {
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc
  Crc *string `json:"crc,omitempty" xml:"crc,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingCompleteFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingCompleteFileResponse) GoString() string {
  return s.String()
}

func (s *HostingCompleteFileResponse) SetContentHash(v string) *HostingCompleteFileResponse {
  s.ContentHash = &v
  return s
}

func (s *HostingCompleteFileResponse) SetContentHashName(v string) *HostingCompleteFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *HostingCompleteFileResponse) SetContentType(v string) *HostingCompleteFileResponse {
  s.ContentType = &v
  return s
}

func (s *HostingCompleteFileResponse) SetCrc(v string) *HostingCompleteFileResponse {
  s.Crc = &v
  return s
}

func (s *HostingCompleteFileResponse) SetCrc64Hash(v string) *HostingCompleteFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *HostingCompleteFileResponse) SetCreatedAt(v string) *HostingCompleteFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *HostingCompleteFileResponse) SetDescription(v string) *HostingCompleteFileResponse {
  s.Description = &v
  return s
}

func (s *HostingCompleteFileResponse) SetDomainId(v string) *HostingCompleteFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingCompleteFileResponse) SetDownloadUrl(v string) *HostingCompleteFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *HostingCompleteFileResponse) SetDriveId(v string) *HostingCompleteFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingCompleteFileResponse) SetFileExtension(v string) *HostingCompleteFileResponse {
  s.FileExtension = &v
  return s
}

func (s *HostingCompleteFileResponse) SetFilePath(v string) *HostingCompleteFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingCompleteFileResponse) SetName(v string) *HostingCompleteFileResponse {
  s.Name = &v
  return s
}

func (s *HostingCompleteFileResponse) SetParentFilePath(v string) *HostingCompleteFileResponse {
  s.ParentFilePath = &v
  return s
}

func (s *HostingCompleteFileResponse) SetShareId(v string) *HostingCompleteFileResponse {
  s.ShareId = &v
  return s
}

func (s *HostingCompleteFileResponse) SetSize(v int64) *HostingCompleteFileResponse {
  s.Size = &v
  return s
}

func (s *HostingCompleteFileResponse) SetStatus(v string) *HostingCompleteFileResponse {
  s.Status = &v
  return s
}

func (s *HostingCompleteFileResponse) SetThumbnail(v string) *HostingCompleteFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *HostingCompleteFileResponse) SetTrashedAt(v string) *HostingCompleteFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *HostingCompleteFileResponse) SetType(v string) *HostingCompleteFileResponse {
  s.Type = &v
  return s
}

func (s *HostingCompleteFileResponse) SetUpdatedAt(v string) *HostingCompleteFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *HostingCompleteFileResponse) SetUploadId(v string) *HostingCompleteFileResponse {
  s.UploadId = &v
  return s
}

func (s *HostingCompleteFileResponse) SetUrl(v string) *HostingCompleteFileResponse {
  s.Url = &v
  return s
}

/**
 * copy file request
 */
type HostingCopyFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
  // new_name
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
  // overwrite
  // type: boolean
  Overwrite *bool `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // to_drive_id
  ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
  // to_parent_file_path
  ToParentFilePath *string `json:"to_parent_file_path,omitempty" xml:"to_parent_file_path,omitempty" require:"true"`
  // share_id
  ToShareId *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty"`
}

func (s HostingCopyFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingCopyFileRequest) GoString() string {
  return s.String()
}

func (s *HostingCopyFileRequest) SetAdditionData(v map[string]interface{}) *HostingCopyFileRequest {
  s.AdditionData = v
  return s
}

func (s *HostingCopyFileRequest) SetDriveId(v string) *HostingCopyFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingCopyFileRequest) SetFilePath(v string) *HostingCopyFileRequest {
  s.FilePath = &v
  return s
}

func (s *HostingCopyFileRequest) SetNewName(v string) *HostingCopyFileRequest {
  s.NewName = &v
  return s
}

func (s *HostingCopyFileRequest) SetOverwrite(v bool) *HostingCopyFileRequest {
  s.Overwrite = &v
  return s
}

func (s *HostingCopyFileRequest) SetReferer(v string) *HostingCopyFileRequest {
  s.Referer = &v
  return s
}

func (s *HostingCopyFileRequest) SetShareId(v string) *HostingCopyFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingCopyFileRequest) SetToDriveId(v string) *HostingCopyFileRequest {
  s.ToDriveId = &v
  return s
}

func (s *HostingCopyFileRequest) SetToParentFilePath(v string) *HostingCopyFileRequest {
  s.ToParentFilePath = &v
  return s
}

func (s *HostingCopyFileRequest) SetToShareId(v string) *HostingCopyFileRequest {
  s.ToShareId = &v
  return s
}

/**
 *  response
 */
type HostingCopyFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z-]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // drive_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingCopyFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingCopyFileResponse) GoString() string {
  return s.String()
}

func (s *HostingCopyFileResponse) SetAsyncTaskId(v string) *HostingCopyFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *HostingCopyFileResponse) SetDomainId(v string) *HostingCopyFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingCopyFileResponse) SetDriveId(v string) *HostingCopyFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingCopyFileResponse) SetFilePath(v string) *HostingCopyFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingCopyFileResponse) SetShareId(v string) *HostingCopyFileResponse {
  s.ShareId = &v
  return s
}

/**
 * create file request
 */
type HostingCreateFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // ContentMd5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
  // ContentType
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // forbid_overwrite
  // type: boolean
  ForbidOverwrite *bool `json:"forbid_overwrite,omitempty" xml:"forbid_overwrite,omitempty"`
  // Name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
  // parent_file_path
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" require:"true"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // Type
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s HostingCreateFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingCreateFileRequest) GoString() string {
  return s.String()
}

func (s *HostingCreateFileRequest) SetAdditionData(v map[string]interface{}) *HostingCreateFileRequest {
  s.AdditionData = v
  return s
}

func (s *HostingCreateFileRequest) SetContentMd5(v string) *HostingCreateFileRequest {
  s.ContentMd5 = &v
  return s
}

func (s *HostingCreateFileRequest) SetContentType(v string) *HostingCreateFileRequest {
  s.ContentType = &v
  return s
}

func (s *HostingCreateFileRequest) SetDriveId(v string) *HostingCreateFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingCreateFileRequest) SetForbidOverwrite(v bool) *HostingCreateFileRequest {
  s.ForbidOverwrite = &v
  return s
}

func (s *HostingCreateFileRequest) SetName(v string) *HostingCreateFileRequest {
  s.Name = &v
  return s
}

func (s *HostingCreateFileRequest) SetParentFilePath(v string) *HostingCreateFileRequest {
  s.ParentFilePath = &v
  return s
}

func (s *HostingCreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *HostingCreateFileRequest {
  s.PartInfoList = v
  return s
}

func (s *HostingCreateFileRequest) SetShareId(v string) *HostingCreateFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingCreateFileRequest) SetSize(v int64) *HostingCreateFileRequest {
  s.Size = &v
  return s
}

func (s *HostingCreateFileRequest) SetType(v string) *HostingCreateFileRequest {
  s.Type = &v
  return s
}

/**
 * Create file response
 */
type HostingCreateFileResponse struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingCreateFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingCreateFileResponse) GoString() string {
  return s.String()
}

func (s *HostingCreateFileResponse) SetDomainId(v string) *HostingCreateFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingCreateFileResponse) SetDriveId(v string) *HostingCreateFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingCreateFileResponse) SetFilePath(v string) *HostingCreateFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingCreateFileResponse) SetPartInfoList(v []*UploadPartInfo) *HostingCreateFileResponse {
  s.PartInfoList = v
  return s
}

func (s *HostingCreateFileResponse) SetShareId(v string) *HostingCreateFileResponse {
  s.ShareId = &v
  return s
}

func (s *HostingCreateFileResponse) SetType(v string) *HostingCreateFileResponse {
  s.Type = &v
  return s
}

func (s *HostingCreateFileResponse) SetUploadId(v string) *HostingCreateFileResponse {
  s.UploadId = &v
  return s
}

/**
 * 
 */
type HostingDeleteFileRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // permanently
  // type: false
  Permanently *bool `json:"permanently,omitempty" xml:"permanently,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingDeleteFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingDeleteFileRequest) GoString() string {
  return s.String()
}

func (s *HostingDeleteFileRequest) SetDriveId(v string) *HostingDeleteFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingDeleteFileRequest) SetFilePath(v string) *HostingDeleteFileRequest {
  s.FilePath = &v
  return s
}

func (s *HostingDeleteFileRequest) SetPermanently(v bool) *HostingDeleteFileRequest {
  s.Permanently = &v
  return s
}

func (s *HostingDeleteFileRequest) SetShareId(v string) *HostingDeleteFileRequest {
  s.ShareId = &v
  return s
}

/**
 *  response
 */
type HostingDeleteFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingDeleteFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingDeleteFileResponse) GoString() string {
  return s.String()
}

func (s *HostingDeleteFileResponse) SetAsyncTaskId(v string) *HostingDeleteFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *HostingDeleteFileResponse) SetDomainId(v string) *HostingDeleteFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingDeleteFileResponse) SetDriveId(v string) *HostingDeleteFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingDeleteFileResponse) SetFilePath(v string) *HostingDeleteFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingDeleteFileResponse) SetShareId(v string) *HostingDeleteFileResponse {
  s.ShareId = &v
  return s
}

/**
 *  response
 */
type HostingDeleteFilesResponse struct {
  // deleted_file_id_list
  DeletedFileIdList []*string `json:"deleted_file_id_list,omitempty" xml:"deleted_file_id_list,omitempty" type:"Repeated"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
}

func (s HostingDeleteFilesResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingDeleteFilesResponse) GoString() string {
  return s.String()
}

func (s *HostingDeleteFilesResponse) SetDeletedFileIdList(v []*string) *HostingDeleteFilesResponse {
  s.DeletedFileIdList = v
  return s
}

func (s *HostingDeleteFilesResponse) SetDomainId(v string) *HostingDeleteFilesResponse {
  s.DomainId = &v
  return s
}

func (s *HostingDeleteFilesResponse) SetDriveId(v string) *HostingDeleteFilesResponse {
  s.DriveId = &v
  return s
}

func (s *HostingDeleteFilesResponse) SetShareId(v string) *HostingDeleteFilesResponse {
  s.ShareId = &v
  return s
}

/**
 * body
 */
type HostingGetDownloadUrlRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"115200" minimum:"10"`
  // file_name
  FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s HostingGetDownloadUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingGetDownloadUrlRequest) GoString() string {
  return s.String()
}

func (s *HostingGetDownloadUrlRequest) SetAdditionData(v map[string]interface{}) *HostingGetDownloadUrlRequest {
  s.AdditionData = v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetDriveId(v string) *HostingGetDownloadUrlRequest {
  s.DriveId = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetExpireSec(v int64) *HostingGetDownloadUrlRequest {
  s.ExpireSec = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetFileName(v string) *HostingGetDownloadUrlRequest {
  s.FileName = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetFilePath(v string) *HostingGetDownloadUrlRequest {
  s.FilePath = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetReferer(v string) *HostingGetDownloadUrlRequest {
  s.Referer = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetShareId(v string) *HostingGetDownloadUrlRequest {
  s.ShareId = &v
  return s
}

func (s *HostingGetDownloadUrlRequest) SetSignToken(v string) *HostingGetDownloadUrlRequest {
  s.SignToken = &v
  return s
}

/**
 * download url response
 */
type HostingGetDownloadUrlResponse struct {
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // method
  Method *string `json:"method,omitempty" xml:"method,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetDownloadUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingGetDownloadUrlResponse) GoString() string {
  return s.String()
}

func (s *HostingGetDownloadUrlResponse) SetExpiration(v string) *HostingGetDownloadUrlResponse {
  s.Expiration = &v
  return s
}

func (s *HostingGetDownloadUrlResponse) SetMethod(v string) *HostingGetDownloadUrlResponse {
  s.Method = &v
  return s
}

func (s *HostingGetDownloadUrlResponse) SetUrl(v string) *HostingGetDownloadUrlResponse {
  s.Url = &v
  return s
}

/**
 * 
 */
type HostingGetFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s HostingGetFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingGetFileRequest) GoString() string {
  return s.String()
}

func (s *HostingGetFileRequest) SetAdditionData(v map[string]interface{}) *HostingGetFileRequest {
  s.AdditionData = v
  return s
}

func (s *HostingGetFileRequest) SetDriveId(v string) *HostingGetFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingGetFileRequest) SetFilePath(v string) *HostingGetFileRequest {
  s.FilePath = &v
  return s
}

func (s *HostingGetFileRequest) SetImageThumbnailProcess(v string) *HostingGetFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *HostingGetFileRequest) SetImageUrlProcess(v string) *HostingGetFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *HostingGetFileRequest) SetOfficeThumbnailProcess(v string) *HostingGetFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *HostingGetFileRequest) SetReferer(v string) *HostingGetFileRequest {
  s.Referer = &v
  return s
}

func (s *HostingGetFileRequest) SetShareId(v string) *HostingGetFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingGetFileRequest) SetSignToken(v string) *HostingGetFileRequest {
  s.SignToken = &v
  return s
}

func (s *HostingGetFileRequest) SetUrlExpireSec(v int64) *HostingGetFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *HostingGetFileRequest) SetVideoThumbnailProcess(v string) *HostingGetFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * response
 */
type HostingGetFileResponse struct {
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingGetFileResponse) GoString() string {
  return s.String()
}

func (s *HostingGetFileResponse) SetContentHash(v string) *HostingGetFileResponse {
  s.ContentHash = &v
  return s
}

func (s *HostingGetFileResponse) SetContentHashName(v string) *HostingGetFileResponse {
  s.ContentHashName = &v
  return s
}

func (s *HostingGetFileResponse) SetContentType(v string) *HostingGetFileResponse {
  s.ContentType = &v
  return s
}

func (s *HostingGetFileResponse) SetCrc64Hash(v string) *HostingGetFileResponse {
  s.Crc64Hash = &v
  return s
}

func (s *HostingGetFileResponse) SetCreatedAt(v string) *HostingGetFileResponse {
  s.CreatedAt = &v
  return s
}

func (s *HostingGetFileResponse) SetDescription(v string) *HostingGetFileResponse {
  s.Description = &v
  return s
}

func (s *HostingGetFileResponse) SetDomainId(v string) *HostingGetFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingGetFileResponse) SetDownloadUrl(v string) *HostingGetFileResponse {
  s.DownloadUrl = &v
  return s
}

func (s *HostingGetFileResponse) SetDriveId(v string) *HostingGetFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingGetFileResponse) SetFileExtension(v string) *HostingGetFileResponse {
  s.FileExtension = &v
  return s
}

func (s *HostingGetFileResponse) SetFilePath(v string) *HostingGetFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingGetFileResponse) SetName(v string) *HostingGetFileResponse {
  s.Name = &v
  return s
}

func (s *HostingGetFileResponse) SetParentFilePath(v string) *HostingGetFileResponse {
  s.ParentFilePath = &v
  return s
}

func (s *HostingGetFileResponse) SetShareId(v string) *HostingGetFileResponse {
  s.ShareId = &v
  return s
}

func (s *HostingGetFileResponse) SetSize(v int64) *HostingGetFileResponse {
  s.Size = &v
  return s
}

func (s *HostingGetFileResponse) SetStatus(v string) *HostingGetFileResponse {
  s.Status = &v
  return s
}

func (s *HostingGetFileResponse) SetThumbnail(v string) *HostingGetFileResponse {
  s.Thumbnail = &v
  return s
}

func (s *HostingGetFileResponse) SetTrashedAt(v string) *HostingGetFileResponse {
  s.TrashedAt = &v
  return s
}

func (s *HostingGetFileResponse) SetType(v string) *HostingGetFileResponse {
  s.Type = &v
  return s
}

func (s *HostingGetFileResponse) SetUpdatedAt(v string) *HostingGetFileResponse {
  s.UpdatedAt = &v
  return s
}

func (s *HostingGetFileResponse) SetUploadId(v string) *HostingGetFileResponse {
  s.UploadId = &v
  return s
}

func (s *HostingGetFileResponse) SetUrl(v string) *HostingGetFileResponse {
  s.Url = &v
  return s
}

/**
 * body
 */
type HostingGetSecureUrlRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec 
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // secure_ip
  SecureIp *string `json:"secure_ip,omitempty" xml:"secure_ip,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingGetSecureUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingGetSecureUrlRequest) GoString() string {
  return s.String()
}

func (s *HostingGetSecureUrlRequest) SetDriveId(v string) *HostingGetSecureUrlRequest {
  s.DriveId = &v
  return s
}

func (s *HostingGetSecureUrlRequest) SetExpireSec(v int64) *HostingGetSecureUrlRequest {
  s.ExpireSec = &v
  return s
}

func (s *HostingGetSecureUrlRequest) SetFilePath(v string) *HostingGetSecureUrlRequest {
  s.FilePath = &v
  return s
}

func (s *HostingGetSecureUrlRequest) SetSecureIp(v string) *HostingGetSecureUrlRequest {
  s.SecureIp = &v
  return s
}

func (s *HostingGetSecureUrlRequest) SetShareId(v string) *HostingGetSecureUrlRequest {
  s.ShareId = &v
  return s
}

/**
 * secure url response
 */
type HostingGetSecureUrlResponse struct {
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetSecureUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingGetSecureUrlResponse) GoString() string {
  return s.String()
}

func (s *HostingGetSecureUrlResponse) SetExpiration(v string) *HostingGetSecureUrlResponse {
  s.Expiration = &v
  return s
}

func (s *HostingGetSecureUrlResponse) SetUrl(v string) *HostingGetSecureUrlResponse {
  s.Url = &v
  return s
}

/**
 * URL
 */
type HostingGetUploadUrlRequest struct {
  // content_md5
  ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
  // upload_part_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s HostingGetUploadUrlRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingGetUploadUrlRequest) GoString() string {
  return s.String()
}

func (s *HostingGetUploadUrlRequest) SetContentMd5(v string) *HostingGetUploadUrlRequest {
  s.ContentMd5 = &v
  return s
}

func (s *HostingGetUploadUrlRequest) SetDriveId(v string) *HostingGetUploadUrlRequest {
  s.DriveId = &v
  return s
}

func (s *HostingGetUploadUrlRequest) SetFilePath(v string) *HostingGetUploadUrlRequest {
  s.FilePath = &v
  return s
}

func (s *HostingGetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *HostingGetUploadUrlRequest {
  s.PartInfoList = v
  return s
}

func (s *HostingGetUploadUrlRequest) SetShareId(v string) *HostingGetUploadUrlRequest {
  s.ShareId = &v
  return s
}

func (s *HostingGetUploadUrlRequest) SetUploadId(v string) *HostingGetUploadUrlRequest {
  s.UploadId = &v
  return s
}

/**
 * Get UploadUrl Response
 */
type HostingGetUploadUrlResponse struct {
  // created_at
  CreateAt *string `json:"create_at,omitempty" xml:"create_at,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingGetUploadUrlResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingGetUploadUrlResponse) GoString() string {
  return s.String()
}

func (s *HostingGetUploadUrlResponse) SetCreateAt(v string) *HostingGetUploadUrlResponse {
  s.CreateAt = &v
  return s
}

func (s *HostingGetUploadUrlResponse) SetDomainId(v string) *HostingGetUploadUrlResponse {
  s.DomainId = &v
  return s
}

func (s *HostingGetUploadUrlResponse) SetDriveId(v string) *HostingGetUploadUrlResponse {
  s.DriveId = &v
  return s
}

func (s *HostingGetUploadUrlResponse) SetFilePath(v string) *HostingGetUploadUrlResponse {
  s.FilePath = &v
  return s
}

func (s *HostingGetUploadUrlResponse) SetPartInfoList(v []*UploadPartInfo) *HostingGetUploadUrlResponse {
  s.PartInfoList = v
  return s
}

func (s *HostingGetUploadUrlResponse) SetUploadId(v string) *HostingGetUploadUrlResponse {
  s.UploadId = &v
  return s
}

/**
 * list file request
 */
type HostingListFileRequest struct {
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // ParentFilePath
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" require:"true"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s HostingListFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingListFileRequest) GoString() string {
  return s.String()
}

func (s *HostingListFileRequest) SetAdditionData(v map[string]interface{}) *HostingListFileRequest {
  s.AdditionData = v
  return s
}

func (s *HostingListFileRequest) SetDriveId(v string) *HostingListFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingListFileRequest) SetImageCroppingAspectRatios(v []*string) *HostingListFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *HostingListFileRequest) SetImageThumbnailProcess(v string) *HostingListFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *HostingListFileRequest) SetImageUrlProcess(v string) *HostingListFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *HostingListFileRequest) SetLimit(v int64) *HostingListFileRequest {
  s.Limit = &v
  return s
}

func (s *HostingListFileRequest) SetMarker(v string) *HostingListFileRequest {
  s.Marker = &v
  return s
}

func (s *HostingListFileRequest) SetOfficeThumbnailProcess(v string) *HostingListFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *HostingListFileRequest) SetParentFilePath(v string) *HostingListFileRequest {
  s.ParentFilePath = &v
  return s
}

func (s *HostingListFileRequest) SetReferer(v string) *HostingListFileRequest {
  s.Referer = &v
  return s
}

func (s *HostingListFileRequest) SetShareId(v string) *HostingListFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingListFileRequest) SetSignToken(v string) *HostingListFileRequest {
  s.SignToken = &v
  return s
}

func (s *HostingListFileRequest) SetUrlExpireSec(v int64) *HostingListFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *HostingListFileRequest) SetVideoThumbnailProcess(v string) *HostingListFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * List file response
 */
type HostingListFileResponse struct {
  // items
  Items []*BaseHostingFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s HostingListFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingListFileResponse) GoString() string {
  return s.String()
}

func (s *HostingListFileResponse) SetItems(v []*BaseHostingFileResponse) *HostingListFileResponse {
  s.Items = v
  return s
}

func (s *HostingListFileResponse) SetNextMarker(v string) *HostingListFileResponse {
  s.NextMarker = &v
  return s
}

/**
 * uploadID
 */
type HostingListUploadedPartRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
  // part_number_marker
  PartNumberMarker *int64 `json:"part_number_marker,omitempty" xml:"part_number_marker,omitempty" minimum:"1"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingListUploadedPartRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingListUploadedPartRequest) GoString() string {
  return s.String()
}

func (s *HostingListUploadedPartRequest) SetDriveId(v string) *HostingListUploadedPartRequest {
  s.DriveId = &v
  return s
}

func (s *HostingListUploadedPartRequest) SetFilePath(v string) *HostingListUploadedPartRequest {
  s.FilePath = &v
  return s
}

func (s *HostingListUploadedPartRequest) SetLimit(v int64) *HostingListUploadedPartRequest {
  s.Limit = &v
  return s
}

func (s *HostingListUploadedPartRequest) SetPartNumberMarker(v int64) *HostingListUploadedPartRequest {
  s.PartNumberMarker = &v
  return s
}

func (s *HostingListUploadedPartRequest) SetShareId(v string) *HostingListUploadedPartRequest {
  s.ShareId = &v
  return s
}

func (s *HostingListUploadedPartRequest) SetUploadId(v string) *HostingListUploadedPartRequest {
  s.UploadId = &v
  return s
}

/**
 *  response
 */
type HostingListUploadedPartResponse struct {
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // next_part_number_marker
  NextPartNumberMarker *string `json:"next_part_number_marker,omitempty" xml:"next_part_number_marker,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // uploaded_parts
  UploadedParts []*UploadPartInfo `json:"uploaded_parts,omitempty" xml:"uploaded_parts,omitempty" type:"Repeated"`
}

func (s HostingListUploadedPartResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingListUploadedPartResponse) GoString() string {
  return s.String()
}

func (s *HostingListUploadedPartResponse) SetFilePath(v string) *HostingListUploadedPartResponse {
  s.FilePath = &v
  return s
}

func (s *HostingListUploadedPartResponse) SetNextPartNumberMarker(v string) *HostingListUploadedPartResponse {
  s.NextPartNumberMarker = &v
  return s
}

func (s *HostingListUploadedPartResponse) SetUploadId(v string) *HostingListUploadedPartResponse {
  s.UploadId = &v
  return s
}

func (s *HostingListUploadedPartResponse) SetUploadedParts(v []*UploadPartInfo) *HostingListUploadedPartResponse {
  s.UploadedParts = v
  return s
}

/**
 * 
 */
type HostingMoveFileRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // new_name
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty"`
  // overwrite
  // type: boolean
  Overwrite *bool `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // file_path
  ToParentFilePath *string `json:"to_parent_file_path,omitempty" xml:"to_parent_file_path,omitempty"`
}

func (s HostingMoveFileRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingMoveFileRequest) GoString() string {
  return s.String()
}

func (s *HostingMoveFileRequest) SetDriveId(v string) *HostingMoveFileRequest {
  s.DriveId = &v
  return s
}

func (s *HostingMoveFileRequest) SetFilePath(v string) *HostingMoveFileRequest {
  s.FilePath = &v
  return s
}

func (s *HostingMoveFileRequest) SetNewName(v string) *HostingMoveFileRequest {
  s.NewName = &v
  return s
}

func (s *HostingMoveFileRequest) SetOverwrite(v bool) *HostingMoveFileRequest {
  s.Overwrite = &v
  return s
}

func (s *HostingMoveFileRequest) SetShareId(v string) *HostingMoveFileRequest {
  s.ShareId = &v
  return s
}

func (s *HostingMoveFileRequest) SetToParentFilePath(v string) *HostingMoveFileRequest {
  s.ToParentFilePath = &v
  return s
}

/**
 *  response
 */
type HostingMoveFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z-]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // drive_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingMoveFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingMoveFileResponse) GoString() string {
  return s.String()
}

func (s *HostingMoveFileResponse) SetAsyncTaskId(v string) *HostingMoveFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *HostingMoveFileResponse) SetDomainId(v string) *HostingMoveFileResponse {
  s.DomainId = &v
  return s
}

func (s *HostingMoveFileResponse) SetDriveId(v string) *HostingMoveFileResponse {
  s.DriveId = &v
  return s
}

func (s *HostingMoveFileResponse) SetFilePath(v string) *HostingMoveFileResponse {
  s.FilePath = &v
  return s
}

func (s *HostingMoveFileResponse) SetShareId(v string) *HostingMoveFileResponse {
  s.ShareId = &v
  return s
}

/**
 * search file response
 */
type HostingSearchFileResponse struct {
  // items
  Items []*BaseHostingFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s HostingSearchFileResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingSearchFileResponse) GoString() string {
  return s.String()
}

func (s *HostingSearchFileResponse) SetItems(v []*BaseHostingFileResponse) *HostingSearchFileResponse {
  s.Items = v
  return s
}

func (s *HostingSearchFileResponse) SetNextMarker(v string) *HostingSearchFileResponse {
  s.NextMarker = &v
  return s
}

/**
 *  response
 */
type HostingUpdateFileMetaResponse struct {
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingUpdateFileMetaResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingUpdateFileMetaResponse) GoString() string {
  return s.String()
}

func (s *HostingUpdateFileMetaResponse) SetContentHash(v string) *HostingUpdateFileMetaResponse {
  s.ContentHash = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetContentHashName(v string) *HostingUpdateFileMetaResponse {
  s.ContentHashName = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetContentType(v string) *HostingUpdateFileMetaResponse {
  s.ContentType = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetCrc64Hash(v string) *HostingUpdateFileMetaResponse {
  s.Crc64Hash = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetCreatedAt(v string) *HostingUpdateFileMetaResponse {
  s.CreatedAt = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetDescription(v string) *HostingUpdateFileMetaResponse {
  s.Description = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetDomainId(v string) *HostingUpdateFileMetaResponse {
  s.DomainId = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetDownloadUrl(v string) *HostingUpdateFileMetaResponse {
  s.DownloadUrl = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetDriveId(v string) *HostingUpdateFileMetaResponse {
  s.DriveId = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetFileExtension(v string) *HostingUpdateFileMetaResponse {
  s.FileExtension = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetFilePath(v string) *HostingUpdateFileMetaResponse {
  s.FilePath = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetName(v string) *HostingUpdateFileMetaResponse {
  s.Name = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetParentFilePath(v string) *HostingUpdateFileMetaResponse {
  s.ParentFilePath = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetShareId(v string) *HostingUpdateFileMetaResponse {
  s.ShareId = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetSize(v int64) *HostingUpdateFileMetaResponse {
  s.Size = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetStatus(v string) *HostingUpdateFileMetaResponse {
  s.Status = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetThumbnail(v string) *HostingUpdateFileMetaResponse {
  s.Thumbnail = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetTrashedAt(v string) *HostingUpdateFileMetaResponse {
  s.TrashedAt = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetType(v string) *HostingUpdateFileMetaResponse {
  s.Type = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetUpdatedAt(v string) *HostingUpdateFileMetaResponse {
  s.UpdatedAt = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetUploadId(v string) *HostingUpdateFileMetaResponse {
  s.UploadId = &v
  return s
}

func (s *HostingUpdateFileMetaResponse) SetUrl(v string) *HostingUpdateFileMetaResponse {
  s.Url = &v
  return s
}

/**
 * DRM License
 */
type HostingVideoDRMLicenseRequest struct {
  // drmType
  DrmType *string `json:"drmType,omitempty" xml:"drmType,omitempty" require:"true"`
  // licenseRequest
  LicenseRequest *string `json:"licenseRequest,omitempty" xml:"licenseRequest,omitempty" require:"true"`
}

func (s HostingVideoDRMLicenseRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoDRMLicenseRequest) GoString() string {
  return s.String()
}

func (s *HostingVideoDRMLicenseRequest) SetDrmType(v string) *HostingVideoDRMLicenseRequest {
  s.DrmType = &v
  return s
}

func (s *HostingVideoDRMLicenseRequest) SetLicenseRequest(v string) *HostingVideoDRMLicenseRequest {
  s.LicenseRequest = &v
  return s
}

/**
 * DRM License response
 */
type HostingVideoDRMLicenseResponse struct {
  // drm_data
  Data *string `json:"data,omitempty" xml:"data,omitempty" require:"true"`
  // device_info
  DeviceInfo *string `json:"device_info,omitempty" xml:"device_info,omitempty" require:"true"`
  // states
  States *int64 `json:"states,omitempty" xml:"states,omitempty" require:"true"`
}

func (s HostingVideoDRMLicenseResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoDRMLicenseResponse) GoString() string {
  return s.String()
}

func (s *HostingVideoDRMLicenseResponse) SetData(v string) *HostingVideoDRMLicenseResponse {
  s.Data = &v
  return s
}

func (s *HostingVideoDRMLicenseResponse) SetDeviceInfo(v string) *HostingVideoDRMLicenseResponse {
  s.DeviceInfo = &v
  return s
}

func (s *HostingVideoDRMLicenseResponse) SetStates(v int64) *HostingVideoDRMLicenseResponse {
  s.States = &v
  return s
}

/**
 * 
 */
type HostingVideoDefinitionRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // protection_scheme
  ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingVideoDefinitionRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoDefinitionRequest) GoString() string {
  return s.String()
}

func (s *HostingVideoDefinitionRequest) SetDriveId(v string) *HostingVideoDefinitionRequest {
  s.DriveId = &v
  return s
}

func (s *HostingVideoDefinitionRequest) SetFilePath(v string) *HostingVideoDefinitionRequest {
  s.FilePath = &v
  return s
}

func (s *HostingVideoDefinitionRequest) SetProtectionScheme(v string) *HostingVideoDefinitionRequest {
  s.ProtectionScheme = &v
  return s
}

func (s *HostingVideoDefinitionRequest) SetShareId(v string) *HostingVideoDefinitionRequest {
  s.ShareId = &v
  return s
}

/**
 * response
 */
type HostingVideoDefinitionResponse struct {
  // definition_list
  DefinitionList []*string `json:"definition_list,omitempty" xml:"definition_list,omitempty" type:"Repeated"`
  // frame_rate
  FrameRate *string `json:"frame_rate,omitempty" xml:"frame_rate,omitempty"`
}

func (s HostingVideoDefinitionResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoDefinitionResponse) GoString() string {
  return s.String()
}

func (s *HostingVideoDefinitionResponse) SetDefinitionList(v []*string) *HostingVideoDefinitionResponse {
  s.DefinitionList = v
  return s
}

func (s *HostingVideoDefinitionResponse) SetFrameRate(v string) *HostingVideoDefinitionResponse {
  s.FrameRate = &v
  return s
}

/**
 * m3u8
 */
type HostingVideoM3U8Request struct {
  // definition
  Definition *string `json:"definition,omitempty" xml:"definition,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // expire_sec
  ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"86400" minimum:"60"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // protection_scheme
  ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // sign_token
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty" require:"true"`
}

func (s HostingVideoM3U8Request) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoM3U8Request) GoString() string {
  return s.String()
}

func (s *HostingVideoM3U8Request) SetDefinition(v string) *HostingVideoM3U8Request {
  s.Definition = &v
  return s
}

func (s *HostingVideoM3U8Request) SetDriveId(v string) *HostingVideoM3U8Request {
  s.DriveId = &v
  return s
}

func (s *HostingVideoM3U8Request) SetExpireSec(v int64) *HostingVideoM3U8Request {
  s.ExpireSec = &v
  return s
}

func (s *HostingVideoM3U8Request) SetFilePath(v string) *HostingVideoM3U8Request {
  s.FilePath = &v
  return s
}

func (s *HostingVideoM3U8Request) SetProtectionScheme(v string) *HostingVideoM3U8Request {
  s.ProtectionScheme = &v
  return s
}

func (s *HostingVideoM3U8Request) SetShareId(v string) *HostingVideoM3U8Request {
  s.ShareId = &v
  return s
}

func (s *HostingVideoM3U8Request) SetSignToken(v string) *HostingVideoM3U8Request {
  s.SignToken = &v
  return s
}

/**
 * 
 */
type HostingVideoTranscodeRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_path
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
  // hls_time
  HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
  // protection_scheme
  ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
  // remarks
  Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
  // transcode
  Transcode *bool `json:"transcode,omitempty" xml:"transcode,omitempty"`
}

func (s HostingVideoTranscodeRequest) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoTranscodeRequest) GoString() string {
  return s.String()
}

func (s *HostingVideoTranscodeRequest) SetDriveId(v string) *HostingVideoTranscodeRequest {
  s.DriveId = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetFilePath(v string) *HostingVideoTranscodeRequest {
  s.FilePath = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetHlsTime(v int64) *HostingVideoTranscodeRequest {
  s.HlsTime = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetProtectionScheme(v string) *HostingVideoTranscodeRequest {
  s.ProtectionScheme = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetRemarks(v string) *HostingVideoTranscodeRequest {
  s.Remarks = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetShareId(v string) *HostingVideoTranscodeRequest {
  s.ShareId = &v
  return s
}

func (s *HostingVideoTranscodeRequest) SetTranscode(v bool) *HostingVideoTranscodeRequest {
  s.Transcode = &v
  return s
}

/**
 * response
 */
type HostingVideoTranscodeResponse struct {
  // definition_list
  DefinitionList []*string `json:"definition_list,omitempty" xml:"definition_list,omitempty" type:"Repeated"`
  // duration
  Duration *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
  // hls_time
  HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
}

func (s HostingVideoTranscodeResponse) String() string {
  return tea.Prettify(s)
}

func (s HostingVideoTranscodeResponse) GoString() string {
  return s.String()
}

func (s *HostingVideoTranscodeResponse) SetDefinitionList(v []*string) *HostingVideoTranscodeResponse {
  s.DefinitionList = v
  return s
}

func (s *HostingVideoTranscodeResponse) SetDuration(v int64) *HostingVideoTranscodeResponse {
  s.Duration = &v
  return s
}

func (s *HostingVideoTranscodeResponse) SetHlsTime(v int64) *HostingVideoTranscodeResponse {
  s.HlsTime = &v
  return s
}

/**
 * 
 */
type ImageMediaMetadata struct {
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  // width
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s ImageMediaMetadata) String() string {
  return tea.Prettify(s)
}

func (s ImageMediaMetadata) GoString() string {
  return s.String()
}

func (s *ImageMediaMetadata) SetHeight(v int64) *ImageMediaMetadata {
  s.Height = &v
  return s
}

func (s *ImageMediaMetadata) SetWidth(v int64) *ImageMediaMetadata {
  s.Width = &v
  return s
}

/**
 * 
 */
type ImageMediaResponse struct {
  // address_line
  AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
  // city
  City *string `json:"city,omitempty" xml:"city,omitempty"`
  // country
  Country *string `json:"country,omitempty" xml:"country,omitempty"`
  // cropping_suggestion
  CroppingSuggestion []*CroppingSuggestionItem `json:"cropping_suggestion,omitempty" xml:"cropping_suggestion,omitempty" type:"Repeated"`
  // district
  District *string `json:"district,omitempty" xml:"district,omitempty"`
  // exif json string
  Exif *string `json:"exif,omitempty" xml:"exif,omitempty"`
  // faces json string
  Faces *string `json:"faces,omitempty" xml:"faces,omitempty"`
  // faces_thumbnail_list
  FacesThumbnail []*FaceThumbnail `json:"faces_thumbnail,omitempty" xml:"faces_thumbnail,omitempty" type:"Repeated"`
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  ImageQuality *ImageQuality `json:"image_quality,omitempty" xml:"image_quality,omitempty"`
  // system_tags
  ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // province
  Province *string `json:"province,omitempty" xml:"province,omitempty"`
  // time
  Time *string `json:"time,omitempty" xml:"time,omitempty"`
  // township
  Township *string `json:"township,omitempty" xml:"township,omitempty"`
  // width
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s ImageMediaResponse) String() string {
  return tea.Prettify(s)
}

func (s ImageMediaResponse) GoString() string {
  return s.String()
}

func (s *ImageMediaResponse) SetAddressLine(v string) *ImageMediaResponse {
  s.AddressLine = &v
  return s
}

func (s *ImageMediaResponse) SetCity(v string) *ImageMediaResponse {
  s.City = &v
  return s
}

func (s *ImageMediaResponse) SetCountry(v string) *ImageMediaResponse {
  s.Country = &v
  return s
}

func (s *ImageMediaResponse) SetCroppingSuggestion(v []*CroppingSuggestionItem) *ImageMediaResponse {
  s.CroppingSuggestion = v
  return s
}

func (s *ImageMediaResponse) SetDistrict(v string) *ImageMediaResponse {
  s.District = &v
  return s
}

func (s *ImageMediaResponse) SetExif(v string) *ImageMediaResponse {
  s.Exif = &v
  return s
}

func (s *ImageMediaResponse) SetFaces(v string) *ImageMediaResponse {
  s.Faces = &v
  return s
}

func (s *ImageMediaResponse) SetFacesThumbnail(v []*FaceThumbnail) *ImageMediaResponse {
  s.FacesThumbnail = v
  return s
}

func (s *ImageMediaResponse) SetHeight(v int64) *ImageMediaResponse {
  s.Height = &v
  return s
}

func (s *ImageMediaResponse) SetImageQuality(v *ImageQuality) *ImageMediaResponse {
  s.ImageQuality = v
  return s
}

func (s *ImageMediaResponse) SetImageTags(v []*SystemTag) *ImageMediaResponse {
  s.ImageTags = v
  return s
}

func (s *ImageMediaResponse) SetLocation(v string) *ImageMediaResponse {
  s.Location = &v
  return s
}

func (s *ImageMediaResponse) SetProvince(v string) *ImageMediaResponse {
  s.Province = &v
  return s
}

func (s *ImageMediaResponse) SetTime(v string) *ImageMediaResponse {
  s.Time = &v
  return s
}

func (s *ImageMediaResponse) SetTownship(v string) *ImageMediaResponse {
  s.Township = &v
  return s
}

func (s *ImageMediaResponse) SetWidth(v int64) *ImageMediaResponse {
  s.Width = &v
  return s
}

/**
 * 
 */
type ImageQuality struct {
  Clarity *float64 `json:"clarity,omitempty" xml:"clarity,omitempty"`
  ClarityScore *float64 `json:"clarity_score,omitempty" xml:"clarity_score,omitempty"`
  Color *float64 `json:"color,omitempty" xml:"color,omitempty"`
  ColorScore *float64 `json:"color_score,omitempty" xml:"color_score,omitempty"`
  CompositionScore *float64 `json:"composition_score,omitempty" xml:"composition_score,omitempty"`
  Contrast *float64 `json:"contrast,omitempty" xml:"contrast,omitempty"`
  ContrastScore *float64 `json:"contrast_score,omitempty" xml:"contrast_score,omitempty"`
  Exposure *float64 `json:"exposure,omitempty" xml:"exposure,omitempty"`
  ExposureScore *float64 `json:"exposure_score,omitempty" xml:"exposure_score,omitempty"`
  OverallScore *float64 `json:"overall_score,omitempty" xml:"overall_score,omitempty"`
}

func (s ImageQuality) String() string {
  return tea.Prettify(s)
}

func (s ImageQuality) GoString() string {
  return s.String()
}

func (s *ImageQuality) SetClarity(v float64) *ImageQuality {
  s.Clarity = &v
  return s
}

func (s *ImageQuality) SetClarityScore(v float64) *ImageQuality {
  s.ClarityScore = &v
  return s
}

func (s *ImageQuality) SetColor(v float64) *ImageQuality {
  s.Color = &v
  return s
}

func (s *ImageQuality) SetColorScore(v float64) *ImageQuality {
  s.ColorScore = &v
  return s
}

func (s *ImageQuality) SetCompositionScore(v float64) *ImageQuality {
  s.CompositionScore = &v
  return s
}

func (s *ImageQuality) SetContrast(v float64) *ImageQuality {
  s.Contrast = &v
  return s
}

func (s *ImageQuality) SetContrastScore(v float64) *ImageQuality {
  s.ContrastScore = &v
  return s
}

func (s *ImageQuality) SetExposure(v float64) *ImageQuality {
  s.Exposure = &v
  return s
}

func (s *ImageQuality) SetExposureScore(v float64) *ImageQuality {
  s.ExposureScore = &v
  return s
}

func (s *ImageQuality) SetOverallScore(v float64) *ImageQuality {
  s.OverallScore = &v
  return s
}

/**
 * 
 */
type LdapConfig struct {
  AdminDn *string `json:"admin_dn,omitempty" xml:"admin_dn,omitempty"`
  AdminPassword *string `json:"admin_password,omitempty" xml:"admin_password,omitempty"`
  BaseDn *string `json:"base_dn,omitempty" xml:"base_dn,omitempty"`
  Host *string `json:"host,omitempty" xml:"host,omitempty"`
  Port *int64 `json:"port,omitempty" xml:"port,omitempty"`
  Uid *string `json:"uid,omitempty" xml:"uid,omitempty"`
}

func (s LdapConfig) String() string {
  return tea.Prettify(s)
}

func (s LdapConfig) GoString() string {
  return s.String()
}

func (s *LdapConfig) SetAdminDn(v string) *LdapConfig {
  s.AdminDn = &v
  return s
}

func (s *LdapConfig) SetAdminPassword(v string) *LdapConfig {
  s.AdminPassword = &v
  return s
}

func (s *LdapConfig) SetBaseDn(v string) *LdapConfig {
  s.BaseDn = &v
  return s
}

func (s *LdapConfig) SetHost(v string) *LdapConfig {
  s.Host = &v
  return s
}

func (s *LdapConfig) SetPort(v int64) *LdapConfig {
  s.Port = &v
  return s
}

func (s *LdapConfig) SetUid(v string) *LdapConfig {
  s.Uid = &v
  return s
}

/**
 * 
 */
type LinkInfo struct {
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty"`
  // 
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s LinkInfo) String() string {
  return tea.Prettify(s)
}

func (s LinkInfo) GoString() string {
  return s.String()
}

func (s *LinkInfo) SetExtra(v string) *LinkInfo {
  s.Extra = &v
  return s
}

func (s *LinkInfo) SetIdentity(v string) *LinkInfo {
  s.Identity = &v
  return s
}

func (s *LinkInfo) SetType(v string) *LinkInfo {
  s.Type = &v
  return s
}

/**
 * 
 */
type LinkInfoListResponse struct {
  // items
  Items []*LinkInfoResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
}

func (s LinkInfoListResponse) String() string {
  return tea.Prettify(s)
}

func (s LinkInfoListResponse) GoString() string {
  return s.String()
}

func (s *LinkInfoListResponse) SetItems(v []*LinkInfoResponse) *LinkInfoListResponse {
  s.Items = v
  return s
}

/**
 * 
 */
type LinkInfoResponse struct {
  // 
  AuthenticationType *string `json:"authentication_type,omitempty" xml:"authentication_type,omitempty" require:"true"`
  // 
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
  // 
  LastLoginTime *int64 `json:"last_login_time,omitempty" xml:"last_login_time,omitempty" require:"true"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty" require:"true"`
  // ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s LinkInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s LinkInfoResponse) GoString() string {
  return s.String()
}

func (s *LinkInfoResponse) SetAuthenticationType(v string) *LinkInfoResponse {
  s.AuthenticationType = &v
  return s
}

func (s *LinkInfoResponse) SetCreatedAt(v int64) *LinkInfoResponse {
  s.CreatedAt = &v
  return s
}

func (s *LinkInfoResponse) SetDomainId(v string) *LinkInfoResponse {
  s.DomainId = &v
  return s
}

func (s *LinkInfoResponse) SetExtra(v string) *LinkInfoResponse {
  s.Extra = &v
  return s
}

func (s *LinkInfoResponse) SetIdentity(v string) *LinkInfoResponse {
  s.Identity = &v
  return s
}

func (s *LinkInfoResponse) SetLastLoginTime(v int64) *LinkInfoResponse {
  s.LastLoginTime = &v
  return s
}

func (s *LinkInfoResponse) SetStatus(v string) *LinkInfoResponse {
  s.Status = &v
  return s
}

func (s *LinkInfoResponse) SetUserId(v string) *LinkInfoResponse {
  s.UserId = &v
  return s
}

/**
 * 
 */
type ListAppsRequest struct {
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListAppsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListAppsRequest) GoString() string {
  return s.String()
}

func (s *ListAppsRequest) SetLimit(v int32) *ListAppsRequest {
  s.Limit = &v
  return s
}

func (s *ListAppsRequest) SetMarker(v string) *ListAppsRequest {
  s.Marker = &v
  return s
}

/**
 * list_file_by_anonymous request
 */
type ListByAnonymousRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9]{1,50}"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListByAnonymousRequest) String() string {
  return tea.Prettify(s)
}

func (s ListByAnonymousRequest) GoString() string {
  return s.String()
}

func (s *ListByAnonymousRequest) SetHeaders(v map[string]*string) *ListByAnonymousRequest {
  s.Headers = v
  return s
}

func (s *ListByAnonymousRequest) SetAdditionData(v map[string]interface{}) *ListByAnonymousRequest {
  s.AdditionData = v
  return s
}

func (s *ListByAnonymousRequest) SetImageThumbnailProcess(v string) *ListByAnonymousRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListByAnonymousRequest) SetImageUrlProcess(v string) *ListByAnonymousRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ListByAnonymousRequest) SetLimit(v int64) *ListByAnonymousRequest {
  s.Limit = &v
  return s
}

func (s *ListByAnonymousRequest) SetMarker(v string) *ListByAnonymousRequest {
  s.Marker = &v
  return s
}

func (s *ListByAnonymousRequest) SetOfficeThumbnailProcess(v string) *ListByAnonymousRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ListByAnonymousRequest) SetParentFileId(v string) *ListByAnonymousRequest {
  s.ParentFileId = &v
  return s
}

func (s *ListByAnonymousRequest) SetReferer(v string) *ListByAnonymousRequest {
  s.Referer = &v
  return s
}

func (s *ListByAnonymousRequest) SetShareId(v string) *ListByAnonymousRequest {
  s.ShareId = &v
  return s
}

func (s *ListByAnonymousRequest) SetSignToken(v string) *ListByAnonymousRequest {
  s.SignToken = &v
  return s
}

func (s *ListByAnonymousRequest) SetVideoThumbnailProcess(v string) *ListByAnonymousRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * list_file_by_anonymous response
 */
type ListByAnonymousResponse struct {
  // items
  Items []*BaseFileAnonymousResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListByAnonymousResponse) String() string {
  return tea.Prettify(s)
}

func (s ListByAnonymousResponse) GoString() string {
  return s.String()
}

func (s *ListByAnonymousResponse) SetItems(v []*BaseFileAnonymousResponse) *ListByAnonymousResponse {
  s.Items = v
  return s
}

func (s *ListByAnonymousResponse) SetNextMarker(v string) *ListByAnonymousResponse {
  s.NextMarker = &v
  return s
}

/**
 * list domain request
 */
type ListDomainsRequest struct {
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListDomainsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListDomainsRequest) GoString() string {
  return s.String()
}

func (s *ListDomainsRequest) SetLimit(v int32) *ListDomainsRequest {
  s.Limit = &v
  return s
}

func (s *ListDomainsRequest) SetMarker(v string) *ListDomainsRequest {
  s.Marker = &v
  return s
}

/**
 * List drive request
 */
type ListDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // , 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // 
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // owner_type
  // 
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s ListDriveRequest) GoString() string {
  return s.String()
}

func (s *ListDriveRequest) SetHeaders(v map[string]*string) *ListDriveRequest {
  s.Headers = v
  return s
}

func (s *ListDriveRequest) SetLimit(v int32) *ListDriveRequest {
  s.Limit = &v
  return s
}

func (s *ListDriveRequest) SetMarker(v string) *ListDriveRequest {
  s.Marker = &v
  return s
}

func (s *ListDriveRequest) SetOwner(v string) *ListDriveRequest {
  s.Owner = &v
  return s
}

func (s *ListDriveRequest) SetOwnerType(v string) *ListDriveRequest {
  s.OwnerType = &v
  return s
}

func (s *ListDriveRequest) SetSubdomainId(v string) *ListDriveRequest {
  s.SubdomainId = &v
  return s
}

/**
 * list drive response
 */
type ListDriveResponse struct {
  // Drive 
  Items []*BaseDriveResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s ListDriveResponse) GoString() string {
  return s.String()
}

func (s *ListDriveResponse) SetItems(v []*BaseDriveResponse) *ListDriveResponse {
  s.Items = v
  return s
}

func (s *ListDriveResponse) SetNextMarker(v string) *ListDriveResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type ListFileActivityRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // DriveID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // FileID
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // Limit, default
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // Marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListFileActivityRequest) String() string {
  return tea.Prettify(s)
}

func (s ListFileActivityRequest) GoString() string {
  return s.String()
}

func (s *ListFileActivityRequest) SetHeaders(v map[string]*string) *ListFileActivityRequest {
  s.Headers = v
  return s
}

func (s *ListFileActivityRequest) SetAdditionData(v map[string]interface{}) *ListFileActivityRequest {
  s.AdditionData = v
  return s
}

func (s *ListFileActivityRequest) SetDriveId(v string) *ListFileActivityRequest {
  s.DriveId = &v
  return s
}

func (s *ListFileActivityRequest) SetFileId(v string) *ListFileActivityRequest {
  s.FileId = &v
  return s
}

func (s *ListFileActivityRequest) SetLimit(v int32) *ListFileActivityRequest {
  s.Limit = &v
  return s
}

func (s *ListFileActivityRequest) SetMarker(v string) *ListFileActivityRequest {
  s.Marker = &v
  return s
}

/**
 * list file activity response
 */
type ListFileActivityResponse struct {
  // Activities
  Activities []*FileActivity `json:"activities,omitempty" xml:"activities,omitempty" type:"Repeated"`
  // NextMarker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListFileActivityResponse) String() string {
  return tea.Prettify(s)
}

func (s ListFileActivityResponse) GoString() string {
  return s.String()
}

func (s *ListFileActivityResponse) SetActivities(v []*FileActivity) *ListFileActivityResponse {
  s.Activities = v
  return s
}

func (s *ListFileActivityResponse) SetNextMarker(v string) *ListFileActivityResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type ListFileByCustomIndexKeyRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // starred
  Starred *bool `json:"Starred,omitempty" xml:"Starred,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // custom_index_key
  CustomIndexKey *string `json:"custom_index_key,omitempty" xml:"custom_index_key,omitempty" require:"true"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // fields
  Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // order_direction
  OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileByCustomIndexKeyRequest) String() string {
  return tea.Prettify(s)
}

func (s ListFileByCustomIndexKeyRequest) GoString() string {
  return s.String()
}

func (s *ListFileByCustomIndexKeyRequest) SetHeaders(v map[string]*string) *ListFileByCustomIndexKeyRequest {
  s.Headers = v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetStarred(v bool) *ListFileByCustomIndexKeyRequest {
  s.Starred = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetAdditionData(v map[string]interface{}) *ListFileByCustomIndexKeyRequest {
  s.AdditionData = v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetCategory(v string) *ListFileByCustomIndexKeyRequest {
  s.Category = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetCustomIndexKey(v string) *ListFileByCustomIndexKeyRequest {
  s.CustomIndexKey = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetDriveId(v string) *ListFileByCustomIndexKeyRequest {
  s.DriveId = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetEncryptMode(v string) *ListFileByCustomIndexKeyRequest {
  s.EncryptMode = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetFields(v string) *ListFileByCustomIndexKeyRequest {
  s.Fields = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageCroppingAspectRatios(v []*string) *ListFileByCustomIndexKeyRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageUrlProcess(v string) *ListFileByCustomIndexKeyRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetLimit(v int64) *ListFileByCustomIndexKeyRequest {
  s.Limit = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetMarker(v string) *ListFileByCustomIndexKeyRequest {
  s.Marker = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetOfficeThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetOrderDirection(v string) *ListFileByCustomIndexKeyRequest {
  s.OrderDirection = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetReferer(v string) *ListFileByCustomIndexKeyRequest {
  s.Referer = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetShareId(v string) *ListFileByCustomIndexKeyRequest {
  s.ShareId = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetSignToken(v string) *ListFileByCustomIndexKeyRequest {
  s.SignToken = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetStatus(v string) *ListFileByCustomIndexKeyRequest {
  s.Status = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetType(v string) *ListFileByCustomIndexKeyRequest {
  s.Type = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetUrlExpireSec(v int64) *ListFileByCustomIndexKeyRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *ListFileByCustomIndexKeyRequest) SetVideoThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type ListFileDeltaRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // cursor 
  Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  // default 100
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileDeltaRequest) String() string {
  return tea.Prettify(s)
}

func (s ListFileDeltaRequest) GoString() string {
  return s.String()
}

func (s *ListFileDeltaRequest) SetHeaders(v map[string]*string) *ListFileDeltaRequest {
  s.Headers = v
  return s
}

func (s *ListFileDeltaRequest) SetCursor(v string) *ListFileDeltaRequest {
  s.Cursor = &v
  return s
}

func (s *ListFileDeltaRequest) SetDriveId(v string) *ListFileDeltaRequest {
  s.DriveId = &v
  return s
}

func (s *ListFileDeltaRequest) SetImageCroppingAspectRatios(v []*string) *ListFileDeltaRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *ListFileDeltaRequest) SetImageThumbnailProcess(v string) *ListFileDeltaRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListFileDeltaRequest) SetImageUrlProcess(v string) *ListFileDeltaRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ListFileDeltaRequest) SetLimit(v int32) *ListFileDeltaRequest {
  s.Limit = &v
  return s
}

func (s *ListFileDeltaRequest) SetOfficeThumbnailProcess(v string) *ListFileDeltaRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ListFileDeltaRequest) SetVideoThumbnailProcess(v string) *ListFileDeltaRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * list file op response
 */
type ListFileDeltaResponse struct {
  // cursor
  Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
  // has_more
  HasMore *bool `json:"has_more,omitempty" xml:"has_more,omitempty"`
  // items
  Items []*FileDeltaResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListFileDeltaResponse) String() string {
  return tea.Prettify(s)
}

func (s ListFileDeltaResponse) GoString() string {
  return s.String()
}

func (s *ListFileDeltaResponse) SetCursor(v string) *ListFileDeltaResponse {
  s.Cursor = &v
  return s
}

func (s *ListFileDeltaResponse) SetHasMore(v bool) *ListFileDeltaResponse {
  s.HasMore = &v
  return s
}

func (s *ListFileDeltaResponse) SetItems(v []*FileDeltaResponse) *ListFileDeltaResponse {
  s.Items = v
  return s
}

/**
 * 
 */
type ListFileInRecycleBinRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // starred
  Starred *bool `json:"Starred,omitempty" xml:"Starred,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // all
  All *bool `json:"all,omitempty" xml:"all,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // fields
  Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // order_by
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
  // order_direction
  OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
  // ParentFileID
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileInRecycleBinRequest) String() string {
  return tea.Prettify(s)
}

func (s ListFileInRecycleBinRequest) GoString() string {
  return s.String()
}

func (s *ListFileInRecycleBinRequest) SetHeaders(v map[string]*string) *ListFileInRecycleBinRequest {
  s.Headers = v
  return s
}

func (s *ListFileInRecycleBinRequest) SetStarred(v bool) *ListFileInRecycleBinRequest {
  s.Starred = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetAdditionData(v map[string]interface{}) *ListFileInRecycleBinRequest {
  s.AdditionData = v
  return s
}

func (s *ListFileInRecycleBinRequest) SetAll(v bool) *ListFileInRecycleBinRequest {
  s.All = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetCategory(v string) *ListFileInRecycleBinRequest {
  s.Category = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetDriveId(v string) *ListFileInRecycleBinRequest {
  s.DriveId = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetFields(v string) *ListFileInRecycleBinRequest {
  s.Fields = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetImageCroppingAspectRatios(v []*string) *ListFileInRecycleBinRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *ListFileInRecycleBinRequest) SetImageThumbnailProcess(v string) *ListFileInRecycleBinRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetImageUrlProcess(v string) *ListFileInRecycleBinRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetLimit(v int64) *ListFileInRecycleBinRequest {
  s.Limit = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetMarker(v string) *ListFileInRecycleBinRequest {
  s.Marker = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetOfficeThumbnailProcess(v string) *ListFileInRecycleBinRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetOrderBy(v string) *ListFileInRecycleBinRequest {
  s.OrderBy = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetOrderDirection(v string) *ListFileInRecycleBinRequest {
  s.OrderDirection = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetParentFileId(v string) *ListFileInRecycleBinRequest {
  s.ParentFileId = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetReferer(v string) *ListFileInRecycleBinRequest {
  s.Referer = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetShareId(v string) *ListFileInRecycleBinRequest {
  s.ShareId = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetSignToken(v string) *ListFileInRecycleBinRequest {
  s.SignToken = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetStatus(v string) *ListFileInRecycleBinRequest {
  s.Status = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetType(v string) *ListFileInRecycleBinRequest {
  s.Type = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetUrlExpireSec(v int64) *ListFileInRecycleBinRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *ListFileInRecycleBinRequest) SetVideoThumbnailProcess(v string) *ListFileInRecycleBinRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * ListFileInRecycleBinResponse
 */
type ListFileInRecycleBinResponse struct {
  // items
  Items []*RecycleBinItemResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListFileInRecycleBinResponse) String() string {
  return tea.Prettify(s)
}

func (s ListFileInRecycleBinResponse) GoString() string {
  return s.String()
}

func (s *ListFileInRecycleBinResponse) SetItems(v []*RecycleBinItemResponse) *ListFileInRecycleBinResponse {
  s.Items = v
  return s
}

func (s *ListFileInRecycleBinResponse) SetNextMarker(v string) *ListFileInRecycleBinResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type ListFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // all
  All *bool `json:"all,omitempty" xml:"all,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // fields
  Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // order_by
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
  // order_direction
  OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
  // ParentFileID
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
  ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // starred
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileRequest) String() string {
  return tea.Prettify(s)
}

func (s ListFileRequest) GoString() string {
  return s.String()
}

func (s *ListFileRequest) SetHeaders(v map[string]*string) *ListFileRequest {
  s.Headers = v
  return s
}

func (s *ListFileRequest) SetAdditionData(v map[string]interface{}) *ListFileRequest {
  s.AdditionData = v
  return s
}

func (s *ListFileRequest) SetAll(v bool) *ListFileRequest {
  s.All = &v
  return s
}

func (s *ListFileRequest) SetCategory(v string) *ListFileRequest {
  s.Category = &v
  return s
}

func (s *ListFileRequest) SetDriveId(v string) *ListFileRequest {
  s.DriveId = &v
  return s
}

func (s *ListFileRequest) SetFields(v string) *ListFileRequest {
  s.Fields = &v
  return s
}

func (s *ListFileRequest) SetImageCroppingAspectRatios(v []*string) *ListFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *ListFileRequest) SetImageThumbnailProcess(v string) *ListFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListFileRequest) SetImageUrlProcess(v string) *ListFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ListFileRequest) SetLimit(v int64) *ListFileRequest {
  s.Limit = &v
  return s
}

func (s *ListFileRequest) SetLocation(v string) *ListFileRequest {
  s.Location = &v
  return s
}

func (s *ListFileRequest) SetMarker(v string) *ListFileRequest {
  s.Marker = &v
  return s
}

func (s *ListFileRequest) SetOfficeThumbnailProcess(v string) *ListFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ListFileRequest) SetOrderBy(v string) *ListFileRequest {
  s.OrderBy = &v
  return s
}

func (s *ListFileRequest) SetOrderDirection(v string) *ListFileRequest {
  s.OrderDirection = &v
  return s
}

func (s *ListFileRequest) SetParentFileId(v string) *ListFileRequest {
  s.ParentFileId = &v
  return s
}

func (s *ListFileRequest) SetParentFileIdPath(v string) *ListFileRequest {
  s.ParentFileIdPath = &v
  return s
}

func (s *ListFileRequest) SetReferer(v string) *ListFileRequest {
  s.Referer = &v
  return s
}

func (s *ListFileRequest) SetShareId(v string) *ListFileRequest {
  s.ShareId = &v
  return s
}

func (s *ListFileRequest) SetSignToken(v string) *ListFileRequest {
  s.SignToken = &v
  return s
}

func (s *ListFileRequest) SetStarred(v bool) *ListFileRequest {
  s.Starred = &v
  return s
}

func (s *ListFileRequest) SetStatus(v string) *ListFileRequest {
  s.Status = &v
  return s
}

func (s *ListFileRequest) SetType(v string) *ListFileRequest {
  s.Type = &v
  return s
}

func (s *ListFileRequest) SetUrlExpireSec(v int64) *ListFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *ListFileRequest) SetVideoThumbnailProcess(v string) *ListFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * List file response
 */
type ListFileResponse struct {
  // items
  Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListFileResponse) String() string {
  return tea.Prettify(s)
}

func (s ListFileResponse) GoString() string {
  return s.String()
}

func (s *ListFileResponse) SetItems(v []*BaseCCPFileResponse) *ListFileResponse {
  s.Items = v
  return s
}

func (s *ListFileResponse) SetNextMarker(v string) *ListFileResponse {
  s.NextMarker = &v
  return s
}

/**
 * List identity benefit package request
 */
type ListIdentityBenefitPkgRequest struct {
  // benefit IDinclude_benefittrue benefit ID
  BenefitIdList []*string `json:"benefit_id_list,omitempty" xml:"benefit_id_list,omitempty" type:"Repeated"`
  // domain ID AKidentity_typeuser
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // user
  IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
  // false
  IncludeBenefit *bool `json:"include_benefit,omitempty" xml:"include_benefit,omitempty"`
  // false
  IncludeExpired *bool `json:"include_expired,omitempty" xml:"include_expired,omitempty"`
  //  ID, AKidentity_typeuser
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s ListIdentityBenefitPkgRequest) String() string {
  return tea.Prettify(s)
}

func (s ListIdentityBenefitPkgRequest) GoString() string {
  return s.String()
}

func (s *ListIdentityBenefitPkgRequest) SetBenefitIdList(v []*string) *ListIdentityBenefitPkgRequest {
  s.BenefitIdList = v
  return s
}

func (s *ListIdentityBenefitPkgRequest) SetDomainId(v string) *ListIdentityBenefitPkgRequest {
  s.DomainId = &v
  return s
}

func (s *ListIdentityBenefitPkgRequest) SetIdentityType(v string) *ListIdentityBenefitPkgRequest {
  s.IdentityType = &v
  return s
}

func (s *ListIdentityBenefitPkgRequest) SetIncludeBenefit(v bool) *ListIdentityBenefitPkgRequest {
  s.IncludeBenefit = &v
  return s
}

func (s *ListIdentityBenefitPkgRequest) SetIncludeExpired(v bool) *ListIdentityBenefitPkgRequest {
  s.IncludeExpired = &v
  return s
}

func (s *ListIdentityBenefitPkgRequest) SetUserId(v string) *ListIdentityBenefitPkgRequest {
  s.UserId = &v
  return s
}

/**
 * List my drive request
 */
type ListMyDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // , 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListMyDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s ListMyDriveRequest) GoString() string {
  return s.String()
}

func (s *ListMyDriveRequest) SetHeaders(v map[string]*string) *ListMyDriveRequest {
  s.Headers = v
  return s
}

func (s *ListMyDriveRequest) SetLimit(v int32) *ListMyDriveRequest {
  s.Limit = &v
  return s
}

func (s *ListMyDriveRequest) SetMarker(v string) *ListMyDriveRequest {
  s.Marker = &v
  return s
}

/**
 * list_share_link request
 */
type ListShareLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // include_cancelled
  IncludeCancelled *bool `json:"include_cancelled,omitempty" xml:"include_cancelled,omitempty"`
  // limit
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // order_by
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
  // order_direction
  OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
}

func (s ListShareLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s ListShareLinkRequest) GoString() string {
  return s.String()
}

func (s *ListShareLinkRequest) SetHeaders(v map[string]*string) *ListShareLinkRequest {
  s.Headers = v
  return s
}

func (s *ListShareLinkRequest) SetCreator(v string) *ListShareLinkRequest {
  s.Creator = &v
  return s
}

func (s *ListShareLinkRequest) SetIncludeCancelled(v bool) *ListShareLinkRequest {
  s.IncludeCancelled = &v
  return s
}

func (s *ListShareLinkRequest) SetLimit(v int32) *ListShareLinkRequest {
  s.Limit = &v
  return s
}

func (s *ListShareLinkRequest) SetMarker(v string) *ListShareLinkRequest {
  s.Marker = &v
  return s
}

func (s *ListShareLinkRequest) SetOrderBy(v string) *ListShareLinkRequest {
  s.OrderBy = &v
  return s
}

func (s *ListShareLinkRequest) SetOrderDirection(v string) *ListShareLinkRequest {
  s.OrderDirection = &v
  return s
}

/**
 * list_share_link response
 */
type ListShareLinkResponse struct {
  // items
  Items []*BaseShareLinkResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListShareLinkResponse) String() string {
  return tea.Prettify(s)
}

func (s ListShareLinkResponse) GoString() string {
  return s.String()
}

func (s *ListShareLinkResponse) SetItems(v []*BaseShareLinkResponse) *ListShareLinkResponse {
  s.Items = v
  return s
}

func (s *ListShareLinkResponse) SetNextMarker(v string) *ListShareLinkResponse {
  s.NextMarker = &v
  return s
}

/**
 * list share request
 */
type ListShareRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // limit
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // Owner
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // owner_type
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // share_file_path
  ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
}

func (s ListShareRequest) String() string {
  return tea.Prettify(s)
}

func (s ListShareRequest) GoString() string {
  return s.String()
}

func (s *ListShareRequest) SetHeaders(v map[string]*string) *ListShareRequest {
  s.Headers = v
  return s
}

func (s *ListShareRequest) SetCreator(v string) *ListShareRequest {
  s.Creator = &v
  return s
}

func (s *ListShareRequest) SetDriveId(v string) *ListShareRequest {
  s.DriveId = &v
  return s
}

func (s *ListShareRequest) SetLimit(v int32) *ListShareRequest {
  s.Limit = &v
  return s
}

func (s *ListShareRequest) SetMarker(v string) *ListShareRequest {
  s.Marker = &v
  return s
}

func (s *ListShareRequest) SetOwner(v string) *ListShareRequest {
  s.Owner = &v
  return s
}

func (s *ListShareRequest) SetOwnerType(v string) *ListShareRequest {
  s.OwnerType = &v
  return s
}

func (s *ListShareRequest) SetShareFilePath(v string) *ListShareRequest {
  s.ShareFilePath = &v
  return s
}

/**
 * List share response
 */
type ListShareResponse struct {
  // items
  Items []*BaseShareResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListShareResponse) String() string {
  return tea.Prettify(s)
}

func (s ListShareResponse) GoString() string {
  return s.String()
}

func (s *ListShareResponse) SetItems(v []*BaseShareResponse) *ListShareResponse {
  s.Items = v
  return s
}

func (s *ListShareResponse) SetNextMarker(v string) *ListShareResponse {
  s.NextMarker = &v
  return s
}

/**
 * list store file
 */
type ListStoreFileRequest struct {
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // parent_file_path
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty"`
  // store_id
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListStoreFileRequest) String() string {
  return tea.Prettify(s)
}

func (s ListStoreFileRequest) GoString() string {
  return s.String()
}

func (s *ListStoreFileRequest) SetLimit(v int64) *ListStoreFileRequest {
  s.Limit = &v
  return s
}

func (s *ListStoreFileRequest) SetMarker(v string) *ListStoreFileRequest {
  s.Marker = &v
  return s
}

func (s *ListStoreFileRequest) SetParentFilePath(v string) *ListStoreFileRequest {
  s.ParentFilePath = &v
  return s
}

func (s *ListStoreFileRequest) SetStoreId(v string) *ListStoreFileRequest {
  s.StoreId = &v
  return s
}

func (s *ListStoreFileRequest) SetType(v string) *ListStoreFileRequest {
  s.Type = &v
  return s
}

/**
 * List storage file
 */
type ListStoreFileResponse struct {
  // items
  // file list
  Items []*StoreFile `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListStoreFileResponse) String() string {
  return tea.Prettify(s)
}

func (s ListStoreFileResponse) GoString() string {
  return s.String()
}

func (s *ListStoreFileResponse) SetItems(v []*StoreFile) *ListStoreFileResponse {
  s.Items = v
  return s
}

func (s *ListStoreFileResponse) SetNextMarker(v string) *ListStoreFileResponse {
  s.NextMarker = &v
  return s
}

/**
 * list storage file
 */
type ListStoreRequest struct {
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
}

func (s ListStoreRequest) String() string {
  return tea.Prettify(s)
}

func (s ListStoreRequest) GoString() string {
  return s.String()
}

func (s *ListStoreRequest) SetDomainId(v string) *ListStoreRequest {
  s.DomainId = &v
  return s
}

/**
 * List storage
 */
type ListStoreResponse struct {
  // items
  Items []*StoreItemResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListStoreResponse) String() string {
  return tea.Prettify(s)
}

func (s ListStoreResponse) GoString() string {
  return s.String()
}

func (s *ListStoreResponse) SetItems(v []*StoreItemResponse) *ListStoreResponse {
  s.Items = v
  return s
}

/**
 * 
 */
type ListStoresRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s ListStoresRequest) String() string {
  return tea.Prettify(s)
}

func (s ListStoresRequest) GoString() string {
  return s.String()
}

func (s *ListStoresRequest) SetDomainId(v string) *ListStoresRequest {
  s.DomainId = &v
  return s
}

/**
 * uploadID
 */
type ListUploadedPartRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
  // part_number_marker
  PartNumberMarker *int64 `json:"part_number_marker,omitempty" xml:"part_number_marker,omitempty" minimum:"1"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s ListUploadedPartRequest) String() string {
  return tea.Prettify(s)
}

func (s ListUploadedPartRequest) GoString() string {
  return s.String()
}

func (s *ListUploadedPartRequest) SetHeaders(v map[string]*string) *ListUploadedPartRequest {
  s.Headers = v
  return s
}

func (s *ListUploadedPartRequest) SetDriveId(v string) *ListUploadedPartRequest {
  s.DriveId = &v
  return s
}

func (s *ListUploadedPartRequest) SetFileId(v string) *ListUploadedPartRequest {
  s.FileId = &v
  return s
}

func (s *ListUploadedPartRequest) SetFileIdPath(v string) *ListUploadedPartRequest {
  s.FileIdPath = &v
  return s
}

func (s *ListUploadedPartRequest) SetLimit(v int64) *ListUploadedPartRequest {
  s.Limit = &v
  return s
}

func (s *ListUploadedPartRequest) SetPartNumberMarker(v int64) *ListUploadedPartRequest {
  s.PartNumberMarker = &v
  return s
}

func (s *ListUploadedPartRequest) SetShareId(v string) *ListUploadedPartRequest {
  s.ShareId = &v
  return s
}

func (s *ListUploadedPartRequest) SetUploadId(v string) *ListUploadedPartRequest {
  s.UploadId = &v
  return s
}

/**
 *  response
 */
type ListUploadedPartResponse struct {
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // next_part_number_marker
  NextPartNumberMarker *string `json:"next_part_number_marker,omitempty" xml:"next_part_number_marker,omitempty"`
  ParallelUpload *bool `json:"parallel_upload,omitempty" xml:"parallel_upload,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // uploaded_parts
  UploadedParts []*UploadPartInfo `json:"uploaded_parts,omitempty" xml:"uploaded_parts,omitempty" type:"Repeated"`
}

func (s ListUploadedPartResponse) String() string {
  return tea.Prettify(s)
}

func (s ListUploadedPartResponse) GoString() string {
  return s.String()
}

func (s *ListUploadedPartResponse) SetFileId(v string) *ListUploadedPartResponse {
  s.FileId = &v
  return s
}

func (s *ListUploadedPartResponse) SetNextPartNumberMarker(v string) *ListUploadedPartResponse {
  s.NextPartNumberMarker = &v
  return s
}

func (s *ListUploadedPartResponse) SetParallelUpload(v bool) *ListUploadedPartResponse {
  s.ParallelUpload = &v
  return s
}

func (s *ListUploadedPartResponse) SetUploadId(v string) *ListUploadedPartResponse {
  s.UploadId = &v
  return s
}

func (s *ListUploadedPartResponse) SetUploadedParts(v []*UploadPartInfo) *ListUploadedPartResponse {
  s.UploadedParts = v
  return s
}

/**
 * task
 */
type LiveTranscodingTaskResponse struct {
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s LiveTranscodingTaskResponse) String() string {
  return tea.Prettify(s)
}

func (s LiveTranscodingTaskResponse) GoString() string {
  return s.String()
}

func (s *LiveTranscodingTaskResponse) SetStatus(v string) *LiveTranscodingTaskResponse {
  s.Status = &v
  return s
}

func (s *LiveTranscodingTaskResponse) SetTemplateId(v string) *LiveTranscodingTaskResponse {
  s.TemplateId = &v
  return s
}

func (s *LiveTranscodingTaskResponse) SetUrl(v string) *LiveTranscodingTaskResponse {
  s.Url = &v
  return s
}

/**
 * 
 */
type LoginByCodeRequest struct {
  // accessToken
  AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // AuthCode
  AuthCode *string `json:"auth_code,omitempty" xml:"auth_code,omitempty"`
  // 
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s LoginByCodeRequest) String() string {
  return tea.Prettify(s)
}

func (s LoginByCodeRequest) GoString() string {
  return s.String()
}

func (s *LoginByCodeRequest) SetAccessToken(v string) *LoginByCodeRequest {
  s.AccessToken = &v
  return s
}

func (s *LoginByCodeRequest) SetAppId(v string) *LoginByCodeRequest {
  s.AppId = &v
  return s
}

func (s *LoginByCodeRequest) SetAuthCode(v string) *LoginByCodeRequest {
  s.AuthCode = &v
  return s
}

func (s *LoginByCodeRequest) SetType(v string) *LoginByCodeRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type LogoutRequest struct {
  // App
  BackUrl *string `json:"BackUrl,omitempty" xml:"BackUrl,omitempty"`
  // Client ID, AppAppID
  ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
  // callback
  LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
}

func (s LogoutRequest) String() string {
  return tea.Prettify(s)
}

func (s LogoutRequest) GoString() string {
  return s.String()
}

func (s *LogoutRequest) SetBackUrl(v string) *LogoutRequest {
  s.BackUrl = &v
  return s
}

func (s *LogoutRequest) SetClientID(v string) *LogoutRequest {
  s.ClientID = &v
  return s
}

func (s *LogoutRequest) SetLoginType(v string) *LogoutRequest {
  s.LoginType = &v
  return s
}

/**
 * 
 */
type MediaPlayInfoTemplate struct {
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s MediaPlayInfoTemplate) String() string {
  return tea.Prettify(s)
}

func (s MediaPlayInfoTemplate) GoString() string {
  return s.String()
}

func (s *MediaPlayInfoTemplate) SetStatus(v string) *MediaPlayInfoTemplate {
  s.Status = &v
  return s
}

func (s *MediaPlayInfoTemplate) SetTemplateId(v string) *MediaPlayInfoTemplate {
  s.TemplateId = &v
  return s
}

func (s *MediaPlayInfoTemplate) SetUrl(v string) *MediaPlayInfoTemplate {
  s.Url = &v
  return s
}

/**
 * 
 */
type MobileCheckExistRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
}

func (s MobileCheckExistRequest) String() string {
  return tea.Prettify(s)
}

func (s MobileCheckExistRequest) GoString() string {
  return s.String()
}

func (s *MobileCheckExistRequest) SetHeaders(v map[string]*string) *MobileCheckExistRequest {
  s.Headers = v
  return s
}

func (s *MobileCheckExistRequest) SetAppId(v string) *MobileCheckExistRequest {
  s.AppId = &v
  return s
}

func (s *MobileCheckExistRequest) SetPhoneNumber(v string) *MobileCheckExistRequest {
  s.PhoneNumber = &v
  return s
}

func (s *MobileCheckExistRequest) SetPhoneRegion(v string) *MobileCheckExistRequest {
  s.PhoneRegion = &v
  return s
}

/**
 * 
 */
type MobileCheckExistResponse struct {
  // 
  IsExist *bool `json:"is_exist,omitempty" xml:"is_exist,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
}

func (s MobileCheckExistResponse) String() string {
  return tea.Prettify(s)
}

func (s MobileCheckExistResponse) GoString() string {
  return s.String()
}

func (s *MobileCheckExistResponse) SetIsExist(v bool) *MobileCheckExistResponse {
  s.IsExist = &v
  return s
}

func (s *MobileCheckExistResponse) SetPhoneNumber(v string) *MobileCheckExistResponse {
  s.PhoneNumber = &v
  return s
}

func (s *MobileCheckExistResponse) SetPhoneRegion(v string) *MobileCheckExistResponse {
  s.PhoneRegion = &v
  return s
}

/**
 * 
 */
type MobileLoginRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // 
  AutoRegister *bool `json:"auto_register,omitempty" xml:"auto_register,omitempty"`
  // ID, 
  CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty"`
  // , 
  CaptchaText *string `json:"captcha_text,omitempty" xml:"captcha_text,omitempty"`
  // AES-256App
  EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty"`
  // 
  NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
  // , 
  Password *string `json:"password,omitempty" xml:"password,omitempty"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  // 
  SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty"`
  // ID
  SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty"`
}

func (s MobileLoginRequest) String() string {
  return tea.Prettify(s)
}

func (s MobileLoginRequest) GoString() string {
  return s.String()
}

func (s *MobileLoginRequest) SetHeaders(v map[string]*string) *MobileLoginRequest {
  s.Headers = v
  return s
}

func (s *MobileLoginRequest) SetAppId(v string) *MobileLoginRequest {
  s.AppId = &v
  return s
}

func (s *MobileLoginRequest) SetAutoRegister(v bool) *MobileLoginRequest {
  s.AutoRegister = &v
  return s
}

func (s *MobileLoginRequest) SetCaptchaId(v string) *MobileLoginRequest {
  s.CaptchaId = &v
  return s
}

func (s *MobileLoginRequest) SetCaptchaText(v string) *MobileLoginRequest {
  s.CaptchaText = &v
  return s
}

func (s *MobileLoginRequest) SetEncryptedKey(v string) *MobileLoginRequest {
  s.EncryptedKey = &v
  return s
}

func (s *MobileLoginRequest) SetNvcParam(v string) *MobileLoginRequest {
  s.NvcParam = &v
  return s
}

func (s *MobileLoginRequest) SetPassword(v string) *MobileLoginRequest {
  s.Password = &v
  return s
}

func (s *MobileLoginRequest) SetPhoneNumber(v string) *MobileLoginRequest {
  s.PhoneNumber = &v
  return s
}

func (s *MobileLoginRequest) SetPhoneRegion(v string) *MobileLoginRequest {
  s.PhoneRegion = &v
  return s
}

func (s *MobileLoginRequest) SetSmsCode(v string) *MobileLoginRequest {
  s.SmsCode = &v
  return s
}

func (s *MobileLoginRequest) SetSmsCodeId(v string) *MobileLoginRequest {
  s.SmsCodeId = &v
  return s
}

/**
 * 
 */
type MobileRegisterRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // 
  NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  // 
  SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty" require:"true"`
  // ID
  SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
}

func (s MobileRegisterRequest) String() string {
  return tea.Prettify(s)
}

func (s MobileRegisterRequest) GoString() string {
  return s.String()
}

func (s *MobileRegisterRequest) SetHeaders(v map[string]*string) *MobileRegisterRequest {
  s.Headers = v
  return s
}

func (s *MobileRegisterRequest) SetAppId(v string) *MobileRegisterRequest {
  s.AppId = &v
  return s
}

func (s *MobileRegisterRequest) SetNvcParam(v string) *MobileRegisterRequest {
  s.NvcParam = &v
  return s
}

func (s *MobileRegisterRequest) SetPhoneNumber(v string) *MobileRegisterRequest {
  s.PhoneNumber = &v
  return s
}

func (s *MobileRegisterRequest) SetPhoneRegion(v string) *MobileRegisterRequest {
  s.PhoneRegion = &v
  return s
}

func (s *MobileRegisterRequest) SetSmsCode(v string) *MobileRegisterRequest {
  s.SmsCode = &v
  return s
}

func (s *MobileRegisterRequest) SetSmsCodeId(v string) *MobileRegisterRequest {
  s.SmsCodeId = &v
  return s
}

/**
 * 
 */
type MobileSendSmsCodeRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // ID
  CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty"`
  // 
  CaptchaText *string `json:"captcha_text,omitempty" xml:"captcha_text,omitempty"`
  // 
  NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  // , : loginregisterchange_password
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s MobileSendSmsCodeRequest) String() string {
  return tea.Prettify(s)
}

func (s MobileSendSmsCodeRequest) GoString() string {
  return s.String()
}

func (s *MobileSendSmsCodeRequest) SetHeaders(v map[string]*string) *MobileSendSmsCodeRequest {
  s.Headers = v
  return s
}

func (s *MobileSendSmsCodeRequest) SetAppId(v string) *MobileSendSmsCodeRequest {
  s.AppId = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetCaptchaId(v string) *MobileSendSmsCodeRequest {
  s.CaptchaId = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetCaptchaText(v string) *MobileSendSmsCodeRequest {
  s.CaptchaText = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetNvcParam(v string) *MobileSendSmsCodeRequest {
  s.NvcParam = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetPhoneNumber(v string) *MobileSendSmsCodeRequest {
  s.PhoneNumber = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetPhoneRegion(v string) *MobileSendSmsCodeRequest {
  s.PhoneRegion = &v
  return s
}

func (s *MobileSendSmsCodeRequest) SetType(v string) *MobileSendSmsCodeRequest {
  s.Type = &v
  return s
}

/**
 * 
 */
type MobileSendSmsCodeResponse struct {
  // ID
  SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
}

func (s MobileSendSmsCodeResponse) String() string {
  return tea.Prettify(s)
}

func (s MobileSendSmsCodeResponse) GoString() string {
  return s.String()
}

func (s *MobileSendSmsCodeResponse) SetSmsCodeId(v string) *MobileSendSmsCodeResponse {
  s.SmsCodeId = &v
  return s
}

/**
 * 
 */
type MoveDetail struct {
  // SrcParentFileID
  SrcParentFileId *string `json:"src_parent_file_id,omitempty" xml:"src_parent_file_id,omitempty"`
  // TgtParentFileID
  TgtParentFileId *string `json:"tgt_parent_file_id,omitempty" xml:"tgt_parent_file_id,omitempty"`
}

func (s MoveDetail) String() string {
  return tea.Prettify(s)
}

func (s MoveDetail) GoString() string {
  return s.String()
}

func (s *MoveDetail) SetSrcParentFileId(v string) *MoveDetail {
  s.SrcParentFileId = &v
  return s
}

func (s *MoveDetail) SetTgtParentFileId(v string) *MoveDetail {
  s.TgtParentFileId = &v
  return s
}

/**
 * 
 */
type MoveFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  AutoRename *bool `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
  CategoryList []*string `json:"category_list,omitempty" xml:"category_list,omitempty" type:"Repeated"`
  // check_name_mode
  CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // new_name
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // to_drive_id
  ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
  // to_parent_file_id
  ToParentFileId *string `json:"to_parent_file_id,omitempty" xml:"to_parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4"`
  ToShareId *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty" pattern:"[0-9]+"`
}

func (s MoveFileRequest) String() string {
  return tea.Prettify(s)
}

func (s MoveFileRequest) GoString() string {
  return s.String()
}

func (s *MoveFileRequest) SetHeaders(v map[string]*string) *MoveFileRequest {
  s.Headers = v
  return s
}

func (s *MoveFileRequest) SetAutoRename(v bool) *MoveFileRequest {
  s.AutoRename = &v
  return s
}

func (s *MoveFileRequest) SetCategoryList(v []*string) *MoveFileRequest {
  s.CategoryList = v
  return s
}

func (s *MoveFileRequest) SetCheckNameMode(v string) *MoveFileRequest {
  s.CheckNameMode = &v
  return s
}

func (s *MoveFileRequest) SetDriveId(v string) *MoveFileRequest {
  s.DriveId = &v
  return s
}

func (s *MoveFileRequest) SetFileId(v string) *MoveFileRequest {
  s.FileId = &v
  return s
}

func (s *MoveFileRequest) SetFileIdPath(v string) *MoveFileRequest {
  s.FileIdPath = &v
  return s
}

func (s *MoveFileRequest) SetNewName(v string) *MoveFileRequest {
  s.NewName = &v
  return s
}

func (s *MoveFileRequest) SetShareId(v string) *MoveFileRequest {
  s.ShareId = &v
  return s
}

func (s *MoveFileRequest) SetToDriveId(v string) *MoveFileRequest {
  s.ToDriveId = &v
  return s
}

func (s *MoveFileRequest) SetToParentFileId(v string) *MoveFileRequest {
  s.ToParentFileId = &v
  return s
}

func (s *MoveFileRequest) SetToShareId(v string) *MoveFileRequest {
  s.ToShareId = &v
  return s
}

/**
 *  response
 */
type MoveFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // exist
  // type: boolean
  Exist *bool `json:"exist,omitempty" xml:"exist,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s MoveFileResponse) String() string {
  return tea.Prettify(s)
}

func (s MoveFileResponse) GoString() string {
  return s.String()
}

func (s *MoveFileResponse) SetAsyncTaskId(v string) *MoveFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *MoveFileResponse) SetDomainId(v string) *MoveFileResponse {
  s.DomainId = &v
  return s
}

func (s *MoveFileResponse) SetDriveId(v string) *MoveFileResponse {
  s.DriveId = &v
  return s
}

func (s *MoveFileResponse) SetExist(v bool) *MoveFileResponse {
  s.Exist = &v
  return s
}

func (s *MoveFileResponse) SetFileId(v string) *MoveFileResponse {
  s.FileId = &v
  return s
}

/**
 * play_media request
 */
type PlayMediaRequest struct {
  // auth_key
  AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty" require:"true" pattern:"[a-z0-9]+"`
  // drive_id
  DriveID *string `json:"DriveID,omitempty" xml:"DriveID,omitempty" require:"true" pattern:"[0-9]+"`
  // file_id
  FileID *string `json:"FileID,omitempty" xml:"FileID,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
}

func (s PlayMediaRequest) String() string {
  return tea.Prettify(s)
}

func (s PlayMediaRequest) GoString() string {
  return s.String()
}

func (s *PlayMediaRequest) SetAuthKey(v string) *PlayMediaRequest {
  s.AuthKey = &v
  return s
}

func (s *PlayMediaRequest) SetDriveID(v string) *PlayMediaRequest {
  s.DriveID = &v
  return s
}

func (s *PlayMediaRequest) SetFileID(v string) *PlayMediaRequest {
  s.FileID = &v
  return s
}

/**
 * Pre hash check Response
 */
type PreHashCheckSuccessResponse struct {
  // code
  Code *string `json:"code,omitempty" xml:"code,omitempty"`
  // file_name
  FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
  // message
  Message *string `json:"message,omitempty" xml:"message,omitempty"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // pre_hash
  PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
}

func (s PreHashCheckSuccessResponse) String() string {
  return tea.Prettify(s)
}

func (s PreHashCheckSuccessResponse) GoString() string {
  return s.String()
}

func (s *PreHashCheckSuccessResponse) SetCode(v string) *PreHashCheckSuccessResponse {
  s.Code = &v
  return s
}

func (s *PreHashCheckSuccessResponse) SetFileName(v string) *PreHashCheckSuccessResponse {
  s.FileName = &v
  return s
}

func (s *PreHashCheckSuccessResponse) SetMessage(v string) *PreHashCheckSuccessResponse {
  s.Message = &v
  return s
}

func (s *PreHashCheckSuccessResponse) SetParentFileId(v string) *PreHashCheckSuccessResponse {
  s.ParentFileId = &v
  return s
}

func (s *PreHashCheckSuccessResponse) SetPreHash(v string) *PreHashCheckSuccessResponse {
  s.PreHash = &v
  return s
}

/**
 * 
 */
type RPVerifyTokenResponse struct {
  // false
  NeedRpVerify *bool `json:"need_rp_verify,omitempty" xml:"need_rp_verify,omitempty" require:"true"`
  VerifyToken *VerifyTokenResponse `json:"verify_token,omitempty" xml:"verify_token,omitempty" require:"true"`
}

func (s RPVerifyTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s RPVerifyTokenResponse) GoString() string {
  return s.String()
}

func (s *RPVerifyTokenResponse) SetNeedRpVerify(v bool) *RPVerifyTokenResponse {
  s.NeedRpVerify = &v
  return s
}

func (s *RPVerifyTokenResponse) SetVerifyToken(v *VerifyTokenResponse) *RPVerifyTokenResponse {
  s.VerifyToken = v
  return s
}

/**
 * 
 */
type RateLimit struct {
  PartSize *int64 `json:"part_size,omitempty" xml:"part_size,omitempty"`
  PartSpeed *int64 `json:"part_speed,omitempty" xml:"part_speed,omitempty"`
}

func (s RateLimit) String() string {
  return tea.Prettify(s)
}

func (s RateLimit) GoString() string {
  return s.String()
}

func (s *RateLimit) SetPartSize(v int64) *RateLimit {
  s.PartSize = &v
  return s
}

func (s *RateLimit) SetPartSpeed(v int64) *RateLimit {
  s.PartSpeed = &v
  return s
}

/**
 * Recycle bin item response
 */
type RecycleBinItemResponse struct {
  // auto_delete_left_sec
  AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // TODO APIfile_path_typeedmpath typePDS
  FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s RecycleBinItemResponse) String() string {
  return tea.Prettify(s)
}

func (s RecycleBinItemResponse) GoString() string {
  return s.String()
}

func (s *RecycleBinItemResponse) SetAutoDeleteLeftSec(v int64) *RecycleBinItemResponse {
  s.AutoDeleteLeftSec = &v
  return s
}

func (s *RecycleBinItemResponse) SetCategory(v string) *RecycleBinItemResponse {
  s.Category = &v
  return s
}

func (s *RecycleBinItemResponse) SetCharacteristicHash(v string) *RecycleBinItemResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *RecycleBinItemResponse) SetContentHash(v string) *RecycleBinItemResponse {
  s.ContentHash = &v
  return s
}

func (s *RecycleBinItemResponse) SetContentHashName(v string) *RecycleBinItemResponse {
  s.ContentHashName = &v
  return s
}

func (s *RecycleBinItemResponse) SetContentType(v string) *RecycleBinItemResponse {
  s.ContentType = &v
  return s
}

func (s *RecycleBinItemResponse) SetCrc64Hash(v string) *RecycleBinItemResponse {
  s.Crc64Hash = &v
  return s
}

func (s *RecycleBinItemResponse) SetCreatedAt(v string) *RecycleBinItemResponse {
  s.CreatedAt = &v
  return s
}

func (s *RecycleBinItemResponse) SetDescription(v string) *RecycleBinItemResponse {
  s.Description = &v
  return s
}

func (s *RecycleBinItemResponse) SetDomainId(v string) *RecycleBinItemResponse {
  s.DomainId = &v
  return s
}

func (s *RecycleBinItemResponse) SetDownloadUrl(v string) *RecycleBinItemResponse {
  s.DownloadUrl = &v
  return s
}

func (s *RecycleBinItemResponse) SetDriveId(v string) *RecycleBinItemResponse {
  s.DriveId = &v
  return s
}

func (s *RecycleBinItemResponse) SetEncryptMode(v string) *RecycleBinItemResponse {
  s.EncryptMode = &v
  return s
}

func (s *RecycleBinItemResponse) SetFileExtension(v string) *RecycleBinItemResponse {
  s.FileExtension = &v
  return s
}

func (s *RecycleBinItemResponse) SetFileId(v string) *RecycleBinItemResponse {
  s.FileId = &v
  return s
}

func (s *RecycleBinItemResponse) SetFilePathType(v string) *RecycleBinItemResponse {
  s.FilePathType = &v
  return s
}

func (s *RecycleBinItemResponse) SetHidden(v bool) *RecycleBinItemResponse {
  s.Hidden = &v
  return s
}

func (s *RecycleBinItemResponse) SetImageMediaMetadata(v *ImageMediaResponse) *RecycleBinItemResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *RecycleBinItemResponse) SetLabels(v []*string) *RecycleBinItemResponse {
  s.Labels = v
  return s
}

func (s *RecycleBinItemResponse) SetLastModifierId(v string) *RecycleBinItemResponse {
  s.LastModifierId = &v
  return s
}

func (s *RecycleBinItemResponse) SetLastModifierName(v string) *RecycleBinItemResponse {
  s.LastModifierName = &v
  return s
}

func (s *RecycleBinItemResponse) SetLastModifierType(v string) *RecycleBinItemResponse {
  s.LastModifierType = &v
  return s
}

func (s *RecycleBinItemResponse) SetMeta(v string) *RecycleBinItemResponse {
  s.Meta = &v
  return s
}

func (s *RecycleBinItemResponse) SetName(v string) *RecycleBinItemResponse {
  s.Name = &v
  return s
}

func (s *RecycleBinItemResponse) SetParentFileId(v string) *RecycleBinItemResponse {
  s.ParentFileId = &v
  return s
}

func (s *RecycleBinItemResponse) SetPunishFlag(v int64) *RecycleBinItemResponse {
  s.PunishFlag = &v
  return s
}

func (s *RecycleBinItemResponse) SetShareId(v string) *RecycleBinItemResponse {
  s.ShareId = &v
  return s
}

func (s *RecycleBinItemResponse) SetSize(v int64) *RecycleBinItemResponse {
  s.Size = &v
  return s
}

func (s *RecycleBinItemResponse) SetStarred(v bool) *RecycleBinItemResponse {
  s.Starred = &v
  return s
}

func (s *RecycleBinItemResponse) SetStatus(v string) *RecycleBinItemResponse {
  s.Status = &v
  return s
}

func (s *RecycleBinItemResponse) SetStreamsInfo(v map[string]interface{}) *RecycleBinItemResponse {
  s.StreamsInfo = v
  return s
}

func (s *RecycleBinItemResponse) SetThumbnail(v string) *RecycleBinItemResponse {
  s.Thumbnail = &v
  return s
}

func (s *RecycleBinItemResponse) SetTrashedAt(v string) *RecycleBinItemResponse {
  s.TrashedAt = &v
  return s
}

func (s *RecycleBinItemResponse) SetType(v string) *RecycleBinItemResponse {
  s.Type = &v
  return s
}

func (s *RecycleBinItemResponse) SetUpdatedAt(v string) *RecycleBinItemResponse {
  s.UpdatedAt = &v
  return s
}

func (s *RecycleBinItemResponse) SetUploadId(v string) *RecycleBinItemResponse {
  s.UploadId = &v
  return s
}

func (s *RecycleBinItemResponse) SetUrl(v string) *RecycleBinItemResponse {
  s.Url = &v
  return s
}

func (s *RecycleBinItemResponse) SetUserMeta(v string) *RecycleBinItemResponse {
  s.UserMeta = &v
  return s
}

func (s *RecycleBinItemResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *RecycleBinItemResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *RecycleBinItemResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *RecycleBinItemResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * office
 */
type RefreshOfficeEditTokenRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // AccessToken
  OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty" require:"true"`
  // RefreshToken
  OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty" require:"true"`
}

func (s RefreshOfficeEditTokenRequest) String() string {
  return tea.Prettify(s)
}

func (s RefreshOfficeEditTokenRequest) GoString() string {
  return s.String()
}

func (s *RefreshOfficeEditTokenRequest) SetHeaders(v map[string]*string) *RefreshOfficeEditTokenRequest {
  s.Headers = v
  return s
}

func (s *RefreshOfficeEditTokenRequest) SetAdditionData(v map[string]interface{}) *RefreshOfficeEditTokenRequest {
  s.AdditionData = v
  return s
}

func (s *RefreshOfficeEditTokenRequest) SetLocation(v string) *RefreshOfficeEditTokenRequest {
  s.Location = &v
  return s
}

func (s *RefreshOfficeEditTokenRequest) SetOfficeAccessToken(v string) *RefreshOfficeEditTokenRequest {
  s.OfficeAccessToken = &v
  return s
}

func (s *RefreshOfficeEditTokenRequest) SetOfficeRefreshToken(v string) *RefreshOfficeEditTokenRequest {
  s.OfficeRefreshToken = &v
  return s
}

/**
 * office response
 */
type RefreshOfficeEditTokenResponse struct {
  // AccessToken
  OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty"`
  // RefreshToken
  OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty"`
}

func (s RefreshOfficeEditTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s RefreshOfficeEditTokenResponse) GoString() string {
  return s.String()
}

func (s *RefreshOfficeEditTokenResponse) SetOfficeAccessToken(v string) *RefreshOfficeEditTokenResponse {
  s.OfficeAccessToken = &v
  return s
}

func (s *RefreshOfficeEditTokenResponse) SetOfficeRefreshToken(v string) *RefreshOfficeEditTokenResponse {
  s.OfficeRefreshToken = &v
  return s
}

/**
 * 
 */
type RemoveStoreRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // store ID
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
}

func (s RemoveStoreRequest) String() string {
  return tea.Prettify(s)
}

func (s RemoveStoreRequest) GoString() string {
  return s.String()
}

func (s *RemoveStoreRequest) SetDomainId(v string) *RemoveStoreRequest {
  s.DomainId = &v
  return s
}

func (s *RemoveStoreRequest) SetStoreId(v string) *RemoveStoreRequest {
  s.StoreId = &v
  return s
}

/**
 * 
 */
type RenameDetail struct {
  // NewName
  NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty"`
  // OldName
  OldName *string `json:"old_name,omitempty" xml:"old_name,omitempty"`
}

func (s RenameDetail) String() string {
  return tea.Prettify(s)
}

func (s RenameDetail) GoString() string {
  return s.String()
}

func (s *RenameDetail) SetNewName(v string) *RenameDetail {
  s.NewName = &v
  return s
}

func (s *RenameDetail) SetOldName(v string) *RenameDetail {
  s.OldName = &v
  return s
}

/**
 * report_event request
 */
type ReportEventRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // event_type
  EventType *string `json:"event_type,omitempty" xml:"event_type,omitempty"`
  ShareLink *ReportShareLinkEventRequest `json:"share_link,omitempty" xml:"share_link,omitempty"`
}

func (s ReportEventRequest) String() string {
  return tea.Prettify(s)
}

func (s ReportEventRequest) GoString() string {
  return s.String()
}

func (s *ReportEventRequest) SetHeaders(v map[string]*string) *ReportEventRequest {
  s.Headers = v
  return s
}

func (s *ReportEventRequest) SetEventType(v string) *ReportEventRequest {
  s.EventType = &v
  return s
}

func (s *ReportEventRequest) SetShareLink(v *ReportShareLinkEventRequest) *ReportEventRequest {
  s.ShareLink = v
  return s
}

/**
 * report_event operation response
 */
type ReportEventResponse struct {
}

func (s ReportEventResponse) String() string {
  return tea.Prettify(s)
}

func (s ReportEventResponse) GoString() string {
  return s.String()
}

/**
 * report_share_link_event request
 */
type ReportShareLinkEventRequest struct {
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // sub_type
  SubType *string `json:"sub_type,omitempty" xml:"sub_type,omitempty"`
}

func (s ReportShareLinkEventRequest) String() string {
  return tea.Prettify(s)
}

func (s ReportShareLinkEventRequest) GoString() string {
  return s.String()
}

func (s *ReportShareLinkEventRequest) SetShareId(v string) *ReportShareLinkEventRequest {
  s.ShareId = &v
  return s
}

func (s *ReportShareLinkEventRequest) SetSubType(v string) *ReportShareLinkEventRequest {
  s.SubType = &v
  return s
}

/**
 * 
 */
type RestoreDetail struct {
}

func (s RestoreDetail) String() string {
  return tea.Prettify(s)
}

func (s RestoreDetail) GoString() string {
  return s.String()
}

/**
 * 
 */
type RestoreFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s RestoreFileRequest) String() string {
  return tea.Prettify(s)
}

func (s RestoreFileRequest) GoString() string {
  return s.String()
}

func (s *RestoreFileRequest) SetHeaders(v map[string]*string) *RestoreFileRequest {
  s.Headers = v
  return s
}

func (s *RestoreFileRequest) SetDriveId(v string) *RestoreFileRequest {
  s.DriveId = &v
  return s
}

func (s *RestoreFileRequest) SetFileId(v string) *RestoreFileRequest {
  s.FileId = &v
  return s
}

/**
 * response
 */
type RestoreFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s RestoreFileResponse) String() string {
  return tea.Prettify(s)
}

func (s RestoreFileResponse) GoString() string {
  return s.String()
}

func (s *RestoreFileResponse) SetAsyncTaskId(v string) *RestoreFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *RestoreFileResponse) SetDomainId(v string) *RestoreFileResponse {
  s.DomainId = &v
  return s
}

func (s *RestoreFileResponse) SetDriveId(v string) *RestoreFileResponse {
  s.DriveId = &v
  return s
}

func (s *RestoreFileResponse) SetFileId(v string) *RestoreFileResponse {
  s.FileId = &v
  return s
}

/**
 * 
 */
type RevokeRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // refresh token, 
  RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty" require:"true"`
}

func (s RevokeRequest) String() string {
  return tea.Prettify(s)
}

func (s RevokeRequest) GoString() string {
  return s.String()
}

func (s *RevokeRequest) SetHeaders(v map[string]*string) *RevokeRequest {
  s.Headers = v
  return s
}

func (s *RevokeRequest) SetAppId(v string) *RevokeRequest {
  s.AppId = &v
  return s
}

func (s *RevokeRequest) SetRefreshToken(v string) *RevokeRequest {
  s.RefreshToken = &v
  return s
}

/**
 * OSS Sha1 gitlab.alibaba-inc.com/oss/parallel_hash.go OSSSha1Digest
type OSSSha1Digest struct {
h   [5]uint32         // hsha1Sha1Sha1
x   [BlockSize]byte   // 6464
nx  int               // 64640
len uint64            //  OSSRequestSha1Ctx Nl, Nh
}

SHA1CTX  OSSSha1Digest 
Sha164nx0x0hlenpart_offsetOSSSha1Digestlen
 */
type SHA1CTX struct {
  H []*int `json:"h,omitempty" xml:"h,omitempty" type:"Repeated"`
  PartOffset *int64 `json:"part_offset,omitempty" xml:"part_offset,omitempty"`
}

func (s SHA1CTX) String() string {
  return tea.Prettify(s)
}

func (s SHA1CTX) GoString() string {
  return s.String()
}

func (s *SHA1CTX) SetH(v []*int) *SHA1CTX {
  s.H = v
  return s
}

func (s *SHA1CTX) SetPartOffset(v int64) *SHA1CTX {
  s.PartOffset = &v
  return s
}

/**
 * filebody
 */
type ScanFileMetaRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"5000" minimum:"1"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ScanFileMetaRequest) String() string {
  return tea.Prettify(s)
}

func (s ScanFileMetaRequest) GoString() string {
  return s.String()
}

func (s *ScanFileMetaRequest) SetHeaders(v map[string]*string) *ScanFileMetaRequest {
  s.Headers = v
  return s
}

func (s *ScanFileMetaRequest) SetAdditionData(v map[string]interface{}) *ScanFileMetaRequest {
  s.AdditionData = v
  return s
}

func (s *ScanFileMetaRequest) SetCategory(v string) *ScanFileMetaRequest {
  s.Category = &v
  return s
}

func (s *ScanFileMetaRequest) SetDriveId(v string) *ScanFileMetaRequest {
  s.DriveId = &v
  return s
}

func (s *ScanFileMetaRequest) SetImageCroppingAspectRatios(v []*string) *ScanFileMetaRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *ScanFileMetaRequest) SetImageThumbnailProcess(v string) *ScanFileMetaRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ScanFileMetaRequest) SetImageUrlProcess(v string) *ScanFileMetaRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *ScanFileMetaRequest) SetLimit(v int32) *ScanFileMetaRequest {
  s.Limit = &v
  return s
}

func (s *ScanFileMetaRequest) SetMarker(v string) *ScanFileMetaRequest {
  s.Marker = &v
  return s
}

func (s *ScanFileMetaRequest) SetOfficeThumbnailProcess(v string) *ScanFileMetaRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *ScanFileMetaRequest) SetVideoThumbnailProcess(v string) *ScanFileMetaRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * scan file meta response
 */
type ScanFileMetaResponse struct {
  // items
  Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ScanFileMetaResponse) String() string {
  return tea.Prettify(s)
}

func (s ScanFileMetaResponse) GoString() string {
  return s.String()
}

func (s *ScanFileMetaResponse) SetItems(v []*BaseCCPFileResponse) *ScanFileMetaResponse {
  s.Items = v
  return s
}

func (s *ScanFileMetaResponse) SetNextMarker(v string) *ScanFileMetaResponse {
  s.NextMarker = &v
  return s
}

/**
 * search domain request
 */
type SearchDomainsRequest struct {
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // domain
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
  // 
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
}

func (s SearchDomainsRequest) String() string {
  return tea.Prettify(s)
}

func (s SearchDomainsRequest) GoString() string {
  return s.String()
}

func (s *SearchDomainsRequest) SetLimit(v int32) *SearchDomainsRequest {
  s.Limit = &v
  return s
}

func (s *SearchDomainsRequest) SetMarker(v string) *SearchDomainsRequest {
  s.Marker = &v
  return s
}

func (s *SearchDomainsRequest) SetName(v string) *SearchDomainsRequest {
  s.Name = &v
  return s
}

func (s *SearchDomainsRequest) SetOrderBy(v string) *SearchDomainsRequest {
  s.OrderBy = &v
  return s
}

/**
 * 
 */
type SearchFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // addition_data
  AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // drive_ids
  DriveIdList []*string `json:"drive_id_list,omitempty" xml:"drive_id_list,omitempty" type:"Repeated"`
  ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // image_url_process
  ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
  // limit
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // Marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // office_thumbnail_process
  OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
  // order_by
  OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
  // query
  Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
  // referer
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  // return_total_count 
  ReturnTotalCount *bool `json:"return_total_count,omitempty" xml:"return_total_count,omitempty"`
  // sign_token
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s SearchFileRequest) String() string {
  return tea.Prettify(s)
}

func (s SearchFileRequest) GoString() string {
  return s.String()
}

func (s *SearchFileRequest) SetHeaders(v map[string]*string) *SearchFileRequest {
  s.Headers = v
  return s
}

func (s *SearchFileRequest) SetAdditionData(v map[string]interface{}) *SearchFileRequest {
  s.AdditionData = v
  return s
}

func (s *SearchFileRequest) SetDriveId(v string) *SearchFileRequest {
  s.DriveId = &v
  return s
}

func (s *SearchFileRequest) SetDriveIdList(v []*string) *SearchFileRequest {
  s.DriveIdList = v
  return s
}

func (s *SearchFileRequest) SetImageCroppingAspectRatios(v []*string) *SearchFileRequest {
  s.ImageCroppingAspectRatios = v
  return s
}

func (s *SearchFileRequest) SetImageThumbnailProcess(v string) *SearchFileRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *SearchFileRequest) SetImageUrlProcess(v string) *SearchFileRequest {
  s.ImageUrlProcess = &v
  return s
}

func (s *SearchFileRequest) SetLimit(v int32) *SearchFileRequest {
  s.Limit = &v
  return s
}

func (s *SearchFileRequest) SetLocation(v string) *SearchFileRequest {
  s.Location = &v
  return s
}

func (s *SearchFileRequest) SetMarker(v string) *SearchFileRequest {
  s.Marker = &v
  return s
}

func (s *SearchFileRequest) SetOfficeThumbnailProcess(v string) *SearchFileRequest {
  s.OfficeThumbnailProcess = &v
  return s
}

func (s *SearchFileRequest) SetOrderBy(v string) *SearchFileRequest {
  s.OrderBy = &v
  return s
}

func (s *SearchFileRequest) SetQuery(v string) *SearchFileRequest {
  s.Query = &v
  return s
}

func (s *SearchFileRequest) SetReferer(v string) *SearchFileRequest {
  s.Referer = &v
  return s
}

func (s *SearchFileRequest) SetReturnTotalCount(v bool) *SearchFileRequest {
  s.ReturnTotalCount = &v
  return s
}

func (s *SearchFileRequest) SetSignToken(v string) *SearchFileRequest {
  s.SignToken = &v
  return s
}

func (s *SearchFileRequest) SetUrlExpireSec(v int64) *SearchFileRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *SearchFileRequest) SetVideoThumbnailProcess(v string) *SearchFileRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * search file response
 */
type SearchFileResponse struct {
  // items
  Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
  // total_count
  TotalCount *int64 `json:"total_count,omitempty" xml:"total_count,omitempty"`
}

func (s SearchFileResponse) String() string {
  return tea.Prettify(s)
}

func (s SearchFileResponse) GoString() string {
  return s.String()
}

func (s *SearchFileResponse) SetItems(v []*BaseCCPFileResponse) *SearchFileResponse {
  s.Items = v
  return s
}

func (s *SearchFileResponse) SetNextMarker(v string) *SearchFileResponse {
  s.NextMarker = &v
  return s
}

func (s *SearchFileResponse) SetTotalCount(v int64) *SearchFileResponse {
  s.TotalCount = &v
  return s
}

/**
 * 
 */
type SetAppPublicKeyRequest struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // RSA, PEM
  PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s SetAppPublicKeyRequest) String() string {
  return tea.Prettify(s)
}

func (s SetAppPublicKeyRequest) GoString() string {
  return s.String()
}

func (s *SetAppPublicKeyRequest) SetAppId(v string) *SetAppPublicKeyRequest {
  s.AppId = &v
  return s
}

func (s *SetAppPublicKeyRequest) SetPublicKey(v string) *SetAppPublicKeyRequest {
  s.PublicKey = &v
  return s
}

/**
 * 
 */
type SetBizCNameCertRequest struct {
  CertID *string `json:"CertID,omitempty" xml:"CertID,omitempty"`
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  // cert body
  CertBody *string `json:"cert_body,omitempty" xml:"cert_body,omitempty" require:"true"`
  // cert name
  CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty" require:"true"`
  // cert privatekey
  CertPrivatekey *string `json:"cert_privatekey,omitempty" xml:"cert_privatekey,omitempty" require:"true"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // biz cname
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameCertRequest) String() string {
  return tea.Prettify(s)
}

func (s SetBizCNameCertRequest) GoString() string {
  return s.String()
}

func (s *SetBizCNameCertRequest) SetCertID(v string) *SetBizCNameCertRequest {
  s.CertID = &v
  return s
}

func (s *SetBizCNameCertRequest) SetBizCname(v string) *SetBizCNameCertRequest {
  s.BizCname = &v
  return s
}

func (s *SetBizCNameCertRequest) SetCertBody(v string) *SetBizCNameCertRequest {
  s.CertBody = &v
  return s
}

func (s *SetBizCNameCertRequest) SetCertName(v string) *SetBizCNameCertRequest {
  s.CertName = &v
  return s
}

func (s *SetBizCNameCertRequest) SetCertPrivatekey(v string) *SetBizCNameCertRequest {
  s.CertPrivatekey = &v
  return s
}

func (s *SetBizCNameCertRequest) SetCnameType(v string) *SetBizCNameCertRequest {
  s.CnameType = &v
  return s
}

func (s *SetBizCNameCertRequest) SetDomainId(v string) *SetBizCNameCertRequest {
  s.DomainId = &v
  return s
}

func (s *SetBizCNameCertRequest) SetIsVpc(v bool) *SetBizCNameCertRequest {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type SetBizCNameRequest struct {
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty" require:"true"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // biz cname
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameRequest) String() string {
  return tea.Prettify(s)
}

func (s SetBizCNameRequest) GoString() string {
  return s.String()
}

func (s *SetBizCNameRequest) SetBizCname(v string) *SetBizCNameRequest {
  s.BizCname = &v
  return s
}

func (s *SetBizCNameRequest) SetCnameType(v string) *SetBizCNameRequest {
  s.CnameType = &v
  return s
}

func (s *SetBizCNameRequest) SetDomainId(v string) *SetBizCNameRequest {
  s.DomainId = &v
  return s
}

func (s *SetBizCNameRequest) SetIsVpc(v bool) *SetBizCNameRequest {
  s.IsVpc = &v
  return s
}

/**
 * list cors rule request
 */
type SetCorsRuleListRequest struct {
  // cors rule list
  CorsRuleList []*CorsRule `json:"cors_rule_list,omitempty" xml:"cors_rule_list,omitempty" require:"true" type:"Repeated"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s SetCorsRuleListRequest) String() string {
  return tea.Prettify(s)
}

func (s SetCorsRuleListRequest) GoString() string {
  return s.String()
}

func (s *SetCorsRuleListRequest) SetCorsRuleList(v []*CorsRule) *SetCorsRuleListRequest {
  s.CorsRuleList = v
  return s
}

func (s *SetCorsRuleListRequest) SetDomainId(v string) *SetCorsRuleListRequest {
  s.DomainId = &v
  return s
}

/**
 * 
 */
type SetDataCNameRequest struct {
  // cn-shanghai data cname
  DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s SetDataCNameRequest) String() string {
  return tea.Prettify(s)
}

func (s SetDataCNameRequest) GoString() string {
  return s.String()
}

func (s *SetDataCNameRequest) SetDataCname(v string) *SetDataCNameRequest {
  s.DataCname = &v
  return s
}

func (s *SetDataCNameRequest) SetDomainId(v string) *SetDataCNameRequest {
  s.DomainId = &v
  return s
}

func (s *SetDataCNameRequest) SetLocation(v string) *SetDataCNameRequest {
  s.Location = &v
  return s
}

/**
 * 
 */
type SetShareLinkStatusRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // enabled
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty" require:"true"`
}

func (s SetShareLinkStatusRequest) String() string {
  return tea.Prettify(s)
}

func (s SetShareLinkStatusRequest) GoString() string {
  return s.String()
}

func (s *SetShareLinkStatusRequest) SetDomainId(v string) *SetShareLinkStatusRequest {
  s.DomainId = &v
  return s
}

func (s *SetShareLinkStatusRequest) SetEnabled(v bool) *SetShareLinkStatusRequest {
  s.Enabled = &v
  return s
}

/**
 * 
 */
type SetShareStatusRequest struct {
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // enabled
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty" require:"true"`
}

func (s SetShareStatusRequest) String() string {
  return tea.Prettify(s)
}

func (s SetShareStatusRequest) GoString() string {
  return s.String()
}

func (s *SetShareStatusRequest) SetDomainId(v string) *SetShareStatusRequest {
  s.DomainId = &v
  return s
}

func (s *SetShareStatusRequest) SetEnabled(v bool) *SetShareStatusRequest {
  s.Enabled = &v
  return s
}

/**
 * 
 */
type SharePermissionPolicy struct {
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
  PermissionInheritable *bool `json:"permission_inheritable,omitempty" xml:"permission_inheritable,omitempty"`
  PermissionList []*string `json:"permission_list,omitempty" xml:"permission_list,omitempty" type:"Repeated"`
  PermissionType *string `json:"permission_type,omitempty" xml:"permission_type,omitempty"`
}

func (s SharePermissionPolicy) String() string {
  return tea.Prettify(s)
}

func (s SharePermissionPolicy) GoString() string {
  return s.String()
}

func (s *SharePermissionPolicy) SetFileId(v string) *SharePermissionPolicy {
  s.FileId = &v
  return s
}

func (s *SharePermissionPolicy) SetFilePath(v string) *SharePermissionPolicy {
  s.FilePath = &v
  return s
}

func (s *SharePermissionPolicy) SetPermissionInheritable(v bool) *SharePermissionPolicy {
  s.PermissionInheritable = &v
  return s
}

func (s *SharePermissionPolicy) SetPermissionList(v []*string) *SharePermissionPolicy {
  s.PermissionList = v
  return s
}

func (s *SharePermissionPolicy) SetPermissionType(v string) *SharePermissionPolicy {
  s.PermissionType = &v
  return s
}

/**
 * 
 */
type SimpleStreamInfo struct {
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s SimpleStreamInfo) String() string {
  return tea.Prettify(s)
}

func (s SimpleStreamInfo) GoString() string {
  return s.String()
}

func (s *SimpleStreamInfo) SetCrc64Hash(v string) *SimpleStreamInfo {
  s.Crc64Hash = &v
  return s
}

func (s *SimpleStreamInfo) SetDownloadUrl(v string) *SimpleStreamInfo {
  s.DownloadUrl = &v
  return s
}

func (s *SimpleStreamInfo) SetSize(v int64) *SimpleStreamInfo {
  s.Size = &v
  return s
}

func (s *SimpleStreamInfo) SetThumbnail(v string) *SimpleStreamInfo {
  s.Thumbnail = &v
  return s
}

func (s *SimpleStreamInfo) SetUrl(v string) *SimpleStreamInfo {
  s.Url = &v
  return s
}

/**
 * 
 */
type Store struct {
  // 
  AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
  // 
  BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
  // bucket
  Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
  // 
  CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
  // 
  CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
  // 
  CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
  // Public
  CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
  // vpc
  CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
  // Public
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
  // vpc
  InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
  // 
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // systemcustom
  Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
  // Policy,systemstorebucket
  Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
  // BucketARN
  RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
  // store ID
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
  // oss
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s Store) String() string {
  return tea.Prettify(s)
}

func (s Store) GoString() string {
  return s.String()
}

func (s *Store) SetAccelerateEndpoint(v string) *Store {
  s.AccelerateEndpoint = &v
  return s
}

func (s *Store) SetBasePath(v string) *Store {
  s.BasePath = &v
  return s
}

func (s *Store) SetBucket(v string) *Store {
  s.Bucket = &v
  return s
}

func (s *Store) SetCdnEndpoint(v string) *Store {
  s.CdnEndpoint = &v
  return s
}

func (s *Store) SetCustomizedAccelerateEndpoint(v string) *Store {
  s.CustomizedAccelerateEndpoint = &v
  return s
}

func (s *Store) SetCustomizedCdnEndpoint(v string) *Store {
  s.CustomizedCdnEndpoint = &v
  return s
}

func (s *Store) SetCustomizedEndpoint(v string) *Store {
  s.CustomizedEndpoint = &v
  return s
}

func (s *Store) SetCustomizedInternalEndpoint(v string) *Store {
  s.CustomizedInternalEndpoint = &v
  return s
}

func (s *Store) SetEndpoint(v string) *Store {
  s.Endpoint = &v
  return s
}

func (s *Store) SetInternalEndpoint(v string) *Store {
  s.InternalEndpoint = &v
  return s
}

func (s *Store) SetLocation(v string) *Store {
  s.Location = &v
  return s
}

func (s *Store) SetOwnership(v string) *Store {
  s.Ownership = &v
  return s
}

func (s *Store) SetPolicy(v string) *Store {
  s.Policy = &v
  return s
}

func (s *Store) SetRoleArn(v string) *Store {
  s.RoleArn = &v
  return s
}

func (s *Store) SetStoreId(v string) *Store {
  s.StoreId = &v
  return s
}

func (s *Store) SetType(v string) *Store {
  s.Type = &v
  return s
}

/**
 * 
 */
type StoreFile struct {
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
  ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty"`
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s StoreFile) String() string {
  return tea.Prettify(s)
}

func (s StoreFile) GoString() string {
  return s.String()
}

func (s *StoreFile) SetDomainId(v string) *StoreFile {
  s.DomainId = &v
  return s
}

func (s *StoreFile) SetName(v string) *StoreFile {
  s.Name = &v
  return s
}

func (s *StoreFile) SetParentFilePath(v string) *StoreFile {
  s.ParentFilePath = &v
  return s
}

func (s *StoreFile) SetStoreId(v string) *StoreFile {
  s.StoreId = &v
  return s
}

func (s *StoreFile) SetType(v string) *StoreFile {
  s.Type = &v
  return s
}

/**
 * 
 */
type StoreItemResponse struct {
  // 
  AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
  // 
  BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
  // bucket
  Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
  // 
  CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
  // 
  CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
  // 
  CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
  // Public
  CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
  // vpc
  CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Public
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
  // vpc
  InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
  // 
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // systemcustom
  Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
  // Policy,systemstorebucket
  Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
  // BucketARN
  RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
  // store ID
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
  // oss
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s StoreItemResponse) String() string {
  return tea.Prettify(s)
}

func (s StoreItemResponse) GoString() string {
  return s.String()
}

func (s *StoreItemResponse) SetAccelerateEndpoint(v string) *StoreItemResponse {
  s.AccelerateEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetBasePath(v string) *StoreItemResponse {
  s.BasePath = &v
  return s
}

func (s *StoreItemResponse) SetBucket(v string) *StoreItemResponse {
  s.Bucket = &v
  return s
}

func (s *StoreItemResponse) SetCdnEndpoint(v string) *StoreItemResponse {
  s.CdnEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetCustomizedAccelerateEndpoint(v string) *StoreItemResponse {
  s.CustomizedAccelerateEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetCustomizedCdnEndpoint(v string) *StoreItemResponse {
  s.CustomizedCdnEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetCustomizedEndpoint(v string) *StoreItemResponse {
  s.CustomizedEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetCustomizedInternalEndpoint(v string) *StoreItemResponse {
  s.CustomizedInternalEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetDomainId(v string) *StoreItemResponse {
  s.DomainId = &v
  return s
}

func (s *StoreItemResponse) SetEndpoint(v string) *StoreItemResponse {
  s.Endpoint = &v
  return s
}

func (s *StoreItemResponse) SetInternalEndpoint(v string) *StoreItemResponse {
  s.InternalEndpoint = &v
  return s
}

func (s *StoreItemResponse) SetLocation(v string) *StoreItemResponse {
  s.Location = &v
  return s
}

func (s *StoreItemResponse) SetOwnership(v string) *StoreItemResponse {
  s.Ownership = &v
  return s
}

func (s *StoreItemResponse) SetPolicy(v string) *StoreItemResponse {
  s.Policy = &v
  return s
}

func (s *StoreItemResponse) SetRoleArn(v string) *StoreItemResponse {
  s.RoleArn = &v
  return s
}

func (s *StoreItemResponse) SetStoreId(v string) *StoreItemResponse {
  s.StoreId = &v
  return s
}

func (s *StoreItemResponse) SetType(v string) *StoreItemResponse {
  s.Type = &v
  return s
}

/**
 * 
 */
type StreamUploadInfo struct {
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // part_info_list
  PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
  // pre_rapid_upload
  // type: boolean
  PreRapidUpload *bool `json:"pre_rapid_upload,omitempty" xml:"pre_rapid_upload,omitempty"`
  // rapid_upload
  // type: boolean
  RapidUpload *bool `json:"rapid_upload,omitempty" xml:"rapid_upload,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s StreamUploadInfo) String() string {
  return tea.Prettify(s)
}

func (s StreamUploadInfo) GoString() string {
  return s.String()
}

func (s *StreamUploadInfo) SetLocation(v string) *StreamUploadInfo {
  s.Location = &v
  return s
}

func (s *StreamUploadInfo) SetPartInfoList(v []*UploadPartInfo) *StreamUploadInfo {
  s.PartInfoList = v
  return s
}

func (s *StreamUploadInfo) SetPreRapidUpload(v bool) *StreamUploadInfo {
  s.PreRapidUpload = &v
  return s
}

func (s *StreamUploadInfo) SetRapidUpload(v bool) *StreamUploadInfo {
  s.RapidUpload = &v
  return s
}

func (s *StreamUploadInfo) SetUploadId(v string) *StreamUploadInfo {
  s.UploadId = &v
  return s
}

/**
 * 
 */
type SystemTag struct {
  Confidence *float64 `json:"confidence,omitempty" xml:"confidence,omitempty"`
  EnName *string `json:"en_name,omitempty" xml:"en_name,omitempty"`
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
  ParentEnName *string `json:"parent_en_name,omitempty" xml:"parent_en_name,omitempty"`
  ParentName *string `json:"parent_name,omitempty" xml:"parent_name,omitempty"`
  Source *string `json:"source,omitempty" xml:"source,omitempty"`
  TagLevel *int64 `json:"tag_level,omitempty" xml:"tag_level,omitempty"`
}

func (s SystemTag) String() string {
  return tea.Prettify(s)
}

func (s SystemTag) GoString() string {
  return s.String()
}

func (s *SystemTag) SetConfidence(v float64) *SystemTag {
  s.Confidence = &v
  return s
}

func (s *SystemTag) SetEnName(v string) *SystemTag {
  s.EnName = &v
  return s
}

func (s *SystemTag) SetName(v string) *SystemTag {
  s.Name = &v
  return s
}

func (s *SystemTag) SetParentEnName(v string) *SystemTag {
  s.ParentEnName = &v
  return s
}

func (s *SystemTag) SetParentName(v string) *SystemTag {
  s.ParentName = &v
  return s
}

func (s *SystemTag) SetSource(v string) *SystemTag {
  s.Source = &v
  return s
}

func (s *SystemTag) SetTagLevel(v int64) *SystemTag {
  s.TagLevel = &v
  return s
}

/**
 * 
 */
type Target struct {
  // FileID
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // FileName
  FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
  // FileType
  FileType *string `json:"file_type,omitempty" xml:"file_type,omitempty"`
}

func (s Target) String() string {
  return tea.Prettify(s)
}

func (s Target) GoString() string {
  return s.String()
}

func (s *Target) SetFileId(v string) *Target {
  s.FileId = &v
  return s
}

func (s *Target) SetFileName(v string) *Target {
  s.FileName = &v
  return s
}

func (s *Target) SetFileType(v string) *Target {
  s.FileType = &v
  return s
}

/**
 * 
 */
type TimeRange struct {
  // EndTime
  EndTime *string `json:"end_time,omitempty" xml:"end_time,omitempty"`
  // StartTime
  StartTime *string `json:"start_time,omitempty" xml:"start_time,omitempty"`
}

func (s TimeRange) String() string {
  return tea.Prettify(s)
}

func (s TimeRange) GoString() string {
  return s.String()
}

func (s *TimeRange) SetEndTime(v string) *TimeRange {
  s.EndTime = &v
  return s
}

func (s *TimeRange) SetStartTime(v string) *TimeRange {
  s.StartTime = &v
  return s
}

/**
 * 
 */
type TokenRequest struct {
  // JWTJWTaccessToken
  Assertion *string `json:"Assertion,omitempty" xml:"Assertion,omitempty"`
  // Client ID, AppAppID
  ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
  // Client ID, AppAppSecret
  ClientSecret *string `json:"ClientSecret,omitempty" xml:"ClientSecret,omitempty" require:"true"`
  // code
  Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
  // OAuth2.0 device flowtoken
  DeviceCode *string `json:"DeviceCode,omitempty" xml:"DeviceCode,omitempty"`
  // codeaccessTokenrefresh_tokenaccessToken
  GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty" require:"true"`
  // , AppOAuth
  RedirectUri *string `json:"RedirectUri,omitempty" xml:"RedirectUri,omitempty"`
  // accessTokenrefreshToken
  RefreshToken *string `json:"RefreshToken,omitempty" xml:"RefreshToken,omitempty"`
  // SubDomainID
  SubDomainID *string `json:"SubDomainID,omitempty" xml:"SubDomainID,omitempty"`
}

func (s TokenRequest) String() string {
  return tea.Prettify(s)
}

func (s TokenRequest) GoString() string {
  return s.String()
}

func (s *TokenRequest) SetAssertion(v string) *TokenRequest {
  s.Assertion = &v
  return s
}

func (s *TokenRequest) SetClientID(v string) *TokenRequest {
  s.ClientID = &v
  return s
}

func (s *TokenRequest) SetClientSecret(v string) *TokenRequest {
  s.ClientSecret = &v
  return s
}

func (s *TokenRequest) SetCode(v string) *TokenRequest {
  s.Code = &v
  return s
}

func (s *TokenRequest) SetDeviceCode(v string) *TokenRequest {
  s.DeviceCode = &v
  return s
}

func (s *TokenRequest) SetGrantType(v string) *TokenRequest {
  s.GrantType = &v
  return s
}

func (s *TokenRequest) SetRedirectUri(v string) *TokenRequest {
  s.RedirectUri = &v
  return s
}

func (s *TokenRequest) SetRefreshToken(v string) *TokenRequest {
  s.RefreshToken = &v
  return s
}

func (s *TokenRequest) SetSubDomainID(v string) *TokenRequest {
  s.SubDomainID = &v
  return s
}

/**
 * 
 */
type TrashDetail struct {
  // ParentFileID
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty"`
}

func (s TrashDetail) String() string {
  return tea.Prettify(s)
}

func (s TrashDetail) GoString() string {
  return s.String()
}

func (s *TrashDetail) SetParentFileId(v string) *TrashDetail {
  s.ParentFileId = &v
  return s
}

/**
 * 
 */
type TrashFileRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // share_id, either share_id or drive_id is required
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s TrashFileRequest) String() string {
  return tea.Prettify(s)
}

func (s TrashFileRequest) GoString() string {
  return s.String()
}

func (s *TrashFileRequest) SetHeaders(v map[string]*string) *TrashFileRequest {
  s.Headers = v
  return s
}

func (s *TrashFileRequest) SetDriveId(v string) *TrashFileRequest {
  s.DriveId = &v
  return s
}

func (s *TrashFileRequest) SetFileId(v string) *TrashFileRequest {
  s.FileId = &v
  return s
}

func (s *TrashFileRequest) SetShareId(v string) *TrashFileRequest {
  s.ShareId = &v
  return s
}

/**
 * response
 */
type TrashFileResponse struct {
  // async_task_id
  AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s TrashFileResponse) String() string {
  return tea.Prettify(s)
}

func (s TrashFileResponse) GoString() string {
  return s.String()
}

func (s *TrashFileResponse) SetAsyncTaskId(v string) *TrashFileResponse {
  s.AsyncTaskId = &v
  return s
}

func (s *TrashFileResponse) SetDomainId(v string) *TrashFileResponse {
  s.DomainId = &v
  return s
}

func (s *TrashFileResponse) SetDriveId(v string) *TrashFileResponse {
  s.DriveId = &v
  return s
}

func (s *TrashFileResponse) SetFileId(v string) *TrashFileResponse {
  s.FileId = &v
  return s
}

/**
 * UCGetObjectInfoByObjectKeyRequest
 */
type UCGetObjectInfoByObjectKeyRequest struct {
  ObjectKey *string `json:"object_key,omitempty" xml:"object_key,omitempty"`
}

func (s UCGetObjectInfoByObjectKeyRequest) String() string {
  return tea.Prettify(s)
}

func (s UCGetObjectInfoByObjectKeyRequest) GoString() string {
  return s.String()
}

func (s *UCGetObjectInfoByObjectKeyRequest) SetObjectKey(v string) *UCGetObjectInfoByObjectKeyRequest {
  s.ObjectKey = &v
  return s
}

/**
 * UCGetObjectInfoBySha1Request
 */
type UCGetObjectInfoBySha1Request struct {
  Sha1 *string `json:"sha1,omitempty" xml:"sha1,omitempty"`
}

func (s UCGetObjectInfoBySha1Request) String() string {
  return tea.Prettify(s)
}

func (s UCGetObjectInfoBySha1Request) GoString() string {
  return s.String()
}

func (s *UCGetObjectInfoBySha1Request) SetSha1(v string) *UCGetObjectInfoBySha1Request {
  s.Sha1 = &v
  return s
}

/**
 * 
 */
type UnionAuthentication struct {
  AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty"`
  CreatedAt *int64 `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty"`
  Extra *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
  Identity *string `json:"Identity,omitempty" xml:"Identity,omitempty"`
  Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
  UnionID *string `json:"UnionID,omitempty" xml:"UnionID,omitempty"`
}

func (s UnionAuthentication) String() string {
  return tea.Prettify(s)
}

func (s UnionAuthentication) GoString() string {
  return s.String()
}

func (s *UnionAuthentication) SetAuthenticationType(v string) *UnionAuthentication {
  s.AuthenticationType = &v
  return s
}

func (s *UnionAuthentication) SetCreatedAt(v int64) *UnionAuthentication {
  s.CreatedAt = &v
  return s
}

func (s *UnionAuthentication) SetExtra(v string) *UnionAuthentication {
  s.Extra = &v
  return s
}

func (s *UnionAuthentication) SetIdentity(v string) *UnionAuthentication {
  s.Identity = &v
  return s
}

func (s *UnionAuthentication) SetStatus(v string) *UnionAuthentication {
  s.Status = &v
  return s
}

func (s *UnionAuthentication) SetUnionID(v string) *UnionAuthentication {
  s.UnionID = &v
  return s
}

/**
 * 
 */
type UnionDomainUserBind struct {
  AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty"`
  DomainID *string `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
  Extra *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
  Identity *string `json:"Identity,omitempty" xml:"Identity,omitempty"`
  UnionID *string `json:"UnionID,omitempty" xml:"UnionID,omitempty"`
  UserID *string `json:"UserID,omitempty" xml:"UserID,omitempty"`
}

func (s UnionDomainUserBind) String() string {
  return tea.Prettify(s)
}

func (s UnionDomainUserBind) GoString() string {
  return s.String()
}

func (s *UnionDomainUserBind) SetAuthenticationType(v string) *UnionDomainUserBind {
  s.AuthenticationType = &v
  return s
}

func (s *UnionDomainUserBind) SetDomainID(v string) *UnionDomainUserBind {
  s.DomainID = &v
  return s
}

func (s *UnionDomainUserBind) SetExtra(v string) *UnionDomainUserBind {
  s.Extra = &v
  return s
}

func (s *UnionDomainUserBind) SetIdentity(v string) *UnionDomainUserBind {
  s.Identity = &v
  return s
}

func (s *UnionDomainUserBind) SetUnionID(v string) *UnionDomainUserBind {
  s.UnionID = &v
  return s
}

func (s *UnionDomainUserBind) SetUserID(v string) *UnionDomainUserBind {
  s.UserID = &v
  return s
}

/**
 * 
 */
type UpdateAppRequest struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // App
  AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" maxLength:"128" minLength:"1"`
  // App
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024" minLength:"0"`
  // App
  Logo *string `json:"logo,omitempty" xml:"logo,omitempty"`
  // App
  RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
  // App
  Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" type:"Repeated"`
  // App
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateAppRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateAppRequest) GoString() string {
  return s.String()
}

func (s *UpdateAppRequest) SetAppId(v string) *UpdateAppRequest {
  s.AppId = &v
  return s
}

func (s *UpdateAppRequest) SetAppName(v string) *UpdateAppRequest {
  s.AppName = &v
  return s
}

func (s *UpdateAppRequest) SetDescription(v string) *UpdateAppRequest {
  s.Description = &v
  return s
}

func (s *UpdateAppRequest) SetLogo(v string) *UpdateAppRequest {
  s.Logo = &v
  return s
}

func (s *UpdateAppRequest) SetRedirectUri(v string) *UpdateAppRequest {
  s.RedirectUri = &v
  return s
}

func (s *UpdateAppRequest) SetScope(v []*string) *UpdateAppRequest {
  s.Scope = v
  return s
}

func (s *UpdateAppRequest) SetType(v string) *UpdateAppRequest {
  s.Type = &v
  return s
}

/**
 * update domain request
 */
type UpdateDomainRequest struct {
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  CustomBenefits map[string]interface{} `json:"custom_benefits,omitempty" xml:"custom_benefits,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  GetBenefit *bool `json:"get_benefit,omitempty" xml:"get_benefit,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  //  Drive  Store ID
  InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
}

func (s UpdateDomainRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateDomainRequest) GoString() string {
  return s.String()
}

func (s *UpdateDomainRequest) SetAuthConfig(v map[string]interface{}) *UpdateDomainRequest {
  s.AuthConfig = v
  return s
}

func (s *UpdateDomainRequest) SetAuthDingdingAppId(v string) *UpdateDomainRequest {
  s.AuthDingdingAppId = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthDingdingAppSecret(v string) *UpdateDomainRequest {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthDingdingEnable(v bool) *UpdateDomainRequest {
  s.AuthDingdingEnable = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthEndpointEnable(v bool) *UpdateDomainRequest {
  s.AuthEndpointEnable = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthRamAppId(v string) *UpdateDomainRequest {
  s.AuthRamAppId = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthRamAppSecret(v string) *UpdateDomainRequest {
  s.AuthRamAppSecret = &v
  return s
}

func (s *UpdateDomainRequest) SetAuthRamEnable(v bool) *UpdateDomainRequest {
  s.AuthRamEnable = &v
  return s
}

func (s *UpdateDomainRequest) SetCustomBenefits(v map[string]interface{}) *UpdateDomainRequest {
  s.CustomBenefits = v
  return s
}

func (s *UpdateDomainRequest) SetDataHashName(v string) *UpdateDomainRequest {
  s.DataHashName = &v
  return s
}

func (s *UpdateDomainRequest) SetDescription(v string) *UpdateDomainRequest {
  s.Description = &v
  return s
}

func (s *UpdateDomainRequest) SetDomainId(v string) *UpdateDomainRequest {
  s.DomainId = &v
  return s
}

func (s *UpdateDomainRequest) SetDomainName(v string) *UpdateDomainRequest {
  s.DomainName = &v
  return s
}

func (s *UpdateDomainRequest) SetEventFilenameMatches(v string) *UpdateDomainRequest {
  s.EventFilenameMatches = &v
  return s
}

func (s *UpdateDomainRequest) SetEventMnsEndpoint(v string) *UpdateDomainRequest {
  s.EventMnsEndpoint = &v
  return s
}

func (s *UpdateDomainRequest) SetEventMnsTopic(v string) *UpdateDomainRequest {
  s.EventMnsTopic = &v
  return s
}

func (s *UpdateDomainRequest) SetEventNames(v []*string) *UpdateDomainRequest {
  s.EventNames = v
  return s
}

func (s *UpdateDomainRequest) SetEventRoleArn(v string) *UpdateDomainRequest {
  s.EventRoleArn = &v
  return s
}

func (s *UpdateDomainRequest) SetGetBenefit(v bool) *UpdateDomainRequest {
  s.GetBenefit = &v
  return s
}

func (s *UpdateDomainRequest) SetInitDriveEnable(v bool) *UpdateDomainRequest {
  s.InitDriveEnable = &v
  return s
}

func (s *UpdateDomainRequest) SetInitDriveSize(v int64) *UpdateDomainRequest {
  s.InitDriveSize = &v
  return s
}

func (s *UpdateDomainRequest) SetInitDriveStoreId(v string) *UpdateDomainRequest {
  s.InitDriveStoreId = &v
  return s
}

func (s *UpdateDomainRequest) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *UpdateDomainRequest {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *UpdateDomainRequest) SetSharable(v bool) *UpdateDomainRequest {
  s.Sharable = &v
  return s
}

/**
 * Update drive request
 */
type UpdateDriveRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
  // Drive 
  DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty" maxLength:"1024"`
  // 
  EncryptDataAccess *bool `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
  // 
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // Subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // ,Byte [ -1 ]
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
}

func (s UpdateDriveRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateDriveRequest) GoString() string {
  return s.String()
}

func (s *UpdateDriveRequest) SetHeaders(v map[string]*string) *UpdateDriveRequest {
  s.Headers = v
  return s
}

func (s *UpdateDriveRequest) SetDescription(v string) *UpdateDriveRequest {
  s.Description = &v
  return s
}

func (s *UpdateDriveRequest) SetDriveId(v string) *UpdateDriveRequest {
  s.DriveId = &v
  return s
}

func (s *UpdateDriveRequest) SetDriveName(v string) *UpdateDriveRequest {
  s.DriveName = &v
  return s
}

func (s *UpdateDriveRequest) SetEncryptDataAccess(v bool) *UpdateDriveRequest {
  s.EncryptDataAccess = &v
  return s
}

func (s *UpdateDriveRequest) SetEncryptMode(v string) *UpdateDriveRequest {
  s.EncryptMode = &v
  return s
}

func (s *UpdateDriveRequest) SetStatus(v string) *UpdateDriveRequest {
  s.Status = &v
  return s
}

func (s *UpdateDriveRequest) SetSubdomainId(v string) *UpdateDriveRequest {
  s.SubdomainId = &v
  return s
}

func (s *UpdateDriveRequest) SetTotalSize(v int64) *UpdateDriveRequest {
  s.TotalSize = &v
  return s
}

/**
 * Update drive response
 */
type UpdateDriveResponse struct {
  // Drive 
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // Drive 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Drive ID
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // Drive 
  DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
  // Drive 
  DriveType *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
  EncryptDataAccess *bool `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // Drive 
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // Drive 
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // DrivestoredomainPathTypeOSSPath
  RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
  // Drive 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  //  ID, domainPathTypeOSSPath
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
  // Drive 
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
  // Drive 
  UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s UpdateDriveResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateDriveResponse) GoString() string {
  return s.String()
}

func (s *UpdateDriveResponse) SetCreator(v string) *UpdateDriveResponse {
  s.Creator = &v
  return s
}

func (s *UpdateDriveResponse) SetDescription(v string) *UpdateDriveResponse {
  s.Description = &v
  return s
}

func (s *UpdateDriveResponse) SetDomainId(v string) *UpdateDriveResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateDriveResponse) SetDriveId(v string) *UpdateDriveResponse {
  s.DriveId = &v
  return s
}

func (s *UpdateDriveResponse) SetDriveName(v string) *UpdateDriveResponse {
  s.DriveName = &v
  return s
}

func (s *UpdateDriveResponse) SetDriveType(v string) *UpdateDriveResponse {
  s.DriveType = &v
  return s
}

func (s *UpdateDriveResponse) SetEncryptDataAccess(v bool) *UpdateDriveResponse {
  s.EncryptDataAccess = &v
  return s
}

func (s *UpdateDriveResponse) SetEncryptMode(v string) *UpdateDriveResponse {
  s.EncryptMode = &v
  return s
}

func (s *UpdateDriveResponse) SetOwner(v string) *UpdateDriveResponse {
  s.Owner = &v
  return s
}

func (s *UpdateDriveResponse) SetOwnerType(v string) *UpdateDriveResponse {
  s.OwnerType = &v
  return s
}

func (s *UpdateDriveResponse) SetRelativePath(v string) *UpdateDriveResponse {
  s.RelativePath = &v
  return s
}

func (s *UpdateDriveResponse) SetStatus(v string) *UpdateDriveResponse {
  s.Status = &v
  return s
}

func (s *UpdateDriveResponse) SetStoreId(v string) *UpdateDriveResponse {
  s.StoreId = &v
  return s
}

func (s *UpdateDriveResponse) SetTotalSize(v int64) *UpdateDriveResponse {
  s.TotalSize = &v
  return s
}

func (s *UpdateDriveResponse) SetUsedSize(v int64) *UpdateDriveResponse {
  s.UsedSize = &v
  return s
}

/**
 * 
 */
type UpdateFileMetaRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // check_name_mode
  CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
  CustomIndexKey *string `json:"custom_index_key,omitempty" xml:"custom_index_key,omitempty"`
  // description
  // type: string
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
  FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
  // hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" maxLength:"1024" minLength:"1"`
  Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
}

func (s UpdateFileMetaRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateFileMetaRequest) GoString() string {
  return s.String()
}

func (s *UpdateFileMetaRequest) SetHeaders(v map[string]*string) *UpdateFileMetaRequest {
  s.Headers = v
  return s
}

func (s *UpdateFileMetaRequest) SetCheckNameMode(v string) *UpdateFileMetaRequest {
  s.CheckNameMode = &v
  return s
}

func (s *UpdateFileMetaRequest) SetCustomIndexKey(v string) *UpdateFileMetaRequest {
  s.CustomIndexKey = &v
  return s
}

func (s *UpdateFileMetaRequest) SetDescription(v string) *UpdateFileMetaRequest {
  s.Description = &v
  return s
}

func (s *UpdateFileMetaRequest) SetDriveId(v string) *UpdateFileMetaRequest {
  s.DriveId = &v
  return s
}

func (s *UpdateFileMetaRequest) SetEncryptMode(v string) *UpdateFileMetaRequest {
  s.EncryptMode = &v
  return s
}

func (s *UpdateFileMetaRequest) SetFileId(v string) *UpdateFileMetaRequest {
  s.FileId = &v
  return s
}

func (s *UpdateFileMetaRequest) SetFileIdPath(v string) *UpdateFileMetaRequest {
  s.FileIdPath = &v
  return s
}

func (s *UpdateFileMetaRequest) SetHidden(v bool) *UpdateFileMetaRequest {
  s.Hidden = &v
  return s
}

func (s *UpdateFileMetaRequest) SetLabels(v []*string) *UpdateFileMetaRequest {
  s.Labels = v
  return s
}

func (s *UpdateFileMetaRequest) SetMeta(v string) *UpdateFileMetaRequest {
  s.Meta = &v
  return s
}

func (s *UpdateFileMetaRequest) SetName(v string) *UpdateFileMetaRequest {
  s.Name = &v
  return s
}

func (s *UpdateFileMetaRequest) SetReferer(v string) *UpdateFileMetaRequest {
  s.Referer = &v
  return s
}

func (s *UpdateFileMetaRequest) SetShareId(v string) *UpdateFileMetaRequest {
  s.ShareId = &v
  return s
}

func (s *UpdateFileMetaRequest) SetSignToken(v string) *UpdateFileMetaRequest {
  s.SignToken = &v
  return s
}

func (s *UpdateFileMetaRequest) SetStarred(v bool) *UpdateFileMetaRequest {
  s.Starred = &v
  return s
}

func (s *UpdateFileMetaRequest) SetUserMeta(v string) *UpdateFileMetaRequest {
  s.UserMeta = &v
  return s
}

/**
 *  response
 */
type UpdateFileMetaResponse struct {
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  // CharacteristicHash
  CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
  // Content Hash
  ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
  // content_hash_name
  ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // crc64_hash
  Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // DomainID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
  // encrypt_mode
  EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
  // file_extension
  FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // Hidden
  // type: boolean
  Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
  ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
  // labels
  Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
  // last_modifier_id
  LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
  // last_modifier_name
  LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
  // last_modifier_type
  LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
  Meta *string `json:"meta,omitempty" xml:"meta,omitempty"`
  // name
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
  // parent_file_id
  ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
  // PunishFlag
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // Size
  Size *int64 `json:"size,omitempty" xml:"size,omitempty" maximum:"53687091200" minimum:"0"`
  // starred
  // type: boolean
  Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // @Deprecated streams url info
  StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // trashed_at
  TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
  // type
  Type *string `json:"type,omitempty" xml:"type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // upload_id
  UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
  // user_meta
  UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
  VideoMediaMetadata *VideoMediaResponse `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
  VideoPreviewMetadata *VideoPreviewResponse `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s UpdateFileMetaResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateFileMetaResponse) GoString() string {
  return s.String()
}

func (s *UpdateFileMetaResponse) SetCategory(v string) *UpdateFileMetaResponse {
  s.Category = &v
  return s
}

func (s *UpdateFileMetaResponse) SetCharacteristicHash(v string) *UpdateFileMetaResponse {
  s.CharacteristicHash = &v
  return s
}

func (s *UpdateFileMetaResponse) SetContentHash(v string) *UpdateFileMetaResponse {
  s.ContentHash = &v
  return s
}

func (s *UpdateFileMetaResponse) SetContentHashName(v string) *UpdateFileMetaResponse {
  s.ContentHashName = &v
  return s
}

func (s *UpdateFileMetaResponse) SetContentType(v string) *UpdateFileMetaResponse {
  s.ContentType = &v
  return s
}

func (s *UpdateFileMetaResponse) SetCrc64Hash(v string) *UpdateFileMetaResponse {
  s.Crc64Hash = &v
  return s
}

func (s *UpdateFileMetaResponse) SetCreatedAt(v string) *UpdateFileMetaResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateFileMetaResponse) SetDescription(v string) *UpdateFileMetaResponse {
  s.Description = &v
  return s
}

func (s *UpdateFileMetaResponse) SetDomainId(v string) *UpdateFileMetaResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetDownloadUrl(v string) *UpdateFileMetaResponse {
  s.DownloadUrl = &v
  return s
}

func (s *UpdateFileMetaResponse) SetDriveId(v string) *UpdateFileMetaResponse {
  s.DriveId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetEncryptMode(v string) *UpdateFileMetaResponse {
  s.EncryptMode = &v
  return s
}

func (s *UpdateFileMetaResponse) SetFileExtension(v string) *UpdateFileMetaResponse {
  s.FileExtension = &v
  return s
}

func (s *UpdateFileMetaResponse) SetFileId(v string) *UpdateFileMetaResponse {
  s.FileId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetHidden(v bool) *UpdateFileMetaResponse {
  s.Hidden = &v
  return s
}

func (s *UpdateFileMetaResponse) SetImageMediaMetadata(v *ImageMediaResponse) *UpdateFileMetaResponse {
  s.ImageMediaMetadata = v
  return s
}

func (s *UpdateFileMetaResponse) SetLabels(v []*string) *UpdateFileMetaResponse {
  s.Labels = v
  return s
}

func (s *UpdateFileMetaResponse) SetLastModifierId(v string) *UpdateFileMetaResponse {
  s.LastModifierId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetLastModifierName(v string) *UpdateFileMetaResponse {
  s.LastModifierName = &v
  return s
}

func (s *UpdateFileMetaResponse) SetLastModifierType(v string) *UpdateFileMetaResponse {
  s.LastModifierType = &v
  return s
}

func (s *UpdateFileMetaResponse) SetMeta(v string) *UpdateFileMetaResponse {
  s.Meta = &v
  return s
}

func (s *UpdateFileMetaResponse) SetName(v string) *UpdateFileMetaResponse {
  s.Name = &v
  return s
}

func (s *UpdateFileMetaResponse) SetParentFileId(v string) *UpdateFileMetaResponse {
  s.ParentFileId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetPunishFlag(v int64) *UpdateFileMetaResponse {
  s.PunishFlag = &v
  return s
}

func (s *UpdateFileMetaResponse) SetShareId(v string) *UpdateFileMetaResponse {
  s.ShareId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetSize(v int64) *UpdateFileMetaResponse {
  s.Size = &v
  return s
}

func (s *UpdateFileMetaResponse) SetStarred(v bool) *UpdateFileMetaResponse {
  s.Starred = &v
  return s
}

func (s *UpdateFileMetaResponse) SetStatus(v string) *UpdateFileMetaResponse {
  s.Status = &v
  return s
}

func (s *UpdateFileMetaResponse) SetStreamsInfo(v map[string]interface{}) *UpdateFileMetaResponse {
  s.StreamsInfo = v
  return s
}

func (s *UpdateFileMetaResponse) SetThumbnail(v string) *UpdateFileMetaResponse {
  s.Thumbnail = &v
  return s
}

func (s *UpdateFileMetaResponse) SetTrashedAt(v string) *UpdateFileMetaResponse {
  s.TrashedAt = &v
  return s
}

func (s *UpdateFileMetaResponse) SetType(v string) *UpdateFileMetaResponse {
  s.Type = &v
  return s
}

func (s *UpdateFileMetaResponse) SetUpdatedAt(v string) *UpdateFileMetaResponse {
  s.UpdatedAt = &v
  return s
}

func (s *UpdateFileMetaResponse) SetUploadId(v string) *UpdateFileMetaResponse {
  s.UploadId = &v
  return s
}

func (s *UpdateFileMetaResponse) SetUrl(v string) *UpdateFileMetaResponse {
  s.Url = &v
  return s
}

func (s *UpdateFileMetaResponse) SetUserMeta(v string) *UpdateFileMetaResponse {
  s.UserMeta = &v
  return s
}

func (s *UpdateFileMetaResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *UpdateFileMetaResponse {
  s.VideoMediaMetadata = v
  return s
}

func (s *UpdateFileMetaResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *UpdateFileMetaResponse {
  s.VideoPreviewMetadata = v
  return s
}

/**
 * update_share_link request
 */
type UpdateShareLinkRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty" maximum:"64" minimum:"0"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s UpdateShareLinkRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareLinkRequest) GoString() string {
  return s.String()
}

func (s *UpdateShareLinkRequest) SetHeaders(v map[string]*string) *UpdateShareLinkRequest {
  s.Headers = v
  return s
}

func (s *UpdateShareLinkRequest) SetDescription(v string) *UpdateShareLinkRequest {
  s.Description = &v
  return s
}

func (s *UpdateShareLinkRequest) SetExpiration(v string) *UpdateShareLinkRequest {
  s.Expiration = &v
  return s
}

func (s *UpdateShareLinkRequest) SetShareId(v string) *UpdateShareLinkRequest {
  s.ShareId = &v
  return s
}

func (s *UpdateShareLinkRequest) SetShareName(v string) *UpdateShareLinkRequest {
  s.ShareName = &v
  return s
}

func (s *UpdateShareLinkRequest) SetSharePwd(v string) *UpdateShareLinkRequest {
  s.SharePwd = &v
  return s
}

func (s *UpdateShareLinkRequest) SetStatus(v string) *UpdateShareLinkRequest {
  s.Status = &v
  return s
}

/**
 * update_share_link response
 */
type UpdateShareLinkResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // file_id_list
  FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
  // file_id_list
  FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
  // preview_count
  PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
  // 
  SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_msg
  ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_policy
  SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
  // share_pwd
  SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
  // share_url
  ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s UpdateShareLinkResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareLinkResponse) GoString() string {
  return s.String()
}

func (s *UpdateShareLinkResponse) SetCreatedAt(v string) *UpdateShareLinkResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateShareLinkResponse) SetCreator(v string) *UpdateShareLinkResponse {
  s.Creator = &v
  return s
}

func (s *UpdateShareLinkResponse) SetDescription(v string) *UpdateShareLinkResponse {
  s.Description = &v
  return s
}

func (s *UpdateShareLinkResponse) SetDownloadCount(v int64) *UpdateShareLinkResponse {
  s.DownloadCount = &v
  return s
}

func (s *UpdateShareLinkResponse) SetDriveId(v string) *UpdateShareLinkResponse {
  s.DriveId = &v
  return s
}

func (s *UpdateShareLinkResponse) SetExpiration(v string) *UpdateShareLinkResponse {
  s.Expiration = &v
  return s
}

func (s *UpdateShareLinkResponse) SetExpired(v bool) *UpdateShareLinkResponse {
  s.Expired = &v
  return s
}

func (s *UpdateShareLinkResponse) SetFileId(v string) *UpdateShareLinkResponse {
  s.FileId = &v
  return s
}

func (s *UpdateShareLinkResponse) SetFileIdList(v []*string) *UpdateShareLinkResponse {
  s.FileIdList = v
  return s
}

func (s *UpdateShareLinkResponse) SetFilePathList(v []*string) *UpdateShareLinkResponse {
  s.FilePathList = v
  return s
}

func (s *UpdateShareLinkResponse) SetPreviewCount(v int64) *UpdateShareLinkResponse {
  s.PreviewCount = &v
  return s
}

func (s *UpdateShareLinkResponse) SetSaveCount(v int64) *UpdateShareLinkResponse {
  s.SaveCount = &v
  return s
}

func (s *UpdateShareLinkResponse) SetShareId(v string) *UpdateShareLinkResponse {
  s.ShareId = &v
  return s
}

func (s *UpdateShareLinkResponse) SetShareMsg(v string) *UpdateShareLinkResponse {
  s.ShareMsg = &v
  return s
}

func (s *UpdateShareLinkResponse) SetShareName(v string) *UpdateShareLinkResponse {
  s.ShareName = &v
  return s
}

func (s *UpdateShareLinkResponse) SetSharePolicy(v string) *UpdateShareLinkResponse {
  s.SharePolicy = &v
  return s
}

func (s *UpdateShareLinkResponse) SetSharePwd(v string) *UpdateShareLinkResponse {
  s.SharePwd = &v
  return s
}

func (s *UpdateShareLinkResponse) SetShareUrl(v string) *UpdateShareLinkResponse {
  s.ShareUrl = &v
  return s
}

func (s *UpdateShareLinkResponse) SetStatus(v string) *UpdateShareLinkResponse {
  s.Status = &v
  return s
}

func (s *UpdateShareLinkResponse) SetUpdatedAt(v string) *UpdateShareLinkResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * update share request
 */
type UpdateShareRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // permissions
  Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  // share_policy
  SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s UpdateShareRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareRequest) GoString() string {
  return s.String()
}

func (s *UpdateShareRequest) SetHeaders(v map[string]*string) *UpdateShareRequest {
  s.Headers = v
  return s
}

func (s *UpdateShareRequest) SetDescription(v string) *UpdateShareRequest {
  s.Description = &v
  return s
}

func (s *UpdateShareRequest) SetExpiration(v string) *UpdateShareRequest {
  s.Expiration = &v
  return s
}

func (s *UpdateShareRequest) SetPermissions(v []*string) *UpdateShareRequest {
  s.Permissions = v
  return s
}

func (s *UpdateShareRequest) SetShareId(v string) *UpdateShareRequest {
  s.ShareId = &v
  return s
}

func (s *UpdateShareRequest) SetShareName(v string) *UpdateShareRequest {
  s.ShareName = &v
  return s
}

func (s *UpdateShareRequest) SetSharePolicy(v []*SharePermissionPolicy) *UpdateShareRequest {
  s.SharePolicy = v
  return s
}

func (s *UpdateShareRequest) SetStatus(v string) *UpdateShareRequest {
  s.Status = &v
  return s
}

/**
 * Update share response
 */
type UpdateShareResponse struct {
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // creator
  Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain_id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // expiration
  Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
  // expired
  Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
  // owner
  Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
  // owner
  OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
  // permissions
  Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
  // share_file_id
  ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
  // share_path
  ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
  // share_id
  ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
  // share_name
  ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
  SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s UpdateShareResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateShareResponse) GoString() string {
  return s.String()
}

func (s *UpdateShareResponse) SetCreatedAt(v string) *UpdateShareResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateShareResponse) SetCreator(v string) *UpdateShareResponse {
  s.Creator = &v
  return s
}

func (s *UpdateShareResponse) SetDescription(v string) *UpdateShareResponse {
  s.Description = &v
  return s
}

func (s *UpdateShareResponse) SetDomainId(v string) *UpdateShareResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateShareResponse) SetDriveId(v string) *UpdateShareResponse {
  s.DriveId = &v
  return s
}

func (s *UpdateShareResponse) SetExpiration(v string) *UpdateShareResponse {
  s.Expiration = &v
  return s
}

func (s *UpdateShareResponse) SetExpired(v bool) *UpdateShareResponse {
  s.Expired = &v
  return s
}

func (s *UpdateShareResponse) SetOwner(v string) *UpdateShareResponse {
  s.Owner = &v
  return s
}

func (s *UpdateShareResponse) SetOwnerType(v string) *UpdateShareResponse {
  s.OwnerType = &v
  return s
}

func (s *UpdateShareResponse) SetPermissions(v []*string) *UpdateShareResponse {
  s.Permissions = v
  return s
}

func (s *UpdateShareResponse) SetShareFileId(v string) *UpdateShareResponse {
  s.ShareFileId = &v
  return s
}

func (s *UpdateShareResponse) SetShareFilePath(v string) *UpdateShareResponse {
  s.ShareFilePath = &v
  return s
}

func (s *UpdateShareResponse) SetShareId(v string) *UpdateShareResponse {
  s.ShareId = &v
  return s
}

func (s *UpdateShareResponse) SetShareName(v string) *UpdateShareResponse {
  s.ShareName = &v
  return s
}

func (s *UpdateShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *UpdateShareResponse {
  s.SharePolicy = v
  return s
}

func (s *UpdateShareResponse) SetStatus(v string) *UpdateShareResponse {
  s.Status = &v
  return s
}

func (s *UpdateShareResponse) SetUpdatedAt(v string) *UpdateShareResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type UploadPartInfo struct {
  // content_type
  ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
  // etag
  Etag *string `json:"etag,omitempty" xml:"etag,omitempty"`
  // internal_upload_url
  InternalUploadUrl *string `json:"internal_upload_url,omitempty" xml:"internal_upload_url,omitempty"`
  ParallelSha1Ctx *SHA1CTX `json:"parallel_sha1_ctx,omitempty" xml:"parallel_sha1_ctx,omitempty"`
  // PartNumber
  PartNumber *int64 `json:"part_number,omitempty" xml:"part_number,omitempty" maximum:"10000" minimum:"1"`
  // PartSize
  PartSize *int64 `json:"part_size,omitempty" xml:"part_size,omitempty" maximum:"5368709120"`
  // upload_url
  UploadUrl *string `json:"upload_url,omitempty" xml:"upload_url,omitempty"`
}

func (s UploadPartInfo) String() string {
  return tea.Prettify(s)
}

func (s UploadPartInfo) GoString() string {
  return s.String()
}

func (s *UploadPartInfo) SetContentType(v string) *UploadPartInfo {
  s.ContentType = &v
  return s
}

func (s *UploadPartInfo) SetEtag(v string) *UploadPartInfo {
  s.Etag = &v
  return s
}

func (s *UploadPartInfo) SetInternalUploadUrl(v string) *UploadPartInfo {
  s.InternalUploadUrl = &v
  return s
}

func (s *UploadPartInfo) SetParallelSha1Ctx(v *SHA1CTX) *UploadPartInfo {
  s.ParallelSha1Ctx = v
  return s
}

func (s *UploadPartInfo) SetPartNumber(v int64) *UploadPartInfo {
  s.PartNumber = &v
  return s
}

func (s *UploadPartInfo) SetPartSize(v int64) *UploadPartInfo {
  s.PartSize = &v
  return s
}

func (s *UploadPartInfo) SetUploadUrl(v string) *UploadPartInfo {
  s.UploadUrl = &v
  return s
}

/**
 * 
 */
type UrlInfo struct {
  // download_url
  DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // url
  Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s UrlInfo) String() string {
  return tea.Prettify(s)
}

func (s UrlInfo) GoString() string {
  return s.String()
}

func (s *UrlInfo) SetDownloadUrl(v string) *UrlInfo {
  s.DownloadUrl = &v
  return s
}

func (s *UrlInfo) SetThumbnail(v string) *UrlInfo {
  s.Thumbnail = &v
  return s
}

func (s *UrlInfo) SetUrl(v string) *UrlInfo {
  s.Url = &v
  return s
}

/**
 * 
 */
type UserAuthentication struct {
  // 
  AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty" require:"true"`
  // 
  CreatedAt *int64 `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty" require:"true"`
  // 
  Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty" require:"true"`
  // Domain ID
  DomainID *string `json:"DomainID,omitempty" xml:"DomainID,omitempty" require:"true"`
  // 
  Identity *string `json:"Identity,omitempty" xml:"Identity,omitempty" require:"true"`
  // 
  LastLoginTime *int64 `json:"LastLoginTime,omitempty" xml:"LastLoginTime,omitempty" require:"true"`
  // 
  Status *string `json:"Status,omitempty" xml:"Status,omitempty" require:"true"`
  // ID
  UserID *string `json:"UserID,omitempty" xml:"UserID,omitempty" require:"true"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s UserAuthentication) String() string {
  return tea.Prettify(s)
}

func (s UserAuthentication) GoString() string {
  return s.String()
}

func (s *UserAuthentication) SetAuthenticationType(v string) *UserAuthentication {
  s.AuthenticationType = &v
  return s
}

func (s *UserAuthentication) SetCreatedAt(v int64) *UserAuthentication {
  s.CreatedAt = &v
  return s
}

func (s *UserAuthentication) SetDetail(v string) *UserAuthentication {
  s.Detail = &v
  return s
}

func (s *UserAuthentication) SetDomainID(v string) *UserAuthentication {
  s.DomainID = &v
  return s
}

func (s *UserAuthentication) SetIdentity(v string) *UserAuthentication {
  s.Identity = &v
  return s
}

func (s *UserAuthentication) SetLastLoginTime(v int64) *UserAuthentication {
  s.LastLoginTime = &v
  return s
}

func (s *UserAuthentication) SetStatus(v string) *UserAuthentication {
  s.Status = &v
  return s
}

func (s *UserAuthentication) SetUserID(v string) *UserAuthentication {
  s.UserID = &v
  return s
}

func (s *UserAuthentication) SetExtra(v string) *UserAuthentication {
  s.Extra = &v
  return s
}

func (s *UserAuthentication) SetSubdomainId(v string) *UserAuthentication {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type VerifyCodeRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // App ID, App
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // 
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
  // 86+
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  // 
  SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty" require:"true"`
  // ID
  SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
  // 
  VerifyType *string `json:"verify_type,omitempty" xml:"verify_type,omitempty"`
}

func (s VerifyCodeRequest) String() string {
  return tea.Prettify(s)
}

func (s VerifyCodeRequest) GoString() string {
  return s.String()
}

func (s *VerifyCodeRequest) SetHeaders(v map[string]*string) *VerifyCodeRequest {
  s.Headers = v
  return s
}

func (s *VerifyCodeRequest) SetAppId(v string) *VerifyCodeRequest {
  s.AppId = &v
  return s
}

func (s *VerifyCodeRequest) SetPhoneNumber(v string) *VerifyCodeRequest {
  s.PhoneNumber = &v
  return s
}

func (s *VerifyCodeRequest) SetPhoneRegion(v string) *VerifyCodeRequest {
  s.PhoneRegion = &v
  return s
}

func (s *VerifyCodeRequest) SetSmsCode(v string) *VerifyCodeRequest {
  s.SmsCode = &v
  return s
}

func (s *VerifyCodeRequest) SetSmsCodeId(v string) *VerifyCodeRequest {
  s.SmsCodeId = &v
  return s
}

func (s *VerifyCodeRequest) SetVerifyType(v string) *VerifyCodeRequest {
  s.VerifyType = &v
  return s
}

/**
 * 
 */
type VerifyCodeResponse struct {
  // 
  State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s VerifyCodeResponse) String() string {
  return tea.Prettify(s)
}

func (s VerifyCodeResponse) GoString() string {
  return s.String()
}

func (s *VerifyCodeResponse) SetState(v string) *VerifyCodeResponse {
  s.State = &v
  return s
}

/**
 * 
 */
type VerifyTokenResponse struct {
  // Token
  Token *string `json:"token,omitempty" xml:"token,omitempty" require:"true"`
  // token1800
  Ttl *int64 `json:"ttl,omitempty" xml:"ttl,omitempty" require:"true"`
  // URLToken
  Url *string `json:"url,omitempty" xml:"url,omitempty" require:"true"`
}

func (s VerifyTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s VerifyTokenResponse) GoString() string {
  return s.String()
}

func (s *VerifyTokenResponse) SetToken(v string) *VerifyTokenResponse {
  s.Token = &v
  return s
}

func (s *VerifyTokenResponse) SetTtl(v int64) *VerifyTokenResponse {
  s.Ttl = &v
  return s
}

func (s *VerifyTokenResponse) SetUrl(v string) *VerifyTokenResponse {
  s.Url = &v
  return s
}

/**
 * 
 */
type VideoMediaAudioStream struct {
  // bit_rate  bps
  BitRate *string `json:"bit_rate,omitempty" xml:"bit_rate,omitempty"`
  // channel_layout 
  ChannelLayout *string `json:"channel_layout,omitempty" xml:"channel_layout,omitempty"`
  // channels /
  Channels *int64 `json:"channels,omitempty" xml:"channels,omitempty"`
  // code_name 
  CodeName *string `json:"code_name,omitempty" xml:"code_name,omitempty"`
  // duration  
  Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
  // sample_rate 
  SampleRate *string `json:"sample_rate,omitempty" xml:"sample_rate,omitempty"`
}

func (s VideoMediaAudioStream) String() string {
  return tea.Prettify(s)
}

func (s VideoMediaAudioStream) GoString() string {
  return s.String()
}

func (s *VideoMediaAudioStream) SetBitRate(v string) *VideoMediaAudioStream {
  s.BitRate = &v
  return s
}

func (s *VideoMediaAudioStream) SetChannelLayout(v string) *VideoMediaAudioStream {
  s.ChannelLayout = &v
  return s
}

func (s *VideoMediaAudioStream) SetChannels(v int64) *VideoMediaAudioStream {
  s.Channels = &v
  return s
}

func (s *VideoMediaAudioStream) SetCodeName(v string) *VideoMediaAudioStream {
  s.CodeName = &v
  return s
}

func (s *VideoMediaAudioStream) SetDuration(v string) *VideoMediaAudioStream {
  s.Duration = &v
  return s
}

func (s *VideoMediaAudioStream) SetSampleRate(v string) *VideoMediaAudioStream {
  s.SampleRate = &v
  return s
}

/**
 * 
 */
type VideoMediaMetadata struct {
  // Duration
  Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
}

func (s VideoMediaMetadata) String() string {
  return tea.Prettify(s)
}

func (s VideoMediaMetadata) GoString() string {
  return s.String()
}

func (s *VideoMediaMetadata) SetDuration(v string) *VideoMediaMetadata {
  s.Duration = &v
  return s
}

/**
 * 
 */
type VideoMediaResponse struct {
  // address_line
  AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
  // city
  City *string `json:"city,omitempty" xml:"city,omitempty"`
  // country
  Country *string `json:"country,omitempty" xml:"country,omitempty"`
  // district
  District *string `json:"district,omitempty" xml:"district,omitempty"`
  // duration  
  Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  // system_tags
  ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
  // location
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // province
  Province *string `json:"province,omitempty" xml:"province,omitempty"`
  // time
  Time *string `json:"time,omitempty" xml:"time,omitempty"`
  // township
  Township *string `json:"township,omitempty" xml:"township,omitempty"`
  VideoMediaAudioStream []*VideoMediaAudioStream `json:"video_media_audio_stream,omitempty" xml:"video_media_audio_stream,omitempty" type:"Repeated"`
  VideoMediaVideoStream []*VideoMediaVideoStream `json:"video_media_video_stream,omitempty" xml:"video_media_video_stream,omitempty" type:"Repeated"`
  // width
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoMediaResponse) String() string {
  return tea.Prettify(s)
}

func (s VideoMediaResponse) GoString() string {
  return s.String()
}

func (s *VideoMediaResponse) SetAddressLine(v string) *VideoMediaResponse {
  s.AddressLine = &v
  return s
}

func (s *VideoMediaResponse) SetCity(v string) *VideoMediaResponse {
  s.City = &v
  return s
}

func (s *VideoMediaResponse) SetCountry(v string) *VideoMediaResponse {
  s.Country = &v
  return s
}

func (s *VideoMediaResponse) SetDistrict(v string) *VideoMediaResponse {
  s.District = &v
  return s
}

func (s *VideoMediaResponse) SetDuration(v string) *VideoMediaResponse {
  s.Duration = &v
  return s
}

func (s *VideoMediaResponse) SetHeight(v int64) *VideoMediaResponse {
  s.Height = &v
  return s
}

func (s *VideoMediaResponse) SetImageTags(v []*SystemTag) *VideoMediaResponse {
  s.ImageTags = v
  return s
}

func (s *VideoMediaResponse) SetLocation(v string) *VideoMediaResponse {
  s.Location = &v
  return s
}

func (s *VideoMediaResponse) SetProvince(v string) *VideoMediaResponse {
  s.Province = &v
  return s
}

func (s *VideoMediaResponse) SetTime(v string) *VideoMediaResponse {
  s.Time = &v
  return s
}

func (s *VideoMediaResponse) SetTownship(v string) *VideoMediaResponse {
  s.Township = &v
  return s
}

func (s *VideoMediaResponse) SetVideoMediaAudioStream(v []*VideoMediaAudioStream) *VideoMediaResponse {
  s.VideoMediaAudioStream = v
  return s
}

func (s *VideoMediaResponse) SetVideoMediaVideoStream(v []*VideoMediaVideoStream) *VideoMediaResponse {
  s.VideoMediaVideoStream = v
  return s
}

func (s *VideoMediaResponse) SetWidth(v int64) *VideoMediaResponse {
  s.Width = &v
  return s
}

/**
 * 
 */
type VideoMediaVideoStream struct {
  // bitrate  bps
  Bitrate *string `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
  // clarity 
  Clarity *string `json:"clarity,omitempty" xml:"clarity,omitempty"`
  // code_name 
  CodeName *string `json:"code_name,omitempty" xml:"code_name,omitempty"`
  // duration  
  Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
  // fps 
  Fps *string `json:"fps,omitempty" xml:"fps,omitempty"`
  // rotate  
  Rotate *string `json:"rotate,omitempty" xml:"rotate,omitempty"`
}

func (s VideoMediaVideoStream) String() string {
  return tea.Prettify(s)
}

func (s VideoMediaVideoStream) GoString() string {
  return s.String()
}

func (s *VideoMediaVideoStream) SetBitrate(v string) *VideoMediaVideoStream {
  s.Bitrate = &v
  return s
}

func (s *VideoMediaVideoStream) SetClarity(v string) *VideoMediaVideoStream {
  s.Clarity = &v
  return s
}

func (s *VideoMediaVideoStream) SetCodeName(v string) *VideoMediaVideoStream {
  s.CodeName = &v
  return s
}

func (s *VideoMediaVideoStream) SetDuration(v string) *VideoMediaVideoStream {
  s.Duration = &v
  return s
}

func (s *VideoMediaVideoStream) SetFps(v string) *VideoMediaVideoStream {
  s.Fps = &v
  return s
}

func (s *VideoMediaVideoStream) SetRotate(v string) *VideoMediaVideoStream {
  s.Rotate = &v
  return s
}

/**
 * 
 */
type VideoPreviewAudioMeta struct {
  // bitrate
  Bitrate *float64 `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
  // channels
  Channels *int64 `json:"channels,omitempty" xml:"channels,omitempty"`
  // duration
  Duration *float64 `json:"duration,omitempty" xml:"duration,omitempty"`
  // sample_rate
  SampleRate *float64 `json:"sample_rate,omitempty" xml:"sample_rate,omitempty"`
}

func (s VideoPreviewAudioMeta) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAudioMeta) GoString() string {
  return s.String()
}

func (s *VideoPreviewAudioMeta) SetBitrate(v float64) *VideoPreviewAudioMeta {
  s.Bitrate = &v
  return s
}

func (s *VideoPreviewAudioMeta) SetChannels(v int64) *VideoPreviewAudioMeta {
  s.Channels = &v
  return s
}

func (s *VideoPreviewAudioMeta) SetDuration(v float64) *VideoPreviewAudioMeta {
  s.Duration = &v
  return s
}

func (s *VideoPreviewAudioMeta) SetSampleRate(v float64) *VideoPreviewAudioMeta {
  s.SampleRate = &v
  return s
}

/**
 * 
 */
type VideoPreviewAudioMusicMeta struct {
  // album
  Album *string `json:"album,omitempty" xml:"album,omitempty"`
  // artist
  Artist *string `json:"artist,omitempty" xml:"artist,omitempty"`
  // cover_url
  CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
  // title
  Title *string `json:"title,omitempty" xml:"title,omitempty"`
}

func (s VideoPreviewAudioMusicMeta) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAudioMusicMeta) GoString() string {
  return s.String()
}

func (s *VideoPreviewAudioMusicMeta) SetAlbum(v string) *VideoPreviewAudioMusicMeta {
  s.Album = &v
  return s
}

func (s *VideoPreviewAudioMusicMeta) SetArtist(v string) *VideoPreviewAudioMusicMeta {
  s.Artist = &v
  return s
}

func (s *VideoPreviewAudioMusicMeta) SetCoverUrl(v string) *VideoPreviewAudioMusicMeta {
  s.CoverUrl = &v
  return s
}

func (s *VideoPreviewAudioMusicMeta) SetTitle(v string) *VideoPreviewAudioMusicMeta {
  s.Title = &v
  return s
}

/**
 * meta
 */
type VideoPreviewPlayInfoMetaResponse struct {
  // duration
  Duration *float64 `json:"duration,omitempty" xml:"duration,omitempty"`
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  // witdh
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewPlayInfoMetaResponse) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewPlayInfoMetaResponse) GoString() string {
  return s.String()
}

func (s *VideoPreviewPlayInfoMetaResponse) SetDuration(v float64) *VideoPreviewPlayInfoMetaResponse {
  s.Duration = &v
  return s
}

func (s *VideoPreviewPlayInfoMetaResponse) SetHeight(v int64) *VideoPreviewPlayInfoMetaResponse {
  s.Height = &v
  return s
}

func (s *VideoPreviewPlayInfoMetaResponse) SetWidth(v int64) *VideoPreviewPlayInfoMetaResponse {
  s.Width = &v
  return s
}

/**
 * 
 */
type VideoPreviewPlayInfoResponse struct {
  // category
  Category *string `json:"category,omitempty" xml:"category,omitempty"`
  LiveTranscodingTaskList []*LiveTranscodingTaskResponse `json:"live_transcoding_task_list,omitempty" xml:"live_transcoding_task_list,omitempty" type:"Repeated"`
  Meta *VideoPreviewPlayInfoMetaResponse `json:"meta,omitempty" xml:"meta,omitempty"`
}

func (s VideoPreviewPlayInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewPlayInfoResponse) GoString() string {
  return s.String()
}

func (s *VideoPreviewPlayInfoResponse) SetCategory(v string) *VideoPreviewPlayInfoResponse {
  s.Category = &v
  return s
}

func (s *VideoPreviewPlayInfoResponse) SetLiveTranscodingTaskList(v []*LiveTranscodingTaskResponse) *VideoPreviewPlayInfoResponse {
  s.LiveTranscodingTaskList = v
  return s
}

func (s *VideoPreviewPlayInfoResponse) SetMeta(v *VideoPreviewPlayInfoMetaResponse) *VideoPreviewPlayInfoResponse {
  s.Meta = v
  return s
}

/**
 * 
 */
type VideoPreviewResponse struct {
  // audio_channels
  AudioChannels *int64 `json:"audio_channels,omitempty" xml:"audio_channels,omitempty"`
  // audio_format
  AudioFormat *string `json:"audio_format,omitempty" xml:"audio_format,omitempty"`
  AudioMeta *VideoPreviewAudioMeta `json:"audio_meta,omitempty" xml:"audio_meta,omitempty"`
  AudioMusicMeta *VideoPreviewAudioMusicMeta `json:"audio_music_meta,omitempty" xml:"audio_music_meta,omitempty"`
  // audio_sample_rate
  AudioSampleRate *string `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
  // audio_template_list
  AudioTemplateList []*VideoPreviewTranscode `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
  // bitrate
  Bitrate *string `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
  // duration
  Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
  // frame_rate
  FrameRate *string `json:"frame_rate,omitempty" xml:"frame_rate,omitempty"`
  // height
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  SpriteInfo *VideoPreviewSpriteResponse `json:"sprite_info,omitempty" xml:"sprite_info,omitempty"`
  // template_list
  TemplateList []*VideoPreviewTranscode `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
  // thumbnail
  Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  // video_format
  VideoFormat *string `json:"video_format,omitempty" xml:"video_format,omitempty"`
  // width
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewResponse) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewResponse) GoString() string {
  return s.String()
}

func (s *VideoPreviewResponse) SetAudioChannels(v int64) *VideoPreviewResponse {
  s.AudioChannels = &v
  return s
}

func (s *VideoPreviewResponse) SetAudioFormat(v string) *VideoPreviewResponse {
  s.AudioFormat = &v
  return s
}

func (s *VideoPreviewResponse) SetAudioMeta(v *VideoPreviewAudioMeta) *VideoPreviewResponse {
  s.AudioMeta = v
  return s
}

func (s *VideoPreviewResponse) SetAudioMusicMeta(v *VideoPreviewAudioMusicMeta) *VideoPreviewResponse {
  s.AudioMusicMeta = v
  return s
}

func (s *VideoPreviewResponse) SetAudioSampleRate(v string) *VideoPreviewResponse {
  s.AudioSampleRate = &v
  return s
}

func (s *VideoPreviewResponse) SetAudioTemplateList(v []*VideoPreviewTranscode) *VideoPreviewResponse {
  s.AudioTemplateList = v
  return s
}

func (s *VideoPreviewResponse) SetBitrate(v string) *VideoPreviewResponse {
  s.Bitrate = &v
  return s
}

func (s *VideoPreviewResponse) SetDuration(v string) *VideoPreviewResponse {
  s.Duration = &v
  return s
}

func (s *VideoPreviewResponse) SetFrameRate(v string) *VideoPreviewResponse {
  s.FrameRate = &v
  return s
}

func (s *VideoPreviewResponse) SetHeight(v int64) *VideoPreviewResponse {
  s.Height = &v
  return s
}

func (s *VideoPreviewResponse) SetSpriteInfo(v *VideoPreviewSpriteResponse) *VideoPreviewResponse {
  s.SpriteInfo = v
  return s
}

func (s *VideoPreviewResponse) SetTemplateList(v []*VideoPreviewTranscode) *VideoPreviewResponse {
  s.TemplateList = v
  return s
}

func (s *VideoPreviewResponse) SetThumbnail(v string) *VideoPreviewResponse {
  s.Thumbnail = &v
  return s
}

func (s *VideoPreviewResponse) SetVideoFormat(v string) *VideoPreviewResponse {
  s.VideoFormat = &v
  return s
}

func (s *VideoPreviewResponse) SetWidth(v int64) *VideoPreviewResponse {
  s.Width = &v
  return s
}

/**
 * 
 */
type VideoPreviewSpriteResponse struct {
  // col
  Col *int64 `json:"col,omitempty" xml:"col,omitempty"`
  // count
  Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
  // frame_count
  FrameCount *int64 `json:"frame_count,omitempty" xml:"frame_count,omitempty"`
  // frame_height
  FrameHeight *int64 `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
  // frame_width
  FrameWidth *int64 `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
  // row
  Row *int64 `json:"row,omitempty" xml:"row,omitempty"`
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s VideoPreviewSpriteResponse) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewSpriteResponse) GoString() string {
  return s.String()
}

func (s *VideoPreviewSpriteResponse) SetCol(v int64) *VideoPreviewSpriteResponse {
  s.Col = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetCount(v int64) *VideoPreviewSpriteResponse {
  s.Count = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetFrameCount(v int64) *VideoPreviewSpriteResponse {
  s.FrameCount = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetFrameHeight(v int64) *VideoPreviewSpriteResponse {
  s.FrameHeight = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetFrameWidth(v int64) *VideoPreviewSpriteResponse {
  s.FrameWidth = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetRow(v int64) *VideoPreviewSpriteResponse {
  s.Row = &v
  return s
}

func (s *VideoPreviewSpriteResponse) SetStatus(v string) *VideoPreviewSpriteResponse {
  s.Status = &v
  return s
}

/**
 * 
 */
type VideoPreviewTranscode struct {
  // status
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // template_id
  TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
}

func (s VideoPreviewTranscode) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewTranscode) GoString() string {
  return s.String()
}

func (s *VideoPreviewTranscode) SetStatus(v string) *VideoPreviewTranscode {
  s.Status = &v
  return s
}

func (s *VideoPreviewTranscode) SetTemplateId(v string) *VideoPreviewTranscode {
  s.TemplateId = &v
  return s
}

/**
 * 
 */
type AddStoreResponse struct {
  // 
  AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
  // 
  BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
  // bucket
  Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
  // 
  CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
  // 
  CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
  // 
  CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
  // Public
  CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
  // vpc
  CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // Public
  Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
  // vpc
  InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
  // 
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // systemcustom
  Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
  // Policy,systemstorebucket
  Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
  // BucketARN
  RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
  // store ID
  StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
  // oss
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s AddStoreResponse) String() string {
  return tea.Prettify(s)
}

func (s AddStoreResponse) GoString() string {
  return s.String()
}

func (s *AddStoreResponse) SetAccelerateEndpoint(v string) *AddStoreResponse {
  s.AccelerateEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetBasePath(v string) *AddStoreResponse {
  s.BasePath = &v
  return s
}

func (s *AddStoreResponse) SetBucket(v string) *AddStoreResponse {
  s.Bucket = &v
  return s
}

func (s *AddStoreResponse) SetCdnEndpoint(v string) *AddStoreResponse {
  s.CdnEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetCustomizedAccelerateEndpoint(v string) *AddStoreResponse {
  s.CustomizedAccelerateEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetCustomizedCdnEndpoint(v string) *AddStoreResponse {
  s.CustomizedCdnEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetCustomizedEndpoint(v string) *AddStoreResponse {
  s.CustomizedEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetCustomizedInternalEndpoint(v string) *AddStoreResponse {
  s.CustomizedInternalEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetDomainId(v string) *AddStoreResponse {
  s.DomainId = &v
  return s
}

func (s *AddStoreResponse) SetEndpoint(v string) *AddStoreResponse {
  s.Endpoint = &v
  return s
}

func (s *AddStoreResponse) SetInternalEndpoint(v string) *AddStoreResponse {
  s.InternalEndpoint = &v
  return s
}

func (s *AddStoreResponse) SetLocation(v string) *AddStoreResponse {
  s.Location = &v
  return s
}

func (s *AddStoreResponse) SetOwnership(v string) *AddStoreResponse {
  s.Ownership = &v
  return s
}

func (s *AddStoreResponse) SetPolicy(v string) *AddStoreResponse {
  s.Policy = &v
  return s
}

func (s *AddStoreResponse) SetRoleArn(v string) *AddStoreResponse {
  s.RoleArn = &v
  return s
}

func (s *AddStoreResponse) SetStoreId(v string) *AddStoreResponse {
  s.StoreId = &v
  return s
}

func (s *AddStoreResponse) SetType(v string) *AddStoreResponse {
  s.Type = &v
  return s
}

/**
 * 
 */
type AdminListStoresRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AdminListStoresRequest) String() string {
  return tea.Prettify(s)
}

func (s AdminListStoresRequest) GoString() string {
  return s.String()
}

func (s *AdminListStoresRequest) SetHeaders(v map[string]*string) *AdminListStoresRequest {
  s.Headers = v
  return s
}

/**
 * base domain response
 */
type BaseDomainResponse struct {
  // Domain APICName
  ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
  // Domain AppCName
  AppCname *string `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
  //  App Id
  AuthAlipayAppId *string `json:"auth_alipay_app_id,omitempty" xml:"auth_alipay_app_id,omitempty"`
  // 
  AuthAlipayEnable *bool `json:"auth_alipay_enable,omitempty" xml:"auth_alipay_enable,omitempty"`
  //  App Secret
  AuthAlipayPrivateKey *string `json:"auth_alipay_private_key,omitempty" xml:"auth_alipay_private_key,omitempty"`
  // Domain AuthCName
  AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
  // 
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  Benefits map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
  // Domain 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  // domain
  ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  //  Drive  Store ID
  InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
  // Domain 
  Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
  OfficePreviewConfig *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
  // Domain 
  PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
  // 
  PrepaidPackage *string `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // Domain ServiceCode
  ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
  // 
  ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
  // 
  SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
  // SPI  id
  SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
  // domain
  Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
  // 
  StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
  //  Region 
  StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
  // Domain 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // 
  UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
  VideoPreviewConfig *VideoPreviewConfig `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
}

func (s BaseDomainResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseDomainResponse) GoString() string {
  return s.String()
}

func (s *BaseDomainResponse) SetApiCname(v string) *BaseDomainResponse {
  s.ApiCname = &v
  return s
}

func (s *BaseDomainResponse) SetAppCname(v string) *BaseDomainResponse {
  s.AppCname = &v
  return s
}

func (s *BaseDomainResponse) SetAuthAlipayAppId(v string) *BaseDomainResponse {
  s.AuthAlipayAppId = &v
  return s
}

func (s *BaseDomainResponse) SetAuthAlipayEnable(v bool) *BaseDomainResponse {
  s.AuthAlipayEnable = &v
  return s
}

func (s *BaseDomainResponse) SetAuthAlipayPrivateKey(v string) *BaseDomainResponse {
  s.AuthAlipayPrivateKey = &v
  return s
}

func (s *BaseDomainResponse) SetAuthCname(v string) *BaseDomainResponse {
  s.AuthCname = &v
  return s
}

func (s *BaseDomainResponse) SetAuthConfig(v map[string]interface{}) *BaseDomainResponse {
  s.AuthConfig = v
  return s
}

func (s *BaseDomainResponse) SetAuthDingdingAppId(v string) *BaseDomainResponse {
  s.AuthDingdingAppId = &v
  return s
}

func (s *BaseDomainResponse) SetAuthDingdingAppSecret(v string) *BaseDomainResponse {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *BaseDomainResponse) SetAuthDingdingEnable(v bool) *BaseDomainResponse {
  s.AuthDingdingEnable = &v
  return s
}

func (s *BaseDomainResponse) SetAuthEndpointEnable(v bool) *BaseDomainResponse {
  s.AuthEndpointEnable = &v
  return s
}

func (s *BaseDomainResponse) SetAuthRamAppId(v string) *BaseDomainResponse {
  s.AuthRamAppId = &v
  return s
}

func (s *BaseDomainResponse) SetAuthRamAppSecret(v string) *BaseDomainResponse {
  s.AuthRamAppSecret = &v
  return s
}

func (s *BaseDomainResponse) SetAuthRamEnable(v bool) *BaseDomainResponse {
  s.AuthRamEnable = &v
  return s
}

func (s *BaseDomainResponse) SetBenefits(v map[string]interface{}) *BaseDomainResponse {
  s.Benefits = v
  return s
}

func (s *BaseDomainResponse) SetCreatedAt(v string) *BaseDomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseDomainResponse) SetDataHashName(v string) *BaseDomainResponse {
  s.DataHashName = &v
  return s
}

func (s *BaseDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *BaseDomainResponse {
  s.DefaultSuperAdminConfig = v
  return s
}

func (s *BaseDomainResponse) SetDescription(v string) *BaseDomainResponse {
  s.Description = &v
  return s
}

func (s *BaseDomainResponse) SetDomainId(v string) *BaseDomainResponse {
  s.DomainId = &v
  return s
}

func (s *BaseDomainResponse) SetDomainName(v string) *BaseDomainResponse {
  s.DomainName = &v
  return s
}

func (s *BaseDomainResponse) SetEventFilenameMatches(v string) *BaseDomainResponse {
  s.EventFilenameMatches = &v
  return s
}

func (s *BaseDomainResponse) SetEventMnsEndpoint(v string) *BaseDomainResponse {
  s.EventMnsEndpoint = &v
  return s
}

func (s *BaseDomainResponse) SetEventMnsTopic(v string) *BaseDomainResponse {
  s.EventMnsTopic = &v
  return s
}

func (s *BaseDomainResponse) SetEventNames(v []*string) *BaseDomainResponse {
  s.EventNames = v
  return s
}

func (s *BaseDomainResponse) SetEventRoleArn(v string) *BaseDomainResponse {
  s.EventRoleArn = &v
  return s
}

func (s *BaseDomainResponse) SetExpireTime(v int64) *BaseDomainResponse {
  s.ExpireTime = &v
  return s
}

func (s *BaseDomainResponse) SetInitDriveEnable(v bool) *BaseDomainResponse {
  s.InitDriveEnable = &v
  return s
}

func (s *BaseDomainResponse) SetInitDriveSize(v int64) *BaseDomainResponse {
  s.InitDriveSize = &v
  return s
}

func (s *BaseDomainResponse) SetInitDriveStoreId(v string) *BaseDomainResponse {
  s.InitDriveStoreId = &v
  return s
}

func (s *BaseDomainResponse) SetMode(v string) *BaseDomainResponse {
  s.Mode = &v
  return s
}

func (s *BaseDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *BaseDomainResponse {
  s.OfficePreviewConfig = v
  return s
}

func (s *BaseDomainResponse) SetPathType(v string) *BaseDomainResponse {
  s.PathType = &v
  return s
}

func (s *BaseDomainResponse) SetPrepaidPackage(v string) *BaseDomainResponse {
  s.PrepaidPackage = &v
  return s
}

func (s *BaseDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *BaseDomainResponse {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *BaseDomainResponse) SetServiceCode(v string) *BaseDomainResponse {
  s.ServiceCode = &v
  return s
}

func (s *BaseDomainResponse) SetSharable(v bool) *BaseDomainResponse {
  s.Sharable = &v
  return s
}

func (s *BaseDomainResponse) SetShareLinkEnabled(v bool) *BaseDomainResponse {
  s.ShareLinkEnabled = &v
  return s
}

func (s *BaseDomainResponse) SetSizeQuota(v int64) *BaseDomainResponse {
  s.SizeQuota = &v
  return s
}

func (s *BaseDomainResponse) SetSpiInstanceId(v string) *BaseDomainResponse {
  s.SpiInstanceId = &v
  return s
}

func (s *BaseDomainResponse) SetStatus(v int64) *BaseDomainResponse {
  s.Status = &v
  return s
}

func (s *BaseDomainResponse) SetStoreLevel(v string) *BaseDomainResponse {
  s.StoreLevel = &v
  return s
}

func (s *BaseDomainResponse) SetStoreRegionList(v []*string) *BaseDomainResponse {
  s.StoreRegionList = v
  return s
}

func (s *BaseDomainResponse) SetUpdatedAt(v string) *BaseDomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseDomainResponse) SetUserCountQuota(v int64) *BaseDomainResponse {
  s.UserCountQuota = &v
  return s
}

func (s *BaseDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *BaseDomainResponse {
  s.VideoPreviewConfig = v
  return s
}

/**
 * 
 */
type BaseSubdomainResponse struct {
  // 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" require:"true"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
  // quota-1
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty" require:"true"`
  // 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
  // quota-1
  UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty" require:"true"`
}

func (s BaseSubdomainResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseSubdomainResponse) GoString() string {
  return s.String()
}

func (s *BaseSubdomainResponse) SetCreatedAt(v string) *BaseSubdomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseSubdomainResponse) SetDescription(v string) *BaseSubdomainResponse {
  s.Description = &v
  return s
}

func (s *BaseSubdomainResponse) SetName(v string) *BaseSubdomainResponse {
  s.Name = &v
  return s
}

func (s *BaseSubdomainResponse) SetSubdomainId(v string) *BaseSubdomainResponse {
  s.SubdomainId = &v
  return s
}

func (s *BaseSubdomainResponse) SetTotalSize(v int64) *BaseSubdomainResponse {
  s.TotalSize = &v
  return s
}

func (s *BaseSubdomainResponse) SetUpdatedAt(v string) *BaseSubdomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseSubdomainResponse) SetUserQuota(v int64) *BaseSubdomainResponse {
  s.UserQuota = &v
  return s
}

/**
 * Benefit base info of benefit package
 */
type BenefitBaseResponse struct {
  // 
  BenefitId *string `json:"benefit_id,omitempty" xml:"benefit_id,omitempty"`
  BenefitMeta *BenefitMetaResponse `json:"benefit_meta,omitempty" xml:"benefit_meta,omitempty"`
  // 
  BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s BenefitBaseResponse) String() string {
  return tea.Prettify(s)
}

func (s BenefitBaseResponse) GoString() string {
  return s.String()
}

func (s *BenefitBaseResponse) SetBenefitId(v string) *BenefitBaseResponse {
  s.BenefitId = &v
  return s
}

func (s *BenefitBaseResponse) SetBenefitMeta(v *BenefitMetaResponse) *BenefitBaseResponse {
  s.BenefitMeta = v
  return s
}

func (s *BenefitBaseResponse) SetBenefitPkgId(v string) *BenefitBaseResponse {
  s.BenefitPkgId = &v
  return s
}

func (s *BenefitBaseResponse) SetName(v string) *BenefitBaseResponse {
  s.Name = &v
  return s
}

/**
 * Benefit meta response
 */
type BenefitMetaResponse struct {
  // 
  Config *string `json:"config,omitempty" xml:"config,omitempty"`
  // 
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
  // 
  Quota *int64 `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s BenefitMetaResponse) String() string {
  return tea.Prettify(s)
}

func (s BenefitMetaResponse) GoString() string {
  return s.String()
}

func (s *BenefitMetaResponse) SetConfig(v string) *BenefitMetaResponse {
  s.Config = &v
  return s
}

func (s *BenefitMetaResponse) SetEnabled(v bool) *BenefitMetaResponse {
  s.Enabled = &v
  return s
}

func (s *BenefitMetaResponse) SetQuota(v int64) *BenefitMetaResponse {
  s.Quota = &v
  return s
}

/**
 * Benefit package delivery info
 */
type BenefitPkgDeliveryInfoResponse struct {
  // 
  Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
  // 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // is_permanentfalse
  ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  // 
  IsPermanent *bool `json:"is_permanent,omitempty" xml:"is_permanent,omitempty"`
}

func (s BenefitPkgDeliveryInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s BenefitPkgDeliveryInfoResponse) GoString() string {
  return s.String()
}

func (s *BenefitPkgDeliveryInfoResponse) SetAmount(v int64) *BenefitPkgDeliveryInfoResponse {
  s.Amount = &v
  return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetCreatedAt(v string) *BenefitPkgDeliveryInfoResponse {
  s.CreatedAt = &v
  return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetExpireTime(v string) *BenefitPkgDeliveryInfoResponse {
  s.ExpireTime = &v
  return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetIsPermanent(v bool) *BenefitPkgDeliveryInfoResponse {
  s.IsPermanent = &v
  return s
}

/**
 * 
 */
type CNameStatus struct {
  // binding state
  BingdingState *string `json:"bingding_state,omitempty" xml:"bingding_state,omitempty" require:"true"`
  // legal state
  LegalState *string `json:"legal_state,omitempty" xml:"legal_state,omitempty" require:"true"`
  // remark
  Remark *string `json:"remark,omitempty" xml:"remark,omitempty" require:"true"`
}

func (s CNameStatus) String() string {
  return tea.Prettify(s)
}

func (s CNameStatus) GoString() string {
  return s.String()
}

func (s *CNameStatus) SetBingdingState(v string) *CNameStatus {
  s.BingdingState = &v
  return s
}

func (s *CNameStatus) SetLegalState(v string) *CNameStatus {
  s.LegalState = &v
  return s
}

func (s *CNameStatus) SetRemark(v string) *CNameStatus {
  s.Remark = &v
  return s
}

/**
 * create domain response
 */
type CreateDomainResponse struct {
  // Domain APICName
  ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
  // Domain AppCName
  AppCname *string `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
  //  App Id
  AuthAlipayAppId *string `json:"auth_alipay_app_id,omitempty" xml:"auth_alipay_app_id,omitempty"`
  // 
  AuthAlipayEnable *bool `json:"auth_alipay_enable,omitempty" xml:"auth_alipay_enable,omitempty"`
  //  App Secret
  AuthAlipayPrivateKey *string `json:"auth_alipay_private_key,omitempty" xml:"auth_alipay_private_key,omitempty"`
  // Domain AuthCName
  AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
  // 
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  Benefits map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
  // Domain 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  // domain
  ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  //  Drive  Store ID
  InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
  // Domain 
  Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
  OfficePreviewConfig *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
  // Domain 
  PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
  // 
  PrepaidPackage *string `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // Domain ServiceCode
  ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
  // 
  ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
  // 
  SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
  // SPI  id
  SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
  // domain
  Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
  // 
  StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
  //  Region 
  StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
  // Domain 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // 
  UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
  VideoPreviewConfig *VideoPreviewConfig `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
}

func (s CreateDomainResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateDomainResponse) GoString() string {
  return s.String()
}

func (s *CreateDomainResponse) SetApiCname(v string) *CreateDomainResponse {
  s.ApiCname = &v
  return s
}

func (s *CreateDomainResponse) SetAppCname(v string) *CreateDomainResponse {
  s.AppCname = &v
  return s
}

func (s *CreateDomainResponse) SetAuthAlipayAppId(v string) *CreateDomainResponse {
  s.AuthAlipayAppId = &v
  return s
}

func (s *CreateDomainResponse) SetAuthAlipayEnable(v bool) *CreateDomainResponse {
  s.AuthAlipayEnable = &v
  return s
}

func (s *CreateDomainResponse) SetAuthAlipayPrivateKey(v string) *CreateDomainResponse {
  s.AuthAlipayPrivateKey = &v
  return s
}

func (s *CreateDomainResponse) SetAuthCname(v string) *CreateDomainResponse {
  s.AuthCname = &v
  return s
}

func (s *CreateDomainResponse) SetAuthConfig(v map[string]interface{}) *CreateDomainResponse {
  s.AuthConfig = v
  return s
}

func (s *CreateDomainResponse) SetAuthDingdingAppId(v string) *CreateDomainResponse {
  s.AuthDingdingAppId = &v
  return s
}

func (s *CreateDomainResponse) SetAuthDingdingAppSecret(v string) *CreateDomainResponse {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *CreateDomainResponse) SetAuthDingdingEnable(v bool) *CreateDomainResponse {
  s.AuthDingdingEnable = &v
  return s
}

func (s *CreateDomainResponse) SetAuthEndpointEnable(v bool) *CreateDomainResponse {
  s.AuthEndpointEnable = &v
  return s
}

func (s *CreateDomainResponse) SetAuthRamAppId(v string) *CreateDomainResponse {
  s.AuthRamAppId = &v
  return s
}

func (s *CreateDomainResponse) SetAuthRamAppSecret(v string) *CreateDomainResponse {
  s.AuthRamAppSecret = &v
  return s
}

func (s *CreateDomainResponse) SetAuthRamEnable(v bool) *CreateDomainResponse {
  s.AuthRamEnable = &v
  return s
}

func (s *CreateDomainResponse) SetBenefits(v map[string]interface{}) *CreateDomainResponse {
  s.Benefits = v
  return s
}

func (s *CreateDomainResponse) SetCreatedAt(v string) *CreateDomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *CreateDomainResponse) SetDataHashName(v string) *CreateDomainResponse {
  s.DataHashName = &v
  return s
}

func (s *CreateDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *CreateDomainResponse {
  s.DefaultSuperAdminConfig = v
  return s
}

func (s *CreateDomainResponse) SetDescription(v string) *CreateDomainResponse {
  s.Description = &v
  return s
}

func (s *CreateDomainResponse) SetDomainId(v string) *CreateDomainResponse {
  s.DomainId = &v
  return s
}

func (s *CreateDomainResponse) SetDomainName(v string) *CreateDomainResponse {
  s.DomainName = &v
  return s
}

func (s *CreateDomainResponse) SetEventFilenameMatches(v string) *CreateDomainResponse {
  s.EventFilenameMatches = &v
  return s
}

func (s *CreateDomainResponse) SetEventMnsEndpoint(v string) *CreateDomainResponse {
  s.EventMnsEndpoint = &v
  return s
}

func (s *CreateDomainResponse) SetEventMnsTopic(v string) *CreateDomainResponse {
  s.EventMnsTopic = &v
  return s
}

func (s *CreateDomainResponse) SetEventNames(v []*string) *CreateDomainResponse {
  s.EventNames = v
  return s
}

func (s *CreateDomainResponse) SetEventRoleArn(v string) *CreateDomainResponse {
  s.EventRoleArn = &v
  return s
}

func (s *CreateDomainResponse) SetExpireTime(v int64) *CreateDomainResponse {
  s.ExpireTime = &v
  return s
}

func (s *CreateDomainResponse) SetInitDriveEnable(v bool) *CreateDomainResponse {
  s.InitDriveEnable = &v
  return s
}

func (s *CreateDomainResponse) SetInitDriveSize(v int64) *CreateDomainResponse {
  s.InitDriveSize = &v
  return s
}

func (s *CreateDomainResponse) SetInitDriveStoreId(v string) *CreateDomainResponse {
  s.InitDriveStoreId = &v
  return s
}

func (s *CreateDomainResponse) SetMode(v string) *CreateDomainResponse {
  s.Mode = &v
  return s
}

func (s *CreateDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *CreateDomainResponse {
  s.OfficePreviewConfig = v
  return s
}

func (s *CreateDomainResponse) SetPathType(v string) *CreateDomainResponse {
  s.PathType = &v
  return s
}

func (s *CreateDomainResponse) SetPrepaidPackage(v string) *CreateDomainResponse {
  s.PrepaidPackage = &v
  return s
}

func (s *CreateDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *CreateDomainResponse {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *CreateDomainResponse) SetServiceCode(v string) *CreateDomainResponse {
  s.ServiceCode = &v
  return s
}

func (s *CreateDomainResponse) SetSharable(v bool) *CreateDomainResponse {
  s.Sharable = &v
  return s
}

func (s *CreateDomainResponse) SetShareLinkEnabled(v bool) *CreateDomainResponse {
  s.ShareLinkEnabled = &v
  return s
}

func (s *CreateDomainResponse) SetSizeQuota(v int64) *CreateDomainResponse {
  s.SizeQuota = &v
  return s
}

func (s *CreateDomainResponse) SetSpiInstanceId(v string) *CreateDomainResponse {
  s.SpiInstanceId = &v
  return s
}

func (s *CreateDomainResponse) SetStatus(v int64) *CreateDomainResponse {
  s.Status = &v
  return s
}

func (s *CreateDomainResponse) SetStoreLevel(v string) *CreateDomainResponse {
  s.StoreLevel = &v
  return s
}

func (s *CreateDomainResponse) SetStoreRegionList(v []*string) *CreateDomainResponse {
  s.StoreRegionList = v
  return s
}

func (s *CreateDomainResponse) SetUpdatedAt(v string) *CreateDomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *CreateDomainResponse) SetUserCountQuota(v int64) *CreateDomainResponse {
  s.UserCountQuota = &v
  return s
}

func (s *CreateDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *CreateDomainResponse {
  s.VideoPreviewConfig = v
  return s
}

/**
 * 
 */
type CreateSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // subdomain
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
  // quota-1
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
  // quota-1
  UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty"`
}

func (s CreateSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateSubdomainRequest) GoString() string {
  return s.String()
}

func (s *CreateSubdomainRequest) SetHeaders(v map[string]*string) *CreateSubdomainRequest {
  s.Headers = v
  return s
}

func (s *CreateSubdomainRequest) SetDescription(v string) *CreateSubdomainRequest {
  s.Description = &v
  return s
}

func (s *CreateSubdomainRequest) SetName(v string) *CreateSubdomainRequest {
  s.Name = &v
  return s
}

func (s *CreateSubdomainRequest) SetTotalSize(v int64) *CreateSubdomainRequest {
  s.TotalSize = &v
  return s
}

func (s *CreateSubdomainRequest) SetUserQuota(v int64) *CreateSubdomainRequest {
  s.UserQuota = &v
  return s
}

/**
 * 
 */
type CreateSubdomainResponse struct {
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s CreateSubdomainResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateSubdomainResponse) GoString() string {
  return s.String()
}

func (s *CreateSubdomainResponse) SetSubdomainId(v string) *CreateSubdomainResponse {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type DataCName struct {
  // datacname
  DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
  // data location
  Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s DataCName) String() string {
  return tea.Prettify(s)
}

func (s DataCName) GoString() string {
  return s.String()
}

func (s *DataCName) SetDataCname(v string) *DataCName {
  s.DataCname = &v
  return s
}

func (s *DataCName) SetLocation(v string) *DataCName {
  s.Location = &v
  return s
}

/**
 * 
 */
type DeleteSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s DeleteSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteSubdomainRequest) GoString() string {
  return s.String()
}

func (s *DeleteSubdomainRequest) SetHeaders(v map[string]*string) *DeleteSubdomainRequest {
  s.Headers = v
  return s
}

func (s *DeleteSubdomainRequest) SetSubdomainId(v string) *DeleteSubdomainRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type DeleteSubdomainResponse struct {
}

func (s DeleteSubdomainResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteSubdomainResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type DomainCNameResponse struct {
  // data cname list
  DataCnameList []*DataCName `json:"data_cname_list,omitempty" xml:"data_cname_list,omitempty" require:"true" type:"Repeated"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s DomainCNameResponse) String() string {
  return tea.Prettify(s)
}

func (s DomainCNameResponse) GoString() string {
  return s.String()
}

func (s *DomainCNameResponse) SetDataCnameList(v []*DataCName) *DomainCNameResponse {
  s.DataCnameList = v
  return s
}

func (s *DomainCNameResponse) SetDomainId(v string) *DomainCNameResponse {
  s.DomainId = &v
  return s
}

/**
 * 
 */
type DomainSuperAdminConfig struct {
  PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
  PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s DomainSuperAdminConfig) String() string {
  return tea.Prettify(s)
}

func (s DomainSuperAdminConfig) GoString() string {
  return s.String()
}

func (s *DomainSuperAdminConfig) SetPhoneNumber(v string) *DomainSuperAdminConfig {
  s.PhoneNumber = &v
  return s
}

func (s *DomainSuperAdminConfig) SetPhoneRegion(v string) *DomainSuperAdminConfig {
  s.PhoneRegion = &v
  return s
}

func (s *DomainSuperAdminConfig) SetUserId(v string) *DomainSuperAdminConfig {
  s.UserId = &v
  return s
}

/**
 * 
 */
type GetAppPublicKeyResponse struct {
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // RSA, PEM
  PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s GetAppPublicKeyResponse) String() string {
  return tea.Prettify(s)
}

func (s GetAppPublicKeyResponse) GoString() string {
  return s.String()
}

func (s *GetAppPublicKeyResponse) SetAppId(v string) *GetAppPublicKeyResponse {
  s.AppId = &v
  return s
}

func (s *GetAppPublicKeyResponse) SetPublicKey(v string) *GetAppPublicKeyResponse {
  s.PublicKey = &v
  return s
}

/**
 * 
 */
type GetAppResponse struct {
  // App 
  AliOwnerId *string `json:"ali_owner_id,omitempty" xml:"ali_owner_id,omitempty" require:"true"`
  // App ID
  AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
  // App
  AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" require:"true" maxLength:"128" minLength:"1" pattern:"[0-9a-zA-Z]+"`
  // App 
  AppSecret *string `json:"app_secret,omitempty" xml:"app_secret,omitempty" require:"true"`
  // App 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
  // App
  Description *string `json:"description,omitempty" xml:"description,omitempty" require:"true" maxLength:"128" minLength:"0"`
  // App
  Logo *string `json:"logo,omitempty" xml:"logo,omitempty" require:"true"`
  // App 
  Provider *string `json:"provider,omitempty" xml:"provider,omitempty" require:"true"`
  // App
  RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty" require:"true"`
  // App
  Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" require:"true" type:"Repeated"`
  // App 
  Screenshots []*string `json:"screenshots,omitempty" xml:"screenshots,omitempty" require:"true" type:"Repeated"`
  // App 
  Stage *string `json:"stage,omitempty" xml:"stage,omitempty" require:"true"`
  // App
  Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
  // App 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
}

func (s GetAppResponse) String() string {
  return tea.Prettify(s)
}

func (s GetAppResponse) GoString() string {
  return s.String()
}

func (s *GetAppResponse) SetAliOwnerId(v string) *GetAppResponse {
  s.AliOwnerId = &v
  return s
}

func (s *GetAppResponse) SetAppId(v string) *GetAppResponse {
  s.AppId = &v
  return s
}

func (s *GetAppResponse) SetAppName(v string) *GetAppResponse {
  s.AppName = &v
  return s
}

func (s *GetAppResponse) SetAppSecret(v string) *GetAppResponse {
  s.AppSecret = &v
  return s
}

func (s *GetAppResponse) SetCreatedAt(v string) *GetAppResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetAppResponse) SetDescription(v string) *GetAppResponse {
  s.Description = &v
  return s
}

func (s *GetAppResponse) SetLogo(v string) *GetAppResponse {
  s.Logo = &v
  return s
}

func (s *GetAppResponse) SetProvider(v string) *GetAppResponse {
  s.Provider = &v
  return s
}

func (s *GetAppResponse) SetRedirectUri(v string) *GetAppResponse {
  s.RedirectUri = &v
  return s
}

func (s *GetAppResponse) SetScope(v []*string) *GetAppResponse {
  s.Scope = v
  return s
}

func (s *GetAppResponse) SetScreenshots(v []*string) *GetAppResponse {
  s.Screenshots = v
  return s
}

func (s *GetAppResponse) SetStage(v string) *GetAppResponse {
  s.Stage = &v
  return s
}

func (s *GetAppResponse) SetType(v string) *GetAppResponse {
  s.Type = &v
  return s
}

func (s *GetAppResponse) SetUpdatedAt(v string) *GetAppResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type GetBizCNameInfoResponse struct {
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  // cert name
  CertId *string `json:"cert_id,omitempty" xml:"cert_id,omitempty"`
  // cert name
  CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty"`
  CnameStatus *CNameStatus `json:"cname_status,omitempty" xml:"cname_status,omitempty"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // is vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s GetBizCNameInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s GetBizCNameInfoResponse) GoString() string {
  return s.String()
}

func (s *GetBizCNameInfoResponse) SetBizCname(v string) *GetBizCNameInfoResponse {
  s.BizCname = &v
  return s
}

func (s *GetBizCNameInfoResponse) SetCertId(v string) *GetBizCNameInfoResponse {
  s.CertId = &v
  return s
}

func (s *GetBizCNameInfoResponse) SetCertName(v string) *GetBizCNameInfoResponse {
  s.CertName = &v
  return s
}

func (s *GetBizCNameInfoResponse) SetCnameStatus(v *CNameStatus) *GetBizCNameInfoResponse {
  s.CnameStatus = v
  return s
}

func (s *GetBizCNameInfoResponse) SetCnameType(v string) *GetBizCNameInfoResponse {
  s.CnameType = &v
  return s
}

func (s *GetBizCNameInfoResponse) SetDomainId(v string) *GetBizCNameInfoResponse {
  s.DomainId = &v
  return s
}

func (s *GetBizCNameInfoResponse) SetIsVpc(v bool) *GetBizCNameInfoResponse {
  s.IsVpc = &v
  return s
}

/**
 * get domain response
 */
type GetDomainResponse struct {
  // Domain APICName
  ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
  // Domain AppCName
  AppCname *string `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
  //  App Id
  AuthAlipayAppId *string `json:"auth_alipay_app_id,omitempty" xml:"auth_alipay_app_id,omitempty"`
  // 
  AuthAlipayEnable *bool `json:"auth_alipay_enable,omitempty" xml:"auth_alipay_enable,omitempty"`
  //  App Secret
  AuthAlipayPrivateKey *string `json:"auth_alipay_private_key,omitempty" xml:"auth_alipay_private_key,omitempty"`
  // Domain AuthCName
  AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
  // 
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  Benefits map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
  // Domain 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  // domain
  ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  //  Drive  Store ID
  InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
  // Domain 
  Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
  OfficePreviewConfig *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
  // Domain 
  PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
  // 
  PrepaidPackage *string `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // Domain ServiceCode
  ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
  // 
  ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
  // 
  SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
  // SPI  id
  SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
  // domain
  Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
  // 
  StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
  //  Region 
  StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
  // Domain 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // 
  UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
  VideoPreviewConfig *VideoPreviewConfig `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
}

func (s GetDomainResponse) String() string {
  return tea.Prettify(s)
}

func (s GetDomainResponse) GoString() string {
  return s.String()
}

func (s *GetDomainResponse) SetApiCname(v string) *GetDomainResponse {
  s.ApiCname = &v
  return s
}

func (s *GetDomainResponse) SetAppCname(v string) *GetDomainResponse {
  s.AppCname = &v
  return s
}

func (s *GetDomainResponse) SetAuthAlipayAppId(v string) *GetDomainResponse {
  s.AuthAlipayAppId = &v
  return s
}

func (s *GetDomainResponse) SetAuthAlipayEnable(v bool) *GetDomainResponse {
  s.AuthAlipayEnable = &v
  return s
}

func (s *GetDomainResponse) SetAuthAlipayPrivateKey(v string) *GetDomainResponse {
  s.AuthAlipayPrivateKey = &v
  return s
}

func (s *GetDomainResponse) SetAuthCname(v string) *GetDomainResponse {
  s.AuthCname = &v
  return s
}

func (s *GetDomainResponse) SetAuthConfig(v map[string]interface{}) *GetDomainResponse {
  s.AuthConfig = v
  return s
}

func (s *GetDomainResponse) SetAuthDingdingAppId(v string) *GetDomainResponse {
  s.AuthDingdingAppId = &v
  return s
}

func (s *GetDomainResponse) SetAuthDingdingAppSecret(v string) *GetDomainResponse {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *GetDomainResponse) SetAuthDingdingEnable(v bool) *GetDomainResponse {
  s.AuthDingdingEnable = &v
  return s
}

func (s *GetDomainResponse) SetAuthEndpointEnable(v bool) *GetDomainResponse {
  s.AuthEndpointEnable = &v
  return s
}

func (s *GetDomainResponse) SetAuthRamAppId(v string) *GetDomainResponse {
  s.AuthRamAppId = &v
  return s
}

func (s *GetDomainResponse) SetAuthRamAppSecret(v string) *GetDomainResponse {
  s.AuthRamAppSecret = &v
  return s
}

func (s *GetDomainResponse) SetAuthRamEnable(v bool) *GetDomainResponse {
  s.AuthRamEnable = &v
  return s
}

func (s *GetDomainResponse) SetBenefits(v map[string]interface{}) *GetDomainResponse {
  s.Benefits = v
  return s
}

func (s *GetDomainResponse) SetCreatedAt(v string) *GetDomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetDomainResponse) SetDataHashName(v string) *GetDomainResponse {
  s.DataHashName = &v
  return s
}

func (s *GetDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *GetDomainResponse {
  s.DefaultSuperAdminConfig = v
  return s
}

func (s *GetDomainResponse) SetDescription(v string) *GetDomainResponse {
  s.Description = &v
  return s
}

func (s *GetDomainResponse) SetDomainId(v string) *GetDomainResponse {
  s.DomainId = &v
  return s
}

func (s *GetDomainResponse) SetDomainName(v string) *GetDomainResponse {
  s.DomainName = &v
  return s
}

func (s *GetDomainResponse) SetEventFilenameMatches(v string) *GetDomainResponse {
  s.EventFilenameMatches = &v
  return s
}

func (s *GetDomainResponse) SetEventMnsEndpoint(v string) *GetDomainResponse {
  s.EventMnsEndpoint = &v
  return s
}

func (s *GetDomainResponse) SetEventMnsTopic(v string) *GetDomainResponse {
  s.EventMnsTopic = &v
  return s
}

func (s *GetDomainResponse) SetEventNames(v []*string) *GetDomainResponse {
  s.EventNames = v
  return s
}

func (s *GetDomainResponse) SetEventRoleArn(v string) *GetDomainResponse {
  s.EventRoleArn = &v
  return s
}

func (s *GetDomainResponse) SetExpireTime(v int64) *GetDomainResponse {
  s.ExpireTime = &v
  return s
}

func (s *GetDomainResponse) SetInitDriveEnable(v bool) *GetDomainResponse {
  s.InitDriveEnable = &v
  return s
}

func (s *GetDomainResponse) SetInitDriveSize(v int64) *GetDomainResponse {
  s.InitDriveSize = &v
  return s
}

func (s *GetDomainResponse) SetInitDriveStoreId(v string) *GetDomainResponse {
  s.InitDriveStoreId = &v
  return s
}

func (s *GetDomainResponse) SetMode(v string) *GetDomainResponse {
  s.Mode = &v
  return s
}

func (s *GetDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *GetDomainResponse {
  s.OfficePreviewConfig = v
  return s
}

func (s *GetDomainResponse) SetPathType(v string) *GetDomainResponse {
  s.PathType = &v
  return s
}

func (s *GetDomainResponse) SetPrepaidPackage(v string) *GetDomainResponse {
  s.PrepaidPackage = &v
  return s
}

func (s *GetDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *GetDomainResponse {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *GetDomainResponse) SetServiceCode(v string) *GetDomainResponse {
  s.ServiceCode = &v
  return s
}

func (s *GetDomainResponse) SetSharable(v bool) *GetDomainResponse {
  s.Sharable = &v
  return s
}

func (s *GetDomainResponse) SetShareLinkEnabled(v bool) *GetDomainResponse {
  s.ShareLinkEnabled = &v
  return s
}

func (s *GetDomainResponse) SetSizeQuota(v int64) *GetDomainResponse {
  s.SizeQuota = &v
  return s
}

func (s *GetDomainResponse) SetSpiInstanceId(v string) *GetDomainResponse {
  s.SpiInstanceId = &v
  return s
}

func (s *GetDomainResponse) SetStatus(v int64) *GetDomainResponse {
  s.Status = &v
  return s
}

func (s *GetDomainResponse) SetStoreLevel(v string) *GetDomainResponse {
  s.StoreLevel = &v
  return s
}

func (s *GetDomainResponse) SetStoreRegionList(v []*string) *GetDomainResponse {
  s.StoreRegionList = v
  return s
}

func (s *GetDomainResponse) SetUpdatedAt(v string) *GetDomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetDomainResponse) SetUserCountQuota(v int64) *GetDomainResponse {
  s.UserCountQuota = &v
  return s
}

func (s *GetDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *GetDomainResponse {
  s.VideoPreviewConfig = v
  return s
}

/**
 * 
 */
type GetSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s GetSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s GetSubdomainRequest) GoString() string {
  return s.String()
}

func (s *GetSubdomainRequest) SetHeaders(v map[string]*string) *GetSubdomainRequest {
  s.Headers = v
  return s
}

func (s *GetSubdomainRequest) SetSubdomainId(v string) *GetSubdomainRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type GetSubdomainResponse struct {
  // 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" require:"true"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
  // quota-1
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty" require:"true"`
  // 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
  // quota-1
  UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty" require:"true"`
}

func (s GetSubdomainResponse) String() string {
  return tea.Prettify(s)
}

func (s GetSubdomainResponse) GoString() string {
  return s.String()
}

func (s *GetSubdomainResponse) SetCreatedAt(v string) *GetSubdomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetSubdomainResponse) SetDescription(v string) *GetSubdomainResponse {
  s.Description = &v
  return s
}

func (s *GetSubdomainResponse) SetName(v string) *GetSubdomainResponse {
  s.Name = &v
  return s
}

func (s *GetSubdomainResponse) SetSubdomainId(v string) *GetSubdomainResponse {
  s.SubdomainId = &v
  return s
}

func (s *GetSubdomainResponse) SetTotalSize(v int64) *GetSubdomainResponse {
  s.TotalSize = &v
  return s
}

func (s *GetSubdomainResponse) SetUpdatedAt(v string) *GetSubdomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetSubdomainResponse) SetUserQuota(v int64) *GetSubdomainResponse {
  s.UserQuota = &v
  return s
}

/**
 * 
 */
type GetUserAccessTokenRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // subdomain ID
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetUserAccessTokenRequest) String() string {
  return tea.Prettify(s)
}

func (s GetUserAccessTokenRequest) GoString() string {
  return s.String()
}

func (s *GetUserAccessTokenRequest) SetHeaders(v map[string]*string) *GetUserAccessTokenRequest {
  s.Headers = v
  return s
}

func (s *GetUserAccessTokenRequest) SetSubdomainId(v string) *GetUserAccessTokenRequest {
  s.SubdomainId = &v
  return s
}

func (s *GetUserAccessTokenRequest) SetUserId(v string) *GetUserAccessTokenRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type GetUserAccessTokenResponse struct {
  // accessToken
  AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty" require:"true"`
  // Default Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty" require:"true"`
  // accessTokenISO
  ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
  // accessToken
  ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty" require:"true"`
  // accessToken
  RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty" require:"true"`
  // accessTokenBearer
  TokenType *string `json:"token_type,omitempty" xml:"token_type,omitempty" require:"true"`
  // ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetUserAccessTokenResponse) String() string {
  return tea.Prettify(s)
}

func (s GetUserAccessTokenResponse) GoString() string {
  return s.String()
}

func (s *GetUserAccessTokenResponse) SetAccessToken(v string) *GetUserAccessTokenResponse {
  s.AccessToken = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetDefaultDriveId(v string) *GetUserAccessTokenResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetExpireTime(v string) *GetUserAccessTokenResponse {
  s.ExpireTime = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetExpiresIn(v int64) *GetUserAccessTokenResponse {
  s.ExpiresIn = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetRefreshToken(v string) *GetUserAccessTokenResponse {
  s.RefreshToken = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetRole(v string) *GetUserAccessTokenResponse {
  s.Role = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetTokenType(v string) *GetUserAccessTokenResponse {
  s.TokenType = &v
  return s
}

func (s *GetUserAccessTokenResponse) SetUserId(v string) *GetUserAccessTokenResponse {
  s.UserId = &v
  return s
}

/**
 * 
 */
type IMMProject struct {
  CanaryPercent *int64 `json:"canary_percent,omitempty" xml:"canary_percent,omitempty"`
  CanaryProjectName *string `json:"canary_project_name,omitempty" xml:"canary_project_name,omitempty"`
  NotifyEndpoint *string `json:"notify_endpoint,omitempty" xml:"notify_endpoint,omitempty"`
  NotifyTopicName *string `json:"notify_topic_name,omitempty" xml:"notify_topic_name,omitempty"`
  ProjectName *string `json:"project_name,omitempty" xml:"project_name,omitempty"`
  Region *string `json:"region,omitempty" xml:"region,omitempty"`
  // ProjectARN
  RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
}

func (s IMMProject) String() string {
  return tea.Prettify(s)
}

func (s IMMProject) GoString() string {
  return s.String()
}

func (s *IMMProject) SetCanaryPercent(v int64) *IMMProject {
  s.CanaryPercent = &v
  return s
}

func (s *IMMProject) SetCanaryProjectName(v string) *IMMProject {
  s.CanaryProjectName = &v
  return s
}

func (s *IMMProject) SetNotifyEndpoint(v string) *IMMProject {
  s.NotifyEndpoint = &v
  return s
}

func (s *IMMProject) SetNotifyTopicName(v string) *IMMProject {
  s.NotifyTopicName = &v
  return s
}

func (s *IMMProject) SetProjectName(v string) *IMMProject {
  s.ProjectName = &v
  return s
}

func (s *IMMProject) SetRegion(v string) *IMMProject {
  s.Region = &v
  return s
}

func (s *IMMProject) SetRoleArn(v string) *IMMProject {
  s.RoleArn = &v
  return s
}

/**
 * Identity benefit package response
 */
type IdentityBenefitPkgResponse struct {
  // 
  BenefitList []*BenefitBaseResponse `json:"benefit_list,omitempty" xml:"benefit_list,omitempty" type:"Repeated"`
  // 
  BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
  // 
  DeliveryInfoList []*BenefitPkgDeliveryInfoResponse `json:"delivery_info_list,omitempty" xml:"delivery_info_list,omitempty" type:"Repeated"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s IdentityBenefitPkgResponse) String() string {
  return tea.Prettify(s)
}

func (s IdentityBenefitPkgResponse) GoString() string {
  return s.String()
}

func (s *IdentityBenefitPkgResponse) SetBenefitList(v []*BenefitBaseResponse) *IdentityBenefitPkgResponse {
  s.BenefitList = v
  return s
}

func (s *IdentityBenefitPkgResponse) SetBenefitPkgId(v string) *IdentityBenefitPkgResponse {
  s.BenefitPkgId = &v
  return s
}

func (s *IdentityBenefitPkgResponse) SetDeliveryInfoList(v []*BenefitPkgDeliveryInfoResponse) *IdentityBenefitPkgResponse {
  s.DeliveryInfoList = v
  return s
}

func (s *IdentityBenefitPkgResponse) SetName(v string) *IdentityBenefitPkgResponse {
  s.Name = &v
  return s
}

/**
 * 
 */
type ListAppsResponse struct {
  // App 
  Items []*GetAppResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
  // App 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListAppsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListAppsResponse) GoString() string {
  return s.String()
}

func (s *ListAppsResponse) SetItems(v []*GetAppResponse) *ListAppsResponse {
  s.Items = v
  return s
}

func (s *ListAppsResponse) SetNextMarker(v string) *ListAppsResponse {
  s.NextMarker = &v
  return s
}

/**
 * list domain cors response
 */
type ListDomainCORSRuleResponse struct {
  // cors rule 
  CorsRuleList []*CorsRule `json:"cors_rule_list,omitempty" xml:"cors_rule_list,omitempty" type:"Repeated"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
}

func (s ListDomainCORSRuleResponse) String() string {
  return tea.Prettify(s)
}

func (s ListDomainCORSRuleResponse) GoString() string {
  return s.String()
}

func (s *ListDomainCORSRuleResponse) SetCorsRuleList(v []*CorsRule) *ListDomainCORSRuleResponse {
  s.CorsRuleList = v
  return s
}

func (s *ListDomainCORSRuleResponse) SetDomainId(v string) *ListDomainCORSRuleResponse {
  s.DomainId = &v
  return s
}

/**
 * list domain response
 */
type ListDomainsResponse struct {
  // domain 
  Items []*BaseDomainResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDomainsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListDomainsResponse) GoString() string {
  return s.String()
}

func (s *ListDomainsResponse) SetItems(v []*BaseDomainResponse) *ListDomainsResponse {
  s.Items = v
  return s
}

func (s *ListDomainsResponse) SetNextMarker(v string) *ListDomainsResponse {
  s.NextMarker = &v
  return s
}

/**
 * List identity benefit package response
 */
type ListIdentityBenefitPkgResponse struct {
  Items []*IdentityBenefitPkgResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListIdentityBenefitPkgResponse) String() string {
  return tea.Prettify(s)
}

func (s ListIdentityBenefitPkgResponse) GoString() string {
  return s.String()
}

func (s *ListIdentityBenefitPkgResponse) SetItems(v []*IdentityBenefitPkgResponse) *ListIdentityBenefitPkgResponse {
  s.Items = v
  return s
}

/**
 * 
 */
type ListStoresResponse struct {
  // Store 
  Items []*Store `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
}

func (s ListStoresResponse) String() string {
  return tea.Prettify(s)
}

func (s ListStoresResponse) GoString() string {
  return s.String()
}

func (s *ListStoresResponse) SetItems(v []*Store) *ListStoresResponse {
  s.Items = v
  return s
}

/**
 * 
 */
type ListSubdomainsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 50
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  //  response 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListSubdomainsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListSubdomainsRequest) GoString() string {
  return s.String()
}

func (s *ListSubdomainsRequest) SetHeaders(v map[string]*string) *ListSubdomainsRequest {
  s.Headers = v
  return s
}

func (s *ListSubdomainsRequest) SetLimit(v int32) *ListSubdomainsRequest {
  s.Limit = &v
  return s
}

func (s *ListSubdomainsRequest) SetMarker(v string) *ListSubdomainsRequest {
  s.Marker = &v
  return s
}

/**
 * 
 */
type ListSubdomainsResponse struct {
  //  subdomain 
  Items []*BaseSubdomainResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
  // list
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty" require:"true"`
}

func (s ListSubdomainsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListSubdomainsResponse) GoString() string {
  return s.String()
}

func (s *ListSubdomainsResponse) SetItems(v []*BaseSubdomainResponse) *ListSubdomainsResponse {
  s.Items = v
  return s
}

func (s *ListSubdomainsResponse) SetNextMarker(v string) *ListSubdomainsResponse {
  s.NextMarker = &v
  return s
}

/**
 * OfficePreviewConfig 
 */
type OfficePreviewConfig struct {
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s OfficePreviewConfig) String() string {
  return tea.Prettify(s)
}

func (s OfficePreviewConfig) GoString() string {
  return s.String()
}

func (s *OfficePreviewConfig) SetEnabled(v bool) *OfficePreviewConfig {
  s.Enabled = &v
  return s
}

/**
 * 
 */
type SetBizCNameCertResponse struct {
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  // cert name
  CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // is vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameCertResponse) String() string {
  return tea.Prettify(s)
}

func (s SetBizCNameCertResponse) GoString() string {
  return s.String()
}

func (s *SetBizCNameCertResponse) SetBizCname(v string) *SetBizCNameCertResponse {
  s.BizCname = &v
  return s
}

func (s *SetBizCNameCertResponse) SetCertName(v string) *SetBizCNameCertResponse {
  s.CertName = &v
  return s
}

func (s *SetBizCNameCertResponse) SetCnameType(v string) *SetBizCNameCertResponse {
  s.CnameType = &v
  return s
}

func (s *SetBizCNameCertResponse) SetDomainId(v string) *SetBizCNameCertResponse {
  s.DomainId = &v
  return s
}

func (s *SetBizCNameCertResponse) SetIsVpc(v bool) *SetBizCNameCertResponse {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type SetBizCNameResponse struct {
  // biz cname
  BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
  CnameStatus *CNameStatus `json:"cname_status,omitempty" xml:"cname_status,omitempty"`
  // cname type
  CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // is vpc
  IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameResponse) String() string {
  return tea.Prettify(s)
}

func (s SetBizCNameResponse) GoString() string {
  return s.String()
}

func (s *SetBizCNameResponse) SetBizCname(v string) *SetBizCNameResponse {
  s.BizCname = &v
  return s
}

func (s *SetBizCNameResponse) SetCnameStatus(v *CNameStatus) *SetBizCNameResponse {
  s.CnameStatus = v
  return s
}

func (s *SetBizCNameResponse) SetCnameType(v string) *SetBizCNameResponse {
  s.CnameType = &v
  return s
}

func (s *SetBizCNameResponse) SetDomainId(v string) *SetBizCNameResponse {
  s.DomainId = &v
  return s
}

func (s *SetBizCNameResponse) SetIsVpc(v bool) *SetBizCNameResponse {
  s.IsVpc = &v
  return s
}

/**
 * 
 */
type SetDataCNameResponse struct {
  // datacname
  DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
  // domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
  // data location
  Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s SetDataCNameResponse) String() string {
  return tea.Prettify(s)
}

func (s SetDataCNameResponse) GoString() string {
  return s.String()
}

func (s *SetDataCNameResponse) SetDataCname(v string) *SetDataCNameResponse {
  s.DataCname = &v
  return s
}

func (s *SetDataCNameResponse) SetDomainId(v string) *SetDataCNameResponse {
  s.DomainId = &v
  return s
}

func (s *SetDataCNameResponse) SetLocation(v string) *SetDataCNameResponse {
  s.Location = &v
  return s
}

/**
 * create domain response
 */
type UpdateDomainResponse struct {
  // Domain APICName
  ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
  // Domain AppCName
  AppCname *string `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
  //  App Id
  AuthAlipayAppId *string `json:"auth_alipay_app_id,omitempty" xml:"auth_alipay_app_id,omitempty"`
  // 
  AuthAlipayEnable *bool `json:"auth_alipay_enable,omitempty" xml:"auth_alipay_enable,omitempty"`
  //  App Secret
  AuthAlipayPrivateKey *string `json:"auth_alipay_private_key,omitempty" xml:"auth_alipay_private_key,omitempty"`
  // Domain AuthCName
  AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
  // 
  AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
  //  App Id
  AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
  //  App Secret
  AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
  // 
  AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
  AuthEndpointEnable *bool `json:"auth_endpoint_enable,omitempty" xml:"auth_endpoint_enable,omitempty"`
  // RAM App Id
  AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
  // RAM App Secret
  AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
  //  RAM 
  AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
  Benefits map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
  // Domain 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Hash 
  DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
  DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
  // Domain 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // Domain 
  DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
  //  MNS 
  EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
  //  MNS Endpoint
  EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
  //  MNS Topic
  EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
  // 
  EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
  //  Role Arn
  EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
  // domain
  ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
  //  Drive
  InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
  //  Drive 
  InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
  //  Drive  Store ID
  InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
  // Domain 
  Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
  OfficePreviewConfig *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
  // Domain 
  PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
  // 
  PrepaidPackage *string `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
  PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
  // Domain ServiceCode
  ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
  // 
  Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
  // 
  ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
  // 
  SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
  // SPI  id
  SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
  // domain
  Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
  // 
  StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
  //  Region 
  StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
  // Domain 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // 
  UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
  VideoPreviewConfig *VideoPreviewConfig `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
}

func (s UpdateDomainResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateDomainResponse) GoString() string {
  return s.String()
}

func (s *UpdateDomainResponse) SetApiCname(v string) *UpdateDomainResponse {
  s.ApiCname = &v
  return s
}

func (s *UpdateDomainResponse) SetAppCname(v string) *UpdateDomainResponse {
  s.AppCname = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthAlipayAppId(v string) *UpdateDomainResponse {
  s.AuthAlipayAppId = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthAlipayEnable(v bool) *UpdateDomainResponse {
  s.AuthAlipayEnable = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthAlipayPrivateKey(v string) *UpdateDomainResponse {
  s.AuthAlipayPrivateKey = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthCname(v string) *UpdateDomainResponse {
  s.AuthCname = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthConfig(v map[string]interface{}) *UpdateDomainResponse {
  s.AuthConfig = v
  return s
}

func (s *UpdateDomainResponse) SetAuthDingdingAppId(v string) *UpdateDomainResponse {
  s.AuthDingdingAppId = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthDingdingAppSecret(v string) *UpdateDomainResponse {
  s.AuthDingdingAppSecret = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthDingdingEnable(v bool) *UpdateDomainResponse {
  s.AuthDingdingEnable = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthEndpointEnable(v bool) *UpdateDomainResponse {
  s.AuthEndpointEnable = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthRamAppId(v string) *UpdateDomainResponse {
  s.AuthRamAppId = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthRamAppSecret(v string) *UpdateDomainResponse {
  s.AuthRamAppSecret = &v
  return s
}

func (s *UpdateDomainResponse) SetAuthRamEnable(v bool) *UpdateDomainResponse {
  s.AuthRamEnable = &v
  return s
}

func (s *UpdateDomainResponse) SetBenefits(v map[string]interface{}) *UpdateDomainResponse {
  s.Benefits = v
  return s
}

func (s *UpdateDomainResponse) SetCreatedAt(v string) *UpdateDomainResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateDomainResponse) SetDataHashName(v string) *UpdateDomainResponse {
  s.DataHashName = &v
  return s
}

func (s *UpdateDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *UpdateDomainResponse {
  s.DefaultSuperAdminConfig = v
  return s
}

func (s *UpdateDomainResponse) SetDescription(v string) *UpdateDomainResponse {
  s.Description = &v
  return s
}

func (s *UpdateDomainResponse) SetDomainId(v string) *UpdateDomainResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateDomainResponse) SetDomainName(v string) *UpdateDomainResponse {
  s.DomainName = &v
  return s
}

func (s *UpdateDomainResponse) SetEventFilenameMatches(v string) *UpdateDomainResponse {
  s.EventFilenameMatches = &v
  return s
}

func (s *UpdateDomainResponse) SetEventMnsEndpoint(v string) *UpdateDomainResponse {
  s.EventMnsEndpoint = &v
  return s
}

func (s *UpdateDomainResponse) SetEventMnsTopic(v string) *UpdateDomainResponse {
  s.EventMnsTopic = &v
  return s
}

func (s *UpdateDomainResponse) SetEventNames(v []*string) *UpdateDomainResponse {
  s.EventNames = v
  return s
}

func (s *UpdateDomainResponse) SetEventRoleArn(v string) *UpdateDomainResponse {
  s.EventRoleArn = &v
  return s
}

func (s *UpdateDomainResponse) SetExpireTime(v int64) *UpdateDomainResponse {
  s.ExpireTime = &v
  return s
}

func (s *UpdateDomainResponse) SetInitDriveEnable(v bool) *UpdateDomainResponse {
  s.InitDriveEnable = &v
  return s
}

func (s *UpdateDomainResponse) SetInitDriveSize(v int64) *UpdateDomainResponse {
  s.InitDriveSize = &v
  return s
}

func (s *UpdateDomainResponse) SetInitDriveStoreId(v string) *UpdateDomainResponse {
  s.InitDriveStoreId = &v
  return s
}

func (s *UpdateDomainResponse) SetMode(v string) *UpdateDomainResponse {
  s.Mode = &v
  return s
}

func (s *UpdateDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *UpdateDomainResponse {
  s.OfficePreviewConfig = v
  return s
}

func (s *UpdateDomainResponse) SetPathType(v string) *UpdateDomainResponse {
  s.PathType = &v
  return s
}

func (s *UpdateDomainResponse) SetPrepaidPackage(v string) *UpdateDomainResponse {
  s.PrepaidPackage = &v
  return s
}

func (s *UpdateDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *UpdateDomainResponse {
  s.PublishedAppAccessStrategy = v
  return s
}

func (s *UpdateDomainResponse) SetServiceCode(v string) *UpdateDomainResponse {
  s.ServiceCode = &v
  return s
}

func (s *UpdateDomainResponse) SetSharable(v bool) *UpdateDomainResponse {
  s.Sharable = &v
  return s
}

func (s *UpdateDomainResponse) SetShareLinkEnabled(v bool) *UpdateDomainResponse {
  s.ShareLinkEnabled = &v
  return s
}

func (s *UpdateDomainResponse) SetSizeQuota(v int64) *UpdateDomainResponse {
  s.SizeQuota = &v
  return s
}

func (s *UpdateDomainResponse) SetSpiInstanceId(v string) *UpdateDomainResponse {
  s.SpiInstanceId = &v
  return s
}

func (s *UpdateDomainResponse) SetStatus(v int64) *UpdateDomainResponse {
  s.Status = &v
  return s
}

func (s *UpdateDomainResponse) SetStoreLevel(v string) *UpdateDomainResponse {
  s.StoreLevel = &v
  return s
}

func (s *UpdateDomainResponse) SetStoreRegionList(v []*string) *UpdateDomainResponse {
  s.StoreRegionList = v
  return s
}

func (s *UpdateDomainResponse) SetUpdatedAt(v string) *UpdateDomainResponse {
  s.UpdatedAt = &v
  return s
}

func (s *UpdateDomainResponse) SetUserCountQuota(v int64) *UpdateDomainResponse {
  s.UserCountQuota = &v
  return s
}

func (s *UpdateDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *UpdateDomainResponse {
  s.VideoPreviewConfig = v
  return s
}

/**
 * 
 */
type UpdateSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
  // subdomain
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
  // quota-1
  TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
  // quota-1
  UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty"`
}

func (s UpdateSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateSubdomainRequest) GoString() string {
  return s.String()
}

func (s *UpdateSubdomainRequest) SetHeaders(v map[string]*string) *UpdateSubdomainRequest {
  s.Headers = v
  return s
}

func (s *UpdateSubdomainRequest) SetDescription(v string) *UpdateSubdomainRequest {
  s.Description = &v
  return s
}

func (s *UpdateSubdomainRequest) SetName(v string) *UpdateSubdomainRequest {
  s.Name = &v
  return s
}

func (s *UpdateSubdomainRequest) SetSubdomainId(v string) *UpdateSubdomainRequest {
  s.SubdomainId = &v
  return s
}

func (s *UpdateSubdomainRequest) SetTotalSize(v int64) *UpdateSubdomainRequest {
  s.TotalSize = &v
  return s
}

func (s *UpdateSubdomainRequest) SetUserQuota(v int64) *UpdateSubdomainRequest {
  s.UserQuota = &v
  return s
}

/**
 * 
 */
type UpdateSubdomainResponse struct {
}

func (s UpdateSubdomainResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateSubdomainResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type VideoPreviewAudio struct {
  AudioBitrate *int64 `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
  AudioChannel *int64 `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
  AudioCodec *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
  AudioSampleRate *int64 `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
}

func (s VideoPreviewAudio) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAudio) GoString() string {
  return s.String()
}

func (s *VideoPreviewAudio) SetAudioBitrate(v int64) *VideoPreviewAudio {
  s.AudioBitrate = &v
  return s
}

func (s *VideoPreviewAudio) SetAudioChannel(v int64) *VideoPreviewAudio {
  s.AudioChannel = &v
  return s
}

func (s *VideoPreviewAudio) SetAudioCodec(v string) *VideoPreviewAudio {
  s.AudioCodec = &v
  return s
}

func (s *VideoPreviewAudio) SetAudioSampleRate(v int64) *VideoPreviewAudio {
  s.AudioSampleRate = &v
  return s
}

/**
 * 
 */
type VideoPreviewAudioConfig struct {
  SupportExt []*string `json:"support_ext,omitempty" xml:"support_ext,omitempty" type:"Repeated"`
  Template []*VideoPreviewAudioTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Repeated"`
}

func (s VideoPreviewAudioConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAudioConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewAudioConfig) SetSupportExt(v []*string) *VideoPreviewAudioConfig {
  s.SupportExt = v
  return s
}

func (s *VideoPreviewAudioConfig) SetTemplate(v []*VideoPreviewAudioTemplate) *VideoPreviewAudioConfig {
  s.Template = v
  return s
}

/**
 * 
 */
type VideoPreviewAudioTemplate struct {
  AudioBitrate *int64 `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
  AudioChannel *int64 `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
  AudioCodec *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
  AudioOutputExt *string `json:"audio_output_ext,omitempty" xml:"audio_output_ext,omitempty"`
  AudioSampleRate *int64 `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
  AudioTemplateId *string `json:"audio_template_id,omitempty" xml:"audio_template_id,omitempty"`
}

func (s VideoPreviewAudioTemplate) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAudioTemplate) GoString() string {
  return s.String()
}

func (s *VideoPreviewAudioTemplate) SetAudioBitrate(v int64) *VideoPreviewAudioTemplate {
  s.AudioBitrate = &v
  return s
}

func (s *VideoPreviewAudioTemplate) SetAudioChannel(v int64) *VideoPreviewAudioTemplate {
  s.AudioChannel = &v
  return s
}

func (s *VideoPreviewAudioTemplate) SetAudioCodec(v string) *VideoPreviewAudioTemplate {
  s.AudioCodec = &v
  return s
}

func (s *VideoPreviewAudioTemplate) SetAudioOutputExt(v string) *VideoPreviewAudioTemplate {
  s.AudioOutputExt = &v
  return s
}

func (s *VideoPreviewAudioTemplate) SetAudioSampleRate(v int64) *VideoPreviewAudioTemplate {
  s.AudioSampleRate = &v
  return s
}

func (s *VideoPreviewAudioTemplate) SetAudioTemplateId(v string) *VideoPreviewAudioTemplate {
  s.AudioTemplateId = &v
  return s
}

/**
 * 
 */
type VideoPreviewAutoScale struct {
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
  MaxLength *int64 `json:"max_length,omitempty" xml:"max_length,omitempty"`
}

func (s VideoPreviewAutoScale) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewAutoScale) GoString() string {
  return s.String()
}

func (s *VideoPreviewAutoScale) SetEnabled(v bool) *VideoPreviewAutoScale {
  s.Enabled = &v
  return s
}

func (s *VideoPreviewAutoScale) SetMaxLength(v int64) *VideoPreviewAutoScale {
  s.MaxLength = &v
  return s
}

/**
 * 
 */
type VideoPreviewBackupConfig struct {
  CountOnce *int64 `json:"count_once,omitempty" xml:"count_once,omitempty"`
  Store *Store `json:"store,omitempty" xml:"store,omitempty"`
  StoreIdMap map[string]interface{} `json:"store_id_map,omitempty" xml:"store_id_map,omitempty"`
}

func (s VideoPreviewBackupConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewBackupConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewBackupConfig) SetCountOnce(v int64) *VideoPreviewBackupConfig {
  s.CountOnce = &v
  return s
}

func (s *VideoPreviewBackupConfig) SetStore(v *Store) *VideoPreviewBackupConfig {
  s.Store = v
  return s
}

func (s *VideoPreviewBackupConfig) SetStoreIdMap(v map[string]interface{}) *VideoPreviewBackupConfig {
  s.StoreIdMap = v
  return s
}

/**
 * 
 */
type VideoPreviewConfig struct {
  AudioConfig *VideoPreviewAudioConfig `json:"audio_config,omitempty" xml:"audio_config,omitempty"`
  AudioTemplateList []*string `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
  AudioThumbnail *VideoPreviewThumbnail `json:"audio_thumbnail,omitempty" xml:"audio_thumbnail,omitempty"`
  BackupConfig *VideoPreviewBackupConfig `json:"backup_config,omitempty" xml:"backup_config,omitempty"`
  EnableConfig *VideoPreviewEnableConfig `json:"enable_config,omitempty" xml:"enable_config,omitempty"`
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
  LiveTranscodingConfig *VideoPreviewLiveTranscodingConfig `json:"live_transcoding_config,omitempty" xml:"live_transcoding_config,omitempty"`
  RateLimitConfig *VideoPreviewRateLimitConfig `json:"rate_limit_config,omitempty" xml:"rate_limit_config,omitempty"`
  Sprite *VideoPreviewSprite `json:"sprite,omitempty" xml:"sprite,omitempty"`
  Store *Store `json:"store,omitempty" xml:"store,omitempty"`
  StoreIdMap map[string]interface{} `json:"store_id_map,omitempty" xml:"store_id_map,omitempty"`
  TemplateList []*string `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
  Thumbnail *VideoPreviewThumbnail `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
  VideoConfig *VideoPreviewVideoConfig `json:"video_config,omitempty" xml:"video_config,omitempty"`
  VideoFilterConfig *VideoPreviewVideoFilterConfig `json:"video_filter_config,omitempty" xml:"video_filter_config,omitempty"`
}

func (s VideoPreviewConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewConfig) SetAudioConfig(v *VideoPreviewAudioConfig) *VideoPreviewConfig {
  s.AudioConfig = v
  return s
}

func (s *VideoPreviewConfig) SetAudioTemplateList(v []*string) *VideoPreviewConfig {
  s.AudioTemplateList = v
  return s
}

func (s *VideoPreviewConfig) SetAudioThumbnail(v *VideoPreviewThumbnail) *VideoPreviewConfig {
  s.AudioThumbnail = v
  return s
}

func (s *VideoPreviewConfig) SetBackupConfig(v *VideoPreviewBackupConfig) *VideoPreviewConfig {
  s.BackupConfig = v
  return s
}

func (s *VideoPreviewConfig) SetEnableConfig(v *VideoPreviewEnableConfig) *VideoPreviewConfig {
  s.EnableConfig = v
  return s
}

func (s *VideoPreviewConfig) SetEnabled(v bool) *VideoPreviewConfig {
  s.Enabled = &v
  return s
}

func (s *VideoPreviewConfig) SetLiveTranscodingConfig(v *VideoPreviewLiveTranscodingConfig) *VideoPreviewConfig {
  s.LiveTranscodingConfig = v
  return s
}

func (s *VideoPreviewConfig) SetRateLimitConfig(v *VideoPreviewRateLimitConfig) *VideoPreviewConfig {
  s.RateLimitConfig = v
  return s
}

func (s *VideoPreviewConfig) SetSprite(v *VideoPreviewSprite) *VideoPreviewConfig {
  s.Sprite = v
  return s
}

func (s *VideoPreviewConfig) SetStore(v *Store) *VideoPreviewConfig {
  s.Store = v
  return s
}

func (s *VideoPreviewConfig) SetStoreIdMap(v map[string]interface{}) *VideoPreviewConfig {
  s.StoreIdMap = v
  return s
}

func (s *VideoPreviewConfig) SetTemplateList(v []*string) *VideoPreviewConfig {
  s.TemplateList = v
  return s
}

func (s *VideoPreviewConfig) SetThumbnail(v *VideoPreviewThumbnail) *VideoPreviewConfig {
  s.Thumbnail = v
  return s
}

func (s *VideoPreviewConfig) SetVideoConfig(v *VideoPreviewVideoConfig) *VideoPreviewConfig {
  s.VideoConfig = v
  return s
}

func (s *VideoPreviewConfig) SetVideoFilterConfig(v *VideoPreviewVideoFilterConfig) *VideoPreviewConfig {
  s.VideoFilterConfig = v
  return s
}

/**
 * 
 */
type VideoPreviewEnableConfig struct {
  EnableTranscodeWhenPlay *bool `json:"enable_transcode_when_play,omitempty" xml:"enable_transcode_when_play,omitempty"`
  EnableTranscodeWhenUploaded *bool `json:"enable_transcode_when_uploaded,omitempty" xml:"enable_transcode_when_uploaded,omitempty"`
}

func (s VideoPreviewEnableConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewEnableConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewEnableConfig) SetEnableTranscodeWhenPlay(v bool) *VideoPreviewEnableConfig {
  s.EnableTranscodeWhenPlay = &v
  return s
}

func (s *VideoPreviewEnableConfig) SetEnableTranscodeWhenUploaded(v bool) *VideoPreviewEnableConfig {
  s.EnableTranscodeWhenUploaded = &v
  return s
}

/**
 * domain config --------
 */
type VideoPreviewLiveTranscodingConfig struct {
  CurrentVersion *int64 `json:"current_version,omitempty" xml:"current_version,omitempty"`
  DeprecatedVersion *int64 `json:"deprecated_version,omitempty" xml:"deprecated_version,omitempty"`
  DetailCountLimit *int64 `json:"detail_count_limit,omitempty" xml:"detail_count_limit,omitempty"`
  Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
  ImmProjectMap map[string]interface{} `json:"imm_project_map,omitempty" xml:"imm_project_map,omitempty"`
  LeadingPrefix *string `json:"leading_prefix,omitempty" xml:"leading_prefix,omitempty"`
  M3u8FilePrefix *string `json:"m3u8_file_prefix,omitempty" xml:"m3u8_file_prefix,omitempty"`
  MediaDurationLimit *float64 `json:"media_duration_limit,omitempty" xml:"media_duration_limit,omitempty"`
  Segment *int64 `json:"segment,omitempty" xml:"segment,omitempty"`
  TemplateList []*string `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
  // Mode              string   `json:"mode"`               // media
  // counttaskstatusstage, 
  TsCountWhenInitM3u8 *int64 `json:"ts_count_when_init_m3u8,omitempty" xml:"ts_count_when_init_m3u8,omitempty"`
  TsCountWhenTs404 *int64 `json:"ts_count_when_ts_404,omitempty" xml:"ts_count_when_ts_404,omitempty"`
  TsFilePrefix *string `json:"ts_file_prefix,omitempty" xml:"ts_file_prefix,omitempty"`
}

func (s VideoPreviewLiveTranscodingConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewLiveTranscodingConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewLiveTranscodingConfig) SetCurrentVersion(v int64) *VideoPreviewLiveTranscodingConfig {
  s.CurrentVersion = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetDeprecatedVersion(v int64) *VideoPreviewLiveTranscodingConfig {
  s.DeprecatedVersion = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetDetailCountLimit(v int64) *VideoPreviewLiveTranscodingConfig {
  s.DetailCountLimit = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetEnabled(v bool) *VideoPreviewLiveTranscodingConfig {
  s.Enabled = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetImmProjectMap(v map[string]interface{}) *VideoPreviewLiveTranscodingConfig {
  s.ImmProjectMap = v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetLeadingPrefix(v string) *VideoPreviewLiveTranscodingConfig {
  s.LeadingPrefix = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetM3u8FilePrefix(v string) *VideoPreviewLiveTranscodingConfig {
  s.M3u8FilePrefix = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetMediaDurationLimit(v float64) *VideoPreviewLiveTranscodingConfig {
  s.MediaDurationLimit = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetSegment(v int64) *VideoPreviewLiveTranscodingConfig {
  s.Segment = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTemplateList(v []*string) *VideoPreviewLiveTranscodingConfig {
  s.TemplateList = v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsCountWhenInitM3u8(v int64) *VideoPreviewLiveTranscodingConfig {
  s.TsCountWhenInitM3u8 = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsCountWhenTs404(v int64) *VideoPreviewLiveTranscodingConfig {
  s.TsCountWhenTs404 = &v
  return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsFilePrefix(v string) *VideoPreviewLiveTranscodingConfig {
  s.TsFilePrefix = &v
  return s
}

/**
 * 
 */
type VideoPreviewM3U8Config struct {
  HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
}

func (s VideoPreviewM3U8Config) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewM3U8Config) GoString() string {
  return s.String()
}

func (s *VideoPreviewM3U8Config) SetHlsTime(v int64) *VideoPreviewM3U8Config {
  s.HlsTime = &v
  return s
}

/**
 * 
 */
type VideoPreviewRateLimitConfig struct {
  RateLimit *int64 `json:"rate_limit,omitempty" xml:"rate_limit,omitempty"`
}

func (s VideoPreviewRateLimitConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewRateLimitConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewRateLimitConfig) SetRateLimit(v int64) *VideoPreviewRateLimitConfig {
  s.RateLimit = &v
  return s
}

/**
 * 
 */
type VideoPreviewSprite struct {
  AutoScale *VideoPreviewAutoScale `json:"auto_scale,omitempty" xml:"auto_scale,omitempty"`
  Col *int64 `json:"col,omitempty" xml:"col,omitempty"`
  FrameHeight *int64 `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
  FrameWidth *int64 `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
  Interval *VideoPreviewSpriteInterval `json:"interval,omitempty" xml:"interval,omitempty"`
  Row *int64 `json:"row,omitempty" xml:"row,omitempty"`
}

func (s VideoPreviewSprite) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewSprite) GoString() string {
  return s.String()
}

func (s *VideoPreviewSprite) SetAutoScale(v *VideoPreviewAutoScale) *VideoPreviewSprite {
  s.AutoScale = v
  return s
}

func (s *VideoPreviewSprite) SetCol(v int64) *VideoPreviewSprite {
  s.Col = &v
  return s
}

func (s *VideoPreviewSprite) SetFrameHeight(v int64) *VideoPreviewSprite {
  s.FrameHeight = &v
  return s
}

func (s *VideoPreviewSprite) SetFrameWidth(v int64) *VideoPreviewSprite {
  s.FrameWidth = &v
  return s
}

func (s *VideoPreviewSprite) SetInterval(v *VideoPreviewSpriteInterval) *VideoPreviewSprite {
  s.Interval = v
  return s
}

func (s *VideoPreviewSprite) SetRow(v int64) *VideoPreviewSprite {
  s.Row = &v
  return s
}

/**
 * 1%
 */
type VideoPreviewSpriteInterval struct {
  DefaultInterval *string `json:"default_interval,omitempty" xml:"default_interval,omitempty"`
  GrabIntervalList []*string `json:"grab_interval_list,omitempty" xml:"grab_interval_list,omitempty" type:"Repeated"`
  UpperLimitList []*int `json:"upper_limit_list,omitempty" xml:"upper_limit_list,omitempty" type:"Repeated"`
}

func (s VideoPreviewSpriteInterval) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewSpriteInterval) GoString() string {
  return s.String()
}

func (s *VideoPreviewSpriteInterval) SetDefaultInterval(v string) *VideoPreviewSpriteInterval {
  s.DefaultInterval = &v
  return s
}

func (s *VideoPreviewSpriteInterval) SetGrabIntervalList(v []*string) *VideoPreviewSpriteInterval {
  s.GrabIntervalList = v
  return s
}

func (s *VideoPreviewSpriteInterval) SetUpperLimitList(v []*int) *VideoPreviewSpriteInterval {
  s.UpperLimitList = v
  return s
}

/**
 * 
 */
type VideoPreviewThumbnail struct {
  SkipBeginPercent *string `json:"skip_begin_percent,omitempty" xml:"skip_begin_percent,omitempty"`
  SkipBeginSec *float64 `json:"skip_begin_sec,omitempty" xml:"skip_begin_sec,omitempty"`
}

func (s VideoPreviewThumbnail) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewThumbnail) GoString() string {
  return s.String()
}

func (s *VideoPreviewThumbnail) SetSkipBeginPercent(v string) *VideoPreviewThumbnail {
  s.SkipBeginPercent = &v
  return s
}

func (s *VideoPreviewThumbnail) SetSkipBeginSec(v float64) *VideoPreviewThumbnail {
  s.SkipBeginSec = &v
  return s
}

/**
 * 
 */
type VideoPreviewVideo struct {
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  KeepOriginal *bool `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
  VideoBitrate *int64 `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
  VideoCodec *string `json:"video_codec,omitempty" xml:"video_codec,omitempty"`
  VideoFrameRate *int64 `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideo) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewVideo) GoString() string {
  return s.String()
}

func (s *VideoPreviewVideo) SetHeight(v int64) *VideoPreviewVideo {
  s.Height = &v
  return s
}

func (s *VideoPreviewVideo) SetKeepOriginal(v bool) *VideoPreviewVideo {
  s.KeepOriginal = &v
  return s
}

func (s *VideoPreviewVideo) SetVideoBitrate(v int64) *VideoPreviewVideo {
  s.VideoBitrate = &v
  return s
}

func (s *VideoPreviewVideo) SetVideoCodec(v string) *VideoPreviewVideo {
  s.VideoCodec = &v
  return s
}

func (s *VideoPreviewVideo) SetVideoFrameRate(v int64) *VideoPreviewVideo {
  s.VideoFrameRate = &v
  return s
}

func (s *VideoPreviewVideo) SetWidth(v int64) *VideoPreviewVideo {
  s.Width = &v
  return s
}

/**
 * 
 */
type VideoPreviewVideoConfig struct {
  DefaultOutputExt *string `json:"default_output_ext,omitempty" xml:"default_output_ext,omitempty"`
  KeepOriginal *bool `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
  M3u8Config *VideoPreviewM3U8Config `json:"m3u8_config,omitempty" xml:"m3u8_config,omitempty"`
  SupportExt []*string `json:"support_ext,omitempty" xml:"support_ext,omitempty" type:"Repeated"`
  Template []*VideoPreviewVideoTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Repeated"`
}

func (s VideoPreviewVideoConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewVideoConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewVideoConfig) SetDefaultOutputExt(v string) *VideoPreviewVideoConfig {
  s.DefaultOutputExt = &v
  return s
}

func (s *VideoPreviewVideoConfig) SetKeepOriginal(v bool) *VideoPreviewVideoConfig {
  s.KeepOriginal = &v
  return s
}

func (s *VideoPreviewVideoConfig) SetM3u8Config(v *VideoPreviewM3U8Config) *VideoPreviewVideoConfig {
  s.M3u8Config = v
  return s
}

func (s *VideoPreviewVideoConfig) SetSupportExt(v []*string) *VideoPreviewVideoConfig {
  s.SupportExt = v
  return s
}

func (s *VideoPreviewVideoConfig) SetTemplate(v []*VideoPreviewVideoTemplate) *VideoPreviewVideoConfig {
  s.Template = v
  return s
}

/**
 * null
 */
type VideoPreviewVideoFilterConfig struct {
  AudioBitrate *int64 `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
  AudioChannel *int64 `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
  // 
  AudioCodecList []*string `json:"audio_codec_list,omitempty" xml:"audio_codec_list,omitempty" type:"Repeated"`
  AudioSampleRate *int64 `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
  Bitrate *int64 `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
  // 
  Duration *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  Pixel *int64 `json:"pixel,omitempty" xml:"pixel,omitempty"`
  Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
  VideoBitrate *int64 `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
  // 
  VideoCodecList []*string `json:"video_codec_list,omitempty" xml:"video_codec_list,omitempty" type:"Repeated"`
  VideoFrameRate *int64 `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideoFilterConfig) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewVideoFilterConfig) GoString() string {
  return s.String()
}

func (s *VideoPreviewVideoFilterConfig) SetAudioBitrate(v int64) *VideoPreviewVideoFilterConfig {
  s.AudioBitrate = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioChannel(v int64) *VideoPreviewVideoFilterConfig {
  s.AudioChannel = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioCodecList(v []*string) *VideoPreviewVideoFilterConfig {
  s.AudioCodecList = v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioSampleRate(v int64) *VideoPreviewVideoFilterConfig {
  s.AudioSampleRate = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetBitrate(v int64) *VideoPreviewVideoFilterConfig {
  s.Bitrate = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetDuration(v int64) *VideoPreviewVideoFilterConfig {
  s.Duration = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetHeight(v int64) *VideoPreviewVideoFilterConfig {
  s.Height = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetPixel(v int64) *VideoPreviewVideoFilterConfig {
  s.Pixel = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetSize(v int64) *VideoPreviewVideoFilterConfig {
  s.Size = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoBitrate(v int64) *VideoPreviewVideoFilterConfig {
  s.VideoBitrate = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoCodecList(v []*string) *VideoPreviewVideoFilterConfig {
  s.VideoCodecList = v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoFrameRate(v int64) *VideoPreviewVideoFilterConfig {
  s.VideoFrameRate = &v
  return s
}

func (s *VideoPreviewVideoFilterConfig) SetWidth(v int64) *VideoPreviewVideoFilterConfig {
  s.Width = &v
  return s
}

/**
 * 
 */
type VideoPreviewVideoTemplate struct {
  AudioBitrate *int64 `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
  AudioChannel *int64 `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
  AudioCodec *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
  AudioSampleRate *int64 `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  KeepOriginal *bool `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
  VideoBitrate *int64 `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
  VideoCodec *string `json:"video_codec,omitempty" xml:"video_codec,omitempty"`
  VideoFrameRate *int64 `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
  VideoOutputExt *string `json:"video_output_ext,omitempty" xml:"video_output_ext,omitempty"`
  VideoTemplateId *string `json:"video_template_id,omitempty" xml:"video_template_id,omitempty"`
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideoTemplate) String() string {
  return tea.Prettify(s)
}

func (s VideoPreviewVideoTemplate) GoString() string {
  return s.String()
}

func (s *VideoPreviewVideoTemplate) SetAudioBitrate(v int64) *VideoPreviewVideoTemplate {
  s.AudioBitrate = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetAudioChannel(v int64) *VideoPreviewVideoTemplate {
  s.AudioChannel = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetAudioCodec(v string) *VideoPreviewVideoTemplate {
  s.AudioCodec = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetAudioSampleRate(v int64) *VideoPreviewVideoTemplate {
  s.AudioSampleRate = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetHeight(v int64) *VideoPreviewVideoTemplate {
  s.Height = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetKeepOriginal(v bool) *VideoPreviewVideoTemplate {
  s.KeepOriginal = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetVideoBitrate(v int64) *VideoPreviewVideoTemplate {
  s.VideoBitrate = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetVideoCodec(v string) *VideoPreviewVideoTemplate {
  s.VideoCodec = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetVideoFrameRate(v int64) *VideoPreviewVideoTemplate {
  s.VideoFrameRate = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetVideoOutputExt(v string) *VideoPreviewVideoTemplate {
  s.VideoOutputExt = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetVideoTemplateId(v string) *VideoPreviewVideoTemplate {
  s.VideoTemplateId = &v
  return s
}

func (s *VideoPreviewVideoTemplate) SetWidth(v int64) *VideoPreviewVideoTemplate {
  s.Width = &v
  return s
}

/**
 * Add user to subdomain request
 */
type AddUserToSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s AddUserToSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s AddUserToSubdomainRequest) GoString() string {
  return s.String()
}

func (s *AddUserToSubdomainRequest) SetHeaders(v map[string]*string) *AddUserToSubdomainRequest {
  s.Headers = v
  return s
}

func (s *AddUserToSubdomainRequest) SetSubdomainId(v string) *AddUserToSubdomainRequest {
  s.SubdomainId = &v
  return s
}

func (s *AddUserToSubdomainRequest) SetUserId(v string) *AddUserToSubdomainRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type Address struct {
  City *string `json:"city,omitempty" xml:"city,omitempty"`
  Country *string `json:"country,omitempty" xml:"country,omitempty"`
  District *string `json:"district,omitempty" xml:"district,omitempty"`
  Province *string `json:"province,omitempty" xml:"province,omitempty"`
  Township *string `json:"township,omitempty" xml:"township,omitempty"`
}

func (s Address) String() string {
  return tea.Prettify(s)
}

func (s Address) GoString() string {
  return s.String()
}

func (s *Address) SetCity(v string) *Address {
  s.City = &v
  return s
}

func (s *Address) SetCountry(v string) *Address {
  s.Country = &v
  return s
}

func (s *Address) SetDistrict(v string) *Address {
  s.District = &v
  return s
}

func (s *Address) SetProvince(v string) *Address {
  s.Province = &v
  return s
}

func (s *Address) SetTownship(v string) *Address {
  s.Township = &v
  return s
}

/**
 * 
 */
type AlbumsBaseRequest struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
}

func (s AlbumsBaseRequest) String() string {
  return tea.Prettify(s)
}

func (s AlbumsBaseRequest) GoString() string {
  return s.String()
}

func (s *AlbumsBaseRequest) SetDriveId(v string) *AlbumsBaseRequest {
  s.DriveId = &v
  return s
}

/**
 * 
 */
type BaseGroupIDRequest struct {
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s BaseGroupIDRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseGroupIDRequest) GoString() string {
  return s.String()
}

func (s *BaseGroupIDRequest) SetGroupId(v string) *BaseGroupIDRequest {
  s.GroupId = &v
  return s
}

func (s *BaseGroupIDRequest) SetSubdomainId(v string) *BaseGroupIDRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type BaseGroupRequest struct {
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
  // group
  IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
}

func (s BaseGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s BaseGroupRequest) GoString() string {
  return s.String()
}

func (s *BaseGroupRequest) SetDescription(v string) *BaseGroupRequest {
  s.Description = &v
  return s
}

func (s *BaseGroupRequest) SetGroupName(v string) *BaseGroupRequest {
  s.GroupName = &v
  return s
}

func (s *BaseGroupRequest) SetIsRoot(v bool) *BaseGroupRequest {
  s.IsRoot = &v
  return s
}

/**
 * 
 */
type BaseGroupResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // group name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseGroupResponse) GoString() string {
  return s.String()
}

func (s *BaseGroupResponse) SetCreatedAt(v int64) *BaseGroupResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseGroupResponse) SetDescription(v string) *BaseGroupResponse {
  s.Description = &v
  return s
}

func (s *BaseGroupResponse) SetDomainId(v string) *BaseGroupResponse {
  s.DomainId = &v
  return s
}

func (s *BaseGroupResponse) SetGroupId(v string) *BaseGroupResponse {
  s.GroupId = &v
  return s
}

func (s *BaseGroupResponse) SetGroupName(v string) *BaseGroupResponse {
  s.GroupName = &v
  return s
}

func (s *BaseGroupResponse) SetUpdatedAt(v int64) *BaseGroupResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type BaseMembershipResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s BaseMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseMembershipResponse) GoString() string {
  return s.String()
}

func (s *BaseMembershipResponse) SetCreatedAt(v int64) *BaseMembershipResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseMembershipResponse) SetDescription(v string) *BaseMembershipResponse {
  s.Description = &v
  return s
}

func (s *BaseMembershipResponse) SetDomainId(v string) *BaseMembershipResponse {
  s.DomainId = &v
  return s
}

func (s *BaseMembershipResponse) SetGroupId(v string) *BaseMembershipResponse {
  s.GroupId = &v
  return s
}

func (s *BaseMembershipResponse) SetMemberRole(v string) *BaseMembershipResponse {
  s.MemberRole = &v
  return s
}

func (s *BaseMembershipResponse) SetMemberType(v string) *BaseMembershipResponse {
  s.MemberType = &v
  return s
}

func (s *BaseMembershipResponse) SetSubGroupId(v string) *BaseMembershipResponse {
  s.SubGroupId = &v
  return s
}

func (s *BaseMembershipResponse) SetUpdatedAt(v int64) *BaseMembershipResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseMembershipResponse) SetUserId(v string) *BaseMembershipResponse {
  s.UserId = &v
  return s
}

/**
 * Base user response
 */
type BaseUserResponse struct {
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // 
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s BaseUserResponse) String() string {
  return tea.Prettify(s)
}

func (s BaseUserResponse) GoString() string {
  return s.String()
}

func (s *BaseUserResponse) SetAvatar(v string) *BaseUserResponse {
  s.Avatar = &v
  return s
}

func (s *BaseUserResponse) SetCreatedAt(v int64) *BaseUserResponse {
  s.CreatedAt = &v
  return s
}

func (s *BaseUserResponse) SetDefaultDriveId(v string) *BaseUserResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *BaseUserResponse) SetDenyChangePasswordBySelf(v bool) *BaseUserResponse {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *BaseUserResponse) SetDescription(v string) *BaseUserResponse {
  s.Description = &v
  return s
}

func (s *BaseUserResponse) SetDomainId(v string) *BaseUserResponse {
  s.DomainId = &v
  return s
}

func (s *BaseUserResponse) SetEmail(v string) *BaseUserResponse {
  s.Email = &v
  return s
}

func (s *BaseUserResponse) SetNeedChangePasswordNextLogin(v bool) *BaseUserResponse {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *BaseUserResponse) SetNickName(v string) *BaseUserResponse {
  s.NickName = &v
  return s
}

func (s *BaseUserResponse) SetPhone(v string) *BaseUserResponse {
  s.Phone = &v
  return s
}

func (s *BaseUserResponse) SetPunishFlag(v int64) *BaseUserResponse {
  s.PunishFlag = &v
  return s
}

func (s *BaseUserResponse) SetRole(v string) *BaseUserResponse {
  s.Role = &v
  return s
}

func (s *BaseUserResponse) SetStatus(v string) *BaseUserResponse {
  s.Status = &v
  return s
}

func (s *BaseUserResponse) SetUpdatedAt(v int64) *BaseUserResponse {
  s.UpdatedAt = &v
  return s
}

func (s *BaseUserResponse) SetUserData(v map[string]interface{}) *BaseUserResponse {
  s.UserData = v
  return s
}

func (s *BaseUserResponse) SetUserId(v string) *BaseUserResponse {
  s.UserId = &v
  return s
}

func (s *BaseUserResponse) SetUserName(v string) *BaseUserResponse {
  s.UserName = &v
  return s
}

/**
 * 
 */
type CreateGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // 
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
  // group
  IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
  // parent group id
  ParentGroupId *string `json:"parent_group_id,omitempty" xml:"parent_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s CreateGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateGroupRequest) GoString() string {
  return s.String()
}

func (s *CreateGroupRequest) SetHeaders(v map[string]*string) *CreateGroupRequest {
  s.Headers = v
  return s
}

func (s *CreateGroupRequest) SetDescription(v string) *CreateGroupRequest {
  s.Description = &v
  return s
}

func (s *CreateGroupRequest) SetGroupName(v string) *CreateGroupRequest {
  s.GroupName = &v
  return s
}

func (s *CreateGroupRequest) SetIsRoot(v bool) *CreateGroupRequest {
  s.IsRoot = &v
  return s
}

func (s *CreateGroupRequest) SetParentGroupId(v string) *CreateGroupRequest {
  s.ParentGroupId = &v
  return s
}

func (s *CreateGroupRequest) SetSubdomainId(v string) *CreateGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type CreateGroupResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // group name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s CreateGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateGroupResponse) GoString() string {
  return s.String()
}

func (s *CreateGroupResponse) SetCreatedAt(v int64) *CreateGroupResponse {
  s.CreatedAt = &v
  return s
}

func (s *CreateGroupResponse) SetDescription(v string) *CreateGroupResponse {
  s.Description = &v
  return s
}

func (s *CreateGroupResponse) SetDomainId(v string) *CreateGroupResponse {
  s.DomainId = &v
  return s
}

func (s *CreateGroupResponse) SetGroupId(v string) *CreateGroupResponse {
  s.GroupId = &v
  return s
}

func (s *CreateGroupResponse) SetGroupName(v string) *CreateGroupResponse {
  s.GroupName = &v
  return s
}

func (s *CreateGroupResponse) SetUpdatedAt(v int64) *CreateGroupResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type CreateMembershipRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s CreateMembershipRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateMembershipRequest) GoString() string {
  return s.String()
}

func (s *CreateMembershipRequest) SetHeaders(v map[string]*string) *CreateMembershipRequest {
  s.Headers = v
  return s
}

func (s *CreateMembershipRequest) SetDescription(v string) *CreateMembershipRequest {
  s.Description = &v
  return s
}

func (s *CreateMembershipRequest) SetGroupId(v string) *CreateMembershipRequest {
  s.GroupId = &v
  return s
}

func (s *CreateMembershipRequest) SetMemberRole(v string) *CreateMembershipRequest {
  s.MemberRole = &v
  return s
}

func (s *CreateMembershipRequest) SetMemberType(v string) *CreateMembershipRequest {
  s.MemberType = &v
  return s
}

func (s *CreateMembershipRequest) SetSubGroupId(v string) *CreateMembershipRequest {
  s.SubGroupId = &v
  return s
}

func (s *CreateMembershipRequest) SetSubdomainId(v string) *CreateMembershipRequest {
  s.SubdomainId = &v
  return s
}

func (s *CreateMembershipRequest) SetUserId(v string) *CreateMembershipRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type CreateMembershipResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s CreateMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateMembershipResponse) GoString() string {
  return s.String()
}

func (s *CreateMembershipResponse) SetCreatedAt(v int64) *CreateMembershipResponse {
  s.CreatedAt = &v
  return s
}

func (s *CreateMembershipResponse) SetDescription(v string) *CreateMembershipResponse {
  s.Description = &v
  return s
}

func (s *CreateMembershipResponse) SetDomainId(v string) *CreateMembershipResponse {
  s.DomainId = &v
  return s
}

func (s *CreateMembershipResponse) SetGroupId(v string) *CreateMembershipResponse {
  s.GroupId = &v
  return s
}

func (s *CreateMembershipResponse) SetMemberRole(v string) *CreateMembershipResponse {
  s.MemberRole = &v
  return s
}

func (s *CreateMembershipResponse) SetMemberType(v string) *CreateMembershipResponse {
  s.MemberType = &v
  return s
}

func (s *CreateMembershipResponse) SetSubGroupId(v string) *CreateMembershipResponse {
  s.SubGroupId = &v
  return s
}

func (s *CreateMembershipResponse) SetUpdatedAt(v int64) *CreateMembershipResponse {
  s.UpdatedAt = &v
  return s
}

func (s *CreateMembershipResponse) SetUserId(v string) *CreateMembershipResponse {
  s.UserId = &v
  return s
}

/**
 * Create story request
 */
type CreateStoryRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // max_image_count
  MaxImageCount *int64 `json:"max_image_count,omitempty" xml:"max_image_count,omitempty"`
  // min_image_count
  MinImageCount *int64 `json:"min_image_count,omitempty" xml:"min_image_count,omitempty"`
  // story_end_time
  StoryEndTime *string `json:"story_end_time,omitempty" xml:"story_end_time,omitempty"`
  // story_name
  StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
  // story_start_time
  StoryStartTime *string `json:"story_start_time,omitempty" xml:"story_start_time,omitempty"`
  // story_type
  StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty" require:"true"`
}

func (s CreateStoryRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateStoryRequest) GoString() string {
  return s.String()
}

func (s *CreateStoryRequest) SetHeaders(v map[string]*string) *CreateStoryRequest {
  s.Headers = v
  return s
}

func (s *CreateStoryRequest) SetDriveId(v string) *CreateStoryRequest {
  s.DriveId = &v
  return s
}

func (s *CreateStoryRequest) SetMaxImageCount(v int64) *CreateStoryRequest {
  s.MaxImageCount = &v
  return s
}

func (s *CreateStoryRequest) SetMinImageCount(v int64) *CreateStoryRequest {
  s.MinImageCount = &v
  return s
}

func (s *CreateStoryRequest) SetStoryEndTime(v string) *CreateStoryRequest {
  s.StoryEndTime = &v
  return s
}

func (s *CreateStoryRequest) SetStoryName(v string) *CreateStoryRequest {
  s.StoryName = &v
  return s
}

func (s *CreateStoryRequest) SetStoryStartTime(v string) *CreateStoryRequest {
  s.StoryStartTime = &v
  return s
}

func (s *CreateStoryRequest) SetStoryType(v string) *CreateStoryRequest {
  s.StoryType = &v
  return s
}

/**
 * 
 */
type CreateStoryResponse struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
}

func (s CreateStoryResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateStoryResponse) GoString() string {
  return s.String()
}

func (s *CreateStoryResponse) SetDriveId(v string) *CreateStoryResponse {
  s.DriveId = &v
  return s
}

/**
 * Create user request
 */
type CreateUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  GroupInfoList []*GroupInfo `json:"group_info_list,omitempty" xml:"group_info_list,omitempty" type:"Repeated"`
  // 
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s CreateUserRequest) String() string {
  return tea.Prettify(s)
}

func (s CreateUserRequest) GoString() string {
  return s.String()
}

func (s *CreateUserRequest) SetHeaders(v map[string]*string) *CreateUserRequest {
  s.Headers = v
  return s
}

func (s *CreateUserRequest) SetAvatar(v string) *CreateUserRequest {
  s.Avatar = &v
  return s
}

func (s *CreateUserRequest) SetDenyChangePasswordBySelf(v bool) *CreateUserRequest {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *CreateUserRequest) SetDescription(v string) *CreateUserRequest {
  s.Description = &v
  return s
}

func (s *CreateUserRequest) SetEmail(v string) *CreateUserRequest {
  s.Email = &v
  return s
}

func (s *CreateUserRequest) SetGroupInfoList(v []*GroupInfo) *CreateUserRequest {
  s.GroupInfoList = v
  return s
}

func (s *CreateUserRequest) SetLocation(v string) *CreateUserRequest {
  s.Location = &v
  return s
}

func (s *CreateUserRequest) SetNeedChangePasswordNextLogin(v bool) *CreateUserRequest {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *CreateUserRequest) SetNickName(v string) *CreateUserRequest {
  s.NickName = &v
  return s
}

func (s *CreateUserRequest) SetPhone(v string) *CreateUserRequest {
  s.Phone = &v
  return s
}

func (s *CreateUserRequest) SetPlainPassword(v string) *CreateUserRequest {
  s.PlainPassword = &v
  return s
}

func (s *CreateUserRequest) SetRole(v string) *CreateUserRequest {
  s.Role = &v
  return s
}

func (s *CreateUserRequest) SetStatus(v string) *CreateUserRequest {
  s.Status = &v
  return s
}

func (s *CreateUserRequest) SetSubdomainId(v string) *CreateUserRequest {
  s.SubdomainId = &v
  return s
}

func (s *CreateUserRequest) SetUserData(v map[string]interface{}) *CreateUserRequest {
  s.UserData = v
  return s
}

func (s *CreateUserRequest) SetUserId(v string) *CreateUserRequest {
  s.UserId = &v
  return s
}

func (s *CreateUserRequest) SetUserName(v string) *CreateUserRequest {
  s.UserName = &v
  return s
}

/**
 * Create user response
 */
type CreateUserResponse struct {
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // 
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s CreateUserResponse) String() string {
  return tea.Prettify(s)
}

func (s CreateUserResponse) GoString() string {
  return s.String()
}

func (s *CreateUserResponse) SetAvatar(v string) *CreateUserResponse {
  s.Avatar = &v
  return s
}

func (s *CreateUserResponse) SetCreatedAt(v int64) *CreateUserResponse {
  s.CreatedAt = &v
  return s
}

func (s *CreateUserResponse) SetDefaultDriveId(v string) *CreateUserResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *CreateUserResponse) SetDenyChangePasswordBySelf(v bool) *CreateUserResponse {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *CreateUserResponse) SetDescription(v string) *CreateUserResponse {
  s.Description = &v
  return s
}

func (s *CreateUserResponse) SetDomainId(v string) *CreateUserResponse {
  s.DomainId = &v
  return s
}

func (s *CreateUserResponse) SetEmail(v string) *CreateUserResponse {
  s.Email = &v
  return s
}

func (s *CreateUserResponse) SetNeedChangePasswordNextLogin(v bool) *CreateUserResponse {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *CreateUserResponse) SetNickName(v string) *CreateUserResponse {
  s.NickName = &v
  return s
}

func (s *CreateUserResponse) SetPhone(v string) *CreateUserResponse {
  s.Phone = &v
  return s
}

func (s *CreateUserResponse) SetPunishFlag(v int64) *CreateUserResponse {
  s.PunishFlag = &v
  return s
}

func (s *CreateUserResponse) SetRole(v string) *CreateUserResponse {
  s.Role = &v
  return s
}

func (s *CreateUserResponse) SetStatus(v string) *CreateUserResponse {
  s.Status = &v
  return s
}

func (s *CreateUserResponse) SetUpdatedAt(v int64) *CreateUserResponse {
  s.UpdatedAt = &v
  return s
}

func (s *CreateUserResponse) SetUserData(v map[string]interface{}) *CreateUserResponse {
  s.UserData = v
  return s
}

func (s *CreateUserResponse) SetUserId(v string) *CreateUserResponse {
  s.UserId = &v
  return s
}

func (s *CreateUserResponse) SetUserName(v string) *CreateUserResponse {
  s.UserName = &v
  return s
}

/**
 * 
 */
type DeleteGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s DeleteGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteGroupRequest) GoString() string {
  return s.String()
}

func (s *DeleteGroupRequest) SetHeaders(v map[string]*string) *DeleteGroupRequest {
  s.Headers = v
  return s
}

func (s *DeleteGroupRequest) SetGroupId(v string) *DeleteGroupRequest {
  s.GroupId = &v
  return s
}

func (s *DeleteGroupRequest) SetSubdomainId(v string) *DeleteGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type DeleteGroupResponse struct {
}

func (s DeleteGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteGroupResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type DeleteMembershipRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s DeleteMembershipRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteMembershipRequest) GoString() string {
  return s.String()
}

func (s *DeleteMembershipRequest) SetHeaders(v map[string]*string) *DeleteMembershipRequest {
  s.Headers = v
  return s
}

func (s *DeleteMembershipRequest) SetGroupId(v string) *DeleteMembershipRequest {
  s.GroupId = &v
  return s
}

func (s *DeleteMembershipRequest) SetMemberType(v string) *DeleteMembershipRequest {
  s.MemberType = &v
  return s
}

func (s *DeleteMembershipRequest) SetSubGroupId(v string) *DeleteMembershipRequest {
  s.SubGroupId = &v
  return s
}

func (s *DeleteMembershipRequest) SetSubdomainId(v string) *DeleteMembershipRequest {
  s.SubdomainId = &v
  return s
}

func (s *DeleteMembershipRequest) SetUserId(v string) *DeleteMembershipRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type DeleteMembershipResponse struct {
}

func (s DeleteMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteMembershipResponse) GoString() string {
  return s.String()
}

/**
 * Delete user request
 */
type DeleteUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s DeleteUserRequest) String() string {
  return tea.Prettify(s)
}

func (s DeleteUserRequest) GoString() string {
  return s.String()
}

func (s *DeleteUserRequest) SetHeaders(v map[string]*string) *DeleteUserRequest {
  s.Headers = v
  return s
}

func (s *DeleteUserRequest) SetUserId(v string) *DeleteUserRequest {
  s.UserId = &v
  return s
}

/**
 * Delete user response
 */
type DeleteUserResponse struct {
}

func (s DeleteUserResponse) String() string {
  return tea.Prettify(s)
}

func (s DeleteUserResponse) GoString() string {
  return s.String()
}

/**
 * 
 */
type FaceBoundary struct {
  Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
  Left *int64 `json:"left,omitempty" xml:"left,omitempty"`
  Top *int64 `json:"top,omitempty" xml:"top,omitempty"`
  Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s FaceBoundary) String() string {
  return tea.Prettify(s)
}

func (s FaceBoundary) GoString() string {
  return s.String()
}

func (s *FaceBoundary) SetHeight(v int64) *FaceBoundary {
  s.Height = &v
  return s
}

func (s *FaceBoundary) SetLeft(v int64) *FaceBoundary {
  s.Left = &v
  return s
}

func (s *FaceBoundary) SetTop(v int64) *FaceBoundary {
  s.Top = &v
  return s
}

func (s *FaceBoundary) SetWidth(v int64) *FaceBoundary {
  s.Width = &v
  return s
}

/**
 * find story request
 */
type FindStoriesRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // cover_image_thumbnail_process
  CoverImageThumbnailProcess *string `json:"cover_image_thumbnail_process,omitempty" xml:"cover_image_thumbnail_process,omitempty"`
  // cover_video_thumbnail_process
  CoverVideoThumbnailProcess *string `json:"cover_video_thumbnail_process,omitempty" xml:"cover_video_thumbnail_process,omitempty"`
  CreateTimeRange *FindStoryRequestTimeRange `json:"create_time_range,omitempty" xml:"create_time_range,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // event_type
  EventType *string `json:"event_type,omitempty" xml:"event_type,omitempty"`
  // face_group_ids
  FaceGroupIds []*string `json:"face_group_ids,omitempty" xml:"face_group_ids,omitempty" type:"Repeated"`
  // limit
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty"`
  // marker
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  StoryEndTimeRange *FindStoryRequestTimeRange `json:"story_end_time_range,omitempty" xml:"story_end_time_range,omitempty"`
  // story_id
  StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
  // story_name
  StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
  StoryStartTimeRange *FindStoryRequestTimeRange `json:"story_start_time_range,omitempty" xml:"story_start_time_range,omitempty"`
  // story_type
  StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty"`
}

func (s FindStoriesRequest) String() string {
  return tea.Prettify(s)
}

func (s FindStoriesRequest) GoString() string {
  return s.String()
}

func (s *FindStoriesRequest) SetHeaders(v map[string]*string) *FindStoriesRequest {
  s.Headers = v
  return s
}

func (s *FindStoriesRequest) SetCoverImageThumbnailProcess(v string) *FindStoriesRequest {
  s.CoverImageThumbnailProcess = &v
  return s
}

func (s *FindStoriesRequest) SetCoverVideoThumbnailProcess(v string) *FindStoriesRequest {
  s.CoverVideoThumbnailProcess = &v
  return s
}

func (s *FindStoriesRequest) SetCreateTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
  s.CreateTimeRange = v
  return s
}

func (s *FindStoriesRequest) SetDriveId(v string) *FindStoriesRequest {
  s.DriveId = &v
  return s
}

func (s *FindStoriesRequest) SetEventType(v string) *FindStoriesRequest {
  s.EventType = &v
  return s
}

func (s *FindStoriesRequest) SetFaceGroupIds(v []*string) *FindStoriesRequest {
  s.FaceGroupIds = v
  return s
}

func (s *FindStoriesRequest) SetLimit(v int64) *FindStoriesRequest {
  s.Limit = &v
  return s
}

func (s *FindStoriesRequest) SetMarker(v string) *FindStoriesRequest {
  s.Marker = &v
  return s
}

func (s *FindStoriesRequest) SetStoryEndTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
  s.StoryEndTimeRange = v
  return s
}

func (s *FindStoriesRequest) SetStoryId(v string) *FindStoriesRequest {
  s.StoryId = &v
  return s
}

func (s *FindStoriesRequest) SetStoryName(v string) *FindStoriesRequest {
  s.StoryName = &v
  return s
}

func (s *FindStoriesRequest) SetStoryStartTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
  s.StoryStartTimeRange = v
  return s
}

func (s *FindStoriesRequest) SetStoryType(v string) *FindStoriesRequest {
  s.StoryType = &v
  return s
}

func (s *FindStoriesRequest) SetUrlExpireSec(v int64) *FindStoriesRequest {
  s.UrlExpireSec = &v
  return s
}

/**
 * 
 */
type FindStoriesResponse struct {
  // items
  Items []*GetStoryResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s FindStoriesResponse) String() string {
  return tea.Prettify(s)
}

func (s FindStoriesResponse) GoString() string {
  return s.String()
}

func (s *FindStoriesResponse) SetItems(v []*GetStoryResponse) *FindStoriesResponse {
  s.Items = v
  return s
}

func (s *FindStoriesResponse) SetNextMarker(v string) *FindStoriesResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type FindStoryRequestTimeRange struct {
  // end
  End *string `json:"end,omitempty" xml:"end,omitempty"`
  // start
  Start *string `json:"start,omitempty" xml:"start,omitempty"`
}

func (s FindStoryRequestTimeRange) String() string {
  return tea.Prettify(s)
}

func (s FindStoryRequestTimeRange) GoString() string {
  return s.String()
}

func (s *FindStoryRequestTimeRange) SetEnd(v string) *FindStoryRequestTimeRange {
  s.End = &v
  return s
}

func (s *FindStoryRequestTimeRange) SetStart(v string) *FindStoryRequestTimeRange {
  s.Start = &v
  return s
}

/**
 * 
 */
type GetGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s GetGroupRequest) GoString() string {
  return s.String()
}

func (s *GetGroupRequest) SetHeaders(v map[string]*string) *GetGroupRequest {
  s.Headers = v
  return s
}

func (s *GetGroupRequest) SetGroupId(v string) *GetGroupRequest {
  s.GroupId = &v
  return s
}

func (s *GetGroupRequest) SetSubdomainId(v string) *GetGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type GetGroupResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // group name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s GetGroupResponse) GoString() string {
  return s.String()
}

func (s *GetGroupResponse) SetCreatedAt(v int64) *GetGroupResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetGroupResponse) SetDescription(v string) *GetGroupResponse {
  s.Description = &v
  return s
}

func (s *GetGroupResponse) SetDomainId(v string) *GetGroupResponse {
  s.DomainId = &v
  return s
}

func (s *GetGroupResponse) SetGroupId(v string) *GetGroupResponse {
  s.GroupId = &v
  return s
}

func (s *GetGroupResponse) SetGroupName(v string) *GetGroupResponse {
  s.GroupName = &v
  return s
}

func (s *GetGroupResponse) SetUpdatedAt(v int64) *GetGroupResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * Get photo count request
 */
type GetImageCountRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
}

func (s GetImageCountRequest) String() string {
  return tea.Prettify(s)
}

func (s GetImageCountRequest) GoString() string {
  return s.String()
}

func (s *GetImageCountRequest) SetHeaders(v map[string]*string) *GetImageCountRequest {
  s.Headers = v
  return s
}

func (s *GetImageCountRequest) SetDriveId(v string) *GetImageCountRequest {
  s.DriveId = &v
  return s
}

/**
 * 
 */
type GetImageCountResponse struct {
  // image_count
  ImageCount *int64 `json:"image_count,omitempty" xml:"image_count,omitempty"`
}

func (s GetImageCountResponse) String() string {
  return tea.Prettify(s)
}

func (s GetImageCountResponse) GoString() string {
  return s.String()
}

func (s *GetImageCountResponse) SetImageCount(v int64) *GetImageCountResponse {
  s.ImageCount = &v
  return s
}

/**
 * 
 */
type GetMembershipRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetMembershipRequest) String() string {
  return tea.Prettify(s)
}

func (s GetMembershipRequest) GoString() string {
  return s.String()
}

func (s *GetMembershipRequest) SetHeaders(v map[string]*string) *GetMembershipRequest {
  s.Headers = v
  return s
}

func (s *GetMembershipRequest) SetGroupId(v string) *GetMembershipRequest {
  s.GroupId = &v
  return s
}

func (s *GetMembershipRequest) SetMemberType(v string) *GetMembershipRequest {
  s.MemberType = &v
  return s
}

func (s *GetMembershipRequest) SetSubGroupId(v string) *GetMembershipRequest {
  s.SubGroupId = &v
  return s
}

func (s *GetMembershipRequest) SetSubdomainId(v string) *GetMembershipRequest {
  s.SubdomainId = &v
  return s
}

func (s *GetMembershipRequest) SetUserId(v string) *GetMembershipRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type GetMembershipResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s GetMembershipResponse) GoString() string {
  return s.String()
}

func (s *GetMembershipResponse) SetCreatedAt(v int64) *GetMembershipResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetMembershipResponse) SetDescription(v string) *GetMembershipResponse {
  s.Description = &v
  return s
}

func (s *GetMembershipResponse) SetDomainId(v string) *GetMembershipResponse {
  s.DomainId = &v
  return s
}

func (s *GetMembershipResponse) SetGroupId(v string) *GetMembershipResponse {
  s.GroupId = &v
  return s
}

func (s *GetMembershipResponse) SetMemberRole(v string) *GetMembershipResponse {
  s.MemberRole = &v
  return s
}

func (s *GetMembershipResponse) SetMemberType(v string) *GetMembershipResponse {
  s.MemberType = &v
  return s
}

func (s *GetMembershipResponse) SetSubGroupId(v string) *GetMembershipResponse {
  s.SubGroupId = &v
  return s
}

func (s *GetMembershipResponse) SetUpdatedAt(v int64) *GetMembershipResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetMembershipResponse) SetUserId(v string) *GetMembershipResponse {
  s.UserId = &v
  return s
}

/**
 * Get story request
 */
type GetStoryRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // cover_image_thumbnail_process
  CoverImageThumbnailProcess *string `json:"cover_image_thumbnail_process,omitempty" xml:"cover_image_thumbnail_process,omitempty"`
  // cover_video_thumbnail_process
  CoverVideoThumbnailProcess *string `json:"cover_video_thumbnail_process,omitempty" xml:"cover_video_thumbnail_process,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // image_process
  ImageProcess *string `json:"image_process,omitempty" xml:"image_process,omitempty"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // story_id
  StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty" require:"true"`
  // url_expire_sec
  UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty"`
  // video_thumbnail_process
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetStoryRequest) String() string {
  return tea.Prettify(s)
}

func (s GetStoryRequest) GoString() string {
  return s.String()
}

func (s *GetStoryRequest) SetHeaders(v map[string]*string) *GetStoryRequest {
  s.Headers = v
  return s
}

func (s *GetStoryRequest) SetCoverImageThumbnailProcess(v string) *GetStoryRequest {
  s.CoverImageThumbnailProcess = &v
  return s
}

func (s *GetStoryRequest) SetCoverVideoThumbnailProcess(v string) *GetStoryRequest {
  s.CoverVideoThumbnailProcess = &v
  return s
}

func (s *GetStoryRequest) SetDriveId(v string) *GetStoryRequest {
  s.DriveId = &v
  return s
}

func (s *GetStoryRequest) SetImageProcess(v string) *GetStoryRequest {
  s.ImageProcess = &v
  return s
}

func (s *GetStoryRequest) SetImageThumbnailProcess(v string) *GetStoryRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *GetStoryRequest) SetStoryId(v string) *GetStoryRequest {
  s.StoryId = &v
  return s
}

func (s *GetStoryRequest) SetUrlExpireSec(v int64) *GetStoryRequest {
  s.UrlExpireSec = &v
  return s
}

func (s *GetStoryRequest) SetVideoThumbnailProcess(v string) *GetStoryRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type GetStoryResponse struct {
  // cover_file_id
  CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
  // cover_file_url
  CoverFileThumbnailUrl *string `json:"cover_file_thumbnail_url,omitempty" xml:"cover_file_thumbnail_url,omitempty"`
  // created_at
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // event_type
  EventType *string `json:"event_type,omitempty" xml:"event_type,omitempty"`
  // face_group_ids
  FaceGroupIds []*string `json:"face_group_ids,omitempty" xml:"face_group_ids,omitempty" type:"Repeated"`
  // story_end_time
  StoryEndTime *string `json:"story_end_time,omitempty" xml:"story_end_time,omitempty"`
  StoryFileList []*BaseCCPFileResponse `json:"story_file_list,omitempty" xml:"story_file_list,omitempty" type:"Repeated"`
  // story_id
  StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
  // story_name
  StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
  // story_start_time
  StoryStartTime *string `json:"story_start_time,omitempty" xml:"story_start_time,omitempty"`
  // story_type
  StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty"`
  // updated_at
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetStoryResponse) String() string {
  return tea.Prettify(s)
}

func (s GetStoryResponse) GoString() string {
  return s.String()
}

func (s *GetStoryResponse) SetCoverFileId(v string) *GetStoryResponse {
  s.CoverFileId = &v
  return s
}

func (s *GetStoryResponse) SetCoverFileThumbnailUrl(v string) *GetStoryResponse {
  s.CoverFileThumbnailUrl = &v
  return s
}

func (s *GetStoryResponse) SetCreatedAt(v string) *GetStoryResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetStoryResponse) SetEventType(v string) *GetStoryResponse {
  s.EventType = &v
  return s
}

func (s *GetStoryResponse) SetFaceGroupIds(v []*string) *GetStoryResponse {
  s.FaceGroupIds = v
  return s
}

func (s *GetStoryResponse) SetStoryEndTime(v string) *GetStoryResponse {
  s.StoryEndTime = &v
  return s
}

func (s *GetStoryResponse) SetStoryFileList(v []*BaseCCPFileResponse) *GetStoryResponse {
  s.StoryFileList = v
  return s
}

func (s *GetStoryResponse) SetStoryId(v string) *GetStoryResponse {
  s.StoryId = &v
  return s
}

func (s *GetStoryResponse) SetStoryName(v string) *GetStoryResponse {
  s.StoryName = &v
  return s
}

func (s *GetStoryResponse) SetStoryStartTime(v string) *GetStoryResponse {
  s.StoryStartTime = &v
  return s
}

func (s *GetStoryResponse) SetStoryType(v string) *GetStoryResponse {
  s.StoryType = &v
  return s
}

func (s *GetStoryResponse) SetUpdatedAt(v string) *GetStoryResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * Get user request
 */
type GetUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  //  ID, ak, access_tokenuser
  // example
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetUserRequest) String() string {
  return tea.Prettify(s)
}

func (s GetUserRequest) GoString() string {
  return s.String()
}

func (s *GetUserRequest) SetHeaders(v map[string]*string) *GetUserRequest {
  s.Headers = v
  return s
}

func (s *GetUserRequest) SetUserId(v string) *GetUserRequest {
  s.UserId = &v
  return s
}

/**
 * Get user response
 */
type GetUserResponse struct {
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // 
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s GetUserResponse) String() string {
  return tea.Prettify(s)
}

func (s GetUserResponse) GoString() string {
  return s.String()
}

func (s *GetUserResponse) SetAvatar(v string) *GetUserResponse {
  s.Avatar = &v
  return s
}

func (s *GetUserResponse) SetCreatedAt(v int64) *GetUserResponse {
  s.CreatedAt = &v
  return s
}

func (s *GetUserResponse) SetDefaultDriveId(v string) *GetUserResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *GetUserResponse) SetDenyChangePasswordBySelf(v bool) *GetUserResponse {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *GetUserResponse) SetDescription(v string) *GetUserResponse {
  s.Description = &v
  return s
}

func (s *GetUserResponse) SetDomainId(v string) *GetUserResponse {
  s.DomainId = &v
  return s
}

func (s *GetUserResponse) SetEmail(v string) *GetUserResponse {
  s.Email = &v
  return s
}

func (s *GetUserResponse) SetNeedChangePasswordNextLogin(v bool) *GetUserResponse {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *GetUserResponse) SetNickName(v string) *GetUserResponse {
  s.NickName = &v
  return s
}

func (s *GetUserResponse) SetPhone(v string) *GetUserResponse {
  s.Phone = &v
  return s
}

func (s *GetUserResponse) SetPunishFlag(v int64) *GetUserResponse {
  s.PunishFlag = &v
  return s
}

func (s *GetUserResponse) SetRole(v string) *GetUserResponse {
  s.Role = &v
  return s
}

func (s *GetUserResponse) SetStatus(v string) *GetUserResponse {
  s.Status = &v
  return s
}

func (s *GetUserResponse) SetUpdatedAt(v int64) *GetUserResponse {
  s.UpdatedAt = &v
  return s
}

func (s *GetUserResponse) SetUserData(v map[string]interface{}) *GetUserResponse {
  s.UserData = v
  return s
}

func (s *GetUserResponse) SetUserId(v string) *GetUserResponse {
  s.UserId = &v
  return s
}

func (s *GetUserResponse) SetUserName(v string) *GetUserResponse {
  s.UserName = &v
  return s
}

/**
 * 
 */
type GroupInfo struct {
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // MemberRole 
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
}

func (s GroupInfo) String() string {
  return tea.Prettify(s)
}

func (s GroupInfo) GoString() string {
  return s.String()
}

func (s *GroupInfo) SetGroupId(v string) *GroupInfo {
  s.GroupId = &v
  return s
}

func (s *GroupInfo) SetMemberRole(v string) *GroupInfo {
  s.MemberRole = &v
  return s
}

/**
 * 
 */
type HasMemberRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s HasMemberRequest) String() string {
  return tea.Prettify(s)
}

func (s HasMemberRequest) GoString() string {
  return s.String()
}

func (s *HasMemberRequest) SetHeaders(v map[string]*string) *HasMemberRequest {
  s.Headers = v
  return s
}

func (s *HasMemberRequest) SetGroupId(v string) *HasMemberRequest {
  s.GroupId = &v
  return s
}

func (s *HasMemberRequest) SetMemberType(v string) *HasMemberRequest {
  s.MemberType = &v
  return s
}

func (s *HasMemberRequest) SetSubGroupId(v string) *HasMemberRequest {
  s.SubGroupId = &v
  return s
}

func (s *HasMemberRequest) SetSubdomainId(v string) *HasMemberRequest {
  s.SubdomainId = &v
  return s
}

func (s *HasMemberRequest) SetUserId(v string) *HasMemberRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type HasMembershipResponse struct {
  Result *bool `json:"result,omitempty" xml:"result,omitempty"`
}

func (s HasMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s HasMembershipResponse) GoString() string {
  return s.String()
}

func (s *HasMembershipResponse) SetResult(v bool) *HasMembershipResponse {
  s.Result = &v
  return s
}

/**
 * 
 */
type ImageAddressResponse struct {
  AddressDetail *Address `json:"address_detail,omitempty" xml:"address_detail,omitempty"`
  // 
  Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
  // cover_file_id
  CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
  // 
  CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
  // 
  Location *string `json:"location,omitempty" xml:"location,omitempty"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ImageAddressResponse) String() string {
  return tea.Prettify(s)
}

func (s ImageAddressResponse) GoString() string {
  return s.String()
}

func (s *ImageAddressResponse) SetAddressDetail(v *Address) *ImageAddressResponse {
  s.AddressDetail = v
  return s
}

func (s *ImageAddressResponse) SetCount(v int64) *ImageAddressResponse {
  s.Count = &v
  return s
}

func (s *ImageAddressResponse) SetCoverFileId(v string) *ImageAddressResponse {
  s.CoverFileId = &v
  return s
}

func (s *ImageAddressResponse) SetCoverUrl(v string) *ImageAddressResponse {
  s.CoverUrl = &v
  return s
}

func (s *ImageAddressResponse) SetLocation(v string) *ImageAddressResponse {
  s.Location = &v
  return s
}

func (s *ImageAddressResponse) SetName(v string) *ImageAddressResponse {
  s.Name = &v
  return s
}

/**
 * 
 */
type ImageFaceGroupResponse struct {
  // 
  CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // 
  FaceCount *int64 `json:"face_count,omitempty" xml:"face_count,omitempty"`
  GroupCoverFaceBoundary *FaceBoundary `json:"group_cover_face_boundary,omitempty" xml:"group_cover_face_boundary,omitempty"`
  // group_cover_file_id
  GroupCoverFileId *string `json:"group_cover_file_id,omitempty" xml:"group_cover_file_id,omitempty"`
  // group_cover_height
  GroupCoverHeight *int64 `json:"group_cover_height,omitempty" xml:"group_cover_height,omitempty"`
  // 
  GroupCoverUrl *string `json:"group_cover_url,omitempty" xml:"group_cover_url,omitempty"`
  // group_cover_width
  GroupCoverWidth *int64 `json:"group_cover_width,omitempty" xml:"group_cover_width,omitempty"`
  //  ID
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // 
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // 
  ImageCount *int64 `json:"image_count,omitempty" xml:"image_count,omitempty"`
  // remarks
  Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
  // remarks_array
  RemarksArray []*string `json:"remarks_array,omitempty" xml:"remarks_array,omitempty" type:"Repeated"`
  // 
  UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s ImageFaceGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s ImageFaceGroupResponse) GoString() string {
  return s.String()
}

func (s *ImageFaceGroupResponse) SetCreatedAt(v string) *ImageFaceGroupResponse {
  s.CreatedAt = &v
  return s
}

func (s *ImageFaceGroupResponse) SetFaceCount(v int64) *ImageFaceGroupResponse {
  s.FaceCount = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverFaceBoundary(v *FaceBoundary) *ImageFaceGroupResponse {
  s.GroupCoverFaceBoundary = v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverFileId(v string) *ImageFaceGroupResponse {
  s.GroupCoverFileId = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverHeight(v int64) *ImageFaceGroupResponse {
  s.GroupCoverHeight = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverUrl(v string) *ImageFaceGroupResponse {
  s.GroupCoverUrl = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverWidth(v int64) *ImageFaceGroupResponse {
  s.GroupCoverWidth = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupId(v string) *ImageFaceGroupResponse {
  s.GroupId = &v
  return s
}

func (s *ImageFaceGroupResponse) SetGroupName(v string) *ImageFaceGroupResponse {
  s.GroupName = &v
  return s
}

func (s *ImageFaceGroupResponse) SetImageCount(v int64) *ImageFaceGroupResponse {
  s.ImageCount = &v
  return s
}

func (s *ImageFaceGroupResponse) SetRemarks(v string) *ImageFaceGroupResponse {
  s.Remarks = &v
  return s
}

func (s *ImageFaceGroupResponse) SetRemarksArray(v []*string) *ImageFaceGroupResponse {
  s.RemarksArray = v
  return s
}

func (s *ImageFaceGroupResponse) SetUpdatedAt(v string) *ImageFaceGroupResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type ImageTagResponse struct {
  // 
  Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
  // cover_file_category
  CoverFileCategory *string `json:"cover_file_category,omitempty" xml:"cover_file_category,omitempty"`
  // cover_file_id
  CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
  // cover_score
  CoverOverallScore *float64 `json:"cover_overall_score,omitempty" xml:"cover_overall_score,omitempty"`
  // cover_tag_confidence
  CoverTagConfidence *float64 `json:"cover_tag_confidence,omitempty" xml:"cover_tag_confidence,omitempty"`
  // 
  CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
  // 
  Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ImageTagResponse) String() string {
  return tea.Prettify(s)
}

func (s ImageTagResponse) GoString() string {
  return s.String()
}

func (s *ImageTagResponse) SetCount(v int64) *ImageTagResponse {
  s.Count = &v
  return s
}

func (s *ImageTagResponse) SetCoverFileCategory(v string) *ImageTagResponse {
  s.CoverFileCategory = &v
  return s
}

func (s *ImageTagResponse) SetCoverFileId(v string) *ImageTagResponse {
  s.CoverFileId = &v
  return s
}

func (s *ImageTagResponse) SetCoverOverallScore(v float64) *ImageTagResponse {
  s.CoverOverallScore = &v
  return s
}

func (s *ImageTagResponse) SetCoverTagConfidence(v float64) *ImageTagResponse {
  s.CoverTagConfidence = &v
  return s
}

func (s *ImageTagResponse) SetCoverUrl(v string) *ImageTagResponse {
  s.CoverUrl = &v
  return s
}

func (s *ImageTagResponse) SetName(v string) *ImageTagResponse {
  s.Name = &v
  return s
}

/**
 * Import user request
 */
type ImportUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  AuthenticationType *string `json:"authentication_type,omitempty" xml:"authentication_type,omitempty" require:"true"`
  // 
  AutoCreateDrive *bool `json:"auto_create_drive,omitempty" xml:"auto_create_drive,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  DriveTotalSize *int64 `json:"drive_total_size,omitempty" xml:"drive_total_size,omitempty"`
  // typemobile86
  Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
  // 
  Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty" require:"true"`
  // 
  PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
}

func (s ImportUserRequest) String() string {
  return tea.Prettify(s)
}

func (s ImportUserRequest) GoString() string {
  return s.String()
}

func (s *ImportUserRequest) SetHeaders(v map[string]*string) *ImportUserRequest {
  s.Headers = v
  return s
}

func (s *ImportUserRequest) SetAuthenticationType(v string) *ImportUserRequest {
  s.AuthenticationType = &v
  return s
}

func (s *ImportUserRequest) SetAutoCreateDrive(v bool) *ImportUserRequest {
  s.AutoCreateDrive = &v
  return s
}

func (s *ImportUserRequest) SetDenyChangePasswordBySelf(v bool) *ImportUserRequest {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *ImportUserRequest) SetDriveTotalSize(v int64) *ImportUserRequest {
  s.DriveTotalSize = &v
  return s
}

func (s *ImportUserRequest) SetExtra(v string) *ImportUserRequest {
  s.Extra = &v
  return s
}

func (s *ImportUserRequest) SetIdentity(v string) *ImportUserRequest {
  s.Identity = &v
  return s
}

func (s *ImportUserRequest) SetNeedChangePasswordNextLogin(v bool) *ImportUserRequest {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *ImportUserRequest) SetNickName(v string) *ImportUserRequest {
  s.NickName = &v
  return s
}

func (s *ImportUserRequest) SetPlainPassword(v string) *ImportUserRequest {
  s.PlainPassword = &v
  return s
}

/**
 * 
 */
type ListDirectChildMembershipsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // 100
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // ["", "member", "admin"], ""
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListDirectChildMembershipsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListDirectChildMembershipsRequest) GoString() string {
  return s.String()
}

func (s *ListDirectChildMembershipsRequest) SetHeaders(v map[string]*string) *ListDirectChildMembershipsRequest {
  s.Headers = v
  return s
}

func (s *ListDirectChildMembershipsRequest) SetGroupId(v string) *ListDirectChildMembershipsRequest {
  s.GroupId = &v
  return s
}

func (s *ListDirectChildMembershipsRequest) SetLimit(v int32) *ListDirectChildMembershipsRequest {
  s.Limit = &v
  return s
}

func (s *ListDirectChildMembershipsRequest) SetMarker(v string) *ListDirectChildMembershipsRequest {
  s.Marker = &v
  return s
}

func (s *ListDirectChildMembershipsRequest) SetMemberType(v string) *ListDirectChildMembershipsRequest {
  s.MemberType = &v
  return s
}

func (s *ListDirectChildMembershipsRequest) SetSubdomainId(v string) *ListDirectChildMembershipsRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type ListDirectChildMembershipsResponse struct {
  // items
  Items []*BaseMembershipResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDirectChildMembershipsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListDirectChildMembershipsResponse) GoString() string {
  return s.String()
}

func (s *ListDirectChildMembershipsResponse) SetItems(v []*BaseMembershipResponse) *ListDirectChildMembershipsResponse {
  s.Items = v
  return s
}

func (s *ListDirectChildMembershipsResponse) SetNextMarker(v string) *ListDirectChildMembershipsResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type ListDirectParentMembershipsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 100
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s ListDirectParentMembershipsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListDirectParentMembershipsRequest) GoString() string {
  return s.String()
}

func (s *ListDirectParentMembershipsRequest) SetHeaders(v map[string]*string) *ListDirectParentMembershipsRequest {
  s.Headers = v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetLimit(v int32) *ListDirectParentMembershipsRequest {
  s.Limit = &v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetMarker(v string) *ListDirectParentMembershipsRequest {
  s.Marker = &v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetMemberType(v string) *ListDirectParentMembershipsRequest {
  s.MemberType = &v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetSubGroupId(v string) *ListDirectParentMembershipsRequest {
  s.SubGroupId = &v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetSubdomainId(v string) *ListDirectParentMembershipsRequest {
  s.SubdomainId = &v
  return s
}

func (s *ListDirectParentMembershipsRequest) SetUserId(v string) *ListDirectParentMembershipsRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type ListDirectParentMembershipsResponse struct {
  // items
  Items []*BaseMembershipResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDirectParentMembershipsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListDirectParentMembershipsResponse) GoString() string {
  return s.String()
}

func (s *ListDirectParentMembershipsResponse) SetItems(v []*BaseMembershipResponse) *ListDirectParentMembershipsResponse {
  s.Items = v
  return s
}

func (s *ListDirectParentMembershipsResponse) SetNextMarker(v string) *ListDirectParentMembershipsResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type ListGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 100
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  //  subdomain group
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s ListGroupRequest) GoString() string {
  return s.String()
}

func (s *ListGroupRequest) SetHeaders(v map[string]*string) *ListGroupRequest {
  s.Headers = v
  return s
}

func (s *ListGroupRequest) SetLimit(v int32) *ListGroupRequest {
  s.Limit = &v
  return s
}

func (s *ListGroupRequest) SetMarker(v string) *ListGroupRequest {
  s.Marker = &v
  return s
}

func (s *ListGroupRequest) SetSubdomainId(v string) *ListGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type ListGroupResponse struct {
  // items
  Items []*BaseGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s ListGroupResponse) GoString() string {
  return s.String()
}

func (s *ListGroupResponse) SetItems(v []*BaseGroupResponse) *ListGroupResponse {
  s.Items = v
  return s
}

func (s *ListGroupResponse) SetNextMarker(v string) *ListGroupResponse {
  s.NextMarker = &v
  return s
}

/**
 * List image address groups request
 */
type ListImageAddressGroupsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // video_thumbnail_process
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListImageAddressGroupsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListImageAddressGroupsRequest) GoString() string {
  return s.String()
}

func (s *ListImageAddressGroupsRequest) SetHeaders(v map[string]*string) *ListImageAddressGroupsRequest {
  s.Headers = v
  return s
}

func (s *ListImageAddressGroupsRequest) SetDriveId(v string) *ListImageAddressGroupsRequest {
  s.DriveId = &v
  return s
}

func (s *ListImageAddressGroupsRequest) SetImageThumbnailProcess(v string) *ListImageAddressGroupsRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListImageAddressGroupsRequest) SetLimit(v int32) *ListImageAddressGroupsRequest {
  s.Limit = &v
  return s
}

func (s *ListImageAddressGroupsRequest) SetMarker(v string) *ListImageAddressGroupsRequest {
  s.Marker = &v
  return s
}

func (s *ListImageAddressGroupsRequest) SetVideoThumbnailProcess(v string) *ListImageAddressGroupsRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type ListImageAddressGroupsResponse struct {
  Items []*ImageAddressResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListImageAddressGroupsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListImageAddressGroupsResponse) GoString() string {
  return s.String()
}

func (s *ListImageAddressGroupsResponse) SetItems(v []*ImageAddressResponse) *ListImageAddressGroupsResponse {
  s.Items = v
  return s
}

func (s *ListImageAddressGroupsResponse) SetNextMarker(v string) *ListImageAddressGroupsResponse {
  s.NextMarker = &v
  return s
}

/**
 * List image face groups request
 */
type ListImageFaceGroupsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // 
  Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  RemarksArrayQuery *RemarksQueryRequest `json:"remarks_array_query,omitempty" xml:"remarks_array_query,omitempty"`
  RemarksQuery *RemarksQueryRequest `json:"remarks_query,omitempty" xml:"remarks_query,omitempty"`
}

func (s ListImageFaceGroupsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListImageFaceGroupsRequest) GoString() string {
  return s.String()
}

func (s *ListImageFaceGroupsRequest) SetHeaders(v map[string]*string) *ListImageFaceGroupsRequest {
  s.Headers = v
  return s
}

func (s *ListImageFaceGroupsRequest) SetDriveId(v string) *ListImageFaceGroupsRequest {
  s.DriveId = &v
  return s
}

func (s *ListImageFaceGroupsRequest) SetLimit(v int64) *ListImageFaceGroupsRequest {
  s.Limit = &v
  return s
}

func (s *ListImageFaceGroupsRequest) SetMarker(v string) *ListImageFaceGroupsRequest {
  s.Marker = &v
  return s
}

func (s *ListImageFaceGroupsRequest) SetRemarksArrayQuery(v *RemarksQueryRequest) *ListImageFaceGroupsRequest {
  s.RemarksArrayQuery = v
  return s
}

func (s *ListImageFaceGroupsRequest) SetRemarksQuery(v *RemarksQueryRequest) *ListImageFaceGroupsRequest {
  s.RemarksQuery = v
  return s
}

/**
 * 
 */
type ListImageFaceGroupsResponse struct {
  Items []*ImageFaceGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListImageFaceGroupsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListImageFaceGroupsResponse) GoString() string {
  return s.String()
}

func (s *ListImageFaceGroupsResponse) SetItems(v []*ImageFaceGroupResponse) *ListImageFaceGroupsResponse {
  s.Items = v
  return s
}

func (s *ListImageFaceGroupsResponse) SetNextMarker(v string) *ListImageFaceGroupsResponse {
  s.NextMarker = &v
  return s
}

/**
 * List image tags request
 */
type ListImageTagsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // video_thumbnail_process
  // type:string
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListImageTagsRequest) String() string {
  return tea.Prettify(s)
}

func (s ListImageTagsRequest) GoString() string {
  return s.String()
}

func (s *ListImageTagsRequest) SetHeaders(v map[string]*string) *ListImageTagsRequest {
  s.Headers = v
  return s
}

func (s *ListImageTagsRequest) SetDriveId(v string) *ListImageTagsRequest {
  s.DriveId = &v
  return s
}

func (s *ListImageTagsRequest) SetImageThumbnailProcess(v string) *ListImageTagsRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *ListImageTagsRequest) SetVideoThumbnailProcess(v string) *ListImageTagsRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type ListImageTagsResponse struct {
  Tags []*ImageTagResponse `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s ListImageTagsResponse) String() string {
  return tea.Prettify(s)
}

func (s ListImageTagsResponse) GoString() string {
  return s.String()
}

func (s *ListImageTagsResponse) SetTags(v []*ImageTagResponse) *ListImageTagsResponse {
  s.Tags = v
  return s
}

/**
 * List user request
 */
type ListUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListUserRequest) String() string {
  return tea.Prettify(s)
}

func (s ListUserRequest) GoString() string {
  return s.String()
}

func (s *ListUserRequest) SetHeaders(v map[string]*string) *ListUserRequest {
  s.Headers = v
  return s
}

func (s *ListUserRequest) SetLimit(v int32) *ListUserRequest {
  s.Limit = &v
  return s
}

func (s *ListUserRequest) SetMarker(v string) *ListUserRequest {
  s.Marker = &v
  return s
}

func (s *ListUserRequest) SetSubdomainId(v string) *ListUserRequest {
  s.SubdomainId = &v
  return s
}

/**
 * List user response
 */
type ListUserResponse struct {
  Items []*BaseUserResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // 
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListUserResponse) String() string {
  return tea.Prettify(s)
}

func (s ListUserResponse) GoString() string {
  return s.String()
}

func (s *ListUserResponse) SetItems(v []*BaseUserResponse) *ListUserResponse {
  s.Items = v
  return s
}

func (s *ListUserResponse) SetNextMarker(v string) *ListUserResponse {
  s.NextMarker = &v
  return s
}

/**
 * 
 */
type MemberIDInfo struct {
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s MemberIDInfo) String() string {
  return tea.Prettify(s)
}

func (s MemberIDInfo) GoString() string {
  return s.String()
}

func (s *MemberIDInfo) SetMemberType(v string) *MemberIDInfo {
  s.MemberType = &v
  return s
}

func (s *MemberIDInfo) SetSubGroupId(v string) *MemberIDInfo {
  s.SubGroupId = &v
  return s
}

func (s *MemberIDInfo) SetUserId(v string) *MemberIDInfo {
  s.UserId = &v
  return s
}

/**
 * Merge face group request
 */
type MergeFaceGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // from_group_id
  FromGroupId *string `json:"from_group_id,omitempty" xml:"from_group_id,omitempty" require:"true"`
  // to_group_id
  ToGroupId *string `json:"to_group_id,omitempty" xml:"to_group_id,omitempty" require:"true"`
}

func (s MergeFaceGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s MergeFaceGroupRequest) GoString() string {
  return s.String()
}

func (s *MergeFaceGroupRequest) SetHeaders(v map[string]*string) *MergeFaceGroupRequest {
  s.Headers = v
  return s
}

func (s *MergeFaceGroupRequest) SetDriveId(v string) *MergeFaceGroupRequest {
  s.DriveId = &v
  return s
}

func (s *MergeFaceGroupRequest) SetFromGroupId(v string) *MergeFaceGroupRequest {
  s.FromGroupId = &v
  return s
}

func (s *MergeFaceGroupRequest) SetToGroupId(v string) *MergeFaceGroupRequest {
  s.ToGroupId = &v
  return s
}

/**
 * Merge face group response
 */
type MergeFaceGroupResponse struct {
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s MergeFaceGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s MergeFaceGroupResponse) GoString() string {
  return s.String()
}

func (s *MergeFaceGroupResponse) SetStatus(v string) *MergeFaceGroupResponse {
  s.Status = &v
  return s
}

func (s *MergeFaceGroupResponse) SetTaskId(v string) *MergeFaceGroupResponse {
  s.TaskId = &v
  return s
}

/**
 * Parse keywords request
 */
type ParseKeywordsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  Keywords *string `json:"keywords,omitempty" xml:"keywords,omitempty"`
}

func (s ParseKeywordsRequest) String() string {
  return tea.Prettify(s)
}

func (s ParseKeywordsRequest) GoString() string {
  return s.String()
}

func (s *ParseKeywordsRequest) SetHeaders(v map[string]*string) *ParseKeywordsRequest {
  s.Headers = v
  return s
}

func (s *ParseKeywordsRequest) SetKeywords(v string) *ParseKeywordsRequest {
  s.Keywords = &v
  return s
}

/**
 * Parse keywords response
 */
type ParseKeywordsResponse struct {
  // AddressLine
  AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
  Tags []*SystemTag `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
  TimeRange *ParseTimeRange `json:"time_range,omitempty" xml:"time_range,omitempty"`
}

func (s ParseKeywordsResponse) String() string {
  return tea.Prettify(s)
}

func (s ParseKeywordsResponse) GoString() string {
  return s.String()
}

func (s *ParseKeywordsResponse) SetAddressLine(v string) *ParseKeywordsResponse {
  s.AddressLine = &v
  return s
}

func (s *ParseKeywordsResponse) SetTags(v []*SystemTag) *ParseKeywordsResponse {
  s.Tags = v
  return s
}

func (s *ParseKeywordsResponse) SetTimeRange(v *ParseTimeRange) *ParseKeywordsResponse {
  s.TimeRange = v
  return s
}

/**
 * 
 */
type ParseTimeRange struct {
  End *string `json:"end,omitempty" xml:"end,omitempty"`
  Start *string `json:"start,omitempty" xml:"start,omitempty"`
}

func (s ParseTimeRange) String() string {
  return tea.Prettify(s)
}

func (s ParseTimeRange) GoString() string {
  return s.String()
}

func (s *ParseTimeRange) SetEnd(v string) *ParseTimeRange {
  s.End = &v
  return s
}

func (s *ParseTimeRange) SetStart(v string) *ParseTimeRange {
  s.Start = &v
  return s
}

/**
 * 
 */
type RemarksQueryRequest struct {
  In []*string `json:"in,omitempty" xml:"in,omitempty" type:"Repeated"`
  NotIn []*string `json:"not_in,omitempty" xml:"not_in,omitempty" type:"Repeated"`
  NotPrefix *string `json:"not_prefix,omitempty" xml:"not_prefix,omitempty"`
  Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
}

func (s RemarksQueryRequest) String() string {
  return tea.Prettify(s)
}

func (s RemarksQueryRequest) GoString() string {
  return s.String()
}

func (s *RemarksQueryRequest) SetIn(v []*string) *RemarksQueryRequest {
  s.In = v
  return s
}

func (s *RemarksQueryRequest) SetNotIn(v []*string) *RemarksQueryRequest {
  s.NotIn = v
  return s
}

func (s *RemarksQueryRequest) SetNotPrefix(v string) *RemarksQueryRequest {
  s.NotPrefix = &v
  return s
}

func (s *RemarksQueryRequest) SetPrefix(v string) *RemarksQueryRequest {
  s.Prefix = &v
  return s
}

/**
 * Remove story images response
 */
type RemoveStoryImagesResponse struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // file_ids
  FileIds []*string `json:"file_ids,omitempty" xml:"file_ids,omitempty" type:"Repeated"`
  Results []*RemoveStoryImagesResultItem `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
  // story_id
  StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
  // success_file_ids
  SuccessFileIds []*string `json:"success_file_ids,omitempty" xml:"success_file_ids,omitempty" type:"Repeated"`
}

func (s RemoveStoryImagesResponse) String() string {
  return tea.Prettify(s)
}

func (s RemoveStoryImagesResponse) GoString() string {
  return s.String()
}

func (s *RemoveStoryImagesResponse) SetDriveId(v string) *RemoveStoryImagesResponse {
  s.DriveId = &v
  return s
}

func (s *RemoveStoryImagesResponse) SetFileIds(v []*string) *RemoveStoryImagesResponse {
  s.FileIds = v
  return s
}

func (s *RemoveStoryImagesResponse) SetResults(v []*RemoveStoryImagesResultItem) *RemoveStoryImagesResponse {
  s.Results = v
  return s
}

func (s *RemoveStoryImagesResponse) SetStoryId(v string) *RemoveStoryImagesResponse {
  s.StoryId = &v
  return s
}

func (s *RemoveStoryImagesResponse) SetSuccessFileIds(v []*string) *RemoveStoryImagesResponse {
  s.SuccessFileIds = v
  return s
}

/**
 * 
 */
type RemoveStoryImagesResultItem struct {
  // code
  Code *string `json:"code,omitempty" xml:"code,omitempty"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
  // is_succeed
  IsSucceed *bool `json:"is_succeed,omitempty" xml:"is_succeed,omitempty"`
  // message
  Message *string `json:"message,omitempty" xml:"message,omitempty"`
}

func (s RemoveStoryImagesResultItem) String() string {
  return tea.Prettify(s)
}

func (s RemoveStoryImagesResultItem) GoString() string {
  return s.String()
}

func (s *RemoveStoryImagesResultItem) SetCode(v string) *RemoveStoryImagesResultItem {
  s.Code = &v
  return s
}

func (s *RemoveStoryImagesResultItem) SetFileId(v string) *RemoveStoryImagesResultItem {
  s.FileId = &v
  return s
}

func (s *RemoveStoryImagesResultItem) SetIsSucceed(v bool) *RemoveStoryImagesResultItem {
  s.IsSucceed = &v
  return s
}

func (s *RemoveStoryImagesResultItem) SetMessage(v string) *RemoveStoryImagesResultItem {
  s.Message = &v
  return s
}

/**
 * Remove user to subdomain request
 */
type RemoveUserFromSubdomainRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s RemoveUserFromSubdomainRequest) String() string {
  return tea.Prettify(s)
}

func (s RemoveUserFromSubdomainRequest) GoString() string {
  return s.String()
}

func (s *RemoveUserFromSubdomainRequest) SetHeaders(v map[string]*string) *RemoveUserFromSubdomainRequest {
  s.Headers = v
  return s
}

func (s *RemoveUserFromSubdomainRequest) SetSubdomainId(v string) *RemoveUserFromSubdomainRequest {
  s.SubdomainId = &v
  return s
}

func (s *RemoveUserFromSubdomainRequest) SetUserId(v string) *RemoveUserFromSubdomainRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type SearchGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // group_name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // 100
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  //  subdomain group
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s SearchGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s SearchGroupRequest) GoString() string {
  return s.String()
}

func (s *SearchGroupRequest) SetHeaders(v map[string]*string) *SearchGroupRequest {
  s.Headers = v
  return s
}

func (s *SearchGroupRequest) SetGroupName(v string) *SearchGroupRequest {
  s.GroupName = &v
  return s
}

func (s *SearchGroupRequest) SetLimit(v int32) *SearchGroupRequest {
  s.Limit = &v
  return s
}

func (s *SearchGroupRequest) SetMarker(v string) *SearchGroupRequest {
  s.Marker = &v
  return s
}

func (s *SearchGroupRequest) SetSubdomainId(v string) *SearchGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type SearchGroupResponse struct {
  // items
  Items []*BaseGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
  // next_marker
  NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s SearchGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s SearchGroupResponse) GoString() string {
  return s.String()
}

func (s *SearchGroupResponse) SetItems(v []*BaseGroupResponse) *SearchGroupResponse {
  s.Items = v
  return s
}

func (s *SearchGroupResponse) SetNextMarker(v string) *SearchGroupResponse {
  s.NextMarker = &v
  return s
}

/**
 * Search image address groups request
 */
type SearchImageAddressGroupsRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  AddressLevel *string `json:"address_level,omitempty" xml:"address_level,omitempty"`
  // 
  AddressNames []*string `json:"address_names,omitempty" xml:"address_names,omitempty" type:"Repeated"`
  // br_geo_point
  BrGeoPoint *string `json:"br_geo_point,omitempty" xml:"br_geo_point,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // image_thumbnail_process
  ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
  // tl_geo_point
  TlGeoPoint *string `json:"tl_geo_point,omitempty" xml:"tl_geo_point,omitempty"`
  // video_thumbnail_process
  VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s SearchImageAddressGroupsRequest) String() string {
  return tea.Prettify(s)
}

func (s SearchImageAddressGroupsRequest) GoString() string {
  return s.String()
}

func (s *SearchImageAddressGroupsRequest) SetHeaders(v map[string]*string) *SearchImageAddressGroupsRequest {
  s.Headers = v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetAddressLevel(v string) *SearchImageAddressGroupsRequest {
  s.AddressLevel = &v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetAddressNames(v []*string) *SearchImageAddressGroupsRequest {
  s.AddressNames = v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetBrGeoPoint(v string) *SearchImageAddressGroupsRequest {
  s.BrGeoPoint = &v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetDriveId(v string) *SearchImageAddressGroupsRequest {
  s.DriveId = &v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetImageThumbnailProcess(v string) *SearchImageAddressGroupsRequest {
  s.ImageThumbnailProcess = &v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetTlGeoPoint(v string) *SearchImageAddressGroupsRequest {
  s.TlGeoPoint = &v
  return s
}

func (s *SearchImageAddressGroupsRequest) SetVideoThumbnailProcess(v string) *SearchImageAddressGroupsRequest {
  s.VideoThumbnailProcess = &v
  return s
}

/**
 * 
 */
type SearchImageAddressGroupsResponse struct {
  Items []*ImageAddressResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s SearchImageAddressGroupsResponse) String() string {
  return tea.Prettify(s)
}

func (s SearchImageAddressGroupsResponse) GoString() string {
  return s.String()
}

func (s *SearchImageAddressGroupsResponse) SetItems(v []*ImageAddressResponse) *SearchImageAddressGroupsResponse {
  s.Items = v
  return s
}

/**
 * Search user request
 */
type SearchUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  // 
  Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
  // 
  Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s SearchUserRequest) String() string {
  return tea.Prettify(s)
}

func (s SearchUserRequest) GoString() string {
  return s.String()
}

func (s *SearchUserRequest) SetHeaders(v map[string]*string) *SearchUserRequest {
  s.Headers = v
  return s
}

func (s *SearchUserRequest) SetEmail(v string) *SearchUserRequest {
  s.Email = &v
  return s
}

func (s *SearchUserRequest) SetLimit(v int32) *SearchUserRequest {
  s.Limit = &v
  return s
}

func (s *SearchUserRequest) SetMarker(v string) *SearchUserRequest {
  s.Marker = &v
  return s
}

func (s *SearchUserRequest) SetNickName(v string) *SearchUserRequest {
  s.NickName = &v
  return s
}

func (s *SearchUserRequest) SetPhone(v string) *SearchUserRequest {
  s.Phone = &v
  return s
}

func (s *SearchUserRequest) SetRole(v string) *SearchUserRequest {
  s.Role = &v
  return s
}

func (s *SearchUserRequest) SetStatus(v string) *SearchUserRequest {
  s.Status = &v
  return s
}

func (s *SearchUserRequest) SetSubdomainId(v string) *SearchUserRequest {
  s.SubdomainId = &v
  return s
}

func (s *SearchUserRequest) SetUserName(v string) *SearchUserRequest {
  s.UserName = &v
  return s
}

/**
 * Unassign facegroup item request
 */
type UnAssignFaceGroupItemRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // face_group_id
  FaceGroupId *string `json:"face_group_id,omitempty" xml:"face_group_id,omitempty" require:"true"`
  // file_id
  FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
}

func (s UnAssignFaceGroupItemRequest) String() string {
  return tea.Prettify(s)
}

func (s UnAssignFaceGroupItemRequest) GoString() string {
  return s.String()
}

func (s *UnAssignFaceGroupItemRequest) SetHeaders(v map[string]*string) *UnAssignFaceGroupItemRequest {
  s.Headers = v
  return s
}

func (s *UnAssignFaceGroupItemRequest) SetDriveId(v string) *UnAssignFaceGroupItemRequest {
  s.DriveId = &v
  return s
}

func (s *UnAssignFaceGroupItemRequest) SetFaceGroupId(v string) *UnAssignFaceGroupItemRequest {
  s.FaceGroupId = &v
  return s
}

func (s *UnAssignFaceGroupItemRequest) SetFileId(v string) *UnAssignFaceGroupItemRequest {
  s.FileId = &v
  return s
}

/**
 * Update face group info request
 */
type UpdateFaceGroupInfoRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
  // group_cover_face_id
  GroupCoverFaceId *string `json:"group_cover_face_id,omitempty" xml:"group_cover_face_id,omitempty"`
  // group_id 
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty" require:"true"`
  // group_name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // remarks
  Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
  // remarks_array
  RemarksArray []*string `json:"remarks_array,omitempty" xml:"remarks_array,omitempty" type:"Repeated"`
}

func (s UpdateFaceGroupInfoRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateFaceGroupInfoRequest) GoString() string {
  return s.String()
}

func (s *UpdateFaceGroupInfoRequest) SetHeaders(v map[string]*string) *UpdateFaceGroupInfoRequest {
  s.Headers = v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetDriveId(v string) *UpdateFaceGroupInfoRequest {
  s.DriveId = &v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupCoverFaceId(v string) *UpdateFaceGroupInfoRequest {
  s.GroupCoverFaceId = &v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupId(v string) *UpdateFaceGroupInfoRequest {
  s.GroupId = &v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupName(v string) *UpdateFaceGroupInfoRequest {
  s.GroupName = &v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetRemarks(v string) *UpdateFaceGroupInfoRequest {
  s.Remarks = &v
  return s
}

func (s *UpdateFaceGroupInfoRequest) SetRemarksArray(v []*string) *UpdateFaceGroupInfoRequest {
  s.RemarksArray = v
  return s
}

/**
 * 
 */
type UpdateFaceGroupInfoResponse struct {
  // drive_id
  DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
  // group_id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
}

func (s UpdateFaceGroupInfoResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateFaceGroupInfoResponse) GoString() string {
  return s.String()
}

func (s *UpdateFaceGroupInfoResponse) SetDriveId(v string) *UpdateFaceGroupInfoResponse {
  s.DriveId = &v
  return s
}

func (s *UpdateFaceGroupInfoResponse) SetGroupId(v string) *UpdateFaceGroupInfoResponse {
  s.GroupId = &v
  return s
}

/**
 * 
 */
type UpdateGroupRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // 
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
  // group
  IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s UpdateGroupRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateGroupRequest) GoString() string {
  return s.String()
}

func (s *UpdateGroupRequest) SetHeaders(v map[string]*string) *UpdateGroupRequest {
  s.Headers = v
  return s
}

func (s *UpdateGroupRequest) SetDescription(v string) *UpdateGroupRequest {
  s.Description = &v
  return s
}

func (s *UpdateGroupRequest) SetGroupId(v string) *UpdateGroupRequest {
  s.GroupId = &v
  return s
}

func (s *UpdateGroupRequest) SetGroupName(v string) *UpdateGroupRequest {
  s.GroupName = &v
  return s
}

func (s *UpdateGroupRequest) SetIsRoot(v bool) *UpdateGroupRequest {
  s.IsRoot = &v
  return s
}

func (s *UpdateGroupRequest) SetSubdomainId(v string) *UpdateGroupRequest {
  s.SubdomainId = &v
  return s
}

/**
 * 
 */
type UpdateGroupResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // description
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  // group name
  GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s UpdateGroupResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateGroupResponse) GoString() string {
  return s.String()
}

func (s *UpdateGroupResponse) SetCreatedAt(v int64) *UpdateGroupResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateGroupResponse) SetDescription(v string) *UpdateGroupResponse {
  s.Description = &v
  return s
}

func (s *UpdateGroupResponse) SetDomainId(v string) *UpdateGroupResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateGroupResponse) SetGroupId(v string) *UpdateGroupResponse {
  s.GroupId = &v
  return s
}

func (s *UpdateGroupResponse) SetGroupName(v string) *UpdateGroupResponse {
  s.GroupName = &v
  return s
}

func (s *UpdateGroupResponse) SetUpdatedAt(v int64) *UpdateGroupResponse {
  s.UpdatedAt = &v
  return s
}

/**
 * 
 */
type UpdateMembershipRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // subdomain id
  SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s UpdateMembershipRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateMembershipRequest) GoString() string {
  return s.String()
}

func (s *UpdateMembershipRequest) SetHeaders(v map[string]*string) *UpdateMembershipRequest {
  s.Headers = v
  return s
}

func (s *UpdateMembershipRequest) SetDescription(v string) *UpdateMembershipRequest {
  s.Description = &v
  return s
}

func (s *UpdateMembershipRequest) SetGroupId(v string) *UpdateMembershipRequest {
  s.GroupId = &v
  return s
}

func (s *UpdateMembershipRequest) SetMemberRole(v string) *UpdateMembershipRequest {
  s.MemberRole = &v
  return s
}

func (s *UpdateMembershipRequest) SetMemberType(v string) *UpdateMembershipRequest {
  s.MemberType = &v
  return s
}

func (s *UpdateMembershipRequest) SetSubGroupId(v string) *UpdateMembershipRequest {
  s.SubGroupId = &v
  return s
}

func (s *UpdateMembershipRequest) SetSubdomainId(v string) *UpdateMembershipRequest {
  s.SubdomainId = &v
  return s
}

func (s *UpdateMembershipRequest) SetUserId(v string) *UpdateMembershipRequest {
  s.UserId = &v
  return s
}

/**
 * 
 */
type UpdateMembershipResponse struct {
  // created_at
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // domain id
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // group id
  GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
  //  member or admin
  MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
  MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
  SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
  // updated_at
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s UpdateMembershipResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateMembershipResponse) GoString() string {
  return s.String()
}

func (s *UpdateMembershipResponse) SetCreatedAt(v int64) *UpdateMembershipResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateMembershipResponse) SetDescription(v string) *UpdateMembershipResponse {
  s.Description = &v
  return s
}

func (s *UpdateMembershipResponse) SetDomainId(v string) *UpdateMembershipResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateMembershipResponse) SetGroupId(v string) *UpdateMembershipResponse {
  s.GroupId = &v
  return s
}

func (s *UpdateMembershipResponse) SetMemberRole(v string) *UpdateMembershipResponse {
  s.MemberRole = &v
  return s
}

func (s *UpdateMembershipResponse) SetMemberType(v string) *UpdateMembershipResponse {
  s.MemberType = &v
  return s
}

func (s *UpdateMembershipResponse) SetSubGroupId(v string) *UpdateMembershipResponse {
  s.SubGroupId = &v
  return s
}

func (s *UpdateMembershipResponse) SetUpdatedAt(v int64) *UpdateMembershipResponse {
  s.UpdatedAt = &v
  return s
}

func (s *UpdateMembershipResponse) SetUserId(v string) *UpdateMembershipResponse {
  s.UserId = &v
  return s
}

/**
 * Update user request
 */
type UpdateUserRequest struct {
  Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  GroupInfoList []*GroupInfo `json:"group_info_list,omitempty" xml:"group_info_list,omitempty" type:"Repeated"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s UpdateUserRequest) String() string {
  return tea.Prettify(s)
}

func (s UpdateUserRequest) GoString() string {
  return s.String()
}

func (s *UpdateUserRequest) SetHeaders(v map[string]*string) *UpdateUserRequest {
  s.Headers = v
  return s
}

func (s *UpdateUserRequest) SetAvatar(v string) *UpdateUserRequest {
  s.Avatar = &v
  return s
}

func (s *UpdateUserRequest) SetDenyChangePasswordBySelf(v bool) *UpdateUserRequest {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *UpdateUserRequest) SetDescription(v string) *UpdateUserRequest {
  s.Description = &v
  return s
}

func (s *UpdateUserRequest) SetEmail(v string) *UpdateUserRequest {
  s.Email = &v
  return s
}

func (s *UpdateUserRequest) SetGroupInfoList(v []*GroupInfo) *UpdateUserRequest {
  s.GroupInfoList = v
  return s
}

func (s *UpdateUserRequest) SetNeedChangePasswordNextLogin(v bool) *UpdateUserRequest {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *UpdateUserRequest) SetNickName(v string) *UpdateUserRequest {
  s.NickName = &v
  return s
}

func (s *UpdateUserRequest) SetPhone(v string) *UpdateUserRequest {
  s.Phone = &v
  return s
}

func (s *UpdateUserRequest) SetPlainPassword(v string) *UpdateUserRequest {
  s.PlainPassword = &v
  return s
}

func (s *UpdateUserRequest) SetRole(v string) *UpdateUserRequest {
  s.Role = &v
  return s
}

func (s *UpdateUserRequest) SetStatus(v string) *UpdateUserRequest {
  s.Status = &v
  return s
}

func (s *UpdateUserRequest) SetUserData(v map[string]interface{}) *UpdateUserRequest {
  s.UserData = v
  return s
}

func (s *UpdateUserRequest) SetUserId(v string) *UpdateUserRequest {
  s.UserId = &v
  return s
}

/**
 * Update user response
 */
type UpdateUserResponse struct {
  // 
  Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
  // 
  CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
  //  Drive ID
  DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
  // 
  DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
  // 
  Description *string `json:"description,omitempty" xml:"description,omitempty"`
  // Domain ID
  DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
  // 
  Email *string `json:"email,omitempty" xml:"email,omitempty"`
  // 
  NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
  // 
  NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
  // 
  Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
  // 
  PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
  // 
  Role *string `json:"role,omitempty" xml:"role,omitempty"`
  // 
  Status *string `json:"status,omitempty" xml:"status,omitempty"`
  // 
  UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
  // json1K
  UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
  //  ID
  UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
  // 
  UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s UpdateUserResponse) String() string {
  return tea.Prettify(s)
}

func (s UpdateUserResponse) GoString() string {
  return s.String()
}

func (s *UpdateUserResponse) SetAvatar(v string) *UpdateUserResponse {
  s.Avatar = &v
  return s
}

func (s *UpdateUserResponse) SetCreatedAt(v int64) *UpdateUserResponse {
  s.CreatedAt = &v
  return s
}

func (s *UpdateUserResponse) SetDefaultDriveId(v string) *UpdateUserResponse {
  s.DefaultDriveId = &v
  return s
}

func (s *UpdateUserResponse) SetDenyChangePasswordBySelf(v bool) *UpdateUserResponse {
  s.DenyChangePasswordBySelf = &v
  return s
}

func (s *UpdateUserResponse) SetDescription(v string) *UpdateUserResponse {
  s.Description = &v
  return s
}

func (s *UpdateUserResponse) SetDomainId(v string) *UpdateUserResponse {
  s.DomainId = &v
  return s
}

func (s *UpdateUserResponse) SetEmail(v string) *UpdateUserResponse {
  s.Email = &v
  return s
}

func (s *UpdateUserResponse) SetNeedChangePasswordNextLogin(v bool) *UpdateUserResponse {
  s.NeedChangePasswordNextLogin = &v
  return s
}

func (s *UpdateUserResponse) SetNickName(v string) *UpdateUserResponse {
  s.NickName = &v
  return s
}

func (s *UpdateUserResponse) SetPhone(v string) *UpdateUserResponse {
  s.Phone = &v
  return s
}

func (s *UpdateUserResponse) SetPunishFlag(v int64) *UpdateUserResponse {
  s.PunishFlag = &v
  return s
}

func (s *UpdateUserResponse) SetRole(v string) *UpdateUserResponse {
  s.Role = &v
  return s
}

func (s *UpdateUserResponse) SetStatus(v string) *UpdateUserResponse {
  s.Status = &v
  return s
}

func (s *UpdateUserResponse) SetUpdatedAt(v int64) *UpdateUserResponse {
  s.UpdatedAt = &v
  return s
}

func (s *UpdateUserResponse) SetUserData(v map[string]interface{}) *UpdateUserResponse {
  s.UserData = v
  return s
}

func (s *UpdateUserResponse) SetUserId(v string) *UpdateUserResponse {
  s.UserId = &v
  return s
}

func (s *UpdateUserResponse) SetUserName(v string) *UpdateUserResponse {
  s.UserName = &v
  return s
}

type Client struct {
  DomainId  *string
  AccessTokenCredential  *accesstokencredential.AccessTokenCredential
  Endpoint  *string
  Protocol  *string
  Nickname  *string
  UserAgent  *string
  Credential  credential.Credential
}

func NewClient(config *Config)(*Client, error) {
  client := new(Client)
  err := client.Init(config)
  return client, err
}

func (client *Client)Init(config *Config)(_err error) {
  if tea.BoolValue(util.IsUnset(tea.ToMap(config))) {
    _err = tea.NewSDKError(map[string]interface{}{
      "name": "ParameterMissing",
      "message": "'config' can not be unset",
    })
    return _err
  }

  _err = util.ValidateModel(config)
  if _err != nil {
    return _err
  }
  if !tea.BoolValue(util.Empty(config.AccessToken)) || !tea.BoolValue(util.Empty(config.RefreshToken)) {
    accessConfig := &accesstokencredential.Config{
      AccessToken: config.AccessToken,
      Endpoint: config.Endpoint,
      DomainId: config.DomainId,
      ClientId: config.ClientId,
      RefreshToken: config.RefreshToken,
      ClientSecret: config.ClientSecret,
      ExpireTime: config.ExpireTime,
    }
    client.AccessTokenCredential, _err = accesstokencredential.NewAccessTokenCredential(accessConfig)
    if _err != nil {
      return _err
    }

  }

  if !tea.BoolValue(util.Empty(config.AccessKeyId)) {
    if tea.BoolValue(util.Empty(config.Type)) {
      config.Type = tea.String("access_key")
    }

    credentialConfig := &credential.Config{
      AccessKeyId: config.AccessKeyId,
      Type: config.Type,
      AccessKeySecret: config.AccessKeySecret,
      SecurityToken: config.SecurityToken,
    }
    client.Credential, _err = credential.NewCredential(credentialConfig)
    if _err != nil {
      return _err
    }

  }

  client.Endpoint = config.Endpoint
  client.Protocol = config.Protocol
  client.UserAgent = config.UserAgent
  client.Nickname = config.Nickname
  client.DomainId = config.DomainId
  return nil
}


/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CancelLinkEx(request *CancelLinkRequest, runtime *RuntimeOptions) (_result *CancelLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CancelLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CancelLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/cancel_link"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CancelLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * , 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ConfirmLinkEx(request *ConfirmLinkRequest, runtime *RuntimeOptions) (_result *ConfirmLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ConfirmLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ConfirmLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/confirm_link"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ConfirmLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 8-20
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ChangePasswordEx(request *DefaultChangePasswordRequest, runtime *RuntimeOptions) (_result *ChangePasswordModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ChangePasswordModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ChangePasswordModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/default/change_password"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ChangePasswordModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 8-20
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SetPasswordEx(request *DefaultSetPasswordRequest, runtime *RuntimeOptions) (_result *SetPasswordModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &SetPasswordModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*SetPasswordModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/default/set_password"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &SetPasswordModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * statestate
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) VerifyCodeEx(request *VerifyCodeRequest, runtime *RuntimeOptions) (_result *VerifyCodeModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &VerifyCodeModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*VerifyCodeModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/default/verify_code"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &VerifyCodeModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetAccessTokenByLinkInfoEx(request *GetAccessTokenByLinkInfoRequest, runtime *RuntimeOptions) (_result *GetAccessTokenByLinkInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetAccessTokenByLinkInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetAccessTokenByLinkInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_access_token_by_link_info"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetAccessTokenByLinkInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoEx(request *GetByLinkInfoRequest, runtime *RuntimeOptions) (_result *GetLinkInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetLinkInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetLinkInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_link_info"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetLinkInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoByUserIdEx(request *GetLinkInfoByUserIDRequest, runtime *RuntimeOptions) (_result *GetLinkInfoByUserIdModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetLinkInfoByUserIdModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetLinkInfoByUserIdModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_link_info_by_user_id"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetLinkInfoByUserIdModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetPublicKeyEx(request *GetPublicKeyRequest, runtime *RuntimeOptions) (_result *GetPublicKeyModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetPublicKeyModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetPublicKeyModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_public_key"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetPublicKeyModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) LinkEx(request *AccountLinkRequest, runtime *RuntimeOptions) (_result *LinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &LinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*LinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/link"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &LinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CheckExistEx(request *MobileCheckExistRequest, runtime *RuntimeOptions) (_result *CheckExistModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CheckExistModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CheckExistModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/mobile/check_exist"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CheckExistModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) LoginEx(request *MobileLoginRequest, runtime *RuntimeOptions) (_result *LoginModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &LoginModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*LoginModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/mobile/login"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &LoginModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) RegisterEx(request *MobileRegisterRequest, runtime *RuntimeOptions) (_result *RegisterModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &RegisterModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*RegisterModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/mobile/register"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &RegisterModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) MobileSendSmsCodeEx(request *MobileSendSmsCodeRequest, runtime *RuntimeOptions) (_result *MobileSendSmsCodeModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &MobileSendSmsCodeModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*MobileSendSmsCodeModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/mobile/send_sms_code"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &MobileSendSmsCodeModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountRevokeEx(request *RevokeRequest, runtime *RuntimeOptions) (_result *AccountRevokeModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &AccountRevokeModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*AccountRevokeModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/revoke"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &AccountRevokeModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * refresh_tokenaccess_token
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountTokenEx(request *AccountTokenRequest, runtime *RuntimeOptions) (_result *AccountTokenModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &AccountTokenModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*AccountTokenModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/token"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".auth.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &AccountTokenModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * Store
 * @tags admin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AdminListStoresEx(request *AdminListStoresRequest, runtime *RuntimeOptions) (_result *AdminListStoresModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &AdminListStoresModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*AdminListStoresModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/domain/list_stores"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &AdminListStoresModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * create subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CreateSubdomainEx(request *CreateSubdomainRequest, runtime *RuntimeOptions) (_result *CreateSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateSubdomainModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * delete subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) DeleteSubdomainEx(request *DeleteSubdomainRequest, runtime *RuntimeOptions) (_result *DeleteSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &DeleteSubdomainModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * get subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetSubdomainEx(request *GetSubdomainRequest, runtime *RuntimeOptions) (_result *GetSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetSubdomainModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * list subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListSubdomainsEx(request *ListSubdomainsRequest, runtime *RuntimeOptions) (_result *ListSubdomainsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListSubdomainsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListSubdomainsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListSubdomainsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * update subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) UpdateSubdomainEx(request *UpdateSubdomainRequest, runtime *RuntimeOptions) (_result *UpdateSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateSubdomainModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * accessToken
 * @tags admin
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 */
func (client *Client) GetUserAccessTokenEx(request *GetUserAccessTokenRequest, runtime *RuntimeOptions) (_result *GetUserAccessTokenModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetUserAccessTokenModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetUserAccessTokenModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/get_access_token"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetUserAccessTokenModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * id
 * 
 * @tags async_task
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAsyncTaskInfoEx(request *GetAsyncTaskRequest, runtime *RuntimeOptions) (_result *GetAsyncTaskInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetAsyncTaskInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetAsyncTaskInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/async_task/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetAsyncTaskInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * 100
 * @tags batch
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BatchOperationEx(request *BatchRequest, runtime *RuntimeOptions) (_result *BatchOperationModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &BatchOperationModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*BatchOperationModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/batch"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &BatchOperationModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * normallargedrive
 * largedrivelist
 * drive1large
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateDriveEx(request *CreateDriveRequest, runtime *RuntimeOptions) (_result *CreateDriveModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateDriveModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateDriveModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateDriveModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteDriveEx(request *DeleteDriveRequest, runtime *RuntimeOptions) (_result *DeleteDriveModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteDriveModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteDriveModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteDriveModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDriveEx(request *GetDriveRequest, runtime *RuntimeOptions) (_result *GetDriveModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetDriveModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetDriveModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetDriveModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drivedrivedrive
 * drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDefaultDriveEx(request *GetDefaultDriveRequest, runtime *RuntimeOptions) (_result *GetDefaultDriveModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetDefaultDriveModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetDefaultDriveModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/get_default_drive"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetDefaultDriveModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDrivesEx(request *ListDriveRequest, runtime *RuntimeOptions) (_result *ListDrivesModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListDrivesModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListDrivesModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListDrivesModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListMyDrivesEx(request *ListMyDriveRequest, runtime *RuntimeOptions) (_result *ListMyDrivesModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListMyDrivesModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListMyDrivesModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/list_my_drives"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListMyDrivesModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateDriveEx(request *UpdateDriveRequest, runtime *RuntimeOptions) (_result *UpdateDriveModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateDriveModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateDriveModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateDriveModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * archive_files
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ArchiveFilesEx(request *CCPArchiveFilesRequest, runtime *RuntimeOptions) (_result *ArchiveFilesModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ArchiveFilesModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ArchiveFilesModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/archive_files"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ArchiveFilesModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFileEx(request *CompleteFileRequest, runtime *RuntimeOptions) (_result *CompleteFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CompleteFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CompleteFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/complete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CompleteFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFileEx(request *CopyFileRequest, runtime *RuntimeOptions) (_result *CopyFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CopyFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CopyFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/copy"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CopyFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CopyFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileEx(request *CreateFileRequest, runtime *RuntimeOptions) (_result *CreateFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithProofEx(request *CreateFileRequest, runtime *RuntimeOptions) (_result *CreateFileWithProofModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateFileWithProofModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateFileWithProofModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/create_with_proof"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateFileWithProofModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteFileEx(request *DeleteFileRequest, runtime *RuntimeOptions) (_result *DeleteFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &DeleteFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteFileModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileEx(request *GetFileRequest, runtime *RuntimeOptions) (_result *GetFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileByPathEx(request *GetFileByPathRequest, runtime *RuntimeOptions) (_result *GetFileByPathModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetFileByPathModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetFileByPathModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_by_path"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetFileByPathModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDownloadUrlEx(request *GetDownloadUrlRequest, runtime *RuntimeOptions) (_result *GetDownloadUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetDownloadUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetDownloadUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_download_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetDownloadUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetLastCursorEx(request *GetLastCursorRequest, runtime *RuntimeOptions) (_result *GetLastCursorModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetLastCursorModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetLastCursorModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_last_cursor"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetLastCursorModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * mediaURLm3u8
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMediaPlayUrlEx(request *GetMediaPlayURLRequest, runtime *RuntimeOptions) (_result *GetMediaPlayUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetMediaPlayUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetMediaPlayUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_media_play_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetMediaPlayUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficeEditUrlEx(request *GetOfficeEditUrlRequest, runtime *RuntimeOptions) (_result *GetOfficeEditUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetOfficeEditUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetOfficeEditUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_office_edit_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetOfficeEditUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * office
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficePreviewUrlEx(request *GetOfficePreviewUrlRequest, runtime *RuntimeOptions) (_result *GetOfficePreviewUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetOfficePreviewUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetOfficePreviewUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_office_preview_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetOfficePreviewUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkDownloadUrlEx(request *GetShareLinkDownloadURLRequest, runtime *RuntimeOptions) (_result *GetShareLinkDownloadUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareLinkDownloadUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareLinkDownloadUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_share_link_download_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareLinkDownloadUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkVideoPreviewPlayInfoEx(request *CCPGetShareLinkVideoPreviewPlayInfoRequest, runtime *RuntimeOptions) (_result *GetShareLinkVideoPreviewPlayInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareLinkVideoPreviewPlayInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareLinkVideoPreviewPlayInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_share_link_video_preview_play_info"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareLinkVideoPreviewPlayInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUploadUrlEx(request *GetUploadUrlRequest, runtime *RuntimeOptions) (_result *GetUploadUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetUploadUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetUploadUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_upload_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetUploadUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewPlayInfoEx(request *CCPGetVideoPreviewPlayInfoRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewPlayInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetVideoPreviewPlayInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetVideoPreviewPlayInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_play_info"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetVideoPreviewPlayInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewSpriteUrlEx(request *GetVideoPreviewSpriteURLRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewSpriteUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetVideoPreviewSpriteUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetVideoPreviewSpriteUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_sprite_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetVideoPreviewSpriteUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewUrlEx(request *GetVideoPreviewURLRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewUrlModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetVideoPreviewUrlModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetVideoPreviewUrlModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_url"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetVideoPreviewUrlModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileEx(request *ListFileRequest, runtime *RuntimeOptions) (_result *ListFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * list file activity
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileActivityEx(request *ListFileActivityRequest, runtime *RuntimeOptions) (_result *ListFileActivityModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFileActivityModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFileActivityModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_activity"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFileActivityModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ShareLinkTokenInvalid ShareToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByAnonymousEx(request *ListByAnonymousRequest, runtime *RuntimeOptions) (_result *ListFileByAnonymousModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFileByAnonymousModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFileByAnonymousModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_by_anonymous"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFileByAnonymousModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByCustomIndexKeyEx(request *ListFileByCustomIndexKeyRequest, runtime *RuntimeOptions) (_result *ListFileByCustomIndexKeyModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFileByCustomIndexKeyModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFileByCustomIndexKeyModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_by_custom_index_key"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFileByCustomIndexKeyModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileDeltaEx(request *ListFileDeltaRequest, runtime *RuntimeOptions) (_result *ListFileDeltaModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFileDeltaModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFileDeltaModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_delta"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFileDeltaModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * upload_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUploadedPartsEx(request *ListUploadedPartRequest, runtime *RuntimeOptions) (_result *ListUploadedPartsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListUploadedPartsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListUploadedPartsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_uploaded_parts"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListUploadedPartsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * live_transcode
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) LiveTranscodeEx(request *CCPLiveTranscodeRequest, runtime *RuntimeOptions) (_result *LiveTranscodeModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &LiveTranscodeModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*LiveTranscodeModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/live_transcode"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &LiveTranscodeModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MoveFileEx(request *MoveFileRequest, runtime *RuntimeOptions) (_result *MoveFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &MoveFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*MoveFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/move"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &MoveFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * Token
 * @tags file, refresh, office, edit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TokenEx(request *RefreshOfficeEditTokenRequest, runtime *RuntimeOptions) (_result *TokenModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &TokenModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*TokenModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/refresh_office_edit_token"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &TokenModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ScanFileMetaEx(request *ScanFileMetaRequest, runtime *RuntimeOptions) (_result *ScanFileMetaModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ScanFileMetaModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ScanFileMetaModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/scan"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ScanFileMetaModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFileEx(request *SearchFileRequest, runtime *RuntimeOptions) (_result *SearchFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &SearchFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*SearchFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/search"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &SearchFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFileEx(request *UpdateFileMetaRequest, runtime *RuntimeOptions) (_result *UpdateFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * walk file
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) WalkFileEx(request *CCPWalkFileRequest, runtime *RuntimeOptions) (_result *WalkFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &WalkFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*WalkFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/walk"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &WalkFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * clear_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ClearRecyclebinEx(request *ClearRecycleBinRequest, runtime *RuntimeOptions) (_result *ClearRecyclebinModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ClearRecyclebinModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ClearRecyclebinModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/clear"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ClearRecyclebinModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * list_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListRecyclebinEx(request *ListFileInRecycleBinRequest, runtime *RuntimeOptions) (_result *ListRecyclebinModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListRecyclebinModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListRecyclebinModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListRecyclebinModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * restore_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RestoreFileEx(request *RestoreFileRequest, runtime *RuntimeOptions) (_result *RestoreFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &RestoreFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*RestoreFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/restore"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &RestoreFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &RestoreFileModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * trash_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TrashFileEx(request *TrashFileRequest, runtime *RuntimeOptions) (_result *TrashFileModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &TrashFileModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*TrashFileModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/trash"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &TrashFileModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &TrashFileModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ReportEventEx(request *ReportEventRequest, runtime *RuntimeOptions) (_result *ReportEventModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ReportEventModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ReportEventModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/report_event"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ReportEventModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareEx(request *CreateShareRequest, runtime *RuntimeOptions) (_result *CreateShareModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateShareModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateShareModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateShareModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteShareEx(request *DeleteShareRequest, runtime *RuntimeOptions) (_result *DeleteShareModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteShareModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteShareModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteShareModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareEx(request *GetShareRequest, runtime *RuntimeOptions) (_result *GetShareModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareEx(request *ListShareRequest, runtime *RuntimeOptions) (_result *ListShareModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListShareModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListShareModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListShareModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareEx(request *UpdateShareRequest, runtime *RuntimeOptions) (_result *UpdateShareModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateShareModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateShareModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateShareModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelShareLinkEx(request *CancelShareLinkRequest, runtime *RuntimeOptions) (_result *CancelShareLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CancelShareLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CancelShareLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/cancel"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &CancelShareLinkModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareLinkEx(request *CreateShareLinkRequest, runtime *RuntimeOptions) (_result *CreateShareLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateShareLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateShareLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateShareLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkEx(request *GetShareLinkRequest, runtime *RuntimeOptions) (_result *GetShareLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareByAnonymousEx(request *GetShareLinkByAnonymousRequest, runtime *RuntimeOptions) (_result *GetShareByAnonymousModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareByAnonymousModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareByAnonymousModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_by_anonymous"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareByAnonymousModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * id
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareIdEx(request *GetShareLinkIDRequest, runtime *RuntimeOptions) (_result *GetShareIdModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareIdModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareIdModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_share_id"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareIdModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * +token
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareTokenEx(request *GetShareLinkTokenRequest, runtime *RuntimeOptions) (_result *GetShareTokenModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetShareTokenModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetShareTokenModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_share_token"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetShareTokenModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareLinkEx(request *ListShareLinkRequest, runtime *RuntimeOptions) (_result *ListShareLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListShareLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListShareLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListShareLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareLinkEx(request *UpdateShareLinkRequest, runtime *RuntimeOptions) (_result *UpdateShareLinkModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateShareLinkModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateShareLinkModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateShareLinkModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateGroupEx(request *CreateGroupRequest, runtime *RuntimeOptions) (_result *CreateGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateGroupModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteGroupEx(request *DeleteGroupRequest, runtime *RuntimeOptions) (_result *DeleteGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteGroupModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetGroupEx(request *GetGroupRequest, runtime *RuntimeOptions) (_result *GetGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetGroupModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListGroupEx(request *ListGroupRequest, runtime *RuntimeOptions) (_result *ListGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListGroupModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchGroupEx(request *SearchGroupRequest, runtime *RuntimeOptions) (_result *SearchGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &SearchGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*SearchGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/search"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &SearchGroupModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateGroupEx(request *UpdateGroupRequest, runtime *RuntimeOptions) (_result *UpdateGroupModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateGroupModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateGroupModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateGroupModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateMembershipEx(request *CreateMembershipRequest, runtime *RuntimeOptions) (_result *CreateMembershipModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateMembershipModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateMembershipModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateMembershipModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteMembershipEx(request *DeleteMembershipRequest, runtime *RuntimeOptions) (_result *DeleteMembershipModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteMembershipModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteMembershipModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteMembershipModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMembershipEx(request *GetMembershipRequest, runtime *RuntimeOptions) (_result *GetMembershipModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetMembershipModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetMembershipModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetMembershipModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * groupmember
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) HasMemberEx(request *HasMemberRequest, runtime *RuntimeOptions) (_result *HasMemberModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &HasMemberModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*HasMemberModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/has_member"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &HasMemberModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectChildMembershipsEx(request *ListDirectChildMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectChildMembershipsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListDirectChildMembershipsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListDirectChildMembershipsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_child_memberships"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListDirectChildMembershipsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectMembershipsEx(request *ListDirectParentMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectMembershipsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListDirectMembershipsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListDirectMembershipsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_memberships"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListDirectMembershipsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectParentMembershipsEx(request *ListDirectParentMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectParentMembershipsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListDirectParentMembershipsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListDirectParentMembershipsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_parent_memberships"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListDirectParentMembershipsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateMembershipEx(request *UpdateMembershipRequest, runtime *RuntimeOptions) (_result *UpdateMembershipModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateMembershipModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateMembershipModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateMembershipModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddUserToSubdomainEx(request *AddUserToSubdomainRequest, runtime *RuntimeOptions) (_result *AddUserToSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &AddUserToSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*AddUserToSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/add_user_to_subdomain"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        _result = &AddUserToSubdomainModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateUserEx(request *CreateUserRequest, runtime *RuntimeOptions) (_result *CreateUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/create"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateUserModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUserEx(request *DeleteUserRequest, runtime *RuntimeOptions) (_result *DeleteUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &DeleteUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*DeleteUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/delete"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &DeleteUserModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUserEx(request *GetUserRequest, runtime *RuntimeOptions) (_result *GetUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/get"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetUserModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ImportUserEx(request *ImportUserRequest, runtime *RuntimeOptions) (_result *ImportUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ImportUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ImportUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/import"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ImportUserModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUsersEx(request *ListUserRequest, runtime *RuntimeOptions) (_result *ListUsersModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListUsersModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListUsersModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/list"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListUsersModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemoveUserFromSubdomainEx(request *RemoveUserFromSubdomainRequest, runtime *RuntimeOptions) (_result *RemoveUserFromSubdomainModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &RemoveUserFromSubdomainModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*RemoveUserFromSubdomainModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/remove_user_from_subdomain"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        _result = &RemoveUserFromSubdomainModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUserEx(request *SearchUserRequest, runtime *RuntimeOptions) (_result *SearchUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &SearchUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*SearchUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/search"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &SearchUserModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * descriptionnick_nameavatar
 * status
 * role
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateUserEx(request *UpdateUserRequest, runtime *RuntimeOptions) (_result *UpdateUserModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateUserModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateUserModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/update"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateUserModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags face_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MergeEx(request *MergeFaceGroupRequest, runtime *RuntimeOptions) (_result *MergeModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &MergeModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*MergeModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/albums/face_group/merge"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &MergeModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags albums
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UnassignFacegroupItemEx(request *UnAssignFaceGroupItemRequest, runtime *RuntimeOptions) (_result *UnassignFacegroupItemModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UnassignFacegroupItemModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UnassignFacegroupItemModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/albums/unassign_facegroup_item"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
        _result = &UnassignFacegroupItemModel{}
        _err = tea.Convert(map[string]map[string]*string{
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateStoryEx(request *CreateStoryRequest, runtime *RuntimeOptions) (_result *CreateStoryModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &CreateStoryModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*CreateStoryModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/create_story"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &CreateStoryModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) FindStoriesEx(request *FindStoriesRequest, runtime *RuntimeOptions) (_result *FindStoriesModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &FindStoriesModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*FindStoriesModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/find_stories"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &FindStoriesModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * Drive
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetPhotoCountEx(request *GetImageCountRequest, runtime *RuntimeOptions) (_result *GetPhotoCountModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetPhotoCountModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetPhotoCountModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/get_photo_count"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetPhotoCountModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetStoryEx(request *GetStoryRequest, runtime *RuntimeOptions) (_result *GetStoryModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &GetStoryModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*GetStoryModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/get_story"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &GetStoryModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListAddressGroupsEx(request *ListImageAddressGroupsRequest, runtime *RuntimeOptions) (_result *ListAddressGroupsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListAddressGroupsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListAddressGroupsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_address_groups"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListAddressGroupsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFacegroupsEx(request *ListImageFaceGroupsRequest, runtime *RuntimeOptions) (_result *ListFacegroupsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListFacegroupsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListFacegroupsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_facegroups"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListFacegroupsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListTagsEx(request *ListImageTagsRequest, runtime *RuntimeOptions) (_result *ListTagsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ListTagsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ListTagsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_tags"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ListTagsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ParseKeywordsEx(request *ParseKeywordsRequest, runtime *RuntimeOptions) (_result *ParseKeywordsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &ParseKeywordsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*ParseKeywordsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/parse_keywords"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &ParseKeywordsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchAddressGroupsEx(request *SearchImageAddressGroupsRequest, runtime *RuntimeOptions) (_result *SearchAddressGroupsModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &SearchAddressGroupsModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*SearchAddressGroupsModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/search_address_groups"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &SearchAddressGroupsModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFacegroupInfoEx(request *UpdateFaceGroupInfoRequest, runtime *RuntimeOptions) (_result *UpdateFacegroupInfoModel, _err error) {
  _err = tea.Validate(request)
  if _err != nil {
    return _result, _err
  }
  _err = tea.Validate(runtime)
  if _err != nil {
    return _result, _err
  }
  _runtime := map[string]interface{}{
    "timeouted": "retry",
    "readTimeout": tea.IntValue(runtime.ReadTimeout),
    "connectTimeout": tea.IntValue(runtime.ConnectTimeout),
    "localAddr": tea.StringValue(runtime.LocalAddr),
    "httpProxy": tea.StringValue(runtime.HttpProxy),
    "httpsProxy": tea.StringValue(runtime.HttpsProxy),
    "noProxy": tea.StringValue(runtime.NoProxy),
    "maxIdleConns": tea.IntValue(runtime.MaxIdleConns),
    "socks5Proxy": tea.StringValue(runtime.Socks5Proxy),
    "socks5NetWork": tea.StringValue(runtime.Socks5NetWork),
    "retry": map[string]interface{}{
      "retryable": tea.BoolValue(runtime.Autoretry),
      "maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
    },
    "backoff": map[string]interface{}{
      "policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
      "period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
    },
    "ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
  }

  _resp := &UpdateFacegroupInfoModel{}
  for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
    if _retryTimes > 0 {
      _backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
      if tea.IntValue(_backoffTime) > 0 {
        tea.Sleep(_backoffTime)
      }
    }

    _resp, _err = func()(*UpdateFacegroupInfoModel, error){
      request_ := tea.NewRequest()
      accesskeyId, _err := client.GetAccessKeyId()
      if _err != nil {
        return _result, _err
      }

      accessKeySecret, _err := client.GetAccessKeySecret()
      if _err != nil {
        return _result, _err
      }

      securityToken, _err := client.GetSecurityToken()
      if _err != nil {
        return _result, _err
      }

      accessToken, _err := client.GetAccessToken()
      if _err != nil {
        return _result, _err
      }

      realReq := util.ToMap(request)
      request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
      request_.Method = tea.String("POST")
      request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/update_facegroup_info"))
      request_.Headers = tea.Merge(map[string]*string{
        "user-agent": client.GetUserAgent(),
        "host": util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId) + ".api.aliyunpds.com")),
        "content-type": tea.String("application/json; charset=utf-8"),
        },request.Headers)
      realReq["headers"] = nil
      if !tea.BoolValue(util.Empty(accessToken)) {
        request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
      } else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
        if !tea.BoolValue(util.Empty(securityToken)) {
          request_.Headers["x-acs-security-token"] = securityToken
        }

        request_.Headers["date"] = util.GetDateUTCString()
        request_.Headers["accept"] = tea.String("application/json")
        request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
        request_.Headers["x-acs-signature-version"] = tea.String("1.0")
        stringToSign := roautil.GetStringToSign(request_)
        request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
      }

      request_.Body = tea.ToReader(util.ToJSONString(realReq))
      response_, _err := tea.DoRequest(request_, _runtime)
      if _err != nil {
        return _result, _err
      }
      var respMap map[string]interface{}
      var obj interface{}
      if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
        obj, _err = util.ReadAsJSON(response_.Body)
        if _err != nil {
          return _result, _err
        }

        respMap = util.AssertAsMap(obj)
        _result = &UpdateFacegroupInfoModel{}
        _err = tea.Convert(map[string]interface{}{
          "body": respMap,
          "headers": response_.Headers,
        }, &_result)
        return _result, _err
      }

      if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
        _err = tea.NewSDKError(map[string]interface{}{
          "data": map[string]interface{}{
            "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
            "statusCode": tea.IntValue(response_.StatusCode),
            "statusMessage": tea.StringValue(response_.StatusMessage),
          },
          "message": tea.StringValue(response_.Headers["x-ca-error-message"]),
        })
        return _result, _err
      }

      obj, _err = util.ReadAsJSON(response_.Body)
      if _err != nil {
        return _result, _err
      }

      respMap = util.AssertAsMap(obj)
      _err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
        "data": map[string]interface{}{
          "requestId": tea.StringValue(response_.Headers["x-ca-request-id"]),
          "statusCode": tea.IntValue(response_.StatusCode),
          "statusMessage": tea.StringValue(response_.StatusMessage),
        },
        },respMap))
      return _result, _err
    }()
    if !tea.BoolValue(tea.Retryable(_err)) {
      break
    }
  }

  return _resp, _err
}


/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CancelLink (request *CancelLinkRequest) (_result *CancelLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CancelLinkModel{}
  _body, _err := client.CancelLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * , 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ConfirmLink (request *ConfirmLinkRequest) (_result *ConfirmLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ConfirmLinkModel{}
  _body, _err := client.ConfirmLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 8-20
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ChangePassword (request *DefaultChangePasswordRequest) (_result *ChangePasswordModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ChangePasswordModel{}
  _body, _err := client.ChangePasswordEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 8-20
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SetPassword (request *DefaultSetPasswordRequest) (_result *SetPasswordModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &SetPasswordModel{}
  _body, _err := client.SetPasswordEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * statestate
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) VerifyCode (request *VerifyCodeRequest) (_result *VerifyCodeModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &VerifyCodeModel{}
  _body, _err := client.VerifyCodeEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetAccessTokenByLinkInfo (request *GetAccessTokenByLinkInfoRequest) (_result *GetAccessTokenByLinkInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetAccessTokenByLinkInfoModel{}
  _body, _err := client.GetAccessTokenByLinkInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfo (request *GetByLinkInfoRequest) (_result *GetLinkInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetLinkInfoModel{}
  _body, _err := client.GetLinkInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoByUserId (request *GetLinkInfoByUserIDRequest) (_result *GetLinkInfoByUserIdModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetLinkInfoByUserIdModel{}
  _body, _err := client.GetLinkInfoByUserIdEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetPublicKey (request *GetPublicKeyRequest) (_result *GetPublicKeyModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetPublicKeyModel{}
  _body, _err := client.GetPublicKeyEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Link (request *AccountLinkRequest) (_result *LinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &LinkModel{}
  _body, _err := client.LinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CheckExist (request *MobileCheckExistRequest) (_result *CheckExistModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CheckExistModel{}
  _body, _err := client.CheckExistEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Login (request *MobileLoginRequest) (_result *LoginModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &LoginModel{}
  _body, _err := client.LoginEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Register (request *MobileRegisterRequest) (_result *RegisterModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &RegisterModel{}
  _body, _err := client.RegisterEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) MobileSendSmsCode (request *MobileSendSmsCodeRequest) (_result *MobileSendSmsCodeModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &MobileSendSmsCodeModel{}
  _body, _err := client.MobileSendSmsCodeEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountRevoke (request *RevokeRequest) (_result *AccountRevokeModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &AccountRevokeModel{}
  _body, _err := client.AccountRevokeEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * refresh_tokenaccess_token
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountToken (request *AccountTokenRequest) (_result *AccountTokenModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &AccountTokenModel{}
  _body, _err := client.AccountTokenEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * Store
 * @tags admin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AdminListStores (request *AdminListStoresRequest) (_result *AdminListStoresModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &AdminListStoresModel{}
  _body, _err := client.AdminListStoresEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * create subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CreateSubdomain (request *CreateSubdomainRequest) (_result *CreateSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateSubdomainModel{}
  _body, _err := client.CreateSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * delete subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) DeleteSubdomain (request *DeleteSubdomainRequest) (_result *DeleteSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteSubdomainModel{}
  _body, _err := client.DeleteSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * get subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetSubdomain (request *GetSubdomainRequest) (_result *GetSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetSubdomainModel{}
  _body, _err := client.GetSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * list subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListSubdomains (request *ListSubdomainsRequest) (_result *ListSubdomainsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListSubdomainsModel{}
  _body, _err := client.ListSubdomainsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * update subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) UpdateSubdomain (request *UpdateSubdomainRequest) (_result *UpdateSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateSubdomainModel{}
  _body, _err := client.UpdateSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * accessToken
 * @tags admin
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 */
func (client *Client) GetUserAccessToken (request *GetUserAccessTokenRequest) (_result *GetUserAccessTokenModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetUserAccessTokenModel{}
  _body, _err := client.GetUserAccessTokenEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * id
 * 
 * @tags async_task
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAsyncTaskInfo (request *GetAsyncTaskRequest) (_result *GetAsyncTaskInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetAsyncTaskInfoModel{}
  _body, _err := client.GetAsyncTaskInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * 100
 * @tags batch
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BatchOperation (request *BatchRequest) (_result *BatchOperationModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &BatchOperationModel{}
  _body, _err := client.BatchOperationEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * normallargedrive
 * largedrivelist
 * drive1large
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateDrive (request *CreateDriveRequest) (_result *CreateDriveModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateDriveModel{}
  _body, _err := client.CreateDriveEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteDrive (request *DeleteDriveRequest) (_result *DeleteDriveModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteDriveModel{}
  _body, _err := client.DeleteDriveEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDrive (request *GetDriveRequest) (_result *GetDriveModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetDriveModel{}
  _body, _err := client.GetDriveEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drivedrivedrive
 * drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDefaultDrive (request *GetDefaultDriveRequest) (_result *GetDefaultDriveModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetDefaultDriveModel{}
  _body, _err := client.GetDefaultDriveEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDrives (request *ListDriveRequest) (_result *ListDrivesModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListDrivesModel{}
  _body, _err := client.ListDrivesEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListMyDrives (request *ListMyDriveRequest) (_result *ListMyDrivesModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListMyDrivesModel{}
  _body, _err := client.ListMyDrivesEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateDrive (request *UpdateDriveRequest) (_result *UpdateDriveModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateDriveModel{}
  _body, _err := client.UpdateDriveEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * archive_files
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ArchiveFiles (request *CCPArchiveFilesRequest) (_result *ArchiveFilesModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ArchiveFilesModel{}
  _body, _err := client.ArchiveFilesEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFile (request *CompleteFileRequest) (_result *CompleteFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CompleteFileModel{}
  _body, _err := client.CompleteFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFile (request *CopyFileRequest) (_result *CopyFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CopyFileModel{}
  _body, _err := client.CopyFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFile (request *CreateFileRequest) (_result *CreateFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateFileModel{}
  _body, _err := client.CreateFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithProof (request *CreateFileRequest) (_result *CreateFileWithProofModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateFileWithProofModel{}
  _body, _err := client.CreateFileWithProofEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteFile (request *DeleteFileRequest) (_result *DeleteFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteFileModel{}
  _body, _err := client.DeleteFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFile (request *GetFileRequest) (_result *GetFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetFileModel{}
  _body, _err := client.GetFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileByPath (request *GetFileByPathRequest) (_result *GetFileByPathModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetFileByPathModel{}
  _body, _err := client.GetFileByPathEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDownloadUrl (request *GetDownloadUrlRequest) (_result *GetDownloadUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetDownloadUrlModel{}
  _body, _err := client.GetDownloadUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetLastCursor (request *GetLastCursorRequest) (_result *GetLastCursorModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetLastCursorModel{}
  _body, _err := client.GetLastCursorEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * mediaURLm3u8
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMediaPlayUrl (request *GetMediaPlayURLRequest) (_result *GetMediaPlayUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetMediaPlayUrlModel{}
  _body, _err := client.GetMediaPlayUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficeEditUrl (request *GetOfficeEditUrlRequest) (_result *GetOfficeEditUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetOfficeEditUrlModel{}
  _body, _err := client.GetOfficeEditUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * office
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficePreviewUrl (request *GetOfficePreviewUrlRequest) (_result *GetOfficePreviewUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetOfficePreviewUrlModel{}
  _body, _err := client.GetOfficePreviewUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkDownloadUrl (request *GetShareLinkDownloadURLRequest) (_result *GetShareLinkDownloadUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareLinkDownloadUrlModel{}
  _body, _err := client.GetShareLinkDownloadUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkVideoPreviewPlayInfo (request *CCPGetShareLinkVideoPreviewPlayInfoRequest) (_result *GetShareLinkVideoPreviewPlayInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareLinkVideoPreviewPlayInfoModel{}
  _body, _err := client.GetShareLinkVideoPreviewPlayInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUploadUrl (request *GetUploadUrlRequest) (_result *GetUploadUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetUploadUrlModel{}
  _body, _err := client.GetUploadUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewPlayInfo (request *CCPGetVideoPreviewPlayInfoRequest) (_result *GetVideoPreviewPlayInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetVideoPreviewPlayInfoModel{}
  _body, _err := client.GetVideoPreviewPlayInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewSpriteUrl (request *GetVideoPreviewSpriteURLRequest) (_result *GetVideoPreviewSpriteUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetVideoPreviewSpriteUrlModel{}
  _body, _err := client.GetVideoPreviewSpriteUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewUrl (request *GetVideoPreviewURLRequest) (_result *GetVideoPreviewUrlModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetVideoPreviewUrlModel{}
  _body, _err := client.GetVideoPreviewUrlEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFile (request *ListFileRequest) (_result *ListFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFileModel{}
  _body, _err := client.ListFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * list file activity
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileActivity (request *ListFileActivityRequest) (_result *ListFileActivityModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFileActivityModel{}
  _body, _err := client.ListFileActivityEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ShareLinkTokenInvalid ShareToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByAnonymous (request *ListByAnonymousRequest) (_result *ListFileByAnonymousModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFileByAnonymousModel{}
  _body, _err := client.ListFileByAnonymousEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByCustomIndexKey (request *ListFileByCustomIndexKeyRequest) (_result *ListFileByCustomIndexKeyModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFileByCustomIndexKeyModel{}
  _body, _err := client.ListFileByCustomIndexKeyEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileDelta (request *ListFileDeltaRequest) (_result *ListFileDeltaModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFileDeltaModel{}
  _body, _err := client.ListFileDeltaEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * upload_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUploadedParts (request *ListUploadedPartRequest) (_result *ListUploadedPartsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListUploadedPartsModel{}
  _body, _err := client.ListUploadedPartsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * live_transcode
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) LiveTranscode (request *CCPLiveTranscodeRequest) (_result *LiveTranscodeModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &LiveTranscodeModel{}
  _body, _err := client.LiveTranscodeEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MoveFile (request *MoveFileRequest) (_result *MoveFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &MoveFileModel{}
  _body, _err := client.MoveFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * Token
 * @tags file, refresh, office, edit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) Token (request *RefreshOfficeEditTokenRequest) (_result *TokenModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &TokenModel{}
  _body, _err := client.TokenEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ScanFileMeta (request *ScanFileMetaRequest) (_result *ScanFileMetaModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ScanFileMetaModel{}
  _body, _err := client.ScanFileMetaEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFile (request *SearchFileRequest) (_result *SearchFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &SearchFileModel{}
  _body, _err := client.SearchFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFile (request *UpdateFileMetaRequest) (_result *UpdateFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateFileModel{}
  _body, _err := client.UpdateFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * walk file
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) WalkFile (request *CCPWalkFileRequest) (_result *WalkFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &WalkFileModel{}
  _body, _err := client.WalkFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * clear_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ClearRecyclebin (request *ClearRecycleBinRequest) (_result *ClearRecyclebinModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ClearRecyclebinModel{}
  _body, _err := client.ClearRecyclebinEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * list_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListRecyclebin (request *ListFileInRecycleBinRequest) (_result *ListRecyclebinModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListRecyclebinModel{}
  _body, _err := client.ListRecyclebinEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * restore_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RestoreFile (request *RestoreFileRequest) (_result *RestoreFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &RestoreFileModel{}
  _body, _err := client.RestoreFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * trash_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TrashFile (request *TrashFileRequest) (_result *TrashFileModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &TrashFileModel{}
  _body, _err := client.TrashFileEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ReportEvent (request *ReportEventRequest) (_result *ReportEventModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ReportEventModel{}
  _body, _err := client.ReportEventEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShare (request *CreateShareRequest) (_result *CreateShareModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateShareModel{}
  _body, _err := client.CreateShareEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteShare (request *DeleteShareRequest) (_result *DeleteShareModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteShareModel{}
  _body, _err := client.DeleteShareEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShare (request *GetShareRequest) (_result *GetShareModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareModel{}
  _body, _err := client.GetShareEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShare (request *ListShareRequest) (_result *ListShareModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListShareModel{}
  _body, _err := client.ListShareEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShare (request *UpdateShareRequest) (_result *UpdateShareModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateShareModel{}
  _body, _err := client.UpdateShareEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelShareLink (request *CancelShareLinkRequest) (_result *CancelShareLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CancelShareLinkModel{}
  _body, _err := client.CancelShareLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareLink (request *CreateShareLinkRequest) (_result *CreateShareLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateShareLinkModel{}
  _body, _err := client.CreateShareLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLink (request *GetShareLinkRequest) (_result *GetShareLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareLinkModel{}
  _body, _err := client.GetShareLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareByAnonymous (request *GetShareLinkByAnonymousRequest) (_result *GetShareByAnonymousModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareByAnonymousModel{}
  _body, _err := client.GetShareByAnonymousEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * id
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareId (request *GetShareLinkIDRequest) (_result *GetShareIdModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareIdModel{}
  _body, _err := client.GetShareIdEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * +token
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareToken (request *GetShareLinkTokenRequest) (_result *GetShareTokenModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetShareTokenModel{}
  _body, _err := client.GetShareTokenEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareLink (request *ListShareLinkRequest) (_result *ListShareLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListShareLinkModel{}
  _body, _err := client.ListShareLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareLink (request *UpdateShareLinkRequest) (_result *UpdateShareLinkModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateShareLinkModel{}
  _body, _err := client.UpdateShareLinkEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateGroup (request *CreateGroupRequest) (_result *CreateGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateGroupModel{}
  _body, _err := client.CreateGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteGroup (request *DeleteGroupRequest) (_result *DeleteGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteGroupModel{}
  _body, _err := client.DeleteGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetGroup (request *GetGroupRequest) (_result *GetGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetGroupModel{}
  _body, _err := client.GetGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListGroup (request *ListGroupRequest) (_result *ListGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListGroupModel{}
  _body, _err := client.ListGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchGroup (request *SearchGroupRequest) (_result *SearchGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &SearchGroupModel{}
  _body, _err := client.SearchGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateGroup (request *UpdateGroupRequest) (_result *UpdateGroupModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateGroupModel{}
  _body, _err := client.UpdateGroupEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateMembership (request *CreateMembershipRequest) (_result *CreateMembershipModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateMembershipModel{}
  _body, _err := client.CreateMembershipEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteMembership (request *DeleteMembershipRequest) (_result *DeleteMembershipModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteMembershipModel{}
  _body, _err := client.DeleteMembershipEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMembership (request *GetMembershipRequest) (_result *GetMembershipModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetMembershipModel{}
  _body, _err := client.GetMembershipEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * groupmember
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) HasMember (request *HasMemberRequest) (_result *HasMemberModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &HasMemberModel{}
  _body, _err := client.HasMemberEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectChildMemberships (request *ListDirectChildMembershipsRequest) (_result *ListDirectChildMembershipsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListDirectChildMembershipsModel{}
  _body, _err := client.ListDirectChildMembershipsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectMemberships (request *ListDirectParentMembershipsRequest) (_result *ListDirectMembershipsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListDirectMembershipsModel{}
  _body, _err := client.ListDirectMembershipsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectParentMemberships (request *ListDirectParentMembershipsRequest) (_result *ListDirectParentMembershipsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListDirectParentMembershipsModel{}
  _body, _err := client.ListDirectParentMembershipsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateMembership (request *UpdateMembershipRequest) (_result *UpdateMembershipModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateMembershipModel{}
  _body, _err := client.UpdateMembershipEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddUserToSubdomain (request *AddUserToSubdomainRequest) (_result *AddUserToSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &AddUserToSubdomainModel{}
  _body, _err := client.AddUserToSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateUser (request *CreateUserRequest) (_result *CreateUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateUserModel{}
  _body, _err := client.CreateUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUser (request *DeleteUserRequest) (_result *DeleteUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &DeleteUserModel{}
  _body, _err := client.DeleteUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUser (request *GetUserRequest) (_result *GetUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetUserModel{}
  _body, _err := client.GetUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ImportUser (request *ImportUserRequest) (_result *ImportUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ImportUserModel{}
  _body, _err := client.ImportUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUsers (request *ListUserRequest) (_result *ListUsersModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListUsersModel{}
  _body, _err := client.ListUsersEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemoveUserFromSubdomain (request *RemoveUserFromSubdomainRequest) (_result *RemoveUserFromSubdomainModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &RemoveUserFromSubdomainModel{}
  _body, _err := client.RemoveUserFromSubdomainEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUser (request *SearchUserRequest) (_result *SearchUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &SearchUserModel{}
  _body, _err := client.SearchUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * descriptionnick_nameavatar
 * status
 * role
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateUser (request *UpdateUserRequest) (_result *UpdateUserModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateUserModel{}
  _body, _err := client.UpdateUserEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags face_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) Merge (request *MergeFaceGroupRequest) (_result *MergeModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &MergeModel{}
  _body, _err := client.MergeEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags albums
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UnassignFacegroupItem (request *UnAssignFaceGroupItemRequest) (_result *UnassignFacegroupItemModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UnassignFacegroupItemModel{}
  _body, _err := client.UnassignFacegroupItemEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateStory (request *CreateStoryRequest) (_result *CreateStoryModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &CreateStoryModel{}
  _body, _err := client.CreateStoryEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) FindStories (request *FindStoriesRequest) (_result *FindStoriesModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &FindStoriesModel{}
  _body, _err := client.FindStoriesEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * Drive
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetPhotoCount (request *GetImageCountRequest) (_result *GetPhotoCountModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetPhotoCountModel{}
  _body, _err := client.GetPhotoCountEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetStory (request *GetStoryRequest) (_result *GetStoryModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &GetStoryModel{}
  _body, _err := client.GetStoryEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListAddressGroups (request *ListImageAddressGroupsRequest) (_result *ListAddressGroupsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListAddressGroupsModel{}
  _body, _err := client.ListAddressGroupsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFacegroups (request *ListImageFaceGroupsRequest) (_result *ListFacegroupsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListFacegroupsModel{}
  _body, _err := client.ListFacegroupsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListTags (request *ListImageTagsRequest) (_result *ListTagsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ListTagsModel{}
  _body, _err := client.ListTagsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ParseKeywords (request *ParseKeywordsRequest) (_result *ParseKeywordsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &ParseKeywordsModel{}
  _body, _err := client.ParseKeywordsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchAddressGroups (request *SearchImageAddressGroupsRequest) (_result *SearchAddressGroupsModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &SearchAddressGroupsModel{}
  _body, _err := client.SearchAddressGroupsEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFacegroupInfo (request *UpdateFaceGroupInfoRequest) (_result *UpdateFacegroupInfoModel, _err error) {
  runtime := &RuntimeOptions{}
  _result = &UpdateFacegroupInfoModel{}
  _body, _err := client.UpdateFacegroupInfoEx(request, runtime)
  if _err != nil {
    return _result, _err
  }
  _result = _body
  return _result, _err
}

func (client *Client) GetPathname (nickname *string, path *string) (_result *string) {
  if tea.BoolValue(util.Empty(nickname)) {
    _result = path
    return _result
  }

  _result = tea.String("/" + tea.StringValue(nickname) + tea.StringValue(path))
  return _result
}

func (client *Client) SetExpireTime (expireTime *string) (_err error) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    return _err
  }

  client.AccessTokenCredential.SetExpireTime(expireTime)
  return _err
}

func (client *Client) GetExpireTime () (_result *string) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    _result = tea.String("")
    return _result
  }

  expireTime := client.AccessTokenCredential.GetExpireTime()
  _result = expireTime
  return _result
}

func (client *Client) SetRefreshToken (token *string) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    return
  }

  client.AccessTokenCredential.SetRefreshToken(token)
}

func (client *Client) GetRefreshToken () (_result *string) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    _result = tea.String("")
    return _result
  }

  token := client.AccessTokenCredential.GetRefreshToken()
  _result = token
  return _result
}

func (client *Client) SetAccessToken (token *string) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    return
  }

  client.AccessTokenCredential.SetAccessToken(token)
}

func (client *Client) GetAccessToken () (_result *string, _err error) {
  if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
    _result = tea.String("")
    return _result, _err
  }

  token, _err := client.AccessTokenCredential.GetAccessToken()
  if _err != nil {
    return _result, _err
  }

  _result = token
  return _result , _err
}

func (client *Client) SetUserAgent (userAgent *string) {
  client.UserAgent = userAgent
}

func (client *Client) AppendUserAgent (userAgent *string) {
  client.UserAgent = tea.String(tea.StringValue(client.UserAgent) + " " + tea.StringValue(userAgent))
}

func (client *Client) GetUserAgent () (_result *string) {
  userAgent := util.GetUserAgent(client.UserAgent)
  _result = userAgent
  return _result
}

func (client *Client) GetAccessKeyId () (_result *string, _err error) {
  if tea.BoolValue(util.IsUnset(client.Credential)) {
    _result = tea.String("")
    return _result, _err
  }

  accessKeyId, _err := client.Credential.GetAccessKeyId()
  if _err != nil {
    return _result, _err
  }

  _result = accessKeyId
  return _result , _err
}

func (client *Client) GetAccessKeySecret () (_result *string, _err error) {
  if tea.BoolValue(util.IsUnset(client.Credential)) {
    _result = tea.String("")
    return _result, _err
  }

  secret, _err := client.Credential.GetAccessKeySecret()
  if _err != nil {
    return _result, _err
  }

  _result = secret
  return _result , _err
}

func (client *Client) GetSecurityToken () (_result *string, _err error) {
  if tea.BoolValue(util.IsUnset(client.Credential)) {
    _result = tea.String("")
    return _result, _err
  }

  token, _err := client.Credential.GetSecurityToken()
  if _err != nil {
    return _result, _err
  }

  _result = token
  return _result , _err
}

