// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	accesstokencredential "github.com/alibabacloud-go/pds-credentials/service"
	roautil "github.com/alibabacloud-go/tea-roa-utils/service"
	util "github.com/alibabacloud-go/tea-utils/service"
	"github.com/alibabacloud-go/tea/tea"
	credential "github.com/aliyun/credentials-go/credentials"
)

type RuntimeOptions struct {
	// whether to try again
	Autoretry *bool `json:"autoretry,omitempty" xml:"autoretry,omitempty"`
	// ignore SSL validation
	IgnoreSSL *bool `json:"ignoreSSL,omitempty" xml:"ignoreSSL,omitempty"`
	// maximum number of retries
	MaxAttempts *int `json:"maxAttempts,omitempty" xml:"maxAttempts,omitempty"`
	// backoff policy
	BackoffPolicy *string `json:"backoffPolicy,omitempty" xml:"backoffPolicy,omitempty"`
	// backoff period
	BackoffPeriod *int `json:"backoffPeriod,omitempty" xml:"backoffPeriod,omitempty"`
	// read timeout
	ReadTimeout *int `json:"readTimeout,omitempty" xml:"readTimeout,omitempty"`
	// connect timeout
	ConnectTimeout *int `json:"connectTimeout,omitempty" xml:"connectTimeout,omitempty"`
	// http proxy url
	HttpProxy *string `json:"httpProxy,omitempty" xml:"httpProxy,omitempty"`
	// https Proxy url
	HttpsProxy *string `json:"httpsProxy,omitempty" xml:"httpsProxy,omitempty"`
	// agent blacklist
	NoProxy *string `json:"noProxy,omitempty" xml:"noProxy,omitempty"`
	// maximum number of connections
	MaxIdleConns *int `json:"maxIdleConns,omitempty" xml:"maxIdleConns,omitempty"`
	// local addr
	LocalAddr *string `json:"localAddr,omitempty" xml:"localAddr,omitempty"`
	// SOCKS5 proxy
	Socks5Proxy *string `json:"socks5Proxy,omitempty" xml:"socks5Proxy,omitempty"`
	// SOCKS5 netWork
	Socks5NetWork *string `json:"socks5NetWork,omitempty" xml:"socks5NetWork,omitempty"`
}

func (s RuntimeOptions) String() string {
	return tea.Prettify(s)
}

func (s RuntimeOptions) GoString() string {
	return s.String()
}

func (s *RuntimeOptions) SetAutoretry(v bool) *RuntimeOptions {
	s.Autoretry = &v
	return s
}

func (s *RuntimeOptions) SetIgnoreSSL(v bool) *RuntimeOptions {
	s.IgnoreSSL = &v
	return s
}

func (s *RuntimeOptions) SetMaxAttempts(v int) *RuntimeOptions {
	s.MaxAttempts = &v
	return s
}

func (s *RuntimeOptions) SetBackoffPolicy(v string) *RuntimeOptions {
	s.BackoffPolicy = &v
	return s
}

func (s *RuntimeOptions) SetBackoffPeriod(v int) *RuntimeOptions {
	s.BackoffPeriod = &v
	return s
}

func (s *RuntimeOptions) SetReadTimeout(v int) *RuntimeOptions {
	s.ReadTimeout = &v
	return s
}

func (s *RuntimeOptions) SetConnectTimeout(v int) *RuntimeOptions {
	s.ConnectTimeout = &v
	return s
}

func (s *RuntimeOptions) SetHttpProxy(v string) *RuntimeOptions {
	s.HttpProxy = &v
	return s
}

func (s *RuntimeOptions) SetHttpsProxy(v string) *RuntimeOptions {
	s.HttpsProxy = &v
	return s
}

func (s *RuntimeOptions) SetNoProxy(v string) *RuntimeOptions {
	s.NoProxy = &v
	return s
}

func (s *RuntimeOptions) SetMaxIdleConns(v int) *RuntimeOptions {
	s.MaxIdleConns = &v
	return s
}

func (s *RuntimeOptions) SetLocalAddr(v string) *RuntimeOptions {
	s.LocalAddr = &v
	return s
}

func (s *RuntimeOptions) SetSocks5Proxy(v string) *RuntimeOptions {
	s.Socks5Proxy = &v
	return s
}

func (s *RuntimeOptions) SetSocks5NetWork(v string) *RuntimeOptions {
	s.Socks5NetWork = &v
	return s
}

type Config struct {
	Endpoint        *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	DomainId        *string `json:"domainId,omitempty" xml:"domainId,omitempty" pattern:"^[a-zA-Z0-9_-]+$"`
	ClientId        *string `json:"clientId,omitempty" xml:"clientId,omitempty"`
	RefreshToken    *string `json:"refreshToken,omitempty" xml:"refreshToken,omitempty"`
	ClientSecret    *string `json:"clientSecret,omitempty" xml:"clientSecret,omitempty"`
	AccessToken     *string `json:"accessToken,omitempty" xml:"accessToken,omitempty"`
	ExpireTime      *string `json:"expireTime,omitempty" xml:"expireTime,omitempty"`
	Protocol        *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	Type            *string `json:"type,omitempty" xml:"type,omitempty"`
	SecurityToken   *string `json:"securityToken,omitempty" xml:"securityToken,omitempty"`
	AccessKeyId     *string `json:"accessKeyId,omitempty" xml:"accessKeyId,omitempty"`
	AccessKeySecret *string `json:"accessKeySecret,omitempty" xml:"accessKeySecret,omitempty"`
	Nickname        *string `json:"nickname,omitempty" xml:"nickname,omitempty"`
	UserAgent       *string `json:"userAgent,omitempty" xml:"userAgent,omitempty"`
}

func (s Config) String() string {
	return tea.Prettify(s)
}

func (s Config) GoString() string {
	return s.String()
}

func (s *Config) SetEndpoint(v string) *Config {
	s.Endpoint = &v
	return s
}

func (s *Config) SetDomainId(v string) *Config {
	s.DomainId = &v
	return s
}

func (s *Config) SetClientId(v string) *Config {
	s.ClientId = &v
	return s
}

func (s *Config) SetRefreshToken(v string) *Config {
	s.RefreshToken = &v
	return s
}

func (s *Config) SetClientSecret(v string) *Config {
	s.ClientSecret = &v
	return s
}

func (s *Config) SetAccessToken(v string) *Config {
	s.AccessToken = &v
	return s
}

func (s *Config) SetExpireTime(v string) *Config {
	s.ExpireTime = &v
	return s
}

func (s *Config) SetProtocol(v string) *Config {
	s.Protocol = &v
	return s
}

func (s *Config) SetType(v string) *Config {
	s.Type = &v
	return s
}

func (s *Config) SetSecurityToken(v string) *Config {
	s.SecurityToken = &v
	return s
}

func (s *Config) SetAccessKeyId(v string) *Config {
	s.AccessKeyId = &v
	return s
}

func (s *Config) SetAccessKeySecret(v string) *Config {
	s.AccessKeySecret = &v
	return s
}

func (s *Config) SetNickname(v string) *Config {
	s.Nickname = &v
	return s
}

func (s *Config) SetUserAgent(v string) *Config {
	s.UserAgent = &v
	return s
}

type CancelLinkModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelLinkModel) String() string {
	return tea.Prettify(s)
}

func (s CancelLinkModel) GoString() string {
	return s.String()
}

func (s *CancelLinkModel) SetHeaders(v map[string]*string) *CancelLinkModel {
	s.Headers = v
	return s
}

func (s *CancelLinkModel) SetBody(v *AccountAccessTokenResponse) *CancelLinkModel {
	s.Body = v
	return s
}

type CheckExistModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CheckExistResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckExistModel) String() string {
	return tea.Prettify(s)
}

func (s CheckExistModel) GoString() string {
	return s.String()
}

func (s *CheckExistModel) SetHeaders(v map[string]*string) *CheckExistModel {
	s.Headers = v
	return s
}

func (s *CheckExistModel) SetBody(v *CheckExistResponse) *CheckExistModel {
	s.Body = v
	return s
}

type ConfirmLinkModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfirmLinkModel) String() string {
	return tea.Prettify(s)
}

func (s ConfirmLinkModel) GoString() string {
	return s.String()
}

func (s *ConfirmLinkModel) SetHeaders(v map[string]*string) *ConfirmLinkModel {
	s.Headers = v
	return s
}

func (s *ConfirmLinkModel) SetBody(v *AccountAccessTokenResponse) *ConfirmLinkModel {
	s.Body = v
	return s
}

type VerifyCodeModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *VerifyCodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyCodeModel) String() string {
	return tea.Prettify(s)
}

func (s VerifyCodeModel) GoString() string {
	return s.String()
}

func (s *VerifyCodeModel) SetHeaders(v map[string]*string) *VerifyCodeModel {
	s.Headers = v
	return s
}

func (s *VerifyCodeModel) SetBody(v *VerifyCodeResponse) *VerifyCodeModel {
	s.Body = v
	return s
}

type GetAccessTokenByLinkInfoModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAccessTokenByLinkInfoModel) String() string {
	return tea.Prettify(s)
}

func (s GetAccessTokenByLinkInfoModel) GoString() string {
	return s.String()
}

func (s *GetAccessTokenByLinkInfoModel) SetHeaders(v map[string]*string) *GetAccessTokenByLinkInfoModel {
	s.Headers = v
	return s
}

func (s *GetAccessTokenByLinkInfoModel) SetBody(v *AccountAccessTokenResponse) *GetAccessTokenByLinkInfoModel {
	s.Body = v
	return s
}

type GetLinkInfoModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *LinkInfoResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLinkInfoModel) String() string {
	return tea.Prettify(s)
}

func (s GetLinkInfoModel) GoString() string {
	return s.String()
}

func (s *GetLinkInfoModel) SetHeaders(v map[string]*string) *GetLinkInfoModel {
	s.Headers = v
	return s
}

func (s *GetLinkInfoModel) SetBody(v *LinkInfoResponse) *GetLinkInfoModel {
	s.Body = v
	return s
}

type GetLinkInfoByUserIdModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *LinkInfoListResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLinkInfoByUserIdModel) String() string {
	return tea.Prettify(s)
}

func (s GetLinkInfoByUserIdModel) GoString() string {
	return s.String()
}

func (s *GetLinkInfoByUserIdModel) SetHeaders(v map[string]*string) *GetLinkInfoByUserIdModel {
	s.Headers = v
	return s
}

func (s *GetLinkInfoByUserIdModel) SetBody(v *LinkInfoListResponse) *GetLinkInfoByUserIdModel {
	s.Body = v
	return s
}

type GetPublicKeyModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetPublicKeyResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPublicKeyModel) String() string {
	return tea.Prettify(s)
}

func (s GetPublicKeyModel) GoString() string {
	return s.String()
}

func (s *GetPublicKeyModel) SetHeaders(v map[string]*string) *GetPublicKeyModel {
	s.Headers = v
	return s
}

func (s *GetPublicKeyModel) SetBody(v *GetPublicKeyResponse) *GetPublicKeyModel {
	s.Body = v
	return s
}

type LinkModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LinkModel) String() string {
	return tea.Prettify(s)
}

func (s LinkModel) GoString() string {
	return s.String()
}

func (s *LinkModel) SetHeaders(v map[string]*string) *LinkModel {
	s.Headers = v
	return s
}

func (s *LinkModel) SetBody(v *AccountAccessTokenResponse) *LinkModel {
	s.Body = v
	return s
}

type LoginModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LoginModel) String() string {
	return tea.Prettify(s)
}

func (s LoginModel) GoString() string {
	return s.String()
}

func (s *LoginModel) SetHeaders(v map[string]*string) *LoginModel {
	s.Headers = v
	return s
}

func (s *LoginModel) SetBody(v *AccountAccessTokenResponse) *LoginModel {
	s.Body = v
	return s
}

type RegisterModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterModel) String() string {
	return tea.Prettify(s)
}

func (s RegisterModel) GoString() string {
	return s.String()
}

func (s *RegisterModel) SetHeaders(v map[string]*string) *RegisterModel {
	s.Headers = v
	return s
}

func (s *RegisterModel) SetBody(v *AccountAccessTokenResponse) *RegisterModel {
	s.Body = v
	return s
}

type AccountRevokeModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AccountRevokeModel) String() string {
	return tea.Prettify(s)
}

func (s AccountRevokeModel) GoString() string {
	return s.String()
}

func (s *AccountRevokeModel) SetHeaders(v map[string]*string) *AccountRevokeModel {
	s.Headers = v
	return s
}

type SendSmsCodeModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SendSmsCodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SendSmsCodeModel) String() string {
	return tea.Prettify(s)
}

func (s SendSmsCodeModel) GoString() string {
	return s.String()
}

func (s *SendSmsCodeModel) SetHeaders(v map[string]*string) *SendSmsCodeModel {
	s.Headers = v
	return s
}

func (s *SendSmsCodeModel) SetBody(v *SendSmsCodeResponse) *SendSmsCodeModel {
	s.Body = v
	return s
}

type AccountTokenModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AccountAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AccountTokenModel) String() string {
	return tea.Prettify(s)
}

func (s AccountTokenModel) GoString() string {
	return s.String()
}

func (s *AccountTokenModel) SetHeaders(v map[string]*string) *AccountTokenModel {
	s.Headers = v
	return s
}

func (s *AccountTokenModel) SetBody(v *AccountAccessTokenResponse) *AccountTokenModel {
	s.Body = v
	return s
}

type ExportAuditLogModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ExportAuditLogResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportAuditLogModel) String() string {
	return tea.Prettify(s)
}

func (s ExportAuditLogModel) GoString() string {
	return s.String()
}

func (s *ExportAuditLogModel) SetHeaders(v map[string]*string) *ExportAuditLogModel {
	s.Headers = v
	return s
}

func (s *ExportAuditLogModel) SetBody(v *ExportAuditLogResponse) *ExportAuditLogModel {
	s.Body = v
	return s
}

type SearchAuditLogModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchAuditLogResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAuditLogModel) String() string {
	return tea.Prettify(s)
}

func (s SearchAuditLogModel) GoString() string {
	return s.String()
}

func (s *SearchAuditLogModel) SetHeaders(v map[string]*string) *SearchAuditLogModel {
	s.Headers = v
	return s
}

func (s *SearchAuditLogModel) SetBody(v *SearchAuditLogResponse) *SearchAuditLogModel {
	s.Body = v
	return s
}

type CreateIdentityToBenefitPkgMappingModel struct {
	Headers map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateIdentityToBenefitPkgMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIdentityToBenefitPkgMappingModel) String() string {
	return tea.Prettify(s)
}

func (s CreateIdentityToBenefitPkgMappingModel) GoString() string {
	return s.String()
}

func (s *CreateIdentityToBenefitPkgMappingModel) SetHeaders(v map[string]*string) *CreateIdentityToBenefitPkgMappingModel {
	s.Headers = v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingModel) SetBody(v *CreateIdentityToBenefitPkgMappingResponse) *CreateIdentityToBenefitPkgMappingModel {
	s.Body = v
	return s
}

type DeleteIdentityToBenefitPkgMappingModel struct {
	Headers map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteIdentityToBenefitPkgMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIdentityToBenefitPkgMappingModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteIdentityToBenefitPkgMappingModel) GoString() string {
	return s.String()
}

func (s *DeleteIdentityToBenefitPkgMappingModel) SetHeaders(v map[string]*string) *DeleteIdentityToBenefitPkgMappingModel {
	s.Headers = v
	return s
}

func (s *DeleteIdentityToBenefitPkgMappingModel) SetBody(v *DeleteIdentityToBenefitPkgMappingResponse) *DeleteIdentityToBenefitPkgMappingModel {
	s.Body = v
	return s
}

type GetIdentityToBenefitPkgMappingModel struct {
	Headers map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BaseIdentityToBenefitPkgMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIdentityToBenefitPkgMappingModel) String() string {
	return tea.Prettify(s)
}

func (s GetIdentityToBenefitPkgMappingModel) GoString() string {
	return s.String()
}

func (s *GetIdentityToBenefitPkgMappingModel) SetHeaders(v map[string]*string) *GetIdentityToBenefitPkgMappingModel {
	s.Headers = v
	return s
}

func (s *GetIdentityToBenefitPkgMappingModel) SetBody(v *BaseIdentityToBenefitPkgMappingResponse) *GetIdentityToBenefitPkgMappingModel {
	s.Body = v
	return s
}

type ListIdentityToBenefitPkgMappingModel struct {
	Headers map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListIdentityToBenefitPkgMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIdentityToBenefitPkgMappingModel) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityToBenefitPkgMappingModel) GoString() string {
	return s.String()
}

func (s *ListIdentityToBenefitPkgMappingModel) SetHeaders(v map[string]*string) *ListIdentityToBenefitPkgMappingModel {
	s.Headers = v
	return s
}

func (s *ListIdentityToBenefitPkgMappingModel) SetBody(v *ListIdentityToBenefitPkgMappingResponse) *ListIdentityToBenefitPkgMappingModel {
	s.Body = v
	return s
}

type UpdateIdentityToBenefitPkgMappingModel struct {
	Headers map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateIdentityToBenefitPkgMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIdentityToBenefitPkgMappingModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateIdentityToBenefitPkgMappingModel) GoString() string {
	return s.String()
}

func (s *UpdateIdentityToBenefitPkgMappingModel) SetHeaders(v map[string]*string) *UpdateIdentityToBenefitPkgMappingModel {
	s.Headers = v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingModel) SetBody(v *UpdateIdentityToBenefitPkgMappingResponse) *UpdateIdentityToBenefitPkgMappingModel {
	s.Body = v
	return s
}

type ListIdentityBenefitPkgModel struct {
	Headers map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListIdentityBenefitPkgResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIdentityBenefitPkgModel) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityBenefitPkgModel) GoString() string {
	return s.String()
}

func (s *ListIdentityBenefitPkgModel) SetHeaders(v map[string]*string) *ListIdentityBenefitPkgModel {
	s.Headers = v
	return s
}

func (s *ListIdentityBenefitPkgModel) SetBody(v *ListIdentityBenefitPkgResponse) *ListIdentityBenefitPkgModel {
	s.Body = v
	return s
}

type AdminListStoresModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListStoresResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AdminListStoresModel) String() string {
	return tea.Prettify(s)
}

func (s AdminListStoresModel) GoString() string {
	return s.String()
}

func (s *AdminListStoresModel) SetHeaders(v map[string]*string) *AdminListStoresModel {
	s.Headers = v
	return s
}

func (s *AdminListStoresModel) SetBody(v *ListStoresResponse) *AdminListStoresModel {
	s.Body = v
	return s
}

type CreateSubdomainModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s CreateSubdomainModel) GoString() string {
	return s.String()
}

func (s *CreateSubdomainModel) SetHeaders(v map[string]*string) *CreateSubdomainModel {
	s.Headers = v
	return s
}

func (s *CreateSubdomainModel) SetBody(v *CreateSubdomainResponse) *CreateSubdomainModel {
	s.Body = v
	return s
}

type DeleteSubdomainModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubdomainModel) GoString() string {
	return s.String()
}

func (s *DeleteSubdomainModel) SetHeaders(v map[string]*string) *DeleteSubdomainModel {
	s.Headers = v
	return s
}

func (s *DeleteSubdomainModel) SetBody(v *DeleteSubdomainResponse) *DeleteSubdomainModel {
	s.Body = v
	return s
}

type GetSubdomainModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainModel) GoString() string {
	return s.String()
}

func (s *GetSubdomainModel) SetHeaders(v map[string]*string) *GetSubdomainModel {
	s.Headers = v
	return s
}

func (s *GetSubdomainModel) SetBody(v *GetSubdomainResponse) *GetSubdomainModel {
	s.Body = v
	return s
}

type ListSubdomainsModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListSubdomainsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSubdomainsModel) String() string {
	return tea.Prettify(s)
}

func (s ListSubdomainsModel) GoString() string {
	return s.String()
}

func (s *ListSubdomainsModel) SetHeaders(v map[string]*string) *ListSubdomainsModel {
	s.Headers = v
	return s
}

func (s *ListSubdomainsModel) SetBody(v *ListSubdomainsResponse) *ListSubdomainsModel {
	s.Body = v
	return s
}

type UpdateSubdomainModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubdomainModel) GoString() string {
	return s.String()
}

func (s *UpdateSubdomainModel) SetHeaders(v map[string]*string) *UpdateSubdomainModel {
	s.Headers = v
	return s
}

func (s *UpdateSubdomainModel) SetBody(v *UpdateSubdomainResponse) *UpdateSubdomainModel {
	s.Body = v
	return s
}

type GetUserAccessTokenModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetUserAccessTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserAccessTokenModel) String() string {
	return tea.Prettify(s)
}

func (s GetUserAccessTokenModel) GoString() string {
	return s.String()
}

func (s *GetUserAccessTokenModel) SetHeaders(v map[string]*string) *GetUserAccessTokenModel {
	s.Headers = v
	return s
}

func (s *GetUserAccessTokenModel) SetBody(v *GetUserAccessTokenResponse) *GetUserAccessTokenModel {
	s.Body = v
	return s
}

type PunishFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s PunishFileModel) String() string {
	return tea.Prettify(s)
}

func (s PunishFileModel) GoString() string {
	return s.String()
}

func (s *PunishFileModel) SetHeaders(v map[string]*string) *PunishFileModel {
	s.Headers = v
	return s
}

type GetAsyncTaskInfoModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetAsyncTaskResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAsyncTaskInfoModel) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskInfoModel) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskInfoModel) SetHeaders(v map[string]*string) *GetAsyncTaskInfoModel {
	s.Headers = v
	return s
}

func (s *GetAsyncTaskInfoModel) SetBody(v *GetAsyncTaskResponse) *GetAsyncTaskInfoModel {
	s.Body = v
	return s
}

type BatchOperationModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BatchResponse     `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchOperationModel) String() string {
	return tea.Prettify(s)
}

func (s BatchOperationModel) GoString() string {
	return s.String()
}

func (s *BatchOperationModel) SetHeaders(v map[string]*string) *BatchOperationModel {
	s.Headers = v
	return s
}

func (s *BatchOperationModel) SetBody(v *BatchResponse) *BatchOperationModel {
	s.Body = v
	return s
}

type CreateDriveModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDriveModel) String() string {
	return tea.Prettify(s)
}

func (s CreateDriveModel) GoString() string {
	return s.String()
}

func (s *CreateDriveModel) SetHeaders(v map[string]*string) *CreateDriveModel {
	s.Headers = v
	return s
}

func (s *CreateDriveModel) SetBody(v *CreateDriveResponse) *CreateDriveModel {
	s.Body = v
	return s
}

type DeleteDriveModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteDriveModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteDriveModel) GoString() string {
	return s.String()
}

func (s *DeleteDriveModel) SetHeaders(v map[string]*string) *DeleteDriveModel {
	s.Headers = v
	return s
}

type GetDriveModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetDriveResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDriveModel) String() string {
	return tea.Prettify(s)
}

func (s GetDriveModel) GoString() string {
	return s.String()
}

func (s *GetDriveModel) SetHeaders(v map[string]*string) *GetDriveModel {
	s.Headers = v
	return s
}

func (s *GetDriveModel) SetBody(v *GetDriveResponse) *GetDriveModel {
	s.Body = v
	return s
}

type GetDefaultDriveModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetDriveResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDefaultDriveModel) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultDriveModel) GoString() string {
	return s.String()
}

func (s *GetDefaultDriveModel) SetHeaders(v map[string]*string) *GetDefaultDriveModel {
	s.Headers = v
	return s
}

func (s *GetDefaultDriveModel) SetBody(v *GetDriveResponse) *GetDefaultDriveModel {
	s.Body = v
	return s
}

type ListDrivesModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDrivesModel) String() string {
	return tea.Prettify(s)
}

func (s ListDrivesModel) GoString() string {
	return s.String()
}

func (s *ListDrivesModel) SetHeaders(v map[string]*string) *ListDrivesModel {
	s.Headers = v
	return s
}

func (s *ListDrivesModel) SetBody(v *ListDriveResponse) *ListDrivesModel {
	s.Body = v
	return s
}

type ListMyDrivesModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListMyDrivesModel) String() string {
	return tea.Prettify(s)
}

func (s ListMyDrivesModel) GoString() string {
	return s.String()
}

func (s *ListMyDrivesModel) SetHeaders(v map[string]*string) *ListMyDrivesModel {
	s.Headers = v
	return s
}

func (s *ListMyDrivesModel) SetBody(v *ListDriveResponse) *ListMyDrivesModel {
	s.Body = v
	return s
}

type SearchDrivesModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchDrivesModel) String() string {
	return tea.Prettify(s)
}

func (s SearchDrivesModel) GoString() string {
	return s.String()
}

func (s *SearchDrivesModel) SetHeaders(v map[string]*string) *SearchDrivesModel {
	s.Headers = v
	return s
}

func (s *SearchDrivesModel) SetBody(v *SearchDriveResponse) *SearchDrivesModel {
	s.Body = v
	return s
}

type UpdateDriveModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateDriveResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDriveModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateDriveModel) GoString() string {
	return s.String()
}

func (s *UpdateDriveModel) SetHeaders(v map[string]*string) *UpdateDriveModel {
	s.Headers = v
	return s
}

func (s *UpdateDriveModel) SetBody(v *UpdateDriveResponse) *UpdateDriveModel {
	s.Body = v
	return s
}

type AddPermissionModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AddPermissionModel) String() string {
	return tea.Prettify(s)
}

func (s AddPermissionModel) GoString() string {
	return s.String()
}

func (s *AddPermissionModel) SetHeaders(v map[string]*string) *AddPermissionModel {
	s.Headers = v
	return s
}

type ArchiveFilesModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CCPArchiveFilesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ArchiveFilesModel) String() string {
	return tea.Prettify(s)
}

func (s ArchiveFilesModel) GoString() string {
	return s.String()
}

func (s *ArchiveFilesModel) SetHeaders(v map[string]*string) *ArchiveFilesModel {
	s.Headers = v
	return s
}

func (s *ArchiveFilesModel) SetBody(v *CCPArchiveFilesResponse) *ArchiveFilesModel {
	s.Body = v
	return s
}

type CompleteFileModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CompleteFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteFileModel) String() string {
	return tea.Prettify(s)
}

func (s CompleteFileModel) GoString() string {
	return s.String()
}

func (s *CompleteFileModel) SetHeaders(v map[string]*string) *CompleteFileModel {
	s.Headers = v
	return s
}

func (s *CompleteFileModel) SetBody(v *CompleteFileResponse) *CompleteFileModel {
	s.Body = v
	return s
}

type CompleteFileWithStoreInfoModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UCCompleteFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteFileWithStoreInfoModel) String() string {
	return tea.Prettify(s)
}

func (s CompleteFileWithStoreInfoModel) GoString() string {
	return s.String()
}

func (s *CompleteFileWithStoreInfoModel) SetHeaders(v map[string]*string) *CompleteFileWithStoreInfoModel {
	s.Headers = v
	return s
}

func (s *CompleteFileWithStoreInfoModel) SetBody(v *UCCompleteFileResponse) *CompleteFileWithStoreInfoModel {
	s.Body = v
	return s
}

type CopyFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CopyFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyFileModel) String() string {
	return tea.Prettify(s)
}

func (s CopyFileModel) GoString() string {
	return s.String()
}

func (s *CopyFileModel) SetHeaders(v map[string]*string) *CopyFileModel {
	s.Headers = v
	return s
}

func (s *CopyFileModel) SetBody(v *CopyFileResponse) *CopyFileModel {
	s.Body = v
	return s
}

type CreateFileModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFileModel) String() string {
	return tea.Prettify(s)
}

func (s CreateFileModel) GoString() string {
	return s.String()
}

func (s *CreateFileModel) SetHeaders(v map[string]*string) *CreateFileModel {
	s.Headers = v
	return s
}

func (s *CreateFileModel) SetBody(v *CreateFileResponse) *CreateFileModel {
	s.Body = v
	return s
}

type CreateFileWithProofModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFileWithProofModel) String() string {
	return tea.Prettify(s)
}

func (s CreateFileWithProofModel) GoString() string {
	return s.String()
}

func (s *CreateFileWithProofModel) SetHeaders(v map[string]*string) *CreateFileWithProofModel {
	s.Headers = v
	return s
}

func (s *CreateFileWithProofModel) SetBody(v *CreateFileResponse) *CreateFileWithProofModel {
	s.Body = v
	return s
}

type CreateFileWithSignatureModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UCCreateFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFileWithSignatureModel) String() string {
	return tea.Prettify(s)
}

func (s CreateFileWithSignatureModel) GoString() string {
	return s.String()
}

func (s *CreateFileWithSignatureModel) SetHeaders(v map[string]*string) *CreateFileWithSignatureModel {
	s.Headers = v
	return s
}

func (s *CreateFileWithSignatureModel) SetBody(v *UCCreateFileResponse) *CreateFileWithSignatureModel {
	s.Body = v
	return s
}

type DeleteFileModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFileModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileModel) GoString() string {
	return s.String()
}

func (s *DeleteFileModel) SetHeaders(v map[string]*string) *DeleteFileModel {
	s.Headers = v
	return s
}

func (s *DeleteFileModel) SetBody(v *DeleteFileResponse) *DeleteFileModel {
	s.Body = v
	return s
}

type DeleteUsertagsModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteUsertagsModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteUsertagsModel) GoString() string {
	return s.String()
}

func (s *DeleteUsertagsModel) SetHeaders(v map[string]*string) *DeleteUsertagsModel {
	s.Headers = v
	return s
}

type GetFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetFileResponse   `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileModel) String() string {
	return tea.Prettify(s)
}

func (s GetFileModel) GoString() string {
	return s.String()
}

func (s *GetFileModel) SetHeaders(v map[string]*string) *GetFileModel {
	s.Headers = v
	return s
}

func (s *GetFileModel) SetBody(v *GetFileResponse) *GetFileModel {
	s.Body = v
	return s
}

type GetFileByPathModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetFileByPathResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileByPathModel) String() string {
	return tea.Prettify(s)
}

func (s GetFileByPathModel) GoString() string {
	return s.String()
}

func (s *GetFileByPathModel) SetHeaders(v map[string]*string) *GetFileByPathModel {
	s.Headers = v
	return s
}

func (s *GetFileByPathModel) SetBody(v *GetFileByPathResponse) *GetFileByPathModel {
	s.Body = v
	return s
}

type GetDownloadUrlModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetDownloadUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDownloadUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadUrlModel) GoString() string {
	return s.String()
}

func (s *GetDownloadUrlModel) SetHeaders(v map[string]*string) *GetDownloadUrlModel {
	s.Headers = v
	return s
}

func (s *GetDownloadUrlModel) SetBody(v *GetDownloadUrlResponse) *GetDownloadUrlModel {
	s.Body = v
	return s
}

type GetLastCursorModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetLastCursorResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLastCursorModel) String() string {
	return tea.Prettify(s)
}

func (s GetLastCursorModel) GoString() string {
	return s.String()
}

func (s *GetLastCursorModel) SetHeaders(v map[string]*string) *GetLastCursorModel {
	s.Headers = v
	return s
}

func (s *GetLastCursorModel) SetBody(v *GetLastCursorResponse) *GetLastCursorModel {
	s.Body = v
	return s
}

type GetMediaPlayUrlModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetMediaPlayURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaPlayUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetMediaPlayUrlModel) GoString() string {
	return s.String()
}

func (s *GetMediaPlayUrlModel) SetHeaders(v map[string]*string) *GetMediaPlayUrlModel {
	s.Headers = v
	return s
}

func (s *GetMediaPlayUrlModel) SetBody(v *GetMediaPlayURLResponse) *GetMediaPlayUrlModel {
	s.Body = v
	return s
}

type GetOfficeEditUrlModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetOfficeEditUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOfficeEditUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeEditUrlModel) GoString() string {
	return s.String()
}

func (s *GetOfficeEditUrlModel) SetHeaders(v map[string]*string) *GetOfficeEditUrlModel {
	s.Headers = v
	return s
}

func (s *GetOfficeEditUrlModel) SetBody(v *GetOfficeEditUrlResponse) *GetOfficeEditUrlModel {
	s.Body = v
	return s
}

type GetOfficePreviewUrlModel struct {
	Headers map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetOfficePreviewUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOfficePreviewUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetOfficePreviewUrlModel) GoString() string {
	return s.String()
}

func (s *GetOfficePreviewUrlModel) SetHeaders(v map[string]*string) *GetOfficePreviewUrlModel {
	s.Headers = v
	return s
}

func (s *GetOfficePreviewUrlModel) SetBody(v *GetOfficePreviewUrlResponse) *GetOfficePreviewUrlModel {
	s.Body = v
	return s
}

type GetShareLinkDownloadUrlModel struct {
	Headers map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetShareLinkDownloadURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkDownloadUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkDownloadUrlModel) GoString() string {
	return s.String()
}

func (s *GetShareLinkDownloadUrlModel) SetHeaders(v map[string]*string) *GetShareLinkDownloadUrlModel {
	s.Headers = v
	return s
}

func (s *GetShareLinkDownloadUrlModel) SetBody(v *GetShareLinkDownloadURLResponse) *GetShareLinkDownloadUrlModel {
	s.Body = v
	return s
}

type GetShareLinkVideoPreviewPlayInfoModel struct {
	Headers map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CCPGetShareLinkVideoPreviewPlayInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkVideoPreviewPlayInfoModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkVideoPreviewPlayInfoModel) GoString() string {
	return s.String()
}

func (s *GetShareLinkVideoPreviewPlayInfoModel) SetHeaders(v map[string]*string) *GetShareLinkVideoPreviewPlayInfoModel {
	s.Headers = v
	return s
}

func (s *GetShareLinkVideoPreviewPlayInfoModel) SetBody(v *CCPGetShareLinkVideoPreviewPlayInfoResponse) *GetShareLinkVideoPreviewPlayInfoModel {
	s.Body = v
	return s
}

type GetFileSignatureModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UCGetSignatureResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileSignatureModel) String() string {
	return tea.Prettify(s)
}

func (s GetFileSignatureModel) GoString() string {
	return s.String()
}

func (s *GetFileSignatureModel) SetHeaders(v map[string]*string) *GetFileSignatureModel {
	s.Headers = v
	return s
}

func (s *GetFileSignatureModel) SetBody(v *UCGetSignatureResponse) *GetFileSignatureModel {
	s.Body = v
	return s
}

type GetUploadUrlModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetUploadUrlResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUploadUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetUploadUrlModel) GoString() string {
	return s.String()
}

func (s *GetUploadUrlModel) SetHeaders(v map[string]*string) *GetUploadUrlModel {
	s.Headers = v
	return s
}

func (s *GetUploadUrlModel) SetBody(v *GetUploadUrlResponse) *GetUploadUrlModel {
	s.Body = v
	return s
}

type GetVideoPreviewPlayInfoModel struct {
	Headers map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CCPGetVideoPreviewPlayInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewPlayInfoModel) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewPlayInfoModel) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewPlayInfoModel) SetHeaders(v map[string]*string) *GetVideoPreviewPlayInfoModel {
	s.Headers = v
	return s
}

func (s *GetVideoPreviewPlayInfoModel) SetBody(v *CCPGetVideoPreviewPlayInfoResponse) *GetVideoPreviewPlayInfoModel {
	s.Body = v
	return s
}

type GetVideoPreviewSpriteUrlModel struct {
	Headers map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetVideoPreviewSpriteURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewSpriteUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteUrlModel) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewSpriteUrlModel) SetHeaders(v map[string]*string) *GetVideoPreviewSpriteUrlModel {
	s.Headers = v
	return s
}

func (s *GetVideoPreviewSpriteUrlModel) SetBody(v *GetVideoPreviewSpriteURLResponse) *GetVideoPreviewSpriteUrlModel {
	s.Body = v
	return s
}

type GetVideoPreviewUrlModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetVideoPreviewURLResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPreviewUrlModel) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewUrlModel) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewUrlModel) SetHeaders(v map[string]*string) *GetVideoPreviewUrlModel {
	s.Headers = v
	return s
}

func (s *GetVideoPreviewUrlModel) SetBody(v *GetVideoPreviewURLResponse) *GetVideoPreviewUrlModel {
	s.Body = v
	return s
}

type ListFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileModel) GoString() string {
	return s.String()
}

func (s *ListFileModel) SetHeaders(v map[string]*string) *ListFileModel {
	s.Headers = v
	return s
}

func (s *ListFileModel) SetBody(v *ListFileResponse) *ListFileModel {
	s.Body = v
	return s
}

type ListFileActivityModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileActivityResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileActivityModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileActivityModel) GoString() string {
	return s.String()
}

func (s *ListFileActivityModel) SetHeaders(v map[string]*string) *ListFileActivityModel {
	s.Headers = v
	return s
}

func (s *ListFileActivityModel) SetBody(v *ListFileActivityResponse) *ListFileActivityModel {
	s.Body = v
	return s
}

type ListFileByAnonymousModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListByAnonymousResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileByAnonymousModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileByAnonymousModel) GoString() string {
	return s.String()
}

func (s *ListFileByAnonymousModel) SetHeaders(v map[string]*string) *ListFileByAnonymousModel {
	s.Headers = v
	return s
}

func (s *ListFileByAnonymousModel) SetBody(v *ListByAnonymousResponse) *ListFileByAnonymousModel {
	s.Body = v
	return s
}

type ListFileByCustomIndexKeyModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileByCustomIndexKeyModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileByCustomIndexKeyModel) GoString() string {
	return s.String()
}

func (s *ListFileByCustomIndexKeyModel) SetHeaders(v map[string]*string) *ListFileByCustomIndexKeyModel {
	s.Headers = v
	return s
}

func (s *ListFileByCustomIndexKeyModel) SetBody(v *ListFileResponse) *ListFileByCustomIndexKeyModel {
	s.Body = v
	return s
}

type ListFileDeltaModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileDeltaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileDeltaModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileDeltaModel) GoString() string {
	return s.String()
}

func (s *ListFileDeltaModel) SetHeaders(v map[string]*string) *ListFileDeltaModel {
	s.Headers = v
	return s
}

func (s *ListFileDeltaModel) SetBody(v *ListFileDeltaResponse) *ListFileDeltaModel {
	s.Body = v
	return s
}

type ListInheritPermissionModel struct {
	Headers map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *FileListInheritPermissionResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInheritPermissionModel) String() string {
	return tea.Prettify(s)
}

func (s ListInheritPermissionModel) GoString() string {
	return s.String()
}

func (s *ListInheritPermissionModel) SetHeaders(v map[string]*string) *ListInheritPermissionModel {
	s.Headers = v
	return s
}

func (s *ListInheritPermissionModel) SetBody(v *FileListInheritPermissionResponse) *ListInheritPermissionModel {
	s.Body = v
	return s
}

type ListManageSharingFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListManageSharingFileModel) String() string {
	return tea.Prettify(s)
}

func (s ListManageSharingFileModel) GoString() string {
	return s.String()
}

func (s *ListManageSharingFileModel) SetHeaders(v map[string]*string) *ListManageSharingFileModel {
	s.Headers = v
	return s
}

func (s *ListManageSharingFileModel) SetBody(v *ListFileResponse) *ListManageSharingFileModel {
	s.Body = v
	return s
}

type ListPermissionModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    []*FilePermissionMember `json:"body,omitempty" xml:"body,omitempty" require:"true" type:"Repeated"`
}

func (s ListPermissionModel) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionModel) GoString() string {
	return s.String()
}

func (s *ListPermissionModel) SetHeaders(v map[string]*string) *ListPermissionModel {
	s.Headers = v
	return s
}

func (s *ListPermissionModel) SetBody(v []*FilePermissionMember) *ListPermissionModel {
	s.Body = v
	return s
}

type ListReceivedFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListReceivedFileModel) String() string {
	return tea.Prettify(s)
}

func (s ListReceivedFileModel) GoString() string {
	return s.String()
}

func (s *ListReceivedFileModel) SetHeaders(v map[string]*string) *ListReceivedFileModel {
	s.Headers = v
	return s
}

func (s *ListReceivedFileModel) SetBody(v *ListFileResponse) *ListReceivedFileModel {
	s.Body = v
	return s
}

type ListSharingFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSharingFileModel) String() string {
	return tea.Prettify(s)
}

func (s ListSharingFileModel) GoString() string {
	return s.String()
}

func (s *ListSharingFileModel) SetHeaders(v map[string]*string) *ListSharingFileModel {
	s.Headers = v
	return s
}

func (s *ListSharingFileModel) SetBody(v *ListFileResponse) *ListSharingFileModel {
	s.Body = v
	return s
}

type ListUploadedPartsModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListUploadedPartResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUploadedPartsModel) String() string {
	return tea.Prettify(s)
}

func (s ListUploadedPartsModel) GoString() string {
	return s.String()
}

func (s *ListUploadedPartsModel) SetHeaders(v map[string]*string) *ListUploadedPartsModel {
	s.Headers = v
	return s
}

func (s *ListUploadedPartsModel) SetBody(v *ListUploadedPartResponse) *ListUploadedPartsModel {
	s.Body = v
	return s
}

type ListUserPermissionModel struct {
	Headers map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *FileListUserPermissionResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserPermissionModel) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionModel) GoString() string {
	return s.String()
}

func (s *ListUserPermissionModel) SetHeaders(v map[string]*string) *ListUserPermissionModel {
	s.Headers = v
	return s
}

func (s *ListUserPermissionModel) SetBody(v *FileListUserPermissionResponse) *ListUserPermissionModel {
	s.Body = v
	return s
}

type LiveTranscodeModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CCPLiveTranscodeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LiveTranscodeModel) String() string {
	return tea.Prettify(s)
}

func (s LiveTranscodeModel) GoString() string {
	return s.String()
}

func (s *LiveTranscodeModel) SetHeaders(v map[string]*string) *LiveTranscodeModel {
	s.Headers = v
	return s
}

func (s *LiveTranscodeModel) SetBody(v *CCPLiveTranscodeResponse) *LiveTranscodeModel {
	s.Body = v
	return s
}

type MoveFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *MoveFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveFileModel) String() string {
	return tea.Prettify(s)
}

func (s MoveFileModel) GoString() string {
	return s.String()
}

func (s *MoveFileModel) SetHeaders(v map[string]*string) *MoveFileModel {
	s.Headers = v
	return s
}

func (s *MoveFileModel) SetBody(v *MoveFileResponse) *MoveFileModel {
	s.Body = v
	return s
}

type PutUsertagsModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *PutFileUserTagsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutUsertagsModel) String() string {
	return tea.Prettify(s)
}

func (s PutUsertagsModel) GoString() string {
	return s.String()
}

func (s *PutUsertagsModel) SetHeaders(v map[string]*string) *PutUsertagsModel {
	s.Headers = v
	return s
}

func (s *PutUsertagsModel) SetBody(v *PutFileUserTagsResponse) *PutUsertagsModel {
	s.Body = v
	return s
}

type TokenModel struct {
	Headers map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *RefreshOfficeEditTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TokenModel) String() string {
	return tea.Prettify(s)
}

func (s TokenModel) GoString() string {
	return s.String()
}

func (s *TokenModel) SetHeaders(v map[string]*string) *TokenModel {
	s.Headers = v
	return s
}

func (s *TokenModel) SetBody(v *RefreshOfficeEditTokenResponse) *TokenModel {
	s.Body = v
	return s
}

type RemovePermissionModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s RemovePermissionModel) String() string {
	return tea.Prettify(s)
}

func (s RemovePermissionModel) GoString() string {
	return s.String()
}

func (s *RemovePermissionModel) SetHeaders(v map[string]*string) *RemovePermissionModel {
	s.Headers = v
	return s
}

type ScanFileMetaModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ScanFileMetaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ScanFileMetaModel) String() string {
	return tea.Prettify(s)
}

func (s ScanFileMetaModel) GoString() string {
	return s.String()
}

func (s *ScanFileMetaModel) SetHeaders(v map[string]*string) *ScanFileMetaModel {
	s.Headers = v
	return s
}

func (s *ScanFileMetaModel) SetBody(v *ScanFileMetaResponse) *ScanFileMetaModel {
	s.Body = v
	return s
}

type SearchFileModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchFileModel) String() string {
	return tea.Prettify(s)
}

func (s SearchFileModel) GoString() string {
	return s.String()
}

func (s *SearchFileModel) SetHeaders(v map[string]*string) *SearchFileModel {
	s.Headers = v
	return s
}

func (s *SearchFileModel) SetBody(v *SearchFileResponse) *SearchFileModel {
	s.Body = v
	return s
}

type SearchFileFpRefsModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchFileFpRefsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchFileFpRefsModel) String() string {
	return tea.Prettify(s)
}

func (s SearchFileFpRefsModel) GoString() string {
	return s.String()
}

func (s *SearchFileFpRefsModel) SetHeaders(v map[string]*string) *SearchFileFpRefsModel {
	s.Headers = v
	return s
}

func (s *SearchFileFpRefsModel) SetBody(v *SearchFileFpRefsResponse) *SearchFileFpRefsModel {
	s.Body = v
	return s
}

type UpdateFileModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateFileMetaResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFileModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileModel) GoString() string {
	return s.String()
}

func (s *UpdateFileModel) SetHeaders(v map[string]*string) *UpdateFileModel {
	s.Headers = v
	return s
}

func (s *UpdateFileModel) SetBody(v *UpdateFileMetaResponse) *UpdateFileModel {
	s.Body = v
	return s
}

type UpdateFileUploadContentHashModel struct {
	Headers map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UCUpdateUploadContentHashResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFileUploadContentHashModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileUploadContentHashModel) GoString() string {
	return s.String()
}

func (s *UpdateFileUploadContentHashModel) SetHeaders(v map[string]*string) *UpdateFileUploadContentHashModel {
	s.Headers = v
	return s
}

func (s *UpdateFileUploadContentHashModel) SetBody(v *UCUpdateUploadContentHashResponse) *UpdateFileUploadContentHashModel {
	s.Body = v
	return s
}

type WalkFileModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CCPWalkFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s WalkFileModel) String() string {
	return tea.Prettify(s)
}

func (s WalkFileModel) GoString() string {
	return s.String()
}

func (s *WalkFileModel) SetHeaders(v map[string]*string) *WalkFileModel {
	s.Headers = v
	return s
}

func (s *WalkFileModel) SetBody(v *CCPWalkFileResponse) *WalkFileModel {
	s.Body = v
	return s
}

type ClearRecyclebinModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ClearRecycleBinResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClearRecyclebinModel) String() string {
	return tea.Prettify(s)
}

func (s ClearRecyclebinModel) GoString() string {
	return s.String()
}

func (s *ClearRecyclebinModel) SetHeaders(v map[string]*string) *ClearRecyclebinModel {
	s.Headers = v
	return s
}

func (s *ClearRecyclebinModel) SetBody(v *ClearRecycleBinResponse) *ClearRecyclebinModel {
	s.Body = v
	return s
}

type ListRecyclebinModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRecyclebinModel) String() string {
	return tea.Prettify(s)
}

func (s ListRecyclebinModel) GoString() string {
	return s.String()
}

func (s *ListRecyclebinModel) SetHeaders(v map[string]*string) *ListRecyclebinModel {
	s.Headers = v
	return s
}

func (s *ListRecyclebinModel) SetBody(v *ListFileResponse) *ListRecyclebinModel {
	s.Body = v
	return s
}

type RestoreFileModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *RestoreFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestoreFileModel) String() string {
	return tea.Prettify(s)
}

func (s RestoreFileModel) GoString() string {
	return s.String()
}

func (s *RestoreFileModel) SetHeaders(v map[string]*string) *RestoreFileModel {
	s.Headers = v
	return s
}

func (s *RestoreFileModel) SetBody(v *RestoreFileResponse) *RestoreFileModel {
	s.Body = v
	return s
}

type TrashFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *TrashFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TrashFileModel) String() string {
	return tea.Prettify(s)
}

func (s TrashFileModel) GoString() string {
	return s.String()
}

func (s *TrashFileModel) SetHeaders(v map[string]*string) *TrashFileModel {
	s.Headers = v
	return s
}

func (s *TrashFileModel) SetBody(v *TrashFileResponse) *TrashFileModel {
	s.Body = v
	return s
}

type ReportEventModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ReportEventResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReportEventModel) String() string {
	return tea.Prettify(s)
}

func (s ReportEventModel) GoString() string {
	return s.String()
}

func (s *ReportEventModel) SetHeaders(v map[string]*string) *ReportEventModel {
	s.Headers = v
	return s
}

func (s *ReportEventModel) SetBody(v *ReportEventResponse) *ReportEventModel {
	s.Body = v
	return s
}

type CreateShareModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateShareModel) String() string {
	return tea.Prettify(s)
}

func (s CreateShareModel) GoString() string {
	return s.String()
}

func (s *CreateShareModel) SetHeaders(v map[string]*string) *CreateShareModel {
	s.Headers = v
	return s
}

func (s *CreateShareModel) SetBody(v *CreateShareResponse) *CreateShareModel {
	s.Body = v
	return s
}

type DeleteShareModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteShareModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareModel) GoString() string {
	return s.String()
}

func (s *DeleteShareModel) SetHeaders(v map[string]*string) *DeleteShareModel {
	s.Headers = v
	return s
}

type GetShareModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetShareResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareModel) GoString() string {
	return s.String()
}

func (s *GetShareModel) SetHeaders(v map[string]*string) *GetShareModel {
	s.Headers = v
	return s
}

func (s *GetShareModel) SetBody(v *GetShareResponse) *GetShareModel {
	s.Body = v
	return s
}

type ListShareModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListShareModel) String() string {
	return tea.Prettify(s)
}

func (s ListShareModel) GoString() string {
	return s.String()
}

func (s *ListShareModel) SetHeaders(v map[string]*string) *ListShareModel {
	s.Headers = v
	return s
}

func (s *ListShareModel) SetBody(v *ListShareResponse) *ListShareModel {
	s.Body = v
	return s
}

type UpdateShareModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateShareResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateShareModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareModel) GoString() string {
	return s.String()
}

func (s *UpdateShareModel) SetHeaders(v map[string]*string) *UpdateShareModel {
	s.Headers = v
	return s
}

func (s *UpdateShareModel) SetBody(v *UpdateShareResponse) *UpdateShareModel {
	s.Body = v
	return s
}

type CancelShareLinkModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s CancelShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s CancelShareLinkModel) GoString() string {
	return s.String()
}

func (s *CancelShareLinkModel) SetHeaders(v map[string]*string) *CancelShareLinkModel {
	s.Headers = v
	return s
}

type CreateShareLinkModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s CreateShareLinkModel) GoString() string {
	return s.String()
}

func (s *CreateShareLinkModel) SetHeaders(v map[string]*string) *CreateShareLinkModel {
	s.Headers = v
	return s
}

func (s *CreateShareLinkModel) SetBody(v *CreateShareLinkResponse) *CreateShareLinkModel {
	s.Body = v
	return s
}

type GetShareLinkModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BaseShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkModel) GoString() string {
	return s.String()
}

func (s *GetShareLinkModel) SetHeaders(v map[string]*string) *GetShareLinkModel {
	s.Headers = v
	return s
}

func (s *GetShareLinkModel) SetBody(v *BaseShareLinkResponse) *GetShareLinkModel {
	s.Body = v
	return s
}

type GetShareByAnonymousModel struct {
	Headers map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetShareLinkByAnonymousResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareByAnonymousModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareByAnonymousModel) GoString() string {
	return s.String()
}

func (s *GetShareByAnonymousModel) SetHeaders(v map[string]*string) *GetShareByAnonymousModel {
	s.Headers = v
	return s
}

func (s *GetShareByAnonymousModel) SetBody(v *GetShareLinkByAnonymousResponse) *GetShareByAnonymousModel {
	s.Body = v
	return s
}

type GetShareIdModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetShareLinkIDResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareIdModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareIdModel) GoString() string {
	return s.String()
}

func (s *GetShareIdModel) SetHeaders(v map[string]*string) *GetShareIdModel {
	s.Headers = v
	return s
}

func (s *GetShareIdModel) SetBody(v *GetShareLinkIDResponse) *GetShareIdModel {
	s.Body = v
	return s
}

type GetShareTokenModel struct {
	Headers map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetShareLinkTokenResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareTokenModel) String() string {
	return tea.Prettify(s)
}

func (s GetShareTokenModel) GoString() string {
	return s.String()
}

func (s *GetShareTokenModel) SetHeaders(v map[string]*string) *GetShareTokenModel {
	s.Headers = v
	return s
}

func (s *GetShareTokenModel) SetBody(v *GetShareLinkTokenResponse) *GetShareTokenModel {
	s.Body = v
	return s
}

type ListShareLinkModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s ListShareLinkModel) GoString() string {
	return s.String()
}

func (s *ListShareLinkModel) SetHeaders(v map[string]*string) *ListShareLinkModel {
	s.Headers = v
	return s
}

func (s *ListShareLinkModel) SetBody(v *ListShareLinkResponse) *ListShareLinkModel {
	s.Body = v
	return s
}

type SearchShareLinkModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s SearchShareLinkModel) GoString() string {
	return s.String()
}

func (s *SearchShareLinkModel) SetHeaders(v map[string]*string) *SearchShareLinkModel {
	s.Headers = v
	return s
}

func (s *SearchShareLinkModel) SetBody(v *SearchShareLinkResponse) *SearchShareLinkModel {
	s.Body = v
	return s
}

type UpdateShareLinkModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateShareLinkResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareLinkModel) GoString() string {
	return s.String()
}

func (s *UpdateShareLinkModel) SetHeaders(v map[string]*string) *UpdateShareLinkModel {
	s.Headers = v
	return s
}

func (s *UpdateShareLinkModel) SetBody(v *UpdateShareLinkResponse) *UpdateShareLinkModel {
	s.Body = v
	return s
}

type AssignModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AssignModel) String() string {
	return tea.Prettify(s)
}

func (s AssignModel) GoString() string {
	return s.String()
}

func (s *AssignModel) SetHeaders(v map[string]*string) *AssignModel {
	s.Headers = v
	return s
}

type CancelAssignModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s CancelAssignModel) String() string {
	return tea.Prettify(s)
}

func (s CancelAssignModel) GoString() string {
	return s.String()
}

func (s *CancelAssignModel) SetHeaders(v map[string]*string) *CancelAssignModel {
	s.Headers = v
	return s
}

type ListIdentityRoleModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BaseRoleMemberResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIdentityRoleModel) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityRoleModel) GoString() string {
	return s.String()
}

func (s *ListIdentityRoleModel) SetHeaders(v map[string]*string) *ListIdentityRoleModel {
	s.Headers = v
	return s
}

func (s *ListIdentityRoleModel) SetBody(v *BaseRoleMemberResponse) *ListIdentityRoleModel {
	s.Body = v
	return s
}

type GetDriveUsedSizeModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetDriveUsedSizeResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDriveUsedSizeModel) String() string {
	return tea.Prettify(s)
}

func (s GetDriveUsedSizeModel) GoString() string {
	return s.String()
}

func (s *GetDriveUsedSizeModel) SetHeaders(v map[string]*string) *GetDriveUsedSizeModel {
	s.Headers = v
	return s
}

func (s *GetDriveUsedSizeModel) SetBody(v *GetDriveUsedSizeResponse) *GetDriveUsedSizeModel {
	s.Body = v
	return s
}

type GetFileCountModel struct {
	Headers map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetFileCountResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetFileCountModel) String() string {
	return tea.Prettify(s)
}

func (s GetFileCountModel) GoString() string {
	return s.String()
}

func (s *GetFileCountModel) SetHeaders(v map[string]*string) *GetFileCountModel {
	s.Headers = v
	return s
}

func (s *GetFileCountModel) SetBody(v *GetFileCountResponse) *GetFileCountModel {
	s.Body = v
	return s
}

type GetSubdomainSummaryModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SubdomainSummaryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSubdomainSummaryModel) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainSummaryModel) GoString() string {
	return s.String()
}

func (s *GetSubdomainSummaryModel) SetHeaders(v map[string]*string) *GetSubdomainSummaryModel {
	s.Headers = v
	return s
}

func (s *GetSubdomainSummaryModel) SetBody(v *SubdomainSummaryResponse) *GetSubdomainSummaryModel {
	s.Body = v
	return s
}

type GetDomainSummaryModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DomainSummaryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDomainSummaryModel) String() string {
	return tea.Prettify(s)
}

func (s GetDomainSummaryModel) GoString() string {
	return s.String()
}

func (s *GetDomainSummaryModel) SetHeaders(v map[string]*string) *GetDomainSummaryModel {
	s.Headers = v
	return s
}

func (s *GetDomainSummaryModel) SetBody(v *DomainSummaryResponse) *GetDomainSummaryModel {
	s.Body = v
	return s
}

type GetAppDebugCmdModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetAppDebugCmdResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppDebugCmdModel) String() string {
	return tea.Prettify(s)
}

func (s GetAppDebugCmdModel) GoString() string {
	return s.String()
}

func (s *GetAppDebugCmdModel) SetHeaders(v map[string]*string) *GetAppDebugCmdModel {
	s.Headers = v
	return s
}

func (s *GetAppDebugCmdModel) SetBody(v *GetAppDebugCmdResponse) *GetAppDebugCmdModel {
	s.Body = v
	return s
}

type UpgradeCheckAppModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpgradeCheckAppResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeCheckAppModel) String() string {
	return tea.Prettify(s)
}

func (s UpgradeCheckAppModel) GoString() string {
	return s.String()
}

func (s *UpgradeCheckAppModel) SetHeaders(v map[string]*string) *UpgradeCheckAppModel {
	s.Headers = v
	return s
}

func (s *UpgradeCheckAppModel) SetBody(v *UpgradeCheckAppResponse) *UpgradeCheckAppModel {
	s.Body = v
	return s
}

type BindDeviceModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BindDeviceResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindDeviceModel) String() string {
	return tea.Prettify(s)
}

func (s BindDeviceModel) GoString() string {
	return s.String()
}

func (s *BindDeviceModel) SetHeaders(v map[string]*string) *BindDeviceModel {
	s.Headers = v
	return s
}

func (s *BindDeviceModel) SetBody(v *BindDeviceResponse) *BindDeviceModel {
	s.Body = v
	return s
}

type ListDeviceModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDeviceResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDeviceModel) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceModel) GoString() string {
	return s.String()
}

func (s *ListDeviceModel) SetHeaders(v map[string]*string) *ListDeviceModel {
	s.Headers = v
	return s
}

func (s *ListDeviceModel) SetBody(v *ListDeviceResponse) *ListDeviceModel {
	s.Body = v
	return s
}

type CreateGroupModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGroupModel) String() string {
	return tea.Prettify(s)
}

func (s CreateGroupModel) GoString() string {
	return s.String()
}

func (s *CreateGroupModel) SetHeaders(v map[string]*string) *CreateGroupModel {
	s.Headers = v
	return s
}

func (s *CreateGroupModel) SetBody(v *CreateGroupResponse) *CreateGroupModel {
	s.Body = v
	return s
}

type DeleteGroupModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGroupModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteGroupModel) GoString() string {
	return s.String()
}

func (s *DeleteGroupModel) SetHeaders(v map[string]*string) *DeleteGroupModel {
	s.Headers = v
	return s
}

func (s *DeleteGroupModel) SetBody(v *DeleteGroupResponse) *DeleteGroupModel {
	s.Body = v
	return s
}

type GetGroupModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetGroupResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGroupModel) String() string {
	return tea.Prettify(s)
}

func (s GetGroupModel) GoString() string {
	return s.String()
}

func (s *GetGroupModel) SetHeaders(v map[string]*string) *GetGroupModel {
	s.Headers = v
	return s
}

func (s *GetGroupModel) SetBody(v *GetGroupResponse) *GetGroupModel {
	s.Body = v
	return s
}

type ListGroupModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGroupModel) String() string {
	return tea.Prettify(s)
}

func (s ListGroupModel) GoString() string {
	return s.String()
}

func (s *ListGroupModel) SetHeaders(v map[string]*string) *ListGroupModel {
	s.Headers = v
	return s
}

func (s *ListGroupModel) SetBody(v *ListGroupResponse) *ListGroupModel {
	s.Body = v
	return s
}

type SearchGroupModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchGroupModel) String() string {
	return tea.Prettify(s)
}

func (s SearchGroupModel) GoString() string {
	return s.String()
}

func (s *SearchGroupModel) SetHeaders(v map[string]*string) *SearchGroupModel {
	s.Headers = v
	return s
}

func (s *SearchGroupModel) SetBody(v *SearchGroupResponse) *SearchGroupModel {
	s.Body = v
	return s
}

type UpdateGroupModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGroupModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateGroupModel) GoString() string {
	return s.String()
}

func (s *UpdateGroupModel) SetHeaders(v map[string]*string) *UpdateGroupModel {
	s.Headers = v
	return s
}

func (s *UpdateGroupModel) SetBody(v *UpdateGroupResponse) *UpdateGroupModel {
	s.Body = v
	return s
}

type CreateMembershipModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMembershipModel) String() string {
	return tea.Prettify(s)
}

func (s CreateMembershipModel) GoString() string {
	return s.String()
}

func (s *CreateMembershipModel) SetHeaders(v map[string]*string) *CreateMembershipModel {
	s.Headers = v
	return s
}

func (s *CreateMembershipModel) SetBody(v *CreateMembershipResponse) *CreateMembershipModel {
	s.Body = v
	return s
}

type DeleteMembershipModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMembershipModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteMembershipModel) GoString() string {
	return s.String()
}

func (s *DeleteMembershipModel) SetHeaders(v map[string]*string) *DeleteMembershipModel {
	s.Headers = v
	return s
}

func (s *DeleteMembershipModel) SetBody(v *DeleteMembershipResponse) *DeleteMembershipModel {
	s.Body = v
	return s
}

type GetMembershipModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMembershipModel) String() string {
	return tea.Prettify(s)
}

func (s GetMembershipModel) GoString() string {
	return s.String()
}

func (s *GetMembershipModel) SetHeaders(v map[string]*string) *GetMembershipModel {
	s.Headers = v
	return s
}

func (s *GetMembershipModel) SetBody(v *GetMembershipResponse) *GetMembershipModel {
	s.Body = v
	return s
}

type HasMemberModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *HasMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s HasMemberModel) String() string {
	return tea.Prettify(s)
}

func (s HasMemberModel) GoString() string {
	return s.String()
}

func (s *HasMemberModel) SetHeaders(v map[string]*string) *HasMemberModel {
	s.Headers = v
	return s
}

func (s *HasMemberModel) SetBody(v *HasMembershipResponse) *HasMemberModel {
	s.Body = v
	return s
}

type ListDirectChildMembershipsModel struct {
	Headers map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDirectChildMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectChildMembershipsModel) String() string {
	return tea.Prettify(s)
}

func (s ListDirectChildMembershipsModel) GoString() string {
	return s.String()
}

func (s *ListDirectChildMembershipsModel) SetHeaders(v map[string]*string) *ListDirectChildMembershipsModel {
	s.Headers = v
	return s
}

func (s *ListDirectChildMembershipsModel) SetBody(v *ListDirectChildMembershipsResponse) *ListDirectChildMembershipsModel {
	s.Body = v
	return s
}

type ListDirectMembershipsModel struct {
	Headers map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDirectParentMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectMembershipsModel) String() string {
	return tea.Prettify(s)
}

func (s ListDirectMembershipsModel) GoString() string {
	return s.String()
}

func (s *ListDirectMembershipsModel) SetHeaders(v map[string]*string) *ListDirectMembershipsModel {
	s.Headers = v
	return s
}

func (s *ListDirectMembershipsModel) SetBody(v *ListDirectParentMembershipsResponse) *ListDirectMembershipsModel {
	s.Body = v
	return s
}

type ListDirectParentMembershipsModel struct {
	Headers map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListDirectParentMembershipsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectParentMembershipsModel) String() string {
	return tea.Prettify(s)
}

func (s ListDirectParentMembershipsModel) GoString() string {
	return s.String()
}

func (s *ListDirectParentMembershipsModel) SetHeaders(v map[string]*string) *ListDirectParentMembershipsModel {
	s.Headers = v
	return s
}

func (s *ListDirectParentMembershipsModel) SetBody(v *ListDirectParentMembershipsResponse) *ListDirectParentMembershipsModel {
	s.Body = v
	return s
}

type UpdateMembershipModel struct {
	Headers map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateMembershipResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMembershipModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateMembershipModel) GoString() string {
	return s.String()
}

func (s *UpdateMembershipModel) SetHeaders(v map[string]*string) *UpdateMembershipModel {
	s.Headers = v
	return s
}

func (s *UpdateMembershipModel) SetBody(v *UpdateMembershipResponse) *UpdateMembershipModel {
	s.Body = v
	return s
}

type CreateSyncMappingModel struct {
	Headers map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateSyncMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSyncMappingModel) String() string {
	return tea.Prettify(s)
}

func (s CreateSyncMappingModel) GoString() string {
	return s.String()
}

func (s *CreateSyncMappingModel) SetHeaders(v map[string]*string) *CreateSyncMappingModel {
	s.Headers = v
	return s
}

func (s *CreateSyncMappingModel) SetBody(v *CreateSyncMappingResponse) *CreateSyncMappingModel {
	s.Body = v
	return s
}

type DeleteSyncMappingModel struct {
	Headers map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteSyncMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSyncMappingModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyncMappingModel) GoString() string {
	return s.String()
}

func (s *DeleteSyncMappingModel) SetHeaders(v map[string]*string) *DeleteSyncMappingModel {
	s.Headers = v
	return s
}

func (s *DeleteSyncMappingModel) SetBody(v *DeleteSyncMappingResponse) *DeleteSyncMappingModel {
	s.Body = v
	return s
}

type ListSyncMappingModel struct {
	Headers map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListSyncMappingResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSyncMappingModel) String() string {
	return tea.Prettify(s)
}

func (s ListSyncMappingModel) GoString() string {
	return s.String()
}

func (s *ListSyncMappingModel) SetHeaders(v map[string]*string) *ListSyncMappingModel {
	s.Headers = v
	return s
}

func (s *ListSyncMappingModel) SetBody(v *ListSyncMappingResponse) *ListSyncMappingModel {
	s.Body = v
	return s
}

type AddUserToSubdomainModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s AddUserToSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s AddUserToSubdomainModel) GoString() string {
	return s.String()
}

func (s *AddUserToSubdomainModel) SetHeaders(v map[string]*string) *AddUserToSubdomainModel {
	s.Headers = v
	return s
}

type CreateUserModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUserModel) String() string {
	return tea.Prettify(s)
}

func (s CreateUserModel) GoString() string {
	return s.String()
}

func (s *CreateUserModel) SetHeaders(v map[string]*string) *CreateUserModel {
	s.Headers = v
	return s
}

func (s *CreateUserModel) SetBody(v *CreateUserResponse) *CreateUserModel {
	s.Body = v
	return s
}

type DeleteUserModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteUserModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserModel) GoString() string {
	return s.String()
}

func (s *DeleteUserModel) SetHeaders(v map[string]*string) *DeleteUserModel {
	s.Headers = v
	return s
}

type GetUserModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetUserResponse   `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserModel) String() string {
	return tea.Prettify(s)
}

func (s GetUserModel) GoString() string {
	return s.String()
}

func (s *GetUserModel) SetHeaders(v map[string]*string) *GetUserModel {
	s.Headers = v
	return s
}

func (s *GetUserModel) SetBody(v *GetUserResponse) *GetUserModel {
	s.Body = v
	return s
}

type ImportUserModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *BaseUserResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportUserModel) String() string {
	return tea.Prettify(s)
}

func (s ImportUserModel) GoString() string {
	return s.String()
}

func (s *ImportUserModel) SetHeaders(v map[string]*string) *ImportUserModel {
	s.Headers = v
	return s
}

func (s *ImportUserModel) SetBody(v *BaseUserResponse) *ImportUserModel {
	s.Body = v
	return s
}

type ListUsersModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListUserResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUsersModel) String() string {
	return tea.Prettify(s)
}

func (s ListUsersModel) GoString() string {
	return s.String()
}

func (s *ListUsersModel) SetHeaders(v map[string]*string) *ListUsersModel {
	s.Headers = v
	return s
}

func (s *ListUsersModel) SetBody(v *ListUserResponse) *ListUsersModel {
	s.Body = v
	return s
}

type MigrateUserToSubdomainModel struct {
	Headers map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *MigrateUserToSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateUserToSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s MigrateUserToSubdomainModel) GoString() string {
	return s.String()
}

func (s *MigrateUserToSubdomainModel) SetHeaders(v map[string]*string) *MigrateUserToSubdomainModel {
	s.Headers = v
	return s
}

func (s *MigrateUserToSubdomainModel) SetBody(v *MigrateUserToSubdomainResponse) *MigrateUserToSubdomainModel {
	s.Body = v
	return s
}

type RemoveUserFromSubdomainModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s RemoveUserFromSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromSubdomainModel) GoString() string {
	return s.String()
}

func (s *RemoveUserFromSubdomainModel) SetHeaders(v map[string]*string) *RemoveUserFromSubdomainModel {
	s.Headers = v
	return s
}

type RollbackUserFromSubdomainModel struct {
	Headers map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *RollbackUserFromSubdomainResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RollbackUserFromSubdomainModel) String() string {
	return tea.Prettify(s)
}

func (s RollbackUserFromSubdomainModel) GoString() string {
	return s.String()
}

func (s *RollbackUserFromSubdomainModel) SetHeaders(v map[string]*string) *RollbackUserFromSubdomainModel {
	s.Headers = v
	return s
}

func (s *RollbackUserFromSubdomainModel) SetBody(v *RollbackUserFromSubdomainResponse) *RollbackUserFromSubdomainModel {
	s.Body = v
	return s
}

type SearchUserModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListUserResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchUserModel) String() string {
	return tea.Prettify(s)
}

func (s SearchUserModel) GoString() string {
	return s.String()
}

func (s *SearchUserModel) SetHeaders(v map[string]*string) *SearchUserModel {
	s.Headers = v
	return s
}

func (s *SearchUserModel) SetBody(v *ListUserResponse) *SearchUserModel {
	s.Body = v
	return s
}

type UpdateUserModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateUserResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateUserModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserModel) GoString() string {
	return s.String()
}

func (s *UpdateUserModel) SetHeaders(v map[string]*string) *UpdateUserModel {
	s.Headers = v
	return s
}

func (s *UpdateUserModel) SetBody(v *UpdateUserResponse) *UpdateUserModel {
	s.Body = v
	return s
}

type SearchUserGroupModel struct {
	Headers map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchUserAndGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchUserGroupModel) String() string {
	return tea.Prettify(s)
}

func (s SearchUserGroupModel) GoString() string {
	return s.String()
}

func (s *SearchUserGroupModel) SetHeaders(v map[string]*string) *SearchUserGroupModel {
	s.Headers = v
	return s
}

func (s *SearchUserGroupModel) SetBody(v *SearchUserAndGroupResponse) *SearchUserGroupModel {
	s.Body = v
	return s
}

type MergeModel struct {
	Headers map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *MergeFaceGroupResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MergeModel) String() string {
	return tea.Prettify(s)
}

func (s MergeModel) GoString() string {
	return s.String()
}

func (s *MergeModel) SetHeaders(v map[string]*string) *MergeModel {
	s.Headers = v
	return s
}

func (s *MergeModel) SetBody(v *MergeFaceGroupResponse) *MergeModel {
	s.Body = v
	return s
}

type UnassignFacegroupItemModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s UnassignFacegroupItemModel) String() string {
	return tea.Prettify(s)
}

func (s UnassignFacegroupItemModel) GoString() string {
	return s.String()
}

func (s *UnassignFacegroupItemModel) SetHeaders(v map[string]*string) *UnassignFacegroupItemModel {
	s.Headers = v
	return s
}

type CreateStoryModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateStoryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateStoryModel) String() string {
	return tea.Prettify(s)
}

func (s CreateStoryModel) GoString() string {
	return s.String()
}

func (s *CreateStoryModel) SetHeaders(v map[string]*string) *CreateStoryModel {
	s.Headers = v
	return s
}

func (s *CreateStoryModel) SetBody(v *CreateStoryResponse) *CreateStoryModel {
	s.Body = v
	return s
}

type DeleteStoryModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *DeleteStoryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteStoryModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteStoryModel) GoString() string {
	return s.String()
}

func (s *DeleteStoryModel) SetHeaders(v map[string]*string) *DeleteStoryModel {
	s.Headers = v
	return s
}

func (s *DeleteStoryModel) SetBody(v *DeleteStoryResponse) *DeleteStoryModel {
	s.Body = v
	return s
}

type FindStoriesModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *FindStoriesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s FindStoriesModel) String() string {
	return tea.Prettify(s)
}

func (s FindStoriesModel) GoString() string {
	return s.String()
}

func (s *FindStoriesModel) SetHeaders(v map[string]*string) *FindStoriesModel {
	s.Headers = v
	return s
}

func (s *FindStoriesModel) SetBody(v *FindStoriesResponse) *FindStoriesModel {
	s.Body = v
	return s
}

type GetPhotoCountModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetImageCountResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPhotoCountModel) String() string {
	return tea.Prettify(s)
}

func (s GetPhotoCountModel) GoString() string {
	return s.String()
}

func (s *GetPhotoCountModel) SetHeaders(v map[string]*string) *GetPhotoCountModel {
	s.Headers = v
	return s
}

func (s *GetPhotoCountModel) SetBody(v *GetImageCountResponse) *GetPhotoCountModel {
	s.Body = v
	return s
}

type GetStoryModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetStoryResponse  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStoryModel) String() string {
	return tea.Prettify(s)
}

func (s GetStoryModel) GoString() string {
	return s.String()
}

func (s *GetStoryModel) SetHeaders(v map[string]*string) *GetStoryModel {
	s.Headers = v
	return s
}

func (s *GetStoryModel) SetBody(v *GetStoryResponse) *GetStoryModel {
	s.Body = v
	return s
}

type ListAddressGroupsModel struct {
	Headers map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListImageAddressGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAddressGroupsModel) String() string {
	return tea.Prettify(s)
}

func (s ListAddressGroupsModel) GoString() string {
	return s.String()
}

func (s *ListAddressGroupsModel) SetHeaders(v map[string]*string) *ListAddressGroupsModel {
	s.Headers = v
	return s
}

func (s *ListAddressGroupsModel) SetBody(v *ListImageAddressGroupsResponse) *ListAddressGroupsModel {
	s.Body = v
	return s
}

type ListFacegroupsModel struct {
	Headers map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListImageFaceGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFacegroupsModel) String() string {
	return tea.Prettify(s)
}

func (s ListFacegroupsModel) GoString() string {
	return s.String()
}

func (s *ListFacegroupsModel) SetHeaders(v map[string]*string) *ListFacegroupsModel {
	s.Headers = v
	return s
}

func (s *ListFacegroupsModel) SetBody(v *ListImageFaceGroupsResponse) *ListFacegroupsModel {
	s.Body = v
	return s
}

type ListTagsModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListImageTagsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagsModel) String() string {
	return tea.Prettify(s)
}

func (s ListTagsModel) GoString() string {
	return s.String()
}

func (s *ListTagsModel) SetHeaders(v map[string]*string) *ListTagsModel {
	s.Headers = v
	return s
}

func (s *ListTagsModel) SetBody(v *ListImageTagsResponse) *ListTagsModel {
	s.Body = v
	return s
}

type ParseKeywordsModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ParseKeywordsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ParseKeywordsModel) String() string {
	return tea.Prettify(s)
}

func (s ParseKeywordsModel) GoString() string {
	return s.String()
}

func (s *ParseKeywordsModel) SetHeaders(v map[string]*string) *ParseKeywordsModel {
	s.Headers = v
	return s
}

func (s *ParseKeywordsModel) SetBody(v *ParseKeywordsResponse) *ParseKeywordsModel {
	s.Body = v
	return s
}

type SearchAddressGroupsModel struct {
	Headers map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchImageAddressGroupsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAddressGroupsModel) String() string {
	return tea.Prettify(s)
}

func (s SearchAddressGroupsModel) GoString() string {
	return s.String()
}

func (s *SearchAddressGroupsModel) SetHeaders(v map[string]*string) *SearchAddressGroupsModel {
	s.Headers = v
	return s
}

func (s *SearchAddressGroupsModel) SetBody(v *SearchImageAddressGroupsResponse) *SearchAddressGroupsModel {
	s.Body = v
	return s
}

type UpdateFacegroupInfoModel struct {
	Headers map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateFaceGroupInfoResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFacegroupInfoModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateFacegroupInfoModel) GoString() string {
	return s.String()
}

func (s *UpdateFacegroupInfoModel) SetHeaders(v map[string]*string) *UpdateFacegroupInfoModel {
	s.Headers = v
	return s
}

func (s *UpdateFacegroupInfoModel) SetBody(v *UpdateFaceGroupInfoResponse) *UpdateFacegroupInfoModel {
	s.Body = v
	return s
}

type UpdateStoryModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *UpdateStoryResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateStoryModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateStoryModel) GoString() string {
	return s.String()
}

func (s *UpdateStoryModel) SetHeaders(v map[string]*string) *UpdateStoryModel {
	s.Headers = v
	return s
}

func (s *UpdateStoryModel) SetBody(v *UpdateStoryResponse) *UpdateStoryModel {
	s.Body = v
	return s
}

type AddFileModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *AddViewFileResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddFileModel) String() string {
	return tea.Prettify(s)
}

func (s AddFileModel) GoString() string {
	return s.String()
}

func (s *AddFileModel) SetHeaders(v map[string]*string) *AddFileModel {
	s.Headers = v
	return s
}

func (s *AddFileModel) SetBody(v *AddViewFileResponse) *AddFileModel {
	s.Body = v
	return s
}

type CopyFilesModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CopyViewFilesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyFilesModel) String() string {
	return tea.Prettify(s)
}

func (s CopyFilesModel) GoString() string {
	return s.String()
}

func (s *CopyFilesModel) SetHeaders(v map[string]*string) *CopyFilesModel {
	s.Headers = v
	return s
}

func (s *CopyFilesModel) SetBody(v *CopyViewFilesResponse) *CopyFilesModel {
	s.Body = v
	return s
}

type CreateViewModel struct {
	Headers map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *CreateViewResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateViewModel) String() string {
	return tea.Prettify(s)
}

func (s CreateViewModel) GoString() string {
	return s.String()
}

func (s *CreateViewModel) SetHeaders(v map[string]*string) *CreateViewModel {
	s.Headers = v
	return s
}

func (s *CreateViewModel) SetBody(v *CreateViewResponse) *CreateViewModel {
	s.Body = v
	return s
}

type DeleteViewModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s DeleteViewModel) String() string {
	return tea.Prettify(s)
}

func (s DeleteViewModel) GoString() string {
	return s.String()
}

func (s *DeleteViewModel) SetHeaders(v map[string]*string) *DeleteViewModel {
	s.Headers = v
	return s
}

type GetViewModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *GetViewResponse   `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetViewModel) String() string {
	return tea.Prettify(s)
}

func (s GetViewModel) GoString() string {
	return s.String()
}

func (s *GetViewModel) SetHeaders(v map[string]*string) *GetViewModel {
	s.Headers = v
	return s
}

func (s *GetViewModel) SetBody(v *GetViewResponse) *GetViewModel {
	s.Body = v
	return s
}

type ListViewsModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListViewsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListViewsModel) String() string {
	return tea.Prettify(s)
}

func (s ListViewsModel) GoString() string {
	return s.String()
}

func (s *ListViewsModel) SetHeaders(v map[string]*string) *ListViewsModel {
	s.Headers = v
	return s
}

func (s *ListViewsModel) SetBody(v *ListViewsResponse) *ListViewsModel {
	s.Body = v
	return s
}

type ViewListFileModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListViewFilesResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ViewListFileModel) String() string {
	return tea.Prettify(s)
}

func (s ViewListFileModel) GoString() string {
	return s.String()
}

func (s *ViewListFileModel) SetHeaders(v map[string]*string) *ViewListFileModel {
	s.Headers = v
	return s
}

func (s *ViewListFileModel) SetBody(v *ListViewFilesResponse) *ViewListFileModel {
	s.Body = v
	return s
}

type ListFileViewsModel struct {
	Headers map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *ListFileViewsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFileViewsModel) String() string {
	return tea.Prettify(s)
}

func (s ListFileViewsModel) GoString() string {
	return s.String()
}

func (s *ListFileViewsModel) SetHeaders(v map[string]*string) *ListFileViewsModel {
	s.Headers = v
	return s
}

func (s *ListFileViewsModel) SetBody(v *ListFileViewsResponse) *ListFileViewsModel {
	s.Body = v
	return s
}

type RemoveFileModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s RemoveFileModel) String() string {
	return tea.Prettify(s)
}

func (s RemoveFileModel) GoString() string {
	return s.String()
}

func (s *RemoveFileModel) SetHeaders(v map[string]*string) *RemoveFileModel {
	s.Headers = v
	return s
}

type SearchViewsModel struct {
	Headers map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	Body    *SearchViewsResponse `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchViewsModel) String() string {
	return tea.Prettify(s)
}

func (s SearchViewsModel) GoString() string {
	return s.String()
}

func (s *SearchViewsModel) SetHeaders(v map[string]*string) *SearchViewsModel {
	s.Headers = v
	return s
}

func (s *SearchViewsModel) SetBody(v *SearchViewsResponse) *SearchViewsModel {
	s.Body = v
	return s
}

type UpdateViewModel struct {
	Headers map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
}

func (s UpdateViewModel) String() string {
	return tea.Prettify(s)
}

func (s UpdateViewModel) GoString() string {
	return s.String()
}

func (s *UpdateViewModel) SetHeaders(v map[string]*string) *UpdateViewModel {
	s.Headers = v
	return s
}

/**
 *
 */
type AccountAccessTokenResponse struct {
	// accessToken
	AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty" require:"true"`
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// Default Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
	// Default Sbox Drive ID
	DefaultSboxDriveId *string `json:"default_sbox_drive_id,omitempty" xml:"default_sbox_drive_id,omitempty"`
	// device_id device flow ID
	DeviceId *string `json:"device_id,omitempty" xml:"device_id,omitempty"`
	// device_name device flow 
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// domainID domainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	ExistLink []*LinkInfo `json:"exist_link,omitempty" xml:"exist_link,omitempty" type:"Repeated"`
	// accessTokenISO
	ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	// accessToken
	ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// 
	IsFirstLogin *bool `json:"is_first_login,omitempty" xml:"is_first_login,omitempty"`
	// 
	NeedLink *bool `json:"need_link,omitempty" xml:"need_link,omitempty" require:"true"`
	// 
	NeedRpVerify *bool `json:"need_rp_verify,omitempty" xml:"need_rp_verify,omitempty"`
	// 
	NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	// 
	PinSetup *bool `json:"pin_setup,omitempty" xml:"pin_setup,omitempty"`
	// accessToken
	RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain_id subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// accessTokenBearer
	TokenType *string `json:"token_type,omitempty" xml:"token_type,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	// ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s AccountAccessTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s AccountAccessTokenResponse) GoString() string {
	return s.String()
}

func (s *AccountAccessTokenResponse) SetAccessToken(v string) *AccountAccessTokenResponse {
	s.AccessToken = &v
	return s
}

func (s *AccountAccessTokenResponse) SetAvatar(v string) *AccountAccessTokenResponse {
	s.Avatar = &v
	return s
}

func (s *AccountAccessTokenResponse) SetDefaultDriveId(v string) *AccountAccessTokenResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetDefaultSboxDriveId(v string) *AccountAccessTokenResponse {
	s.DefaultSboxDriveId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetDeviceId(v string) *AccountAccessTokenResponse {
	s.DeviceId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetDeviceName(v string) *AccountAccessTokenResponse {
	s.DeviceName = &v
	return s
}

func (s *AccountAccessTokenResponse) SetDomainId(v string) *AccountAccessTokenResponse {
	s.DomainId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetExistLink(v []*LinkInfo) *AccountAccessTokenResponse {
	s.ExistLink = v
	return s
}

func (s *AccountAccessTokenResponse) SetExpireTime(v string) *AccountAccessTokenResponse {
	s.ExpireTime = &v
	return s
}

func (s *AccountAccessTokenResponse) SetExpiresIn(v int64) *AccountAccessTokenResponse {
	s.ExpiresIn = &v
	return s
}

func (s *AccountAccessTokenResponse) SetIsFirstLogin(v bool) *AccountAccessTokenResponse {
	s.IsFirstLogin = &v
	return s
}

func (s *AccountAccessTokenResponse) SetNeedLink(v bool) *AccountAccessTokenResponse {
	s.NeedLink = &v
	return s
}

func (s *AccountAccessTokenResponse) SetNeedRpVerify(v bool) *AccountAccessTokenResponse {
	s.NeedRpVerify = &v
	return s
}

func (s *AccountAccessTokenResponse) SetNickName(v string) *AccountAccessTokenResponse {
	s.NickName = &v
	return s
}

func (s *AccountAccessTokenResponse) SetPinSetup(v bool) *AccountAccessTokenResponse {
	s.PinSetup = &v
	return s
}

func (s *AccountAccessTokenResponse) SetRefreshToken(v string) *AccountAccessTokenResponse {
	s.RefreshToken = &v
	return s
}

func (s *AccountAccessTokenResponse) SetRole(v string) *AccountAccessTokenResponse {
	s.Role = &v
	return s
}

func (s *AccountAccessTokenResponse) SetState(v string) *AccountAccessTokenResponse {
	s.State = &v
	return s
}

func (s *AccountAccessTokenResponse) SetStatus(v string) *AccountAccessTokenResponse {
	s.Status = &v
	return s
}

func (s *AccountAccessTokenResponse) SetSubdomainId(v string) *AccountAccessTokenResponse {
	s.SubdomainId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetTokenType(v string) *AccountAccessTokenResponse {
	s.TokenType = &v
	return s
}

func (s *AccountAccessTokenResponse) SetUserData(v map[string]interface{}) *AccountAccessTokenResponse {
	s.UserData = v
	return s
}

func (s *AccountAccessTokenResponse) SetUserId(v string) *AccountAccessTokenResponse {
	s.UserId = &v
	return s
}

func (s *AccountAccessTokenResponse) SetUserName(v string) *AccountAccessTokenResponse {
	s.UserName = &v
	return s
}

/**
 *
 */
type AccountLinkRequest struct {
	Httpheaders    map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	CustomIdentity *string            `json:"custom_identity,omitempty" xml:"custom_identity,omitempty"`
	// 
	Detail *string `json:"detail,omitempty" xml:"detail,omitempty"`
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s AccountLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AccountLinkRequest) GoString() string {
	return s.String()
}

func (s *AccountLinkRequest) SetHttpheaders(v map[string]*string) *AccountLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *AccountLinkRequest) SetCustomIdentity(v string) *AccountLinkRequest {
	s.CustomIdentity = &v
	return s
}

func (s *AccountLinkRequest) SetDetail(v string) *AccountLinkRequest {
	s.Detail = &v
	return s
}

func (s *AccountLinkRequest) SetExtra(v string) *AccountLinkRequest {
	s.Extra = &v
	return s
}

func (s *AccountLinkRequest) SetIdentity(v string) *AccountLinkRequest {
	s.Identity = &v
	return s
}

func (s *AccountLinkRequest) SetStatus(v string) *AccountLinkRequest {
	s.Status = &v
	return s
}

func (s *AccountLinkRequest) SetType(v string) *AccountLinkRequest {
	s.Type = &v
	return s
}

func (s *AccountLinkRequest) SetUserId(v string) *AccountLinkRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type AccountTokenRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// refresh_token
	GrantType *string `json:"grant_type,omitempty" xml:"grant_type,omitempty" require:"true"`
	// refresh token, 
	RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty" require:"true"`
}

func (s AccountTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s AccountTokenRequest) GoString() string {
	return s.String()
}

func (s *AccountTokenRequest) SetHttpheaders(v map[string]*string) *AccountTokenRequest {
	s.Httpheaders = v
	return s
}

func (s *AccountTokenRequest) SetAdditionData(v map[string]interface{}) *AccountTokenRequest {
	s.AdditionData = v
	return s
}

func (s *AccountTokenRequest) SetAppId(v string) *AccountTokenRequest {
	s.AppId = &v
	return s
}

func (s *AccountTokenRequest) SetGrantType(v string) *AccountTokenRequest {
	s.GrantType = &v
	return s
}

func (s *AccountTokenRequest) SetRefreshToken(v string) *AccountTokenRequest {
	s.RefreshToken = &v
	return s
}

/**
 *
 */
type ActionDetail struct {
	Create  *CreateDetail  `json:"create,omitempty" xml:"create,omitempty"`
	Delete  *DeleteDetail  `json:"delete,omitempty" xml:"delete,omitempty"`
	Edit    *EditDetail    `json:"edit,omitempty" xml:"edit,omitempty"`
	Move    *MoveDetail    `json:"move,omitempty" xml:"move,omitempty"`
	Rename  *RenameDetail  `json:"rename,omitempty" xml:"rename,omitempty"`
	Restore *RestoreDetail `json:"restore,omitempty" xml:"restore,omitempty"`
	Trash   *TrashDetail   `json:"trash,omitempty" xml:"trash,omitempty"`
}

func (s ActionDetail) String() string {
	return tea.Prettify(s)
}

func (s ActionDetail) GoString() string {
	return s.String()
}

func (s *ActionDetail) SetCreate(v *CreateDetail) *ActionDetail {
	s.Create = v
	return s
}

func (s *ActionDetail) SetDelete(v *DeleteDetail) *ActionDetail {
	s.Delete = v
	return s
}

func (s *ActionDetail) SetEdit(v *EditDetail) *ActionDetail {
	s.Edit = v
	return s
}

func (s *ActionDetail) SetMove(v *MoveDetail) *ActionDetail {
	s.Move = v
	return s
}

func (s *ActionDetail) SetRename(v *RenameDetail) *ActionDetail {
	s.Rename = v
	return s
}

func (s *ActionDetail) SetRestore(v *RestoreDetail) *ActionDetail {
	s.Restore = v
	return s
}

func (s *ActionDetail) SetTrash(v *TrashDetail) *ActionDetail {
	s.Trash = v
	return s
}

/**
 *
 */
type ActionItem struct {
	Action        *string `json:"action,omitempty" xml:"action,omitempty"`
	Effect        *string `json:"effect,omitempty" xml:"effect,omitempty"`
	Inherited     *bool   `json:"inherited,omitempty" xml:"inherited,omitempty"`
	InheritedFrom *string `json:"inherited_from,omitempty" xml:"inherited_from,omitempty"`
}

func (s ActionItem) String() string {
	return tea.Prettify(s)
}

func (s ActionItem) GoString() string {
	return s.String()
}

func (s *ActionItem) SetAction(v string) *ActionItem {
	s.Action = &v
	return s
}

func (s *ActionItem) SetEffect(v string) *ActionItem {
	s.Effect = &v
	return s
}

func (s *ActionItem) SetInherited(v bool) *ActionItem {
	s.Inherited = &v
	return s
}

func (s *ActionItem) SetInheritedFrom(v string) *ActionItem {
	s.InheritedFrom = &v
	return s
}

/**
 *
 */
type Actor struct {
	AliUser       *ActorAliUser       `json:"ali_user,omitempty" xml:"ali_user,omitempty"`
	AnonymousUser *ActorAnonymousUser `json:"anonymous_user,omitempty" xml:"anonymous_user,omitempty"`
	ShareLinkUser *ActorShareLinkUser `json:"share_link_user,omitempty" xml:"share_link_user,omitempty"`
	System        *ActorSystem        `json:"system,omitempty" xml:"system,omitempty"`
	User          *ActorUser          `json:"user,omitempty" xml:"user,omitempty"`
}

func (s Actor) String() string {
	return tea.Prettify(s)
}

func (s Actor) GoString() string {
	return s.String()
}

func (s *Actor) SetAliUser(v *ActorAliUser) *Actor {
	s.AliUser = v
	return s
}

func (s *Actor) SetAnonymousUser(v *ActorAnonymousUser) *Actor {
	s.AnonymousUser = v
	return s
}

func (s *Actor) SetShareLinkUser(v *ActorShareLinkUser) *Actor {
	s.ShareLinkUser = v
	return s
}

func (s *Actor) SetSystem(v *ActorSystem) *Actor {
	s.System = v
	return s
}

func (s *Actor) SetUser(v *ActorUser) *Actor {
	s.User = v
	return s
}

/**
 *
 */
type ActorAliUser struct {
	// AliUserID
	AliUserId *string `json:"ali_user_id,omitempty" xml:"ali_user_id,omitempty"`
	// AliUserType
	AliUserType *string `json:"ali_user_type,omitempty" xml:"ali_user_type,omitempty"`
	// AsUserID
	AsUserId *string `json:"as_user_id,omitempty" xml:"as_user_id,omitempty"`
}

func (s ActorAliUser) String() string {
	return tea.Prettify(s)
}

func (s ActorAliUser) GoString() string {
	return s.String()
}

func (s *ActorAliUser) SetAliUserId(v string) *ActorAliUser {
	s.AliUserId = &v
	return s
}

func (s *ActorAliUser) SetAliUserType(v string) *ActorAliUser {
	s.AliUserType = &v
	return s
}

func (s *ActorAliUser) SetAsUserId(v string) *ActorAliUser {
	s.AsUserId = &v
	return s
}

/**
 *
 */
type ActorAnonymousUser struct {
}

func (s ActorAnonymousUser) String() string {
	return tea.Prettify(s)
}

func (s ActorAnonymousUser) GoString() string {
	return s.String()
}

/**
 *
 */
type ActorShareLinkUser struct {
	// Creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// ShareID
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// UserID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// UserName
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s ActorShareLinkUser) String() string {
	return tea.Prettify(s)
}

func (s ActorShareLinkUser) GoString() string {
	return s.String()
}

func (s *ActorShareLinkUser) SetCreator(v string) *ActorShareLinkUser {
	s.Creator = &v
	return s
}

func (s *ActorShareLinkUser) SetShareId(v string) *ActorShareLinkUser {
	s.ShareId = &v
	return s
}

func (s *ActorShareLinkUser) SetUserId(v string) *ActorShareLinkUser {
	s.UserId = &v
	return s
}

func (s *ActorShareLinkUser) SetUserName(v string) *ActorShareLinkUser {
	s.UserName = &v
	return s
}

/**
 *
 */
type ActorSystem struct {
	// EventType
	EventType *string `json:"event_type,omitempty" xml:"event_type,omitempty"`
}

func (s ActorSystem) String() string {
	return tea.Prettify(s)
}

func (s ActorSystem) GoString() string {
	return s.String()
}

func (s *ActorSystem) SetEventType(v string) *ActorSystem {
	s.EventType = &v
	return s
}

/**
 *
 */
type ActorUser struct {
	// UserID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// UserName
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s ActorUser) String() string {
	return tea.Prettify(s)
}

func (s ActorUser) GoString() string {
	return s.String()
}

func (s *ActorUser) SetUserId(v string) *ActorUser {
	s.UserId = &v
	return s
}

func (s *ActorUser) SetUserName(v string) *ActorUser {
	s.UserName = &v
	return s
}

/**
 *
 */
type AddStoreRequest struct {
	// 
	BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
	// bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// 
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
	// systemcustom
	Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty"`
	// BucketARN
	RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
	// oss
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s AddStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s AddStoreRequest) GoString() string {
	return s.String()
}

func (s *AddStoreRequest) SetBasePath(v string) *AddStoreRequest {
	s.BasePath = &v
	return s
}

func (s *AddStoreRequest) SetBucket(v string) *AddStoreRequest {
	s.Bucket = &v
	return s
}

func (s *AddStoreRequest) SetDomainId(v string) *AddStoreRequest {
	s.DomainId = &v
	return s
}

func (s *AddStoreRequest) SetEndpoint(v string) *AddStoreRequest {
	s.Endpoint = &v
	return s
}

func (s *AddStoreRequest) SetOwnership(v string) *AddStoreRequest {
	s.Ownership = &v
	return s
}

func (s *AddStoreRequest) SetRoleArn(v string) *AddStoreRequest {
	s.RoleArn = &v
	return s
}

func (s *AddStoreRequest) SetType(v string) *AddStoreRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type AppAccessStrategy struct {
	Effect          *string   `json:"effect,omitempty" xml:"effect,omitempty"`
	ExceptAppIdList []*string `json:"except_app_id_list,omitempty" xml:"except_app_id_list,omitempty" type:"Repeated"`
}

func (s AppAccessStrategy) String() string {
	return tea.Prettify(s)
}

func (s AppAccessStrategy) GoString() string {
	return s.String()
}

func (s *AppAccessStrategy) SetEffect(v string) *AppAccessStrategy {
	s.Effect = &v
	return s
}

func (s *AppAccessStrategy) SetExceptAppIdList(v []*string) *AppAccessStrategy {
	s.ExceptAppIdList = v
	return s
}

/**
 * 
 */
type ArchiveListRequest struct {
	// uc
	Format      *string `json:"Format,omitempty" xml:"Format,omitempty"`
	RequestID   *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
	ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
	DomainId    *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// TODO ShareID
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId   *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
}

func (s ArchiveListRequest) String() string {
	return tea.Prettify(s)
}

func (s ArchiveListRequest) GoString() string {
	return s.String()
}

func (s *ArchiveListRequest) SetFormat(v string) *ArchiveListRequest {
	s.Format = &v
	return s
}

func (s *ArchiveListRequest) SetRequestID(v string) *ArchiveListRequest {
	s.RequestID = &v
	return s
}

func (s *ArchiveListRequest) SetArchiveType(v string) *ArchiveListRequest {
	s.ArchiveType = &v
	return s
}

func (s *ArchiveListRequest) SetDomainId(v string) *ArchiveListRequest {
	s.DomainId = &v
	return s
}

func (s *ArchiveListRequest) SetDriveId(v string) *ArchiveListRequest {
	s.DriveId = &v
	return s
}

func (s *ArchiveListRequest) SetFileId(v string) *ArchiveListRequest {
	s.FileId = &v
	return s
}

func (s *ArchiveListRequest) SetPassword(v string) *ArchiveListRequest {
	s.Password = &v
	return s
}

/**
 *  response
 */
type ArchiveListResponse struct {
	FileList map[string]interface{} `json:"file_list,omitempty" xml:"file_list,omitempty"`
	State    *string                `json:"state,omitempty" xml:"state,omitempty"`
	TaskId   *string                `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveListResponse) String() string {
	return tea.Prettify(s)
}

func (s ArchiveListResponse) GoString() string {
	return s.String()
}

func (s *ArchiveListResponse) SetFileList(v map[string]interface{}) *ArchiveListResponse {
	s.FileList = v
	return s
}

func (s *ArchiveListResponse) SetState(v string) *ArchiveListResponse {
	s.State = &v
	return s
}

func (s *ArchiveListResponse) SetTaskId(v string) *ArchiveListResponse {
	s.TaskId = &v
	return s
}

/**
 * 
 */
type ArchiveStatusRequest struct {
	// uc
	Format      *string `json:"Format,omitempty" xml:"Format,omitempty"`
	RequestID   *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
	ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
	DomainId    *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// TODO ShareID
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId   *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	TaskId   *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s ArchiveStatusRequest) GoString() string {
	return s.String()
}

func (s *ArchiveStatusRequest) SetFormat(v string) *ArchiveStatusRequest {
	s.Format = &v
	return s
}

func (s *ArchiveStatusRequest) SetRequestID(v string) *ArchiveStatusRequest {
	s.RequestID = &v
	return s
}

func (s *ArchiveStatusRequest) SetArchiveType(v string) *ArchiveStatusRequest {
	s.ArchiveType = &v
	return s
}

func (s *ArchiveStatusRequest) SetDomainId(v string) *ArchiveStatusRequest {
	s.DomainId = &v
	return s
}

func (s *ArchiveStatusRequest) SetDriveId(v string) *ArchiveStatusRequest {
	s.DriveId = &v
	return s
}

func (s *ArchiveStatusRequest) SetFileId(v string) *ArchiveStatusRequest {
	s.FileId = &v
	return s
}

func (s *ArchiveStatusRequest) SetPassword(v string) *ArchiveStatusRequest {
	s.Password = &v
	return s
}

func (s *ArchiveStatusRequest) SetTaskId(v string) *ArchiveStatusRequest {
	s.TaskId = &v
	return s
}

/**
 * ArchiveStatusResponse response
 */
type ArchiveStatusResponse struct {
	FileList map[string]interface{} `json:"file_list,omitempty" xml:"file_list,omitempty"`
	Progress *int64                 `json:"progress,omitempty" xml:"progress,omitempty"`
	State    *string                `json:"state,omitempty" xml:"state,omitempty"`
	TaskId   *string                `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s ArchiveStatusResponse) GoString() string {
	return s.String()
}

func (s *ArchiveStatusResponse) SetFileList(v map[string]interface{}) *ArchiveStatusResponse {
	s.FileList = v
	return s
}

func (s *ArchiveStatusResponse) SetProgress(v int64) *ArchiveStatusResponse {
	s.Progress = &v
	return s
}

func (s *ArchiveStatusResponse) SetState(v string) *ArchiveStatusResponse {
	s.State = &v
	return s
}

func (s *ArchiveStatusResponse) SetTaskId(v string) *ArchiveStatusResponse {
	s.TaskId = &v
	return s
}

/**
 * 
 */
type ArchiveUncompressRequest struct {
	// uc
	Format      *string `json:"Format,omitempty" xml:"Format,omitempty"`
	RequestID   *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
	ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
	DomainId    *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// TODO ShareID
	DriveId       *string   `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId        *string   `json:"file_id,omitempty" xml:"file_id,omitempty"`
	FileList      []*string `json:"file_list,omitempty" xml:"file_list,omitempty" type:"Repeated"`
	Password      *string   `json:"password,omitempty" xml:"password,omitempty"`
	TargetDriveId *string   `json:"target_drive_id,omitempty" xml:"target_drive_id,omitempty"`
	TargetFileId  *string   `json:"target_file_id,omitempty" xml:"target_file_id,omitempty"`
}

func (s ArchiveUncompressRequest) String() string {
	return tea.Prettify(s)
}

func (s ArchiveUncompressRequest) GoString() string {
	return s.String()
}

func (s *ArchiveUncompressRequest) SetFormat(v string) *ArchiveUncompressRequest {
	s.Format = &v
	return s
}

func (s *ArchiveUncompressRequest) SetRequestID(v string) *ArchiveUncompressRequest {
	s.RequestID = &v
	return s
}

func (s *ArchiveUncompressRequest) SetArchiveType(v string) *ArchiveUncompressRequest {
	s.ArchiveType = &v
	return s
}

func (s *ArchiveUncompressRequest) SetDomainId(v string) *ArchiveUncompressRequest {
	s.DomainId = &v
	return s
}

func (s *ArchiveUncompressRequest) SetDriveId(v string) *ArchiveUncompressRequest {
	s.DriveId = &v
	return s
}

func (s *ArchiveUncompressRequest) SetFileId(v string) *ArchiveUncompressRequest {
	s.FileId = &v
	return s
}

func (s *ArchiveUncompressRequest) SetFileList(v []*string) *ArchiveUncompressRequest {
	s.FileList = v
	return s
}

func (s *ArchiveUncompressRequest) SetPassword(v string) *ArchiveUncompressRequest {
	s.Password = &v
	return s
}

func (s *ArchiveUncompressRequest) SetTargetDriveId(v string) *ArchiveUncompressRequest {
	s.TargetDriveId = &v
	return s
}

func (s *ArchiveUncompressRequest) SetTargetFileId(v string) *ArchiveUncompressRequest {
	s.TargetFileId = &v
	return s
}

/**
 *  response
 */
type ArchiveUncompressResponse struct {
	State  *string `json:"state,omitempty" xml:"state,omitempty"`
	TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ArchiveUncompressResponse) String() string {
	return tea.Prettify(s)
}

func (s ArchiveUncompressResponse) GoString() string {
	return s.String()
}

func (s *ArchiveUncompressResponse) SetState(v string) *ArchiveUncompressResponse {
	s.State = &v
	return s
}

func (s *ArchiveUncompressResponse) SetTaskId(v string) *ArchiveUncompressResponse {
	s.TaskId = &v
	return s
}

/**
 *
 */
type AuthConfig struct {
	AppId             *string                `json:"app_id,omitempty" xml:"app_id,omitempty"`
	AppSecret         *string                `json:"app_secret,omitempty" xml:"app_secret,omitempty"`
	CallbackSecurity  *bool                  `json:"callback_security,omitempty" xml:"callback_security,omitempty"`
	Enable            *bool                  `json:"enable,omitempty" xml:"enable,omitempty"`
	EncodingAesKey    *string                `json:"encoding_aes_key,omitempty" xml:"encoding_aes_key,omitempty"`
	Endpoint          *string                `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	EnterpriseId      *string                `json:"enterprise_id,omitempty" xml:"enterprise_id,omitempty"`
	LdapConfig        *LdapConfig            `json:"ldap_config,omitempty" xml:"ldap_config,omitempty"`
	LoginPageHeaders  map[string]interface{} `json:"login_page_headers,omitempty" xml:"login_page_headers,omitempty"`
	LoginPageTemplate *string                `json:"login_page_template,omitempty" xml:"login_page_template,omitempty"`
	LoginPageVars     map[string]interface{} `json:"login_page_vars,omitempty" xml:"login_page_vars,omitempty"`
	Token             *string                `json:"token,omitempty" xml:"token,omitempty"`
	WeChatSyncConfig  *WeChatSyncConfig      `json:"we_chat_sync_config,omitempty" xml:"we_chat_sync_config,omitempty"`
	WhiteListConfig   map[string]interface{} `json:"white_list_config,omitempty" xml:"white_list_config,omitempty"`
	WhiteListEnable   *bool                  `json:"white_list_enable,omitempty" xml:"white_list_enable,omitempty"`
}

func (s AuthConfig) String() string {
	return tea.Prettify(s)
}

func (s AuthConfig) GoString() string {
	return s.String()
}

func (s *AuthConfig) SetAppId(v string) *AuthConfig {
	s.AppId = &v
	return s
}

func (s *AuthConfig) SetAppSecret(v string) *AuthConfig {
	s.AppSecret = &v
	return s
}

func (s *AuthConfig) SetCallbackSecurity(v bool) *AuthConfig {
	s.CallbackSecurity = &v
	return s
}

func (s *AuthConfig) SetEnable(v bool) *AuthConfig {
	s.Enable = &v
	return s
}

func (s *AuthConfig) SetEncodingAesKey(v string) *AuthConfig {
	s.EncodingAesKey = &v
	return s
}

func (s *AuthConfig) SetEndpoint(v string) *AuthConfig {
	s.Endpoint = &v
	return s
}

func (s *AuthConfig) SetEnterpriseId(v string) *AuthConfig {
	s.EnterpriseId = &v
	return s
}

func (s *AuthConfig) SetLdapConfig(v *LdapConfig) *AuthConfig {
	s.LdapConfig = v
	return s
}

func (s *AuthConfig) SetLoginPageHeaders(v map[string]interface{}) *AuthConfig {
	s.LoginPageHeaders = v
	return s
}

func (s *AuthConfig) SetLoginPageTemplate(v string) *AuthConfig {
	s.LoginPageTemplate = &v
	return s
}

func (s *AuthConfig) SetLoginPageVars(v map[string]interface{}) *AuthConfig {
	s.LoginPageVars = v
	return s
}

func (s *AuthConfig) SetToken(v string) *AuthConfig {
	s.Token = &v
	return s
}

func (s *AuthConfig) SetWeChatSyncConfig(v *WeChatSyncConfig) *AuthConfig {
	s.WeChatSyncConfig = v
	return s
}

func (s *AuthConfig) SetWhiteListConfig(v map[string]interface{}) *AuthConfig {
	s.WhiteListConfig = v
	return s
}

func (s *AuthConfig) SetWhiteListEnable(v bool) *AuthConfig {
	s.WhiteListEnable = &v
	return s
}

/**
 *
 */
type AuthorizeRequest struct {
	// Client ID, AppAppID
	ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
	// 
	DomainID *string `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
	// 
	HideConsent *bool `json:"HideConsent,omitempty" xml:"HideConsent,omitempty"`
	// ding,ram
	LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
	// , App
	RedirectUri *string `json:"RedirectUri,omitempty" xml:"RedirectUri,omitempty" require:"true"`
	// , code
	ResponseType *string `json:"ResponseType,omitempty" xml:"ResponseType,omitempty" require:"true"`
	// , 
	Scope []*string `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Repeated"`
	// callback
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// 
	UserCode *string `json:"UserCode,omitempty" xml:"UserCode,omitempty"`
}

func (s AuthorizeRequest) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeRequest) GoString() string {
	return s.String()
}

func (s *AuthorizeRequest) SetClientID(v string) *AuthorizeRequest {
	s.ClientID = &v
	return s
}

func (s *AuthorizeRequest) SetDomainID(v string) *AuthorizeRequest {
	s.DomainID = &v
	return s
}

func (s *AuthorizeRequest) SetHideConsent(v bool) *AuthorizeRequest {
	s.HideConsent = &v
	return s
}

func (s *AuthorizeRequest) SetLoginType(v string) *AuthorizeRequest {
	s.LoginType = &v
	return s
}

func (s *AuthorizeRequest) SetRedirectUri(v string) *AuthorizeRequest {
	s.RedirectUri = &v
	return s
}

func (s *AuthorizeRequest) SetResponseType(v string) *AuthorizeRequest {
	s.ResponseType = &v
	return s
}

func (s *AuthorizeRequest) SetScope(v []*string) *AuthorizeRequest {
	s.Scope = v
	return s
}

func (s *AuthorizeRequest) SetState(v string) *AuthorizeRequest {
	s.State = &v
	return s
}

func (s *AuthorizeRequest) SetUserCode(v string) *AuthorizeRequest {
	s.UserCode = &v
	return s
}

/**
 *
 */
type BackUpConfig struct {
	// folder_id
	FolderId *string `json:"folder_id,omitempty" xml:"folder_id,omitempty"`
	// photo_folder_id
	PhotoFolderId *string `json:"photo_folder_id,omitempty" xml:"photo_folder_id,omitempty"`
	// sub_folder
	SubFolder map[string]interface{} `json:"sub_folder,omitempty" xml:"sub_folder,omitempty"`
	// video_folder_id
	VideoFolderId *string `json:"video_folder_id,omitempty" xml:"video_folder_id,omitempty"`
}

func (s BackUpConfig) String() string {
	return tea.Prettify(s)
}

func (s BackUpConfig) GoString() string {
	return s.String()
}

func (s *BackUpConfig) SetFolderId(v string) *BackUpConfig {
	s.FolderId = &v
	return s
}

func (s *BackUpConfig) SetPhotoFolderId(v string) *BackUpConfig {
	s.PhotoFolderId = &v
	return s
}

func (s *BackUpConfig) SetSubFolder(v map[string]interface{}) *BackUpConfig {
	s.SubFolder = v
	return s
}

func (s *BackUpConfig) SetVideoFolderId(v string) *BackUpConfig {
	s.VideoFolderId = &v
	return s
}

/**
 *
 */
type BaseAdditionDataRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
}

func (s BaseAdditionDataRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseAdditionDataRequest) GoString() string {
	return s.String()
}

func (s *BaseAdditionDataRequest) SetAdditionData(v map[string]interface{}) *BaseAdditionDataRequest {
	s.AdditionData = v
	return s
}

/**
 *
 */
type BaseAuthentication struct {
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
}

func (s BaseAuthentication) String() string {
	return tea.Prettify(s)
}

func (s BaseAuthentication) GoString() string {
	return s.String()
}

func (s *BaseAuthentication) SetEmail(v string) *BaseAuthentication {
	s.Email = &v
	return s
}

func (s *BaseAuthentication) SetPhoneNumber(v string) *BaseAuthentication {
	s.PhoneNumber = &v
	return s
}

func (s *BaseAuthentication) SetPhoneRegion(v string) *BaseAuthentication {
	s.PhoneRegion = &v
	return s
}

/**
 * Base file response
 */
type BaseCCPFileResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s BaseCCPFileResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseCCPFileResponse) GoString() string {
	return s.String()
}

func (s *BaseCCPFileResponse) SetActionList(v []*string) *BaseCCPFileResponse {
	s.ActionList = v
	return s
}

func (s *BaseCCPFileResponse) SetAutoDeleteLeftSec(v int64) *BaseCCPFileResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *BaseCCPFileResponse) SetCategory(v string) *BaseCCPFileResponse {
	s.Category = &v
	return s
}

func (s *BaseCCPFileResponse) SetCharacteristicHash(v string) *BaseCCPFileResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *BaseCCPFileResponse) SetContentHash(v string) *BaseCCPFileResponse {
	s.ContentHash = &v
	return s
}

func (s *BaseCCPFileResponse) SetContentHashName(v string) *BaseCCPFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *BaseCCPFileResponse) SetContentType(v string) *BaseCCPFileResponse {
	s.ContentType = &v
	return s
}

func (s *BaseCCPFileResponse) SetCrc64Hash(v string) *BaseCCPFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *BaseCCPFileResponse) SetCreatedAt(v string) *BaseCCPFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseCCPFileResponse) SetCreatorId(v string) *BaseCCPFileResponse {
	s.CreatorId = &v
	return s
}

func (s *BaseCCPFileResponse) SetCreatorName(v string) *BaseCCPFileResponse {
	s.CreatorName = &v
	return s
}

func (s *BaseCCPFileResponse) SetCreatorType(v string) *BaseCCPFileResponse {
	s.CreatorType = &v
	return s
}

func (s *BaseCCPFileResponse) SetCustomField1(v string) *BaseCCPFileResponse {
	s.CustomField1 = &v
	return s
}

func (s *BaseCCPFileResponse) SetCustomField2(v string) *BaseCCPFileResponse {
	s.CustomField2 = &v
	return s
}

func (s *BaseCCPFileResponse) SetCustomType(v string) *BaseCCPFileResponse {
	s.CustomType = &v
	return s
}

func (s *BaseCCPFileResponse) SetDescription(v string) *BaseCCPFileResponse {
	s.Description = &v
	return s
}

func (s *BaseCCPFileResponse) SetDomainId(v string) *BaseCCPFileResponse {
	s.DomainId = &v
	return s
}

func (s *BaseCCPFileResponse) SetDownloadUrl(v string) *BaseCCPFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *BaseCCPFileResponse) SetDriveId(v string) *BaseCCPFileResponse {
	s.DriveId = &v
	return s
}

func (s *BaseCCPFileResponse) SetEncryptMode(v string) *BaseCCPFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *BaseCCPFileResponse) SetExFieldsInfo(v map[string]interface{}) *BaseCCPFileResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *BaseCCPFileResponse) SetFileExtension(v string) *BaseCCPFileResponse {
	s.FileExtension = &v
	return s
}

func (s *BaseCCPFileResponse) SetFileId(v string) *BaseCCPFileResponse {
	s.FileId = &v
	return s
}

func (s *BaseCCPFileResponse) SetFilePathType(v string) *BaseCCPFileResponse {
	s.FilePathType = &v
	return s
}

func (s *BaseCCPFileResponse) SetHidden(v bool) *BaseCCPFileResponse {
	s.Hidden = &v
	return s
}

func (s *BaseCCPFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *BaseCCPFileResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *BaseCCPFileResponse) SetLabels(v []*string) *BaseCCPFileResponse {
	s.Labels = v
	return s
}

func (s *BaseCCPFileResponse) SetLastModifierId(v string) *BaseCCPFileResponse {
	s.LastModifierId = &v
	return s
}

func (s *BaseCCPFileResponse) SetLastModifierName(v string) *BaseCCPFileResponse {
	s.LastModifierName = &v
	return s
}

func (s *BaseCCPFileResponse) SetLastModifierType(v string) *BaseCCPFileResponse {
	s.LastModifierType = &v
	return s
}

func (s *BaseCCPFileResponse) SetLocalCreatedAt(v string) *BaseCCPFileResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *BaseCCPFileResponse) SetLocalModifiedAt(v string) *BaseCCPFileResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *BaseCCPFileResponse) SetMeta(v string) *BaseCCPFileResponse {
	s.Meta = &v
	return s
}

func (s *BaseCCPFileResponse) SetMimeExtension(v string) *BaseCCPFileResponse {
	s.MimeExtension = &v
	return s
}

func (s *BaseCCPFileResponse) SetMimeType(v string) *BaseCCPFileResponse {
	s.MimeType = &v
	return s
}

func (s *BaseCCPFileResponse) SetName(v string) *BaseCCPFileResponse {
	s.Name = &v
	return s
}

func (s *BaseCCPFileResponse) SetParentFileId(v string) *BaseCCPFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *BaseCCPFileResponse) SetPunishFlag(v int64) *BaseCCPFileResponse {
	s.PunishFlag = &v
	return s
}

func (s *BaseCCPFileResponse) SetRevisionId(v string) *BaseCCPFileResponse {
	s.RevisionId = &v
	return s
}

func (s *BaseCCPFileResponse) SetShareId(v string) *BaseCCPFileResponse {
	s.ShareId = &v
	return s
}

func (s *BaseCCPFileResponse) SetSize(v int64) *BaseCCPFileResponse {
	s.Size = &v
	return s
}

func (s *BaseCCPFileResponse) SetStarred(v bool) *BaseCCPFileResponse {
	s.Starred = &v
	return s
}

func (s *BaseCCPFileResponse) SetStatus(v string) *BaseCCPFileResponse {
	s.Status = &v
	return s
}

func (s *BaseCCPFileResponse) SetStreamsInfo(v map[string]interface{}) *BaseCCPFileResponse {
	s.StreamsInfo = v
	return s
}

func (s *BaseCCPFileResponse) SetSyncDeviceFlag(v bool) *BaseCCPFileResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *BaseCCPFileResponse) SetSyncFlag(v bool) *BaseCCPFileResponse {
	s.SyncFlag = &v
	return s
}

func (s *BaseCCPFileResponse) SetSyncMeta(v string) *BaseCCPFileResponse {
	s.SyncMeta = &v
	return s
}

func (s *BaseCCPFileResponse) SetThumbnail(v string) *BaseCCPFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *BaseCCPFileResponse) SetTrashedAt(v string) *BaseCCPFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *BaseCCPFileResponse) SetType(v string) *BaseCCPFileResponse {
	s.Type = &v
	return s
}

func (s *BaseCCPFileResponse) SetUpdatedAt(v string) *BaseCCPFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseCCPFileResponse) SetUploadId(v string) *BaseCCPFileResponse {
	s.UploadId = &v
	return s
}

func (s *BaseCCPFileResponse) SetUrl(v string) *BaseCCPFileResponse {
	s.Url = &v
	return s
}

func (s *BaseCCPFileResponse) SetUserMeta(v string) *BaseCCPFileResponse {
	s.UserMeta = &v
	return s
}

func (s *BaseCCPFileResponse) SetUserTags(v map[string]interface{}) *BaseCCPFileResponse {
	s.UserTags = v
	return s
}

func (s *BaseCCPFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *BaseCCPFileResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *BaseCCPFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *BaseCCPFileResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 * complete file request
 */
type BaseCompleteFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s BaseCompleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseCompleteFileRequest) GoString() string {
	return s.String()
}

func (s *BaseCompleteFileRequest) SetAdditionData(v map[string]interface{}) *BaseCompleteFileRequest {
	s.AdditionData = v
	return s
}

func (s *BaseCompleteFileRequest) SetDriveId(v string) *BaseCompleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *BaseCompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *BaseCompleteFileRequest {
	s.PartInfoList = v
	return s
}

func (s *BaseCompleteFileRequest) SetShareId(v string) *BaseCompleteFileRequest {
	s.ShareId = &v
	return s
}

func (s *BaseCompleteFileRequest) SetUploadId(v string) *BaseCompleteFileRequest {
	s.UploadId = &v
	return s
}

/**
 * create file request
 */
type BaseCreateFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// ContentMd5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// ContentType
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// Name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// Type
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s BaseCreateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseCreateFileRequest) GoString() string {
	return s.String()
}

func (s *BaseCreateFileRequest) SetAdditionData(v map[string]interface{}) *BaseCreateFileRequest {
	s.AdditionData = v
	return s
}

func (s *BaseCreateFileRequest) SetContentMd5(v string) *BaseCreateFileRequest {
	s.ContentMd5 = &v
	return s
}

func (s *BaseCreateFileRequest) SetContentType(v string) *BaseCreateFileRequest {
	s.ContentType = &v
	return s
}

func (s *BaseCreateFileRequest) SetName(v string) *BaseCreateFileRequest {
	s.Name = &v
	return s
}

func (s *BaseCreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *BaseCreateFileRequest {
	s.PartInfoList = v
	return s
}

func (s *BaseCreateFileRequest) SetSize(v int64) *BaseCreateFileRequest {
	s.Size = &v
	return s
}

func (s *BaseCreateFileRequest) SetType(v string) *BaseCreateFileRequest {
	s.Type = &v
	return s
}

/**
 * Base drive response
 */
type BaseDriveResponse struct {
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	CreatedAt  *string   `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Drive 
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// Drive 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// Drive 
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
	// Drive 
	DriveType         *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
	EncryptDataAccess *bool   `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
	EncryptMode       *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// Drive 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// Drive 
	OwnerType  *string                `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// DrivestoredomainPathTypeOSSPath
	RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
	// Drive 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	//  ID, domainPathTypeOSSPath
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// Drive 
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// Drive 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s BaseDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseDriveResponse) GoString() string {
	return s.String()
}

func (s *BaseDriveResponse) SetActionList(v []*string) *BaseDriveResponse {
	s.ActionList = v
	return s
}

func (s *BaseDriveResponse) SetCreatedAt(v string) *BaseDriveResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseDriveResponse) SetCreator(v string) *BaseDriveResponse {
	s.Creator = &v
	return s
}

func (s *BaseDriveResponse) SetDescription(v string) *BaseDriveResponse {
	s.Description = &v
	return s
}

func (s *BaseDriveResponse) SetDomainId(v string) *BaseDriveResponse {
	s.DomainId = &v
	return s
}

func (s *BaseDriveResponse) SetDriveId(v string) *BaseDriveResponse {
	s.DriveId = &v
	return s
}

func (s *BaseDriveResponse) SetDriveName(v string) *BaseDriveResponse {
	s.DriveName = &v
	return s
}

func (s *BaseDriveResponse) SetDriveType(v string) *BaseDriveResponse {
	s.DriveType = &v
	return s
}

func (s *BaseDriveResponse) SetEncryptDataAccess(v bool) *BaseDriveResponse {
	s.EncryptDataAccess = &v
	return s
}

func (s *BaseDriveResponse) SetEncryptMode(v string) *BaseDriveResponse {
	s.EncryptMode = &v
	return s
}

func (s *BaseDriveResponse) SetOwner(v string) *BaseDriveResponse {
	s.Owner = &v
	return s
}

func (s *BaseDriveResponse) SetOwnerType(v string) *BaseDriveResponse {
	s.OwnerType = &v
	return s
}

func (s *BaseDriveResponse) SetPermission(v map[string]interface{}) *BaseDriveResponse {
	s.Permission = v
	return s
}

func (s *BaseDriveResponse) SetRelativePath(v string) *BaseDriveResponse {
	s.RelativePath = &v
	return s
}

func (s *BaseDriveResponse) SetStatus(v string) *BaseDriveResponse {
	s.Status = &v
	return s
}

func (s *BaseDriveResponse) SetStoreId(v string) *BaseDriveResponse {
	s.StoreId = &v
	return s
}

func (s *BaseDriveResponse) SetSubdomainId(v string) *BaseDriveResponse {
	s.SubdomainId = &v
	return s
}

func (s *BaseDriveResponse) SetTotalSize(v int64) *BaseDriveResponse {
	s.TotalSize = &v
	return s
}

func (s *BaseDriveResponse) SetUsedSize(v int64) *BaseDriveResponse {
	s.UsedSize = &v
	return s
}

/**
 * list_file_by_anonymous base response
 */
type BaseFileAnonymousResponse struct {
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// size, type=file
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseFileAnonymousResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseFileAnonymousResponse) GoString() string {
	return s.String()
}

func (s *BaseFileAnonymousResponse) SetFileId(v string) *BaseFileAnonymousResponse {
	s.FileId = &v
	return s
}

func (s *BaseFileAnonymousResponse) SetName(v string) *BaseFileAnonymousResponse {
	s.Name = &v
	return s
}

func (s *BaseFileAnonymousResponse) SetSize(v int64) *BaseFileAnonymousResponse {
	s.Size = &v
	return s
}

func (s *BaseFileAnonymousResponse) SetThumbnail(v string) *BaseFileAnonymousResponse {
	s.Thumbnail = &v
	return s
}

func (s *BaseFileAnonymousResponse) SetType(v string) *BaseFileAnonymousResponse {
	s.Type = &v
	return s
}

func (s *BaseFileAnonymousResponse) SetUpdatedAt(v string) *BaseFileAnonymousResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type BaseFileListInheritPermissionResponse struct {
	// ID
	FileId *string               `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	Member *FilePermissionMember `json:"member,omitempty" xml:"member,omitempty"`
}

func (s BaseFileListInheritPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseFileListInheritPermissionResponse) GoString() string {
	return s.String()
}

func (s *BaseFileListInheritPermissionResponse) SetFileId(v string) *BaseFileListInheritPermissionResponse {
	s.FileId = &v
	return s
}

func (s *BaseFileListInheritPermissionResponse) SetMember(v *FilePermissionMember) *BaseFileListInheritPermissionResponse {
	s.Member = v
	return s
}

/**
 *
 */
type BaseFileProcessRequest struct {
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseFileProcessRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseFileProcessRequest) GoString() string {
	return s.String()
}

func (s *BaseFileProcessRequest) SetImageCroppingAspectRatios(v []*string) *BaseFileProcessRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *BaseFileProcessRequest) SetImageThumbnailProcess(v string) *BaseFileProcessRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *BaseFileProcessRequest) SetImageUrlProcess(v string) *BaseFileProcessRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *BaseFileProcessRequest) SetOfficeThumbnailProcess(v string) *BaseFileProcessRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *BaseFileProcessRequest) SetVideoThumbnailProcess(v string) *BaseFileProcessRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * /
 */
type BaseFileUserPermissionResponse struct {
	// 
	CanAccess *bool `json:"can_access,omitempty" xml:"can_access,omitempty" require:"true"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// UserID
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty" require:"true"`
	// 
	DisinheritSubGroup *bool `json:"disinherit_sub_group,omitempty" xml:"disinherit_sub_group,omitempty" require:"true"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// driveID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// 
	ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
	// ID
	FileFullPath *string `json:"file_full_path,omitempty" xml:"file_full_path,omitempty" require:"true"`
	// ID
	FileId   *string   `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	Identity *Identity `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty" require:"true"`
}

func (s BaseFileUserPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseFileUserPermissionResponse) GoString() string {
	return s.String()
}

func (s *BaseFileUserPermissionResponse) SetCanAccess(v bool) *BaseFileUserPermissionResponse {
	s.CanAccess = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetCreatedAt(v int64) *BaseFileUserPermissionResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetCreator(v string) *BaseFileUserPermissionResponse {
	s.Creator = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetDisinheritSubGroup(v bool) *BaseFileUserPermissionResponse {
	s.DisinheritSubGroup = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetDomainId(v string) *BaseFileUserPermissionResponse {
	s.DomainId = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetDriveId(v string) *BaseFileUserPermissionResponse {
	s.DriveId = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetExpireTime(v int64) *BaseFileUserPermissionResponse {
	s.ExpireTime = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetFileFullPath(v string) *BaseFileUserPermissionResponse {
	s.FileFullPath = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetFileId(v string) *BaseFileUserPermissionResponse {
	s.FileId = &v
	return s
}

func (s *BaseFileUserPermissionResponse) SetIdentity(v *Identity) *BaseFileUserPermissionResponse {
	s.Identity = v
	return s
}

func (s *BaseFileUserPermissionResponse) SetRoleId(v string) *BaseFileUserPermissionResponse {
	s.RoleId = &v
	return s
}

/**
 * URL
 */
type BaseGetUploadUrlRequest struct {
	// content_md5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// upload_part_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s BaseGetUploadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseGetUploadUrlRequest) GoString() string {
	return s.String()
}

func (s *BaseGetUploadUrlRequest) SetContentMd5(v string) *BaseGetUploadUrlRequest {
	s.ContentMd5 = &v
	return s
}

func (s *BaseGetUploadUrlRequest) SetDriveId(v string) *BaseGetUploadUrlRequest {
	s.DriveId = &v
	return s
}

func (s *BaseGetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *BaseGetUploadUrlRequest {
	s.PartInfoList = v
	return s
}

func (s *BaseGetUploadUrlRequest) SetShareId(v string) *BaseGetUploadUrlRequest {
	s.ShareId = &v
	return s
}

func (s *BaseGetUploadUrlRequest) SetUploadId(v string) *BaseGetUploadUrlRequest {
	s.UploadId = &v
	return s
}

/**
 * Base file response
 */
type BaseHostingFileResponse struct {
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s BaseHostingFileResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseHostingFileResponse) GoString() string {
	return s.String()
}

func (s *BaseHostingFileResponse) SetContentHash(v string) *BaseHostingFileResponse {
	s.ContentHash = &v
	return s
}

func (s *BaseHostingFileResponse) SetContentHashName(v string) *BaseHostingFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *BaseHostingFileResponse) SetContentType(v string) *BaseHostingFileResponse {
	s.ContentType = &v
	return s
}

func (s *BaseHostingFileResponse) SetCrc64Hash(v string) *BaseHostingFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *BaseHostingFileResponse) SetCreatedAt(v string) *BaseHostingFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseHostingFileResponse) SetDescription(v string) *BaseHostingFileResponse {
	s.Description = &v
	return s
}

func (s *BaseHostingFileResponse) SetDomainId(v string) *BaseHostingFileResponse {
	s.DomainId = &v
	return s
}

func (s *BaseHostingFileResponse) SetDownloadUrl(v string) *BaseHostingFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *BaseHostingFileResponse) SetDriveId(v string) *BaseHostingFileResponse {
	s.DriveId = &v
	return s
}

func (s *BaseHostingFileResponse) SetFileExtension(v string) *BaseHostingFileResponse {
	s.FileExtension = &v
	return s
}

func (s *BaseHostingFileResponse) SetFilePath(v string) *BaseHostingFileResponse {
	s.FilePath = &v
	return s
}

func (s *BaseHostingFileResponse) SetName(v string) *BaseHostingFileResponse {
	s.Name = &v
	return s
}

func (s *BaseHostingFileResponse) SetParentFilePath(v string) *BaseHostingFileResponse {
	s.ParentFilePath = &v
	return s
}

func (s *BaseHostingFileResponse) SetShareId(v string) *BaseHostingFileResponse {
	s.ShareId = &v
	return s
}

func (s *BaseHostingFileResponse) SetSize(v int64) *BaseHostingFileResponse {
	s.Size = &v
	return s
}

func (s *BaseHostingFileResponse) SetStatus(v string) *BaseHostingFileResponse {
	s.Status = &v
	return s
}

func (s *BaseHostingFileResponse) SetThumbnail(v string) *BaseHostingFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *BaseHostingFileResponse) SetTrashedAt(v string) *BaseHostingFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *BaseHostingFileResponse) SetType(v string) *BaseHostingFileResponse {
	s.Type = &v
	return s
}

func (s *BaseHostingFileResponse) SetUpdatedAt(v string) *BaseHostingFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseHostingFileResponse) SetUploadId(v string) *BaseHostingFileResponse {
	s.UploadId = &v
	return s
}

func (s *BaseHostingFileResponse) SetUrl(v string) *BaseHostingFileResponse {
	s.Url = &v
	return s
}

/**
 * Base image process
 */
type BaseImageProcessRequest struct {
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseImageProcessRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseImageProcessRequest) GoString() string {
	return s.String()
}

func (s *BaseImageProcessRequest) SetImageThumbnailProcess(v string) *BaseImageProcessRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *BaseImageProcessRequest) SetImageUrlProcess(v string) *BaseImageProcessRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *BaseImageProcessRequest) SetOfficeThumbnailProcess(v string) *BaseImageProcessRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *BaseImageProcessRequest) SetVideoThumbnailProcess(v string) *BaseImageProcessRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * list file request
 */
type BaseListFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId                   *string   `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s BaseListFileRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseListFileRequest) GoString() string {
	return s.String()
}

func (s *BaseListFileRequest) SetAdditionData(v map[string]interface{}) *BaseListFileRequest {
	s.AdditionData = v
	return s
}

func (s *BaseListFileRequest) SetDriveId(v string) *BaseListFileRequest {
	s.DriveId = &v
	return s
}

func (s *BaseListFileRequest) SetImageCroppingAspectRatios(v []*string) *BaseListFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *BaseListFileRequest) SetImageThumbnailProcess(v string) *BaseListFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *BaseListFileRequest) SetImageUrlProcess(v string) *BaseListFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *BaseListFileRequest) SetLimit(v int64) *BaseListFileRequest {
	s.Limit = &v
	return s
}

func (s *BaseListFileRequest) SetMarker(v string) *BaseListFileRequest {
	s.Marker = &v
	return s
}

func (s *BaseListFileRequest) SetOfficeThumbnailProcess(v string) *BaseListFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *BaseListFileRequest) SetReferer(v string) *BaseListFileRequest {
	s.Referer = &v
	return s
}

func (s *BaseListFileRequest) SetShareId(v string) *BaseListFileRequest {
	s.ShareId = &v
	return s
}

func (s *BaseListFileRequest) SetSignToken(v string) *BaseListFileRequest {
	s.SignToken = &v
	return s
}

func (s *BaseListFileRequest) SetVideoThumbnailProcess(v string) *BaseListFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 *
 */
type BaseMediaResponse struct {
	// address_line
	AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
	// city
	City *string `json:"city,omitempty" xml:"city,omitempty"`
	// country
	Country *string `json:"country,omitempty" xml:"country,omitempty"`
	// district
	District *string `json:"district,omitempty" xml:"district,omitempty"`
	// height
	Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
	// system_tags
	ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// province
	Province *string `json:"province,omitempty" xml:"province,omitempty"`
	// time
	Time *string `json:"time,omitempty" xml:"time,omitempty"`
	// township
	Township *string `json:"township,omitempty" xml:"township,omitempty"`
	// width
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s BaseMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseMediaResponse) GoString() string {
	return s.String()
}

func (s *BaseMediaResponse) SetAddressLine(v string) *BaseMediaResponse {
	s.AddressLine = &v
	return s
}

func (s *BaseMediaResponse) SetCity(v string) *BaseMediaResponse {
	s.City = &v
	return s
}

func (s *BaseMediaResponse) SetCountry(v string) *BaseMediaResponse {
	s.Country = &v
	return s
}

func (s *BaseMediaResponse) SetDistrict(v string) *BaseMediaResponse {
	s.District = &v
	return s
}

func (s *BaseMediaResponse) SetHeight(v int64) *BaseMediaResponse {
	s.Height = &v
	return s
}

func (s *BaseMediaResponse) SetImageTags(v []*SystemTag) *BaseMediaResponse {
	s.ImageTags = v
	return s
}

func (s *BaseMediaResponse) SetLocation(v string) *BaseMediaResponse {
	s.Location = &v
	return s
}

func (s *BaseMediaResponse) SetProvince(v string) *BaseMediaResponse {
	s.Province = &v
	return s
}

func (s *BaseMediaResponse) SetTime(v string) *BaseMediaResponse {
	s.Time = &v
	return s
}

func (s *BaseMediaResponse) SetTownship(v string) *BaseMediaResponse {
	s.Township = &v
	return s
}

func (s *BaseMediaResponse) SetWidth(v int64) *BaseMediaResponse {
	s.Width = &v
	return s
}

/**
 * 
 */
type BaseMoveFileRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s BaseMoveFileRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseMoveFileRequest) GoString() string {
	return s.String()
}

func (s *BaseMoveFileRequest) SetDriveId(v string) *BaseMoveFileRequest {
	s.DriveId = &v
	return s
}

func (s *BaseMoveFileRequest) SetNewName(v string) *BaseMoveFileRequest {
	s.NewName = &v
	return s
}

func (s *BaseMoveFileRequest) SetShareId(v string) *BaseMoveFileRequest {
	s.ShareId = &v
	return s
}

/**
 * list_share_link response
 */
type BaseShareLinkResponse struct {
	// access_count
	AccessCount *int64 `json:"access_count,omitempty" xml:"access_count,omitempty"`
	// Category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// file_list
	DriveFileList []*ShareFile `json:"drive_file_list,omitempty" xml:"drive_file_list,omitempty" type:"Repeated"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// enable_file_changed_notify
	EnableFileChangedNotify *bool `json:"enable_file_changed_notify,omitempty" xml:"enable_file_changed_notify,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// file_id_list
	FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
	// file_id_list
	FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
	// is_subscribed
	IsSubscribed *bool `json:"is_subscribed,omitempty" xml:"is_subscribed,omitempty"`
	// num_of_subscribers
	NumOfSubscribers *int64 `json:"num_of_subscribers,omitempty" xml:"num_of_subscribers,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// 
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_msg
	ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_policy
	SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
	// share_url
	ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
	// ViewID
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s BaseShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseShareLinkResponse) GoString() string {
	return s.String()
}

func (s *BaseShareLinkResponse) SetAccessCount(v int64) *BaseShareLinkResponse {
	s.AccessCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetCategory(v string) *BaseShareLinkResponse {
	s.Category = &v
	return s
}

func (s *BaseShareLinkResponse) SetComments(v string) *BaseShareLinkResponse {
	s.Comments = &v
	return s
}

func (s *BaseShareLinkResponse) SetCreatedAt(v string) *BaseShareLinkResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseShareLinkResponse) SetCreator(v string) *BaseShareLinkResponse {
	s.Creator = &v
	return s
}

func (s *BaseShareLinkResponse) SetDescription(v string) *BaseShareLinkResponse {
	s.Description = &v
	return s
}

func (s *BaseShareLinkResponse) SetDisableDownload(v bool) *BaseShareLinkResponse {
	s.DisableDownload = &v
	return s
}

func (s *BaseShareLinkResponse) SetDisablePreview(v bool) *BaseShareLinkResponse {
	s.DisablePreview = &v
	return s
}

func (s *BaseShareLinkResponse) SetDisableSave(v bool) *BaseShareLinkResponse {
	s.DisableSave = &v
	return s
}

func (s *BaseShareLinkResponse) SetDownloadCount(v int64) *BaseShareLinkResponse {
	s.DownloadCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetDownloadLimit(v int64) *BaseShareLinkResponse {
	s.DownloadLimit = &v
	return s
}

func (s *BaseShareLinkResponse) SetDriveFileList(v []*ShareFile) *BaseShareLinkResponse {
	s.DriveFileList = v
	return s
}

func (s *BaseShareLinkResponse) SetDriveId(v string) *BaseShareLinkResponse {
	s.DriveId = &v
	return s
}

func (s *BaseShareLinkResponse) SetEnableFileChangedNotify(v bool) *BaseShareLinkResponse {
	s.EnableFileChangedNotify = &v
	return s
}

func (s *BaseShareLinkResponse) SetExpiration(v string) *BaseShareLinkResponse {
	s.Expiration = &v
	return s
}

func (s *BaseShareLinkResponse) SetExpired(v bool) *BaseShareLinkResponse {
	s.Expired = &v
	return s
}

func (s *BaseShareLinkResponse) SetFileId(v string) *BaseShareLinkResponse {
	s.FileId = &v
	return s
}

func (s *BaseShareLinkResponse) SetFileIdList(v []*string) *BaseShareLinkResponse {
	s.FileIdList = v
	return s
}

func (s *BaseShareLinkResponse) SetFilePathList(v []*string) *BaseShareLinkResponse {
	s.FilePathList = v
	return s
}

func (s *BaseShareLinkResponse) SetIsSubscribed(v bool) *BaseShareLinkResponse {
	s.IsSubscribed = &v
	return s
}

func (s *BaseShareLinkResponse) SetNumOfSubscribers(v int64) *BaseShareLinkResponse {
	s.NumOfSubscribers = &v
	return s
}

func (s *BaseShareLinkResponse) SetPreviewCount(v int64) *BaseShareLinkResponse {
	s.PreviewCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetPreviewLimit(v int64) *BaseShareLinkResponse {
	s.PreviewLimit = &v
	return s
}

func (s *BaseShareLinkResponse) SetReportCount(v int64) *BaseShareLinkResponse {
	s.ReportCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetRequireLogin(v bool) *BaseShareLinkResponse {
	s.RequireLogin = &v
	return s
}

func (s *BaseShareLinkResponse) SetSaveCount(v int64) *BaseShareLinkResponse {
	s.SaveCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetSaveDownloadLimit(v int64) *BaseShareLinkResponse {
	s.SaveDownloadLimit = &v
	return s
}

func (s *BaseShareLinkResponse) SetSaveLimit(v int64) *BaseShareLinkResponse {
	s.SaveLimit = &v
	return s
}

func (s *BaseShareLinkResponse) SetShareIcon(v string) *BaseShareLinkResponse {
	s.ShareIcon = &v
	return s
}

func (s *BaseShareLinkResponse) SetShareId(v string) *BaseShareLinkResponse {
	s.ShareId = &v
	return s
}

func (s *BaseShareLinkResponse) SetShareMsg(v string) *BaseShareLinkResponse {
	s.ShareMsg = &v
	return s
}

func (s *BaseShareLinkResponse) SetShareName(v string) *BaseShareLinkResponse {
	s.ShareName = &v
	return s
}

func (s *BaseShareLinkResponse) SetSharePolicy(v string) *BaseShareLinkResponse {
	s.SharePolicy = &v
	return s
}

func (s *BaseShareLinkResponse) SetSharePwd(v string) *BaseShareLinkResponse {
	s.SharePwd = &v
	return s
}

func (s *BaseShareLinkResponse) SetShareUrl(v string) *BaseShareLinkResponse {
	s.ShareUrl = &v
	return s
}

func (s *BaseShareLinkResponse) SetStatus(v string) *BaseShareLinkResponse {
	s.Status = &v
	return s
}

func (s *BaseShareLinkResponse) SetUpdatedAt(v string) *BaseShareLinkResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseShareLinkResponse) SetVideoPreviewCount(v int64) *BaseShareLinkResponse {
	s.VideoPreviewCount = &v
	return s
}

func (s *BaseShareLinkResponse) SetViewId(v string) *BaseShareLinkResponse {
	s.ViewId = &v
	return s
}

/**
 * List share response
 */
type BaseShareResponse struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// share_file_id
	ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
	// share_path
	ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_name
	ShareName   *string                  `json:"share_name,omitempty" xml:"share_name,omitempty"`
	SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseShareResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseShareResponse) GoString() string {
	return s.String()
}

func (s *BaseShareResponse) SetCreatedAt(v string) *BaseShareResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseShareResponse) SetCreator(v string) *BaseShareResponse {
	s.Creator = &v
	return s
}

func (s *BaseShareResponse) SetDescription(v string) *BaseShareResponse {
	s.Description = &v
	return s
}

func (s *BaseShareResponse) SetDomainId(v string) *BaseShareResponse {
	s.DomainId = &v
	return s
}

func (s *BaseShareResponse) SetDriveId(v string) *BaseShareResponse {
	s.DriveId = &v
	return s
}

func (s *BaseShareResponse) SetExpiration(v string) *BaseShareResponse {
	s.Expiration = &v
	return s
}

func (s *BaseShareResponse) SetExpired(v bool) *BaseShareResponse {
	s.Expired = &v
	return s
}

func (s *BaseShareResponse) SetOwner(v string) *BaseShareResponse {
	s.Owner = &v
	return s
}

func (s *BaseShareResponse) SetOwnerType(v string) *BaseShareResponse {
	s.OwnerType = &v
	return s
}

func (s *BaseShareResponse) SetPermissions(v []*string) *BaseShareResponse {
	s.Permissions = v
	return s
}

func (s *BaseShareResponse) SetShareFileId(v string) *BaseShareResponse {
	s.ShareFileId = &v
	return s
}

func (s *BaseShareResponse) SetShareFilePath(v string) *BaseShareResponse {
	s.ShareFilePath = &v
	return s
}

func (s *BaseShareResponse) SetShareId(v string) *BaseShareResponse {
	s.ShareId = &v
	return s
}

func (s *BaseShareResponse) SetShareName(v string) *BaseShareResponse {
	s.ShareName = &v
	return s
}

func (s *BaseShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *BaseShareResponse {
	s.SharePolicy = v
	return s
}

func (s *BaseShareResponse) SetStatus(v string) *BaseShareResponse {
	s.Status = &v
	return s
}

func (s *BaseShareResponse) SetUpdatedAt(v string) *BaseShareResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type BaseSortShareLinkRequest struct {
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
}

func (s BaseSortShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseSortShareLinkRequest) GoString() string {
	return s.String()
}

func (s *BaseSortShareLinkRequest) SetOrderBy(v string) *BaseSortShareLinkRequest {
	s.OrderBy = &v
	return s
}

func (s *BaseSortShareLinkRequest) SetOrderDirection(v string) *BaseSortShareLinkRequest {
	s.OrderDirection = &v
	return s
}

/**
 * user_tags 
 */
type BaseUserTagsRequest struct {
	// user_tags
	UserTags []*UserTag `json:"user_tags,omitempty" xml:"user_tags,omitempty" type:"Repeated"`
}

func (s BaseUserTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseUserTagsRequest) GoString() string {
	return s.String()
}

func (s *BaseUserTagsRequest) SetUserTags(v []*UserTag) *BaseUserTagsRequest {
	s.UserTags = v
	return s
}

/**
 * 
 */
type BatchRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// Requests 
	Requests []*BatchSubRequest `json:"requests,omitempty" xml:"requests,omitempty" require:"true" type:"Repeated"`
	// 
	Resource *string `json:"resource,omitempty" xml:"resource,omitempty" require:"true"`
}

func (s BatchRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchRequest) GoString() string {
	return s.String()
}

func (s *BatchRequest) SetHttpheaders(v map[string]*string) *BatchRequest {
	s.Httpheaders = v
	return s
}

func (s *BatchRequest) SetRequests(v []*BatchSubRequest) *BatchRequest {
	s.Requests = v
	return s
}

func (s *BatchRequest) SetResource(v string) *BatchRequest {
	s.Resource = &v
	return s
}

/**
 * batch operation response
 */
type BatchResponse struct {
	// responses 
	Responses []*BatchSubResponse `json:"responses,omitempty" xml:"responses,omitempty" type:"Repeated"`
}

func (s BatchResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchResponse) GoString() string {
	return s.String()
}

func (s *BatchResponse) SetResponses(v []*BatchSubResponse) *BatchResponse {
	s.Responses = v
	return s
}

/**
 *
 */
type BatchSubRequest struct {
	// body  json , body headers  "Content-Type" "application/json"
	Body map[string]interface{} `json:"body,omitempty" xml:"body,omitempty"`
	// headers body
	Headers map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
	// id request  response 
	Id *string `json:"id,omitempty" xml:"id,omitempty" require:"true"`
	// method
	Method *string `json:"method,omitempty" xml:"method,omitempty" require:"true"`
	// url api path 
	Url *string `json:"url,omitempty" xml:"url,omitempty" require:"true"`
}

func (s BatchSubRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSubRequest) GoString() string {
	return s.String()
}

func (s *BatchSubRequest) SetBody(v map[string]interface{}) *BatchSubRequest {
	s.Body = v
	return s
}

func (s *BatchSubRequest) SetHeaders(v map[string]interface{}) *BatchSubRequest {
	s.Headers = v
	return s
}

func (s *BatchSubRequest) SetId(v string) *BatchSubRequest {
	s.Id = &v
	return s
}

func (s *BatchSubRequest) SetMethod(v string) *BatchSubRequest {
	s.Method = &v
	return s
}

func (s *BatchSubRequest) SetUrl(v string) *BatchSubRequest {
	s.Url = &v
	return s
}

/**
 *
 */
type BatchSubResponse struct {
	// body  json 
	Body map[string]interface{} `json:"body,omitempty" xml:"body,omitempty"`
	// id id,  request 
	Id *string `json:"id,omitempty" xml:"id,omitempty"`
	// status 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
}

func (s BatchSubResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSubResponse) GoString() string {
	return s.String()
}

func (s *BatchSubResponse) SetBody(v map[string]interface{}) *BatchSubResponse {
	s.Body = v
	return s
}

func (s *BatchSubResponse) SetId(v string) *BatchSubResponse {
	s.Id = &v
	return s
}

func (s *BatchSubResponse) SetStatus(v int64) *BatchSubResponse {
	s.Status = &v
	return s
}

/**
 * 
 */
type CCPArchiveFilesRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string     `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	Files   []*FileInfo `json:"files,omitempty" xml:"files,omitempty" type:"Repeated"`
	// file_name
	Name    *string `json:"name,omitempty" xml:"name,omitempty" maxLength:"1024" minLength:"1"`
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CCPArchiveFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPArchiveFilesRequest) GoString() string {
	return s.String()
}

func (s *CCPArchiveFilesRequest) SetHttpheaders(v map[string]*string) *CCPArchiveFilesRequest {
	s.Httpheaders = v
	return s
}

func (s *CCPArchiveFilesRequest) SetAdditionData(v map[string]interface{}) *CCPArchiveFilesRequest {
	s.AdditionData = v
	return s
}

func (s *CCPArchiveFilesRequest) SetDriveId(v string) *CCPArchiveFilesRequest {
	s.DriveId = &v
	return s
}

func (s *CCPArchiveFilesRequest) SetFiles(v []*FileInfo) *CCPArchiveFilesRequest {
	s.Files = v
	return s
}

func (s *CCPArchiveFilesRequest) SetName(v string) *CCPArchiveFilesRequest {
	s.Name = &v
	return s
}

func (s *CCPArchiveFilesRequest) SetReferer(v string) *CCPArchiveFilesRequest {
	s.Referer = &v
	return s
}

func (s *CCPArchiveFilesRequest) SetShareId(v string) *CCPArchiveFilesRequest {
	s.ShareId = &v
	return s
}

/**
 * response
 */
type CCPArchiveFilesResponse struct {
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s CCPArchiveFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPArchiveFilesResponse) GoString() string {
	return s.String()
}

func (s *CCPArchiveFilesResponse) SetAsyncTaskId(v string) *CCPArchiveFilesResponse {
	s.AsyncTaskId = &v
	return s
}

/**
 *
 */
type CCPArchiveRequest struct {
	// uc
	Format      *string `json:"Format,omitempty" xml:"Format,omitempty"`
	RequestID   *string `json:"RequestID,omitempty" xml:"RequestID,omitempty"`
	ArchiveType *string `json:"archive_type,omitempty" xml:"archive_type,omitempty"`
	DomainId    *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// TODO ShareID
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId   *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
}

func (s CCPArchiveRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPArchiveRequest) GoString() string {
	return s.String()
}

func (s *CCPArchiveRequest) SetFormat(v string) *CCPArchiveRequest {
	s.Format = &v
	return s
}

func (s *CCPArchiveRequest) SetRequestID(v string) *CCPArchiveRequest {
	s.RequestID = &v
	return s
}

func (s *CCPArchiveRequest) SetArchiveType(v string) *CCPArchiveRequest {
	s.ArchiveType = &v
	return s
}

func (s *CCPArchiveRequest) SetDomainId(v string) *CCPArchiveRequest {
	s.DomainId = &v
	return s
}

func (s *CCPArchiveRequest) SetDriveId(v string) *CCPArchiveRequest {
	s.DriveId = &v
	return s
}

func (s *CCPArchiveRequest) SetFileId(v string) *CCPArchiveRequest {
	s.FileId = &v
	return s
}

func (s *CCPArchiveRequest) SetPassword(v string) *CCPArchiveRequest {
	s.Password = &v
	return s
}

/**
 *
 */
type CCPArchiveResponse struct {
	State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s CCPArchiveResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPArchiveResponse) GoString() string {
	return s.String()
}

func (s *CCPArchiveResponse) SetState(v string) *CCPArchiveResponse {
	s.State = &v
	return s
}

/**
 * size
 */
type CCPGetDirSizeInfoRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	// share_id, either share_id or drive_id is required
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CCPGetDirSizeInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPGetDirSizeInfoRequest) GoString() string {
	return s.String()
}

func (s *CCPGetDirSizeInfoRequest) SetDriveId(v string) *CCPGetDirSizeInfoRequest {
	s.DriveId = &v
	return s
}

func (s *CCPGetDirSizeInfoRequest) SetFileId(v string) *CCPGetDirSizeInfoRequest {
	s.FileId = &v
	return s
}

func (s *CCPGetDirSizeInfoRequest) SetShareId(v string) *CCPGetDirSizeInfoRequest {
	s.ShareId = &v
	return s
}

/**
 * 
 */
type CCPGetFolderInfoRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
}

func (s CCPGetFolderInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPGetFolderInfoRequest) GoString() string {
	return s.String()
}

func (s *CCPGetFolderInfoRequest) SetDriveId(v string) *CCPGetFolderInfoRequest {
	s.DriveId = &v
	return s
}

func (s *CCPGetFolderInfoRequest) SetFileId(v string) *CCPGetFolderInfoRequest {
	s.FileId = &v
	return s
}

/**
 * 
 */
type CCPGetFolderInfoResponse struct {
	// total_size
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// used_size
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s CCPGetFolderInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPGetFolderInfoResponse) GoString() string {
	return s.String()
}

func (s *CCPGetFolderInfoResponse) SetTotalSize(v int64) *CCPGetFolderInfoResponse {
	s.TotalSize = &v
	return s
}

func (s *CCPGetFolderInfoResponse) SetUsedSize(v int64) *CCPGetFolderInfoResponse {
	s.UsedSize = &v
	return s
}

/**
 * body
 */
type CCPGetShareLinkVideoPreviewPlayInfoRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// get_preview_url
	GetPreviewUrl *bool `json:"get_preview_url,omitempty" xml:"get_preview_url,omitempty"`
	// get_subtitle_info
	GetSubtitleInfo *bool `json:"get_subtitle_info,omitempty" xml:"get_subtitle_info,omitempty"`
	// get_without_url
	GetWithoutUrl *bool `json:"get_without_url,omitempty" xml:"get_without_url,omitempty"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// subtitle_language_list, , 
	SubtitleLanguageList []*string `json:"subtitle_language_list,omitempty" xml:"subtitle_language_list,omitempty" type:"Repeated"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"600" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s CCPGetShareLinkVideoPreviewPlayInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPGetShareLinkVideoPreviewPlayInfoRequest) GoString() string {
	return s.String()
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetHttpheaders(v map[string]*string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.Httpheaders = v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetAdditionData(v map[string]interface{}) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.AdditionData = v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetCategory(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.Category = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetDriveId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.DriveId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetFileId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.FileId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetFileIdPath(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.FileIdPath = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetGetPreviewUrl(v bool) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.GetPreviewUrl = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetGetSubtitleInfo(v bool) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.GetSubtitleInfo = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetGetWithoutUrl(v bool) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.GetWithoutUrl = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetImageThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetImageUrlProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetLocation(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.Location = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetOfficeThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetReferer(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.Referer = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetShareId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.ShareId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetSignToken(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.SignToken = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetSubtitleLanguageList(v []*string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.SubtitleLanguageList = v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetTemplateId(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.TemplateId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetUrlExpireSec(v int64) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoRequest) SetVideoThumbnailProcess(v string) *CCPGetShareLinkVideoPreviewPlayInfoRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type CCPGetShareLinkVideoPreviewPlayInfoResponse struct {
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId              *string                       `json:"share_id,omitempty" xml:"share_id,omitempty"`
	VideoPreviewPlayInfo *VideoPreviewPlayInfoResponse `json:"video_preview_play_info,omitempty" xml:"video_preview_play_info,omitempty"`
}

func (s CCPGetShareLinkVideoPreviewPlayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPGetShareLinkVideoPreviewPlayInfoResponse) GoString() string {
	return s.String()
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetFileId(v string) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
	s.FileId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetShareId(v string) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
	s.ShareId = &v
	return s
}

func (s *CCPGetShareLinkVideoPreviewPlayInfoResponse) SetVideoPreviewPlayInfo(v *VideoPreviewPlayInfoResponse) *CCPGetShareLinkVideoPreviewPlayInfoResponse {
	s.VideoPreviewPlayInfo = v
	return s
}

/**
 * 
 */
type CCPGetVideoPreviewPlayInfoRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// get_preview_url
	GetPreviewUrl *bool `json:"get_preview_url,omitempty" xml:"get_preview_url,omitempty"`
	// get_subtitle_info
	GetSubtitleInfo *bool `json:"get_subtitle_info,omitempty" xml:"get_subtitle_info,omitempty"`
	// get_without_url
	GetWithoutUrl *bool `json:"get_without_url,omitempty" xml:"get_without_url,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	Referer  *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// subtitle_language_list, , 
	SubtitleLanguageList []*string `json:"subtitle_language_list,omitempty" xml:"subtitle_language_list,omitempty" type:"Repeated"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
}

func (s CCPGetVideoPreviewPlayInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPGetVideoPreviewPlayInfoRequest) GoString() string {
	return s.String()
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetHttpheaders(v map[string]*string) *CCPGetVideoPreviewPlayInfoRequest {
	s.Httpheaders = v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetAdditionData(v map[string]interface{}) *CCPGetVideoPreviewPlayInfoRequest {
	s.AdditionData = v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetCategory(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.Category = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetDriveId(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.DriveId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetFileId(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.FileId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetFileIdPath(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.FileIdPath = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetGetPreviewUrl(v bool) *CCPGetVideoPreviewPlayInfoRequest {
	s.GetPreviewUrl = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetGetSubtitleInfo(v bool) *CCPGetVideoPreviewPlayInfoRequest {
	s.GetSubtitleInfo = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetGetWithoutUrl(v bool) *CCPGetVideoPreviewPlayInfoRequest {
	s.GetWithoutUrl = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetLocation(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.Location = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetReferer(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.Referer = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetShareId(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.ShareId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetSignToken(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.SignToken = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetSubtitleLanguageList(v []*string) *CCPGetVideoPreviewPlayInfoRequest {
	s.SubtitleLanguageList = v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetTemplateId(v string) *CCPGetVideoPreviewPlayInfoRequest {
	s.TemplateId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoRequest) SetUrlExpireSec(v int64) *CCPGetVideoPreviewPlayInfoRequest {
	s.UrlExpireSec = &v
	return s
}

/**
 * 
 */
type CCPGetVideoPreviewPlayInfoResponse struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId              *string                       `json:"share_id,omitempty" xml:"share_id,omitempty"`
	VideoPreviewPlayInfo *VideoPreviewPlayInfoResponse `json:"video_preview_play_info,omitempty" xml:"video_preview_play_info,omitempty"`
}

func (s CCPGetVideoPreviewPlayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPGetVideoPreviewPlayInfoResponse) GoString() string {
	return s.String()
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetDomainId(v string) *CCPGetVideoPreviewPlayInfoResponse {
	s.DomainId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetDriveId(v string) *CCPGetVideoPreviewPlayInfoResponse {
	s.DriveId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetFileId(v string) *CCPGetVideoPreviewPlayInfoResponse {
	s.FileId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetShareId(v string) *CCPGetVideoPreviewPlayInfoResponse {
	s.ShareId = &v
	return s
}

func (s *CCPGetVideoPreviewPlayInfoResponse) SetVideoPreviewPlayInfo(v *VideoPreviewPlayInfoResponse) *CCPGetVideoPreviewPlayInfoResponse {
	s.VideoPreviewPlayInfo = v
	return s
}

/**
 * 
 */
type CCPLiveTranscodeRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// object_path
	ObjectPath *string `json:"object_path,omitempty" xml:"object_path,omitempty"`
}

func (s CCPLiveTranscodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPLiveTranscodeRequest) GoString() string {
	return s.String()
}

func (s *CCPLiveTranscodeRequest) SetHttpheaders(v map[string]*string) *CCPLiveTranscodeRequest {
	s.Httpheaders = v
	return s
}

func (s *CCPLiveTranscodeRequest) SetAdditionData(v map[string]interface{}) *CCPLiveTranscodeRequest {
	s.AdditionData = v
	return s
}

func (s *CCPLiveTranscodeRequest) SetObjectPath(v string) *CCPLiveTranscodeRequest {
	s.ObjectPath = &v
	return s
}

/**
 * CCPLiveTranscodeResponse
 */
type CCPLiveTranscodeResponse struct {
}

func (s CCPLiveTranscodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPLiveTranscodeResponse) GoString() string {
	return s.String()
}

/**
 * 
 */
type CCPWalkFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// all
	All *bool `json:"all,omitempty" xml:"all,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// ParentFileID
	ParentFileId     *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
	ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
	Referer          *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// starred
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s CCPWalkFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CCPWalkFileRequest) GoString() string {
	return s.String()
}

func (s *CCPWalkFileRequest) SetHttpheaders(v map[string]*string) *CCPWalkFileRequest {
	s.Httpheaders = v
	return s
}

func (s *CCPWalkFileRequest) SetAdditionData(v map[string]interface{}) *CCPWalkFileRequest {
	s.AdditionData = v
	return s
}

func (s *CCPWalkFileRequest) SetAll(v bool) *CCPWalkFileRequest {
	s.All = &v
	return s
}

func (s *CCPWalkFileRequest) SetCategory(v string) *CCPWalkFileRequest {
	s.Category = &v
	return s
}

func (s *CCPWalkFileRequest) SetDriveId(v string) *CCPWalkFileRequest {
	s.DriveId = &v
	return s
}

func (s *CCPWalkFileRequest) SetFields(v string) *CCPWalkFileRequest {
	s.Fields = &v
	return s
}

func (s *CCPWalkFileRequest) SetImageCroppingAspectRatios(v []*string) *CCPWalkFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *CCPWalkFileRequest) SetImageThumbnailProcess(v string) *CCPWalkFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *CCPWalkFileRequest) SetImageUrlProcess(v string) *CCPWalkFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *CCPWalkFileRequest) SetLimit(v int64) *CCPWalkFileRequest {
	s.Limit = &v
	return s
}

func (s *CCPWalkFileRequest) SetLocation(v string) *CCPWalkFileRequest {
	s.Location = &v
	return s
}

func (s *CCPWalkFileRequest) SetMarker(v string) *CCPWalkFileRequest {
	s.Marker = &v
	return s
}

func (s *CCPWalkFileRequest) SetOfficeThumbnailProcess(v string) *CCPWalkFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *CCPWalkFileRequest) SetOrderBy(v string) *CCPWalkFileRequest {
	s.OrderBy = &v
	return s
}

func (s *CCPWalkFileRequest) SetOrderDirection(v string) *CCPWalkFileRequest {
	s.OrderDirection = &v
	return s
}

func (s *CCPWalkFileRequest) SetParentFileId(v string) *CCPWalkFileRequest {
	s.ParentFileId = &v
	return s
}

func (s *CCPWalkFileRequest) SetParentFileIdPath(v string) *CCPWalkFileRequest {
	s.ParentFileIdPath = &v
	return s
}

func (s *CCPWalkFileRequest) SetReferer(v string) *CCPWalkFileRequest {
	s.Referer = &v
	return s
}

func (s *CCPWalkFileRequest) SetShareId(v string) *CCPWalkFileRequest {
	s.ShareId = &v
	return s
}

func (s *CCPWalkFileRequest) SetSignToken(v string) *CCPWalkFileRequest {
	s.SignToken = &v
	return s
}

func (s *CCPWalkFileRequest) SetStarred(v bool) *CCPWalkFileRequest {
	s.Starred = &v
	return s
}

func (s *CCPWalkFileRequest) SetStatus(v string) *CCPWalkFileRequest {
	s.Status = &v
	return s
}

func (s *CCPWalkFileRequest) SetType(v string) *CCPWalkFileRequest {
	s.Type = &v
	return s
}

func (s *CCPWalkFileRequest) SetUrlExpireSec(v int64) *CCPWalkFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *CCPWalkFileRequest) SetVideoThumbnailProcess(v string) *CCPWalkFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type CCPWalkFileResponse struct {
	// items
	Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	// punished_file_count
	PunishedFileCount *int64 `json:"punished_file_count,omitempty" xml:"punished_file_count,omitempty"`
}

func (s CCPWalkFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CCPWalkFileResponse) GoString() string {
	return s.String()
}

func (s *CCPWalkFileResponse) SetItems(v []*BaseCCPFileResponse) *CCPWalkFileResponse {
	s.Items = v
	return s
}

func (s *CCPWalkFileResponse) SetNextMarker(v string) *CCPWalkFileResponse {
	s.NextMarker = &v
	return s
}

func (s *CCPWalkFileResponse) SetPunishedFileCount(v int64) *CCPWalkFileResponse {
	s.PunishedFileCount = &v
	return s
}

/**
 *
 */
type Callback struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	Url  *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s Callback) String() string {
	return tea.Prettify(s)
}

func (s Callback) GoString() string {
	return s.String()
}

func (s *Callback) SetBody(v string) *Callback {
	s.Body = &v
	return s
}

func (s *Callback) SetUrl(v string) *Callback {
	s.Url = &v
	return s
}

/**
 *
 */
type CancelLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// tokentoken
	TemporaryToken *string `json:"temporary_token,omitempty" xml:"temporary_token,omitempty" require:"true"`
}

func (s CancelLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelLinkRequest) GoString() string {
	return s.String()
}

func (s *CancelLinkRequest) SetHttpheaders(v map[string]*string) *CancelLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *CancelLinkRequest) SetTemporaryToken(v string) *CancelLinkRequest {
	s.TemporaryToken = &v
	return s
}

/**
 *
 */
type CancelRPVerifyRequest struct {
	// User ID, 
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s CancelRPVerifyRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelRPVerifyRequest) GoString() string {
	return s.String()
}

func (s *CancelRPVerifyRequest) SetUserId(v string) *CancelRPVerifyRequest {
	s.UserId = &v
	return s
}

/**
 * cancel_share_link request
 */
type CancelShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CancelShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelShareLinkRequest) GoString() string {
	return s.String()
}

func (s *CancelShareLinkRequest) SetHttpheaders(v map[string]*string) *CancelShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *CancelShareLinkRequest) SetShareId(v string) *CancelShareLinkRequest {
	s.ShareId = &v
	return s
}

/**
 *
 */
type Captcha struct {
	// base64
	Captcha *string `json:"captcha,omitempty" xml:"captcha,omitempty" require:"true"`
	// 
	CaptchaFormat *string `json:"captcha_format,omitempty" xml:"captcha_format,omitempty" require:"true"`
	// ID
	CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty" require:"true"`
}

func (s Captcha) String() string {
	return tea.Prettify(s)
}

func (s Captcha) GoString() string {
	return s.String()
}

func (s *Captcha) SetCaptcha(v string) *Captcha {
	s.Captcha = &v
	return s
}

func (s *Captcha) SetCaptchaFormat(v string) *Captcha {
	s.CaptchaFormat = &v
	return s
}

func (s *Captcha) SetCaptchaId(v string) *Captcha {
	s.CaptchaId = &v
	return s
}

/**
 *
 */
type CcpCallback struct {
	Body map[string]interface{} `json:"body,omitempty" xml:"body,omitempty"`
	Url  *string                `json:"url,omitempty" xml:"url,omitempty"`
}

func (s CcpCallback) String() string {
	return tea.Prettify(s)
}

func (s CcpCallback) GoString() string {
	return s.String()
}

func (s *CcpCallback) SetBody(v map[string]interface{}) *CcpCallback {
	s.Body = v
	return s
}

func (s *CcpCallback) SetUrl(v string) *CcpCallback {
	s.Url = &v
	return s
}

/**
 *
 */
type CertInfo struct {
	CertID *string `json:"CertID,omitempty" xml:"CertID,omitempty"`
	// cert body
	CertBody *string `json:"cert_body,omitempty" xml:"cert_body,omitempty" require:"true"`
	// cert name
	CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty" require:"true"`
	// cert privatekey
	CertPrivatekey *string `json:"cert_privatekey,omitempty" xml:"cert_privatekey,omitempty" require:"true"`
}

func (s CertInfo) String() string {
	return tea.Prettify(s)
}

func (s CertInfo) GoString() string {
	return s.String()
}

func (s *CertInfo) SetCertID(v string) *CertInfo {
	s.CertID = &v
	return s
}

func (s *CertInfo) SetCertBody(v string) *CertInfo {
	s.CertBody = &v
	return s
}

func (s *CertInfo) SetCertName(v string) *CertInfo {
	s.CertName = &v
	return s
}

func (s *CertInfo) SetCertPrivatekey(v string) *CertInfo {
	s.CertPrivatekey = &v
	return s
}

/**
 *
 */
type CheckExistRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
}

func (s CheckExistRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckExistRequest) GoString() string {
	return s.String()
}

func (s *CheckExistRequest) SetHttpheaders(v map[string]*string) *CheckExistRequest {
	s.Httpheaders = v
	return s
}

func (s *CheckExistRequest) SetAppId(v string) *CheckExistRequest {
	s.AppId = &v
	return s
}

func (s *CheckExistRequest) SetEmail(v string) *CheckExistRequest {
	s.Email = &v
	return s
}

func (s *CheckExistRequest) SetPhoneNumber(v string) *CheckExistRequest {
	s.PhoneNumber = &v
	return s
}

func (s *CheckExistRequest) SetPhoneRegion(v string) *CheckExistRequest {
	s.PhoneRegion = &v
	return s
}

/**
 *
 */
type CheckExistResponse struct {
	// 
	IsExist *bool `json:"is_exist,omitempty" xml:"is_exist,omitempty" require:"true"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
}

func (s CheckExistResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckExistResponse) GoString() string {
	return s.String()
}

func (s *CheckExistResponse) SetIsExist(v bool) *CheckExistResponse {
	s.IsExist = &v
	return s
}

func (s *CheckExistResponse) SetPhoneNumber(v string) *CheckExistResponse {
	s.PhoneNumber = &v
	return s
}

func (s *CheckExistResponse) SetPhoneRegion(v string) *CheckExistResponse {
	s.PhoneRegion = &v
	return s
}

/**
 * 
 */
type ClearRecycleBinRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
}

func (s ClearRecycleBinRequest) String() string {
	return tea.Prettify(s)
}

func (s ClearRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *ClearRecycleBinRequest) SetHttpheaders(v map[string]*string) *ClearRecycleBinRequest {
	s.Httpheaders = v
	return s
}

func (s *ClearRecycleBinRequest) SetDriveId(v string) *ClearRecycleBinRequest {
	s.DriveId = &v
	return s
}

/**
 * ClearRecycleBinResponse
 */
type ClearRecycleBinResponse struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// task_id
	TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s ClearRecycleBinResponse) String() string {
	return tea.Prettify(s)
}

func (s ClearRecycleBinResponse) GoString() string {
	return s.String()
}

func (s *ClearRecycleBinResponse) SetDomainId(v string) *ClearRecycleBinResponse {
	s.DomainId = &v
	return s
}

func (s *ClearRecycleBinResponse) SetDriveId(v string) *ClearRecycleBinResponse {
	s.DriveId = &v
	return s
}

func (s *ClearRecycleBinResponse) SetTaskId(v string) *ClearRecycleBinResponse {
	s.TaskId = &v
	return s
}

/**
 * 
 */
type CompleteFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s CompleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CompleteFileRequest) GoString() string {
	return s.String()
}

func (s *CompleteFileRequest) SetHttpheaders(v map[string]*string) *CompleteFileRequest {
	s.Httpheaders = v
	return s
}

func (s *CompleteFileRequest) SetAdditionData(v map[string]interface{}) *CompleteFileRequest {
	s.AdditionData = v
	return s
}

func (s *CompleteFileRequest) SetDriveId(v string) *CompleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *CompleteFileRequest) SetFileId(v string) *CompleteFileRequest {
	s.FileId = &v
	return s
}

func (s *CompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *CompleteFileRequest {
	s.PartInfoList = v
	return s
}

func (s *CompleteFileRequest) SetShareId(v string) *CompleteFileRequest {
	s.ShareId = &v
	return s
}

func (s *CompleteFileRequest) SetUploadId(v string) *CompleteFileRequest {
	s.UploadId = &v
	return s
}

/**
 * complete file response
 */
type CompleteFileResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	Meta     *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status          *string                `json:"status,omitempty" xml:"status,omitempty"`
	StreamLocations map[string]interface{} `json:"stream_locations,omitempty" xml:"stream_locations,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s CompleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CompleteFileResponse) GoString() string {
	return s.String()
}

func (s *CompleteFileResponse) SetActionList(v []*string) *CompleteFileResponse {
	s.ActionList = v
	return s
}

func (s *CompleteFileResponse) SetAutoDeleteLeftSec(v int64) *CompleteFileResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *CompleteFileResponse) SetCategory(v string) *CompleteFileResponse {
	s.Category = &v
	return s
}

func (s *CompleteFileResponse) SetCharacteristicHash(v string) *CompleteFileResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *CompleteFileResponse) SetContentHash(v string) *CompleteFileResponse {
	s.ContentHash = &v
	return s
}

func (s *CompleteFileResponse) SetContentHashName(v string) *CompleteFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *CompleteFileResponse) SetContentType(v string) *CompleteFileResponse {
	s.ContentType = &v
	return s
}

func (s *CompleteFileResponse) SetCrc64Hash(v string) *CompleteFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *CompleteFileResponse) SetCreatedAt(v string) *CompleteFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *CompleteFileResponse) SetCreatorId(v string) *CompleteFileResponse {
	s.CreatorId = &v
	return s
}

func (s *CompleteFileResponse) SetCreatorName(v string) *CompleteFileResponse {
	s.CreatorName = &v
	return s
}

func (s *CompleteFileResponse) SetCreatorType(v string) *CompleteFileResponse {
	s.CreatorType = &v
	return s
}

func (s *CompleteFileResponse) SetCustomField1(v string) *CompleteFileResponse {
	s.CustomField1 = &v
	return s
}

func (s *CompleteFileResponse) SetCustomField2(v string) *CompleteFileResponse {
	s.CustomField2 = &v
	return s
}

func (s *CompleteFileResponse) SetCustomType(v string) *CompleteFileResponse {
	s.CustomType = &v
	return s
}

func (s *CompleteFileResponse) SetDescription(v string) *CompleteFileResponse {
	s.Description = &v
	return s
}

func (s *CompleteFileResponse) SetDomainId(v string) *CompleteFileResponse {
	s.DomainId = &v
	return s
}

func (s *CompleteFileResponse) SetDownloadUrl(v string) *CompleteFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *CompleteFileResponse) SetDriveId(v string) *CompleteFileResponse {
	s.DriveId = &v
	return s
}

func (s *CompleteFileResponse) SetEncryptMode(v string) *CompleteFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *CompleteFileResponse) SetExFieldsInfo(v map[string]interface{}) *CompleteFileResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *CompleteFileResponse) SetFileExtension(v string) *CompleteFileResponse {
	s.FileExtension = &v
	return s
}

func (s *CompleteFileResponse) SetFileId(v string) *CompleteFileResponse {
	s.FileId = &v
	return s
}

func (s *CompleteFileResponse) SetFilePathType(v string) *CompleteFileResponse {
	s.FilePathType = &v
	return s
}

func (s *CompleteFileResponse) SetHidden(v bool) *CompleteFileResponse {
	s.Hidden = &v
	return s
}

func (s *CompleteFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *CompleteFileResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *CompleteFileResponse) SetLabels(v []*string) *CompleteFileResponse {
	s.Labels = v
	return s
}

func (s *CompleteFileResponse) SetLastModifierId(v string) *CompleteFileResponse {
	s.LastModifierId = &v
	return s
}

func (s *CompleteFileResponse) SetLastModifierName(v string) *CompleteFileResponse {
	s.LastModifierName = &v
	return s
}

func (s *CompleteFileResponse) SetLastModifierType(v string) *CompleteFileResponse {
	s.LastModifierType = &v
	return s
}

func (s *CompleteFileResponse) SetLocalCreatedAt(v string) *CompleteFileResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *CompleteFileResponse) SetLocalModifiedAt(v string) *CompleteFileResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *CompleteFileResponse) SetLocation(v string) *CompleteFileResponse {
	s.Location = &v
	return s
}

func (s *CompleteFileResponse) SetMeta(v string) *CompleteFileResponse {
	s.Meta = &v
	return s
}

func (s *CompleteFileResponse) SetMimeExtension(v string) *CompleteFileResponse {
	s.MimeExtension = &v
	return s
}

func (s *CompleteFileResponse) SetMimeType(v string) *CompleteFileResponse {
	s.MimeType = &v
	return s
}

func (s *CompleteFileResponse) SetName(v string) *CompleteFileResponse {
	s.Name = &v
	return s
}

func (s *CompleteFileResponse) SetParentFileId(v string) *CompleteFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *CompleteFileResponse) SetPunishFlag(v int64) *CompleteFileResponse {
	s.PunishFlag = &v
	return s
}

func (s *CompleteFileResponse) SetRevisionId(v string) *CompleteFileResponse {
	s.RevisionId = &v
	return s
}

func (s *CompleteFileResponse) SetShareId(v string) *CompleteFileResponse {
	s.ShareId = &v
	return s
}

func (s *CompleteFileResponse) SetSize(v int64) *CompleteFileResponse {
	s.Size = &v
	return s
}

func (s *CompleteFileResponse) SetStarred(v bool) *CompleteFileResponse {
	s.Starred = &v
	return s
}

func (s *CompleteFileResponse) SetStatus(v string) *CompleteFileResponse {
	s.Status = &v
	return s
}

func (s *CompleteFileResponse) SetStreamLocations(v map[string]interface{}) *CompleteFileResponse {
	s.StreamLocations = v
	return s
}

func (s *CompleteFileResponse) SetStreamsInfo(v map[string]interface{}) *CompleteFileResponse {
	s.StreamsInfo = v
	return s
}

func (s *CompleteFileResponse) SetSyncDeviceFlag(v bool) *CompleteFileResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *CompleteFileResponse) SetSyncFlag(v bool) *CompleteFileResponse {
	s.SyncFlag = &v
	return s
}

func (s *CompleteFileResponse) SetSyncMeta(v string) *CompleteFileResponse {
	s.SyncMeta = &v
	return s
}

func (s *CompleteFileResponse) SetThumbnail(v string) *CompleteFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *CompleteFileResponse) SetTrashedAt(v string) *CompleteFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *CompleteFileResponse) SetType(v string) *CompleteFileResponse {
	s.Type = &v
	return s
}

func (s *CompleteFileResponse) SetUpdatedAt(v string) *CompleteFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *CompleteFileResponse) SetUploadId(v string) *CompleteFileResponse {
	s.UploadId = &v
	return s
}

func (s *CompleteFileResponse) SetUrl(v string) *CompleteFileResponse {
	s.Url = &v
	return s
}

func (s *CompleteFileResponse) SetUserMeta(v string) *CompleteFileResponse {
	s.UserMeta = &v
	return s
}

func (s *CompleteFileResponse) SetUserTags(v map[string]interface{}) *CompleteFileResponse {
	s.UserTags = v
	return s
}

func (s *CompleteFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *CompleteFileResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *CompleteFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *CompleteFileResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 *
 */
type ConfirmLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// tokentoken
	TemporaryToken *string `json:"temporary_token,omitempty" xml:"temporary_token,omitempty" require:"true"`
}

func (s ConfirmLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfirmLinkRequest) GoString() string {
	return s.String()
}

func (s *ConfirmLinkRequest) SetHttpheaders(v map[string]*string) *ConfirmLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *ConfirmLinkRequest) SetTemporaryToken(v string) *ConfirmLinkRequest {
	s.TemporaryToken = &v
	return s
}

/**
 * 
 */
type CopyFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// auto_rename
	// type: boolean
	AutoRename *bool   `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
	BatchId    *string `json:"batch_id,omitempty" xml:"batch_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// to_drive_id
	ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
	// to_parent_file_id
	ToParentFileId *string `json:"to_parent_file_id,omitempty" xml:"to_parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
	// to_drive_id
	ToShareId *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty" pattern:"[0-9]+"`
}

func (s CopyFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyFileRequest) GoString() string {
	return s.String()
}

func (s *CopyFileRequest) SetHttpheaders(v map[string]*string) *CopyFileRequest {
	s.Httpheaders = v
	return s
}

func (s *CopyFileRequest) SetAdditionData(v map[string]interface{}) *CopyFileRequest {
	s.AdditionData = v
	return s
}

func (s *CopyFileRequest) SetAutoRename(v bool) *CopyFileRequest {
	s.AutoRename = &v
	return s
}

func (s *CopyFileRequest) SetBatchId(v string) *CopyFileRequest {
	s.BatchId = &v
	return s
}

func (s *CopyFileRequest) SetDriveId(v string) *CopyFileRequest {
	s.DriveId = &v
	return s
}

func (s *CopyFileRequest) SetFileId(v string) *CopyFileRequest {
	s.FileId = &v
	return s
}

func (s *CopyFileRequest) SetFileIdPath(v string) *CopyFileRequest {
	s.FileIdPath = &v
	return s
}

func (s *CopyFileRequest) SetNewName(v string) *CopyFileRequest {
	s.NewName = &v
	return s
}

func (s *CopyFileRequest) SetReferer(v string) *CopyFileRequest {
	s.Referer = &v
	return s
}

func (s *CopyFileRequest) SetShareId(v string) *CopyFileRequest {
	s.ShareId = &v
	return s
}

func (s *CopyFileRequest) SetToDriveId(v string) *CopyFileRequest {
	s.ToDriveId = &v
	return s
}

func (s *CopyFileRequest) SetToParentFileId(v string) *CopyFileRequest {
	s.ToParentFileId = &v
	return s
}

func (s *CopyFileRequest) SetToShareId(v string) *CopyFileRequest {
	s.ToShareId = &v
	return s
}

/**
 *  response
 */
type CopyFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s CopyFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyFileResponse) GoString() string {
	return s.String()
}

func (s *CopyFileResponse) SetAsyncTaskId(v string) *CopyFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *CopyFileResponse) SetDomainId(v string) *CopyFileResponse {
	s.DomainId = &v
	return s
}

func (s *CopyFileResponse) SetDriveId(v string) *CopyFileResponse {
	s.DriveId = &v
	return s
}

func (s *CopyFileResponse) SetFileId(v string) *CopyFileResponse {
	s.FileId = &v
	return s
}

/**
 *
 */
type CorsRule struct {
	// AllowedHeader
	AllowedHeader []*string `json:"allowed_header,omitempty" xml:"allowed_header,omitempty" type:"Repeated"`
	// AllowedMethod
	AllowedMethod []*string `json:"allowed_method,omitempty" xml:"allowed_method,omitempty" type:"Repeated"`
	// AllowedOrigin
	AllowedOrigin []*string `json:"allowed_origin,omitempty" xml:"allowed_origin,omitempty" type:"Repeated"`
	// ExposeHeader
	ExposeHeader []*string `json:"expose_header,omitempty" xml:"expose_header,omitempty" type:"Repeated"`
	// MaxAgeSeconds
	MaxAgeSeconds *int64 `json:"max_age_seconds,omitempty" xml:"max_age_seconds,omitempty"`
}

func (s CorsRule) String() string {
	return tea.Prettify(s)
}

func (s CorsRule) GoString() string {
	return s.String()
}

func (s *CorsRule) SetAllowedHeader(v []*string) *CorsRule {
	s.AllowedHeader = v
	return s
}

func (s *CorsRule) SetAllowedMethod(v []*string) *CorsRule {
	s.AllowedMethod = v
	return s
}

func (s *CorsRule) SetAllowedOrigin(v []*string) *CorsRule {
	s.AllowedOrigin = v
	return s
}

func (s *CorsRule) SetExposeHeader(v []*string) *CorsRule {
	s.ExposeHeader = v
	return s
}

func (s *CorsRule) SetMaxAgeSeconds(v int64) *CorsRule {
	s.MaxAgeSeconds = &v
	return s
}

/**
 *
 */
type CreateAppRequest struct {
	// App
	AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" require:"true" maxLength:"128" minLength:"1"`
	// App
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"128" minLength:"0"`
	// domainApp
	IsThirdParty *bool `json:"is_third_party,omitempty" xml:"is_third_party,omitempty"`
	// App
	Logo *string `json:"logo,omitempty" xml:"logo,omitempty" require:"true"`
	// RSA, PEM
	PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
	// App
	RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
	// App
	Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" require:"true" type:"Repeated"`
	// App
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s CreateAppRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAppRequest) GoString() string {
	return s.String()
}

func (s *CreateAppRequest) SetAppName(v string) *CreateAppRequest {
	s.AppName = &v
	return s
}

func (s *CreateAppRequest) SetDescription(v string) *CreateAppRequest {
	s.Description = &v
	return s
}

func (s *CreateAppRequest) SetIsThirdParty(v bool) *CreateAppRequest {
	s.IsThirdParty = &v
	return s
}

func (s *CreateAppRequest) SetLogo(v string) *CreateAppRequest {
	s.Logo = &v
	return s
}

func (s *CreateAppRequest) SetPublicKey(v string) *CreateAppRequest {
	s.PublicKey = &v
	return s
}

func (s *CreateAppRequest) SetRedirectUri(v string) *CreateAppRequest {
	s.RedirectUri = &v
	return s
}

func (s *CreateAppRequest) SetScope(v []*string) *CreateAppRequest {
	s.Scope = v
	return s
}

func (s *CreateAppRequest) SetType(v string) *CreateAppRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type CreateDetail struct {
	// CreateType
	CreateType *string `json:"create_type,omitempty" xml:"create_type,omitempty"`
	// SrcFileID
	SrcFileId *string `json:"src_file_id,omitempty" xml:"src_file_id,omitempty"`
}

func (s CreateDetail) String() string {
	return tea.Prettify(s)
}

func (s CreateDetail) GoString() string {
	return s.String()
}

func (s *CreateDetail) SetCreateType(v string) *CreateDetail {
	s.CreateType = &v
	return s
}

func (s *CreateDetail) SetSrcFileId(v string) *CreateDetail {
	s.SrcFileId = &v
	return s
}

/**
 * create domain request
 */
type CreateDomainRequest struct {
	// 
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable *bool `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	//  Hash 
	DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	// drive
	GroupSingleDriveEnabled *bool `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	IndependentStore        *bool `json:"independent_store,omitempty" xml:"independent_store,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	// Domain 
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	//  Domain ID
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
	// Domain 
	PathType                   *string            `json:"path_type,omitempty" xml:"path_type,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	// 
	Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
	// quota-1
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// 
	StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
	//  Region 
	StoreRegionList []*string `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// drive
	UserSingleDriveEnabled *bool `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
}

func (s CreateDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainRequest) GoString() string {
	return s.String()
}

func (s *CreateDomainRequest) SetAuthConfig(v map[string]interface{}) *CreateDomainRequest {
	s.AuthConfig = v
	return s
}

func (s *CreateDomainRequest) SetAuthDingdingAppId(v string) *CreateDomainRequest {
	s.AuthDingdingAppId = &v
	return s
}

func (s *CreateDomainRequest) SetAuthDingdingAppSecret(v string) *CreateDomainRequest {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *CreateDomainRequest) SetAuthDingdingEnable(v bool) *CreateDomainRequest {
	s.AuthDingdingEnable = &v
	return s
}

func (s *CreateDomainRequest) SetAuthRamAppId(v string) *CreateDomainRequest {
	s.AuthRamAppId = &v
	return s
}

func (s *CreateDomainRequest) SetAuthRamAppSecret(v string) *CreateDomainRequest {
	s.AuthRamAppSecret = &v
	return s
}

func (s *CreateDomainRequest) SetAuthRamEnable(v bool) *CreateDomainRequest {
	s.AuthRamEnable = &v
	return s
}

func (s *CreateDomainRequest) SetDataHashName(v string) *CreateDomainRequest {
	s.DataHashName = &v
	return s
}

func (s *CreateDomainRequest) SetDescription(v string) *CreateDomainRequest {
	s.Description = &v
	return s
}

func (s *CreateDomainRequest) SetDomainName(v string) *CreateDomainRequest {
	s.DomainName = &v
	return s
}

func (s *CreateDomainRequest) SetEventFilenameMatches(v string) *CreateDomainRequest {
	s.EventFilenameMatches = &v
	return s
}

func (s *CreateDomainRequest) SetEventMnsEndpoint(v string) *CreateDomainRequest {
	s.EventMnsEndpoint = &v
	return s
}

func (s *CreateDomainRequest) SetEventMnsTopic(v string) *CreateDomainRequest {
	s.EventMnsTopic = &v
	return s
}

func (s *CreateDomainRequest) SetEventNames(v []*string) *CreateDomainRequest {
	s.EventNames = v
	return s
}

func (s *CreateDomainRequest) SetEventRoleArn(v string) *CreateDomainRequest {
	s.EventRoleArn = &v
	return s
}

func (s *CreateDomainRequest) SetGroupSingleDriveEnabled(v bool) *CreateDomainRequest {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *CreateDomainRequest) SetIndependentStore(v bool) *CreateDomainRequest {
	s.IndependentStore = &v
	return s
}

func (s *CreateDomainRequest) SetInitDriveEnable(v bool) *CreateDomainRequest {
	s.InitDriveEnable = &v
	return s
}

func (s *CreateDomainRequest) SetInitDriveSize(v int64) *CreateDomainRequest {
	s.InitDriveSize = &v
	return s
}

func (s *CreateDomainRequest) SetMode(v string) *CreateDomainRequest {
	s.Mode = &v
	return s
}

func (s *CreateDomainRequest) SetParentDomainId(v string) *CreateDomainRequest {
	s.ParentDomainId = &v
	return s
}

func (s *CreateDomainRequest) SetPathType(v string) *CreateDomainRequest {
	s.PathType = &v
	return s
}

func (s *CreateDomainRequest) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *CreateDomainRequest {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *CreateDomainRequest) SetSharable(v bool) *CreateDomainRequest {
	s.Sharable = &v
	return s
}

func (s *CreateDomainRequest) SetSizeQuota(v int64) *CreateDomainRequest {
	s.SizeQuota = &v
	return s
}

func (s *CreateDomainRequest) SetStoreLevel(v string) *CreateDomainRequest {
	s.StoreLevel = &v
	return s
}

func (s *CreateDomainRequest) SetStoreRegionList(v []*string) *CreateDomainRequest {
	s.StoreRegionList = v
	return s
}

func (s *CreateDomainRequest) SetUsedSizeRefreshInterval(v int64) *CreateDomainRequest {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *CreateDomainRequest) SetUserCountQuota(v int64) *CreateDomainRequest {
	s.UserCountQuota = &v
	return s
}

func (s *CreateDomainRequest) SetUserSingleDriveEnabled(v bool) *CreateDomainRequest {
	s.UserSingleDriveEnabled = &v
	return s
}

/**
 * create drive request
 */
type CreateDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive, drive
	Default *bool `json:"default,omitempty" xml:"default,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// Drive 
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty" require:"true" maxLength:"1024"`
	// Drive
	DriveType   *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
	// 
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty" require:"true"`
	// domainPathTypeOSSPath Drivestore
	RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// StoreID , domainPathTypeOSSPath
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// ,Byte [ -1 ]
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
}

func (s CreateDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDriveRequest) GoString() string {
	return s.String()
}

func (s *CreateDriveRequest) SetHttpheaders(v map[string]*string) *CreateDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateDriveRequest) SetDefault(v bool) *CreateDriveRequest {
	s.Default = &v
	return s
}

func (s *CreateDriveRequest) SetDescription(v string) *CreateDriveRequest {
	s.Description = &v
	return s
}

func (s *CreateDriveRequest) SetDriveName(v string) *CreateDriveRequest {
	s.DriveName = &v
	return s
}

func (s *CreateDriveRequest) SetDriveType(v string) *CreateDriveRequest {
	s.DriveType = &v
	return s
}

func (s *CreateDriveRequest) SetEncryptMode(v string) *CreateDriveRequest {
	s.EncryptMode = &v
	return s
}

func (s *CreateDriveRequest) SetLocation(v string) *CreateDriveRequest {
	s.Location = &v
	return s
}

func (s *CreateDriveRequest) SetOwner(v string) *CreateDriveRequest {
	s.Owner = &v
	return s
}

func (s *CreateDriveRequest) SetOwnerType(v string) *CreateDriveRequest {
	s.OwnerType = &v
	return s
}

func (s *CreateDriveRequest) SetRelativePath(v string) *CreateDriveRequest {
	s.RelativePath = &v
	return s
}

func (s *CreateDriveRequest) SetStatus(v string) *CreateDriveRequest {
	s.Status = &v
	return s
}

func (s *CreateDriveRequest) SetStoreId(v string) *CreateDriveRequest {
	s.StoreId = &v
	return s
}

func (s *CreateDriveRequest) SetSubdomainId(v string) *CreateDriveRequest {
	s.SubdomainId = &v
	return s
}

func (s *CreateDriveRequest) SetTotalSize(v int64) *CreateDriveRequest {
	s.TotalSize = &v
	return s
}

/**
 * Create drive response
 */
type CreateDriveResponse struct {
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
}

func (s CreateDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDriveResponse) GoString() string {
	return s.String()
}

func (s *CreateDriveResponse) SetDomainId(v string) *CreateDriveResponse {
	s.DomainId = &v
	return s
}

func (s *CreateDriveResponse) SetDriveId(v string) *CreateDriveResponse {
	s.DriveId = &v
	return s
}

/**
 * 
 */
type CreateFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	AutoRename   *bool                  `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
	// check_name_mode
	CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
	// content_hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// ContentMd5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// ContentType
	ContentType  *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	CreateReason *string `json:"create_reason,omitempty" xml:"create_reason,omitempty"`
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	CustomType   *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024" minLength:"0"`
	// drive_id
	DriveId     *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// force_upload_to_location
	ForceUploadToLocation *bool `json:"force_upload_to_location,omitempty" xml:"force_upload_to_location,omitempty"`
	// hidden
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaMetadata `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_updated_at
	LastUpdatedAt *string `json:"last_updated_at,omitempty" xml:"last_updated_at,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	Meta     *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// Name
	Name                    *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
	NeedMergePeriodRevision *bool   `json:"need_merge_period_revision,omitempty" xml:"need_merge_period_revision,omitempty"`
	ParallelUpload          *bool   `json:"parallel_upload,omitempty" xml:"parallel_upload,omitempty"`
	// parent_file_id
	ParentFileId     *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9]{1,50}"`
	ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// pre_hash
	PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
	// proof_code
	ProofCode *string `json:"proof_code,omitempty" xml:"proof_code,omitempty"`
	// proof_version
	ProofVersion *string `json:"proof_version,omitempty" xml:"proof_version,omitempty"`
	// share_id
	// example
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// streams_info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// Type
	Type       *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
	UploadType *string `json:"upload_type,omitempty" xml:"upload_type,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags           []*UserTag          `json:"user_tags,omitempty" xml:"user_tags,omitempty" type:"Repeated"`
	VideoMediaMetadata *VideoMediaMetadata `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
}

func (s CreateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFileRequest) GoString() string {
	return s.String()
}

func (s *CreateFileRequest) SetHttpheaders(v map[string]*string) *CreateFileRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateFileRequest) SetAdditionData(v map[string]interface{}) *CreateFileRequest {
	s.AdditionData = v
	return s
}

func (s *CreateFileRequest) SetAutoRename(v bool) *CreateFileRequest {
	s.AutoRename = &v
	return s
}

func (s *CreateFileRequest) SetCheckNameMode(v string) *CreateFileRequest {
	s.CheckNameMode = &v
	return s
}

func (s *CreateFileRequest) SetContentHash(v string) *CreateFileRequest {
	s.ContentHash = &v
	return s
}

func (s *CreateFileRequest) SetContentHashName(v string) *CreateFileRequest {
	s.ContentHashName = &v
	return s
}

func (s *CreateFileRequest) SetContentMd5(v string) *CreateFileRequest {
	s.ContentMd5 = &v
	return s
}

func (s *CreateFileRequest) SetContentType(v string) *CreateFileRequest {
	s.ContentType = &v
	return s
}

func (s *CreateFileRequest) SetCreateReason(v string) *CreateFileRequest {
	s.CreateReason = &v
	return s
}

func (s *CreateFileRequest) SetCustomField1(v string) *CreateFileRequest {
	s.CustomField1 = &v
	return s
}

func (s *CreateFileRequest) SetCustomField2(v string) *CreateFileRequest {
	s.CustomField2 = &v
	return s
}

func (s *CreateFileRequest) SetCustomType(v string) *CreateFileRequest {
	s.CustomType = &v
	return s
}

func (s *CreateFileRequest) SetDescription(v string) *CreateFileRequest {
	s.Description = &v
	return s
}

func (s *CreateFileRequest) SetDriveId(v string) *CreateFileRequest {
	s.DriveId = &v
	return s
}

func (s *CreateFileRequest) SetEncryptMode(v string) *CreateFileRequest {
	s.EncryptMode = &v
	return s
}

func (s *CreateFileRequest) SetFileId(v string) *CreateFileRequest {
	s.FileId = &v
	return s
}

func (s *CreateFileRequest) SetForceUploadToLocation(v bool) *CreateFileRequest {
	s.ForceUploadToLocation = &v
	return s
}

func (s *CreateFileRequest) SetHidden(v bool) *CreateFileRequest {
	s.Hidden = &v
	return s
}

func (s *CreateFileRequest) SetImageMediaMetadata(v *ImageMediaMetadata) *CreateFileRequest {
	s.ImageMediaMetadata = v
	return s
}

func (s *CreateFileRequest) SetLabels(v []*string) *CreateFileRequest {
	s.Labels = v
	return s
}

func (s *CreateFileRequest) SetLastUpdatedAt(v string) *CreateFileRequest {
	s.LastUpdatedAt = &v
	return s
}

func (s *CreateFileRequest) SetLocalCreatedAt(v string) *CreateFileRequest {
	s.LocalCreatedAt = &v
	return s
}

func (s *CreateFileRequest) SetLocalModifiedAt(v string) *CreateFileRequest {
	s.LocalModifiedAt = &v
	return s
}

func (s *CreateFileRequest) SetLocation(v string) *CreateFileRequest {
	s.Location = &v
	return s
}

func (s *CreateFileRequest) SetMeta(v string) *CreateFileRequest {
	s.Meta = &v
	return s
}

func (s *CreateFileRequest) SetName(v string) *CreateFileRequest {
	s.Name = &v
	return s
}

func (s *CreateFileRequest) SetNeedMergePeriodRevision(v bool) *CreateFileRequest {
	s.NeedMergePeriodRevision = &v
	return s
}

func (s *CreateFileRequest) SetParallelUpload(v bool) *CreateFileRequest {
	s.ParallelUpload = &v
	return s
}

func (s *CreateFileRequest) SetParentFileId(v string) *CreateFileRequest {
	s.ParentFileId = &v
	return s
}

func (s *CreateFileRequest) SetParentFileIdPath(v string) *CreateFileRequest {
	s.ParentFileIdPath = &v
	return s
}

func (s *CreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *CreateFileRequest {
	s.PartInfoList = v
	return s
}

func (s *CreateFileRequest) SetPreHash(v string) *CreateFileRequest {
	s.PreHash = &v
	return s
}

func (s *CreateFileRequest) SetProofCode(v string) *CreateFileRequest {
	s.ProofCode = &v
	return s
}

func (s *CreateFileRequest) SetProofVersion(v string) *CreateFileRequest {
	s.ProofVersion = &v
	return s
}

func (s *CreateFileRequest) SetShareId(v string) *CreateFileRequest {
	s.ShareId = &v
	return s
}

func (s *CreateFileRequest) SetSize(v int64) *CreateFileRequest {
	s.Size = &v
	return s
}

func (s *CreateFileRequest) SetStreamsInfo(v map[string]interface{}) *CreateFileRequest {
	s.StreamsInfo = v
	return s
}

func (s *CreateFileRequest) SetType(v string) *CreateFileRequest {
	s.Type = &v
	return s
}

func (s *CreateFileRequest) SetUploadType(v string) *CreateFileRequest {
	s.UploadType = &v
	return s
}

func (s *CreateFileRequest) SetUserMeta(v string) *CreateFileRequest {
	s.UserMeta = &v
	return s
}

func (s *CreateFileRequest) SetUserTags(v []*UserTag) *CreateFileRequest {
	s.UserTags = v
	return s
}

func (s *CreateFileRequest) SetVideoMediaMetadata(v *VideoMediaMetadata) *CreateFileRequest {
	s.VideoMediaMetadata = v
	return s
}

/**
 * Create file response
 */
type CreateFileResponse struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// exist
	// type: boolean
	Exist *bool `json:"exist,omitempty" xml:"exist,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty" maxLength:"255" minLength:"1"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// rapid_upload
	// type: boolean
	RapidUpload *bool `json:"rapid_upload,omitempty" xml:"rapid_upload,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// streams_upload_info
	StreamsUploadInfo map[string]interface{} `json:"streams_upload_info,omitempty" xml:"streams_upload_info,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s CreateFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFileResponse) GoString() string {
	return s.String()
}

func (s *CreateFileResponse) SetDomainId(v string) *CreateFileResponse {
	s.DomainId = &v
	return s
}

func (s *CreateFileResponse) SetDriveId(v string) *CreateFileResponse {
	s.DriveId = &v
	return s
}

func (s *CreateFileResponse) SetEncryptMode(v string) *CreateFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *CreateFileResponse) SetExist(v bool) *CreateFileResponse {
	s.Exist = &v
	return s
}

func (s *CreateFileResponse) SetFileId(v string) *CreateFileResponse {
	s.FileId = &v
	return s
}

func (s *CreateFileResponse) SetFileName(v string) *CreateFileResponse {
	s.FileName = &v
	return s
}

func (s *CreateFileResponse) SetLocation(v string) *CreateFileResponse {
	s.Location = &v
	return s
}

func (s *CreateFileResponse) SetParentFileId(v string) *CreateFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *CreateFileResponse) SetPartInfoList(v []*UploadPartInfo) *CreateFileResponse {
	s.PartInfoList = v
	return s
}

func (s *CreateFileResponse) SetRapidUpload(v bool) *CreateFileResponse {
	s.RapidUpload = &v
	return s
}

func (s *CreateFileResponse) SetStatus(v string) *CreateFileResponse {
	s.Status = &v
	return s
}

func (s *CreateFileResponse) SetStreamsUploadInfo(v map[string]interface{}) *CreateFileResponse {
	s.StreamsUploadInfo = v
	return s
}

func (s *CreateFileResponse) SetType(v string) *CreateFileResponse {
	s.Type = &v
	return s
}

func (s *CreateFileResponse) SetUploadId(v string) *CreateFileResponse {
	s.UploadId = &v
	return s
}

/**
 *
 */
type CreateShareLinkPermissionRequest struct {
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// 
	EnableUpload *bool `json:"enable_upload,omitempty" xml:"enable_upload,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
}

func (s CreateShareLinkPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateShareLinkPermissionRequest) GoString() string {
	return s.String()
}

func (s *CreateShareLinkPermissionRequest) SetDisableDownload(v bool) *CreateShareLinkPermissionRequest {
	s.DisableDownload = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetDisablePreview(v bool) *CreateShareLinkPermissionRequest {
	s.DisablePreview = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetDisableSave(v bool) *CreateShareLinkPermissionRequest {
	s.DisableSave = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetDownloadLimit(v int64) *CreateShareLinkPermissionRequest {
	s.DownloadLimit = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetEnableUpload(v bool) *CreateShareLinkPermissionRequest {
	s.EnableUpload = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetPreviewLimit(v int64) *CreateShareLinkPermissionRequest {
	s.PreviewLimit = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetRequireLogin(v bool) *CreateShareLinkPermissionRequest {
	s.RequireLogin = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetSaveDownloadLimit(v int64) *CreateShareLinkPermissionRequest {
	s.SaveDownloadLimit = &v
	return s
}

func (s *CreateShareLinkPermissionRequest) SetSaveLimit(v int64) *CreateShareLinkPermissionRequest {
	s.SaveLimit = &v
	return s
}

/**
 * create_share_link request
 */
type CreateShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// driveviewdriveview
	DriveFileList []*ShareFile `json:"drive_file_list,omitempty" xml:"drive_file_list,omitempty" type:"Repeated"`
	// drive
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// enable_file_changed_notify
	EnableFileChangedNotify *bool `json:"enable_file_changed_notify,omitempty" xml:"enable_file_changed_notify,omitempty"`
	// 
	EnableUpload *bool `json:"enable_upload,omitempty" xml:"enable_upload,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// file_id_list
	FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
	// file_path_list
	FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
	// filter_group
	FilterGroup *string `json:"filter_group,omitempty" xml:"filter_group,omitempty"`
	// 
	PreviewLimit *int64  `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	Referer      *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
	// user_id, only admin or aksk can set
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s CreateShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateShareLinkRequest) GoString() string {
	return s.String()
}

func (s *CreateShareLinkRequest) SetHttpheaders(v map[string]*string) *CreateShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateShareLinkRequest) SetAdditionData(v map[string]interface{}) *CreateShareLinkRequest {
	s.AdditionData = v
	return s
}

func (s *CreateShareLinkRequest) SetCategory(v string) *CreateShareLinkRequest {
	s.Category = &v
	return s
}

func (s *CreateShareLinkRequest) SetComments(v string) *CreateShareLinkRequest {
	s.Comments = &v
	return s
}

func (s *CreateShareLinkRequest) SetDescription(v string) *CreateShareLinkRequest {
	s.Description = &v
	return s
}

func (s *CreateShareLinkRequest) SetDisableDownload(v bool) *CreateShareLinkRequest {
	s.DisableDownload = &v
	return s
}

func (s *CreateShareLinkRequest) SetDisablePreview(v bool) *CreateShareLinkRequest {
	s.DisablePreview = &v
	return s
}

func (s *CreateShareLinkRequest) SetDisableSave(v bool) *CreateShareLinkRequest {
	s.DisableSave = &v
	return s
}

func (s *CreateShareLinkRequest) SetDownloadLimit(v int64) *CreateShareLinkRequest {
	s.DownloadLimit = &v
	return s
}

func (s *CreateShareLinkRequest) SetDriveFileList(v []*ShareFile) *CreateShareLinkRequest {
	s.DriveFileList = v
	return s
}

func (s *CreateShareLinkRequest) SetDriveId(v string) *CreateShareLinkRequest {
	s.DriveId = &v
	return s
}

func (s *CreateShareLinkRequest) SetEnableFileChangedNotify(v bool) *CreateShareLinkRequest {
	s.EnableFileChangedNotify = &v
	return s
}

func (s *CreateShareLinkRequest) SetEnableUpload(v bool) *CreateShareLinkRequest {
	s.EnableUpload = &v
	return s
}

func (s *CreateShareLinkRequest) SetExpiration(v string) *CreateShareLinkRequest {
	s.Expiration = &v
	return s
}

func (s *CreateShareLinkRequest) SetFileId(v string) *CreateShareLinkRequest {
	s.FileId = &v
	return s
}

func (s *CreateShareLinkRequest) SetFileIdList(v []*string) *CreateShareLinkRequest {
	s.FileIdList = v
	return s
}

func (s *CreateShareLinkRequest) SetFilePathList(v []*string) *CreateShareLinkRequest {
	s.FilePathList = v
	return s
}

func (s *CreateShareLinkRequest) SetFilterGroup(v string) *CreateShareLinkRequest {
	s.FilterGroup = &v
	return s
}

func (s *CreateShareLinkRequest) SetPreviewLimit(v int64) *CreateShareLinkRequest {
	s.PreviewLimit = &v
	return s
}

func (s *CreateShareLinkRequest) SetReferer(v string) *CreateShareLinkRequest {
	s.Referer = &v
	return s
}

func (s *CreateShareLinkRequest) SetRequireLogin(v bool) *CreateShareLinkRequest {
	s.RequireLogin = &v
	return s
}

func (s *CreateShareLinkRequest) SetSaveDownloadLimit(v int64) *CreateShareLinkRequest {
	s.SaveDownloadLimit = &v
	return s
}

func (s *CreateShareLinkRequest) SetSaveLimit(v int64) *CreateShareLinkRequest {
	s.SaveLimit = &v
	return s
}

func (s *CreateShareLinkRequest) SetShareIcon(v string) *CreateShareLinkRequest {
	s.ShareIcon = &v
	return s
}

func (s *CreateShareLinkRequest) SetShareName(v string) *CreateShareLinkRequest {
	s.ShareName = &v
	return s
}

func (s *CreateShareLinkRequest) SetSharePwd(v string) *CreateShareLinkRequest {
	s.SharePwd = &v
	return s
}

func (s *CreateShareLinkRequest) SetUserId(v string) *CreateShareLinkRequest {
	s.UserId = &v
	return s
}

func (s *CreateShareLinkRequest) SetViewId(v string) *CreateShareLinkRequest {
	s.ViewId = &v
	return s
}

/**
 * create_share_link response
 */
type CreateShareLinkResponse struct {
	// access_count
	AccessCount *int64 `json:"access_count,omitempty" xml:"access_count,omitempty"`
	// Category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// file_list
	DriveFileList []*ShareFile `json:"drive_file_list,omitempty" xml:"drive_file_list,omitempty" type:"Repeated"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// enable_file_changed_notify
	EnableFileChangedNotify *bool `json:"enable_file_changed_notify,omitempty" xml:"enable_file_changed_notify,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// file_id_list
	FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
	// file_id_list
	FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
	// is_subscribed
	IsSubscribed *bool `json:"is_subscribed,omitempty" xml:"is_subscribed,omitempty"`
	// num_of_subscribers
	NumOfSubscribers *int64 `json:"num_of_subscribers,omitempty" xml:"num_of_subscribers,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// 
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_msg
	ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_policy
	SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
	// share_url
	ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
	// ViewID
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s CreateShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateShareLinkResponse) GoString() string {
	return s.String()
}

func (s *CreateShareLinkResponse) SetAccessCount(v int64) *CreateShareLinkResponse {
	s.AccessCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetCategory(v string) *CreateShareLinkResponse {
	s.Category = &v
	return s
}

func (s *CreateShareLinkResponse) SetComments(v string) *CreateShareLinkResponse {
	s.Comments = &v
	return s
}

func (s *CreateShareLinkResponse) SetCreatedAt(v string) *CreateShareLinkResponse {
	s.CreatedAt = &v
	return s
}

func (s *CreateShareLinkResponse) SetCreator(v string) *CreateShareLinkResponse {
	s.Creator = &v
	return s
}

func (s *CreateShareLinkResponse) SetDescription(v string) *CreateShareLinkResponse {
	s.Description = &v
	return s
}

func (s *CreateShareLinkResponse) SetDisableDownload(v bool) *CreateShareLinkResponse {
	s.DisableDownload = &v
	return s
}

func (s *CreateShareLinkResponse) SetDisablePreview(v bool) *CreateShareLinkResponse {
	s.DisablePreview = &v
	return s
}

func (s *CreateShareLinkResponse) SetDisableSave(v bool) *CreateShareLinkResponse {
	s.DisableSave = &v
	return s
}

func (s *CreateShareLinkResponse) SetDownloadCount(v int64) *CreateShareLinkResponse {
	s.DownloadCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetDownloadLimit(v int64) *CreateShareLinkResponse {
	s.DownloadLimit = &v
	return s
}

func (s *CreateShareLinkResponse) SetDriveFileList(v []*ShareFile) *CreateShareLinkResponse {
	s.DriveFileList = v
	return s
}

func (s *CreateShareLinkResponse) SetDriveId(v string) *CreateShareLinkResponse {
	s.DriveId = &v
	return s
}

func (s *CreateShareLinkResponse) SetEnableFileChangedNotify(v bool) *CreateShareLinkResponse {
	s.EnableFileChangedNotify = &v
	return s
}

func (s *CreateShareLinkResponse) SetExpiration(v string) *CreateShareLinkResponse {
	s.Expiration = &v
	return s
}

func (s *CreateShareLinkResponse) SetExpired(v bool) *CreateShareLinkResponse {
	s.Expired = &v
	return s
}

func (s *CreateShareLinkResponse) SetFileId(v string) *CreateShareLinkResponse {
	s.FileId = &v
	return s
}

func (s *CreateShareLinkResponse) SetFileIdList(v []*string) *CreateShareLinkResponse {
	s.FileIdList = v
	return s
}

func (s *CreateShareLinkResponse) SetFilePathList(v []*string) *CreateShareLinkResponse {
	s.FilePathList = v
	return s
}

func (s *CreateShareLinkResponse) SetIsSubscribed(v bool) *CreateShareLinkResponse {
	s.IsSubscribed = &v
	return s
}

func (s *CreateShareLinkResponse) SetNumOfSubscribers(v int64) *CreateShareLinkResponse {
	s.NumOfSubscribers = &v
	return s
}

func (s *CreateShareLinkResponse) SetPreviewCount(v int64) *CreateShareLinkResponse {
	s.PreviewCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetPreviewLimit(v int64) *CreateShareLinkResponse {
	s.PreviewLimit = &v
	return s
}

func (s *CreateShareLinkResponse) SetReportCount(v int64) *CreateShareLinkResponse {
	s.ReportCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetRequireLogin(v bool) *CreateShareLinkResponse {
	s.RequireLogin = &v
	return s
}

func (s *CreateShareLinkResponse) SetSaveCount(v int64) *CreateShareLinkResponse {
	s.SaveCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetSaveDownloadLimit(v int64) *CreateShareLinkResponse {
	s.SaveDownloadLimit = &v
	return s
}

func (s *CreateShareLinkResponse) SetSaveLimit(v int64) *CreateShareLinkResponse {
	s.SaveLimit = &v
	return s
}

func (s *CreateShareLinkResponse) SetShareIcon(v string) *CreateShareLinkResponse {
	s.ShareIcon = &v
	return s
}

func (s *CreateShareLinkResponse) SetShareId(v string) *CreateShareLinkResponse {
	s.ShareId = &v
	return s
}

func (s *CreateShareLinkResponse) SetShareMsg(v string) *CreateShareLinkResponse {
	s.ShareMsg = &v
	return s
}

func (s *CreateShareLinkResponse) SetShareName(v string) *CreateShareLinkResponse {
	s.ShareName = &v
	return s
}

func (s *CreateShareLinkResponse) SetSharePolicy(v string) *CreateShareLinkResponse {
	s.SharePolicy = &v
	return s
}

func (s *CreateShareLinkResponse) SetSharePwd(v string) *CreateShareLinkResponse {
	s.SharePwd = &v
	return s
}

func (s *CreateShareLinkResponse) SetShareUrl(v string) *CreateShareLinkResponse {
	s.ShareUrl = &v
	return s
}

func (s *CreateShareLinkResponse) SetStatus(v string) *CreateShareLinkResponse {
	s.Status = &v
	return s
}

func (s *CreateShareLinkResponse) SetUpdatedAt(v string) *CreateShareLinkResponse {
	s.UpdatedAt = &v
	return s
}

func (s *CreateShareLinkResponse) SetVideoPreviewCount(v int64) *CreateShareLinkResponse {
	s.VideoPreviewCount = &v
	return s
}

func (s *CreateShareLinkResponse) SetViewId(v string) *CreateShareLinkResponse {
	s.ViewId = &v
	return s
}

/**
 * create share request
 */
type CreateShareRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
	// owner_type
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// share_file_id
	ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
	// share_file_path
	ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share create policy
	//
	// share_policy
	SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s CreateShareRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateShareRequest) GoString() string {
	return s.String()
}

func (s *CreateShareRequest) SetHttpheaders(v map[string]*string) *CreateShareRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateShareRequest) SetDescription(v string) *CreateShareRequest {
	s.Description = &v
	return s
}

func (s *CreateShareRequest) SetDriveId(v string) *CreateShareRequest {
	s.DriveId = &v
	return s
}

func (s *CreateShareRequest) SetExpiration(v string) *CreateShareRequest {
	s.Expiration = &v
	return s
}

func (s *CreateShareRequest) SetOwner(v string) *CreateShareRequest {
	s.Owner = &v
	return s
}

func (s *CreateShareRequest) SetOwnerType(v string) *CreateShareRequest {
	s.OwnerType = &v
	return s
}

func (s *CreateShareRequest) SetPermissions(v []*string) *CreateShareRequest {
	s.Permissions = v
	return s
}

func (s *CreateShareRequest) SetShareFileId(v string) *CreateShareRequest {
	s.ShareFileId = &v
	return s
}

func (s *CreateShareRequest) SetShareFilePath(v string) *CreateShareRequest {
	s.ShareFilePath = &v
	return s
}

func (s *CreateShareRequest) SetShareName(v string) *CreateShareRequest {
	s.ShareName = &v
	return s
}

func (s *CreateShareRequest) SetSharePolicy(v []*SharePermissionPolicy) *CreateShareRequest {
	s.SharePolicy = v
	return s
}

func (s *CreateShareRequest) SetStatus(v string) *CreateShareRequest {
	s.Status = &v
	return s
}

/**
 * Create share response
 */
type CreateShareResponse struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s CreateShareResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateShareResponse) GoString() string {
	return s.String()
}

func (s *CreateShareResponse) SetDomainId(v string) *CreateShareResponse {
	s.DomainId = &v
	return s
}

func (s *CreateShareResponse) SetShareId(v string) *CreateShareResponse {
	s.ShareId = &v
	return s
}

/**
 *
 */
type CroppingBoundary struct {
	Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
	Left   *int64 `json:"left,omitempty" xml:"left,omitempty"`
	Top    *int64 `json:"top,omitempty" xml:"top,omitempty"`
	Width  *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s CroppingBoundary) String() string {
	return tea.Prettify(s)
}

func (s CroppingBoundary) GoString() string {
	return s.String()
}

func (s *CroppingBoundary) SetHeight(v int64) *CroppingBoundary {
	s.Height = &v
	return s
}

func (s *CroppingBoundary) SetLeft(v int64) *CroppingBoundary {
	s.Left = &v
	return s
}

func (s *CroppingBoundary) SetTop(v int64) *CroppingBoundary {
	s.Top = &v
	return s
}

func (s *CroppingBoundary) SetWidth(v int64) *CroppingBoundary {
	s.Width = &v
	return s
}

/**
 *
 */
type CroppingSuggestionItem struct {
	AspectRatio      *string           `json:"aspect_ratio,omitempty" xml:"aspect_ratio,omitempty"`
	CroppingBoundary *CroppingBoundary `json:"cropping_boundary,omitempty" xml:"cropping_boundary,omitempty"`
	Score            *float64          `json:"score,omitempty" xml:"score,omitempty"`
}

func (s CroppingSuggestionItem) String() string {
	return tea.Prettify(s)
}

func (s CroppingSuggestionItem) GoString() string {
	return s.String()
}

func (s *CroppingSuggestionItem) SetAspectRatio(v string) *CroppingSuggestionItem {
	s.AspectRatio = &v
	return s
}

func (s *CroppingSuggestionItem) SetCroppingBoundary(v *CroppingBoundary) *CroppingSuggestionItem {
	s.CroppingBoundary = v
	return s
}

func (s *CroppingSuggestionItem) SetScore(v float64) *CroppingSuggestionItem {
	s.Score = &v
	return s
}

/**
 *
 */
type CustomBenefitMetaRequest struct {
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s CustomBenefitMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s CustomBenefitMetaRequest) GoString() string {
	return s.String()
}

func (s *CustomBenefitMetaRequest) SetEnabled(v bool) *CustomBenefitMetaRequest {
	s.Enabled = &v
	return s
}

/**
 *
 */
type DataBoxPrivileges struct {
	// feature_attr_id
	FeatureAttrId *string `json:"feature_attr_id,omitempty" xml:"feature_attr_id,omitempty"`
	// feature_id
	FeatureId *string `json:"feature_id,omitempty" xml:"feature_id,omitempty"`
	// quota
	Quota *int64 `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s DataBoxPrivileges) String() string {
	return tea.Prettify(s)
}

func (s DataBoxPrivileges) GoString() string {
	return s.String()
}

func (s *DataBoxPrivileges) SetFeatureAttrId(v string) *DataBoxPrivileges {
	s.FeatureAttrId = &v
	return s
}

func (s *DataBoxPrivileges) SetFeatureId(v string) *DataBoxPrivileges {
	s.FeatureId = &v
	return s
}

func (s *DataBoxPrivileges) SetQuota(v int64) *DataBoxPrivileges {
	s.Quota = &v
	return s
}

/**
 *
 */
type DefaultChangePasswordRequest struct {
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// AES-256App
	EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty" require:"true"`
	// 8-20
	NewPassword *string `json:"new_password,omitempty" xml:"new_password,omitempty" require:"true"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	// 
	State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s DefaultChangePasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s DefaultChangePasswordRequest) GoString() string {
	return s.String()
}

func (s *DefaultChangePasswordRequest) SetAppId(v string) *DefaultChangePasswordRequest {
	s.AppId = &v
	return s
}

func (s *DefaultChangePasswordRequest) SetEncryptedKey(v string) *DefaultChangePasswordRequest {
	s.EncryptedKey = &v
	return s
}

func (s *DefaultChangePasswordRequest) SetNewPassword(v string) *DefaultChangePasswordRequest {
	s.NewPassword = &v
	return s
}

func (s *DefaultChangePasswordRequest) SetPhoneNumber(v string) *DefaultChangePasswordRequest {
	s.PhoneNumber = &v
	return s
}

func (s *DefaultChangePasswordRequest) SetPhoneRegion(v string) *DefaultChangePasswordRequest {
	s.PhoneRegion = &v
	return s
}

func (s *DefaultChangePasswordRequest) SetState(v string) *DefaultChangePasswordRequest {
	s.State = &v
	return s
}

/**
 *
 */
type DefaultSetPasswordRequest struct {
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// AES-256App
	EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty" require:"true"`
	// 8-20AES-256CBC, PKCS7Paddingbase64
	NewPassword *string `json:"new_password,omitempty" xml:"new_password,omitempty" require:"true"`
	// 
	State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s DefaultSetPasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s DefaultSetPasswordRequest) GoString() string {
	return s.String()
}

func (s *DefaultSetPasswordRequest) SetAppId(v string) *DefaultSetPasswordRequest {
	s.AppId = &v
	return s
}

func (s *DefaultSetPasswordRequest) SetEncryptedKey(v string) *DefaultSetPasswordRequest {
	s.EncryptedKey = &v
	return s
}

func (s *DefaultSetPasswordRequest) SetNewPassword(v string) *DefaultSetPasswordRequest {
	s.NewPassword = &v
	return s
}

func (s *DefaultSetPasswordRequest) SetState(v string) *DefaultSetPasswordRequest {
	s.State = &v
	return s
}

/**
 *
 */
type DeleteAppRequest struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s DeleteAppRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppRequest) GoString() string {
	return s.String()
}

func (s *DeleteAppRequest) SetAppId(v string) *DeleteAppRequest {
	s.AppId = &v
	return s
}

/**
 *
 */
type DeleteBizCNameAndCertRequest struct {
	// api cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s DeleteBizCNameAndCertRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBizCNameAndCertRequest) GoString() string {
	return s.String()
}

func (s *DeleteBizCNameAndCertRequest) SetBizCname(v string) *DeleteBizCNameAndCertRequest {
	s.BizCname = &v
	return s
}

func (s *DeleteBizCNameAndCertRequest) SetCnameType(v string) *DeleteBizCNameAndCertRequest {
	s.CnameType = &v
	return s
}

func (s *DeleteBizCNameAndCertRequest) SetDomainId(v string) *DeleteBizCNameAndCertRequest {
	s.DomainId = &v
	return s
}

func (s *DeleteBizCNameAndCertRequest) SetIsVpc(v bool) *DeleteBizCNameAndCertRequest {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type DeleteBizCNameCertRequest struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert id
	CertId *string `json:"cert_id,omitempty" xml:"cert_id,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s DeleteBizCNameCertRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBizCNameCertRequest) GoString() string {
	return s.String()
}

func (s *DeleteBizCNameCertRequest) SetBizCname(v string) *DeleteBizCNameCertRequest {
	s.BizCname = &v
	return s
}

func (s *DeleteBizCNameCertRequest) SetCertId(v string) *DeleteBizCNameCertRequest {
	s.CertId = &v
	return s
}

func (s *DeleteBizCNameCertRequest) SetCnameType(v string) *DeleteBizCNameCertRequest {
	s.CnameType = &v
	return s
}

func (s *DeleteBizCNameCertRequest) SetDomainId(v string) *DeleteBizCNameCertRequest {
	s.DomainId = &v
	return s
}

func (s *DeleteBizCNameCertRequest) SetIsVpc(v bool) *DeleteBizCNameCertRequest {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type DeleteDataCNameAndCertRequest struct {
	// cn-shanghai data cname
	DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s DeleteDataCNameAndCertRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataCNameAndCertRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataCNameAndCertRequest) SetDataCname(v string) *DeleteDataCNameAndCertRequest {
	s.DataCname = &v
	return s
}

func (s *DeleteDataCNameAndCertRequest) SetDomainId(v string) *DeleteDataCNameAndCertRequest {
	s.DomainId = &v
	return s
}

func (s *DeleteDataCNameAndCertRequest) SetLocation(v string) *DeleteDataCNameAndCertRequest {
	s.Location = &v
	return s
}

/**
 *
 */
type DeleteDetail struct {
}

func (s DeleteDetail) String() string {
	return tea.Prettify(s)
}

func (s DeleteDetail) GoString() string {
	return s.String()
}

/**
 * delete domain request
 */
type DeleteDomainRequest struct {
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s DeleteDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainRequest) SetDomainId(v string) *DeleteDomainRequest {
	s.DomainId = &v
	return s
}

/**
 * Delete drive request
 */
type DeleteDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s DeleteDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDriveRequest) GoString() string {
	return s.String()
}

func (s *DeleteDriveRequest) SetHttpheaders(v map[string]*string) *DeleteDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteDriveRequest) SetDriveId(v string) *DeleteDriveRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteDriveRequest) SetSubdomainId(v string) *DeleteDriveRequest {
	s.SubdomainId = &v
	return s
}

/**
 * delete drive response
 */
type DeleteDriveResponse struct {
}

func (s DeleteDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDriveResponse) GoString() string {
	return s.String()
}

/**
 * 
 */
type DeleteFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId    *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// permanently
	// type: false
	Permanently *bool   `json:"permanently,omitempty" xml:"permanently,omitempty"`
	ShareId     *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s DeleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteFileRequest) SetHttpheaders(v map[string]*string) *DeleteFileRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteFileRequest) SetDriveId(v string) *DeleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteFileRequest) SetFileId(v string) *DeleteFileRequest {
	s.FileId = &v
	return s
}

func (s *DeleteFileRequest) SetFileIdPath(v string) *DeleteFileRequest {
	s.FileIdPath = &v
	return s
}

func (s *DeleteFileRequest) SetPermanently(v bool) *DeleteFileRequest {
	s.Permanently = &v
	return s
}

func (s *DeleteFileRequest) SetShareId(v string) *DeleteFileRequest {
	s.ShareId = &v
	return s
}

/**
 *  response
 */
type DeleteFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s DeleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteFileResponse) SetAsyncTaskId(v string) *DeleteFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *DeleteFileResponse) SetDomainId(v string) *DeleteFileResponse {
	s.DomainId = &v
	return s
}

func (s *DeleteFileResponse) SetDriveId(v string) *DeleteFileResponse {
	s.DriveId = &v
	return s
}

func (s *DeleteFileResponse) SetFileId(v string) *DeleteFileResponse {
	s.FileId = &v
	return s
}

/**
 *  user_tags 
 */
type DeleteFileUserTagsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	// key_list
	KeyList []*string `json:"key_list,omitempty" xml:"key_list,omitempty" type:"Repeated"`
}

func (s DeleteFileUserTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileUserTagsRequest) GoString() string {
	return s.String()
}

func (s *DeleteFileUserTagsRequest) SetHttpheaders(v map[string]*string) *DeleteFileUserTagsRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteFileUserTagsRequest) SetDriveId(v string) *DeleteFileUserTagsRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteFileUserTagsRequest) SetFileId(v string) *DeleteFileUserTagsRequest {
	s.FileId = &v
	return s
}

func (s *DeleteFileUserTagsRequest) SetKeyList(v []*string) *DeleteFileUserTagsRequest {
	s.KeyList = v
	return s
}

/**
 *  user tags response
 */
type DeleteFileUserTagsResponse struct {
}

func (s DeleteFileUserTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileUserTagsResponse) GoString() string {
	return s.String()
}

/**
 * 
 */
type DeleteFilesRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id_list
	FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" require:"true" type:"Repeated"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s DeleteFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFilesRequest) GoString() string {
	return s.String()
}

func (s *DeleteFilesRequest) SetDriveId(v string) *DeleteFilesRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteFilesRequest) SetFileIdList(v []*string) *DeleteFilesRequest {
	s.FileIdList = v
	return s
}

func (s *DeleteFilesRequest) SetShareId(v string) *DeleteFilesRequest {
	s.ShareId = &v
	return s
}

/**
 *  response
 */
type DeleteFilesResponse struct {
	// deleted_file_id_list
	DeletedFileIdList []*string `json:"deleted_file_id_list,omitempty" xml:"deleted_file_id_list,omitempty" type:"Repeated"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
}

func (s DeleteFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFilesResponse) GoString() string {
	return s.String()
}

func (s *DeleteFilesResponse) SetDeletedFileIdList(v []*string) *DeleteFilesResponse {
	s.DeletedFileIdList = v
	return s
}

func (s *DeleteFilesResponse) SetDomainId(v string) *DeleteFilesResponse {
	s.DomainId = &v
	return s
}

func (s *DeleteFilesResponse) SetDriveId(v string) *DeleteFilesResponse {
	s.DriveId = &v
	return s
}

/**
 * delete share request
 */
type DeleteShareRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
}

func (s DeleteShareRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareRequest) GoString() string {
	return s.String()
}

func (s *DeleteShareRequest) SetHttpheaders(v map[string]*string) *DeleteShareRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteShareRequest) SetShareId(v string) *DeleteShareRequest {
	s.ShareId = &v
	return s
}

/**
 *
 */
type DeviceAuthorizeRequest struct {
	// Client ID, AppAppID
	ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
	// 
	DeviceInfo *string `json:"DeviceInfo,omitempty" xml:"DeviceInfo,omitempty"`
	// +
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" require:"true"`
	// ding,ram
	LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
	// , 
	Scope []*string `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Repeated"`
}

func (s DeviceAuthorizeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeviceAuthorizeRequest) GoString() string {
	return s.String()
}

func (s *DeviceAuthorizeRequest) SetClientID(v string) *DeviceAuthorizeRequest {
	s.ClientID = &v
	return s
}

func (s *DeviceAuthorizeRequest) SetDeviceInfo(v string) *DeviceAuthorizeRequest {
	s.DeviceInfo = &v
	return s
}

func (s *DeviceAuthorizeRequest) SetDeviceName(v string) *DeviceAuthorizeRequest {
	s.DeviceName = &v
	return s
}

func (s *DeviceAuthorizeRequest) SetLoginType(v string) *DeviceAuthorizeRequest {
	s.LoginType = &v
	return s
}

func (s *DeviceAuthorizeRequest) SetScope(v []*string) *DeviceAuthorizeRequest {
	s.Scope = v
	return s
}

/**
 * domain update name request
 */
type DomainUpdateNameRequest struct {
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// Domain 
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
}

func (s DomainUpdateNameRequest) String() string {
	return tea.Prettify(s)
}

func (s DomainUpdateNameRequest) GoString() string {
	return s.String()
}

func (s *DomainUpdateNameRequest) SetDomainId(v string) *DomainUpdateNameRequest {
	s.DomainId = &v
	return s
}

func (s *DomainUpdateNameRequest) SetName(v string) *DomainUpdateNameRequest {
	s.Name = &v
	return s
}

/**
 * body
 */
type DownloadRequest struct {
	// drive id
	DriveID *string `json:"DriveID,omitempty" xml:"DriveID,omitempty"`
	// file id
	FileID *string `json:"FileID,omitempty" xml:"FileID,omitempty" require:"true"`
	// in: query
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"ImageThumbnailProcess,omitempty" xml:"ImageThumbnailProcess,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"OfficeThumbnailProcess,omitempty" xml:"OfficeThumbnailProcess,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareID *string `json:"ShareID,omitempty" xml:"ShareID,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"VideoThumbnailProcess,omitempty" xml:"VideoThumbnailProcess,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	FileIdPath   *string                `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// location
	Location  *string `json:"location,omitempty" xml:"location,omitempty"`
	Referer   *string `json:"referer,omitempty" xml:"referer,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s DownloadRequest) String() string {
	return tea.Prettify(s)
}

func (s DownloadRequest) GoString() string {
	return s.String()
}

func (s *DownloadRequest) SetDriveID(v string) *DownloadRequest {
	s.DriveID = &v
	return s
}

func (s *DownloadRequest) SetFileID(v string) *DownloadRequest {
	s.FileID = &v
	return s
}

func (s *DownloadRequest) SetImageThumbnailProcess(v string) *DownloadRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *DownloadRequest) SetOfficeThumbnailProcess(v string) *DownloadRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *DownloadRequest) SetShareID(v string) *DownloadRequest {
	s.ShareID = &v
	return s
}

func (s *DownloadRequest) SetVideoThumbnailProcess(v string) *DownloadRequest {
	s.VideoThumbnailProcess = &v
	return s
}

func (s *DownloadRequest) SetAdditionData(v map[string]interface{}) *DownloadRequest {
	s.AdditionData = v
	return s
}

func (s *DownloadRequest) SetFileIdPath(v string) *DownloadRequest {
	s.FileIdPath = &v
	return s
}

func (s *DownloadRequest) SetLocation(v string) *DownloadRequest {
	s.Location = &v
	return s
}

func (s *DownloadRequest) SetReferer(v string) *DownloadRequest {
	s.Referer = &v
	return s
}

func (s *DownloadRequest) SetSignToken(v string) *DownloadRequest {
	s.SignToken = &v
	return s
}

/**
 *
 */
type EditDetail struct {
}

func (s EditDetail) String() string {
	return tea.Prettify(s)
}

func (s EditDetail) GoString() string {
	return s.String()
}

/**
 *
 */
type FaceThumbnail struct {
	FaceGroupId   *string `json:"face_group_id,omitempty" xml:"face_group_id,omitempty"`
	FaceId        *string `json:"face_id,omitempty" xml:"face_id,omitempty"`
	FaceThumbnail *string `json:"face_thumbnail,omitempty" xml:"face_thumbnail,omitempty"`
}

func (s FaceThumbnail) String() string {
	return tea.Prettify(s)
}

func (s FaceThumbnail) GoString() string {
	return s.String()
}

func (s *FaceThumbnail) SetFaceGroupId(v string) *FaceThumbnail {
	s.FaceGroupId = &v
	return s
}

func (s *FaceThumbnail) SetFaceId(v string) *FaceThumbnail {
	s.FaceId = &v
	return s
}

func (s *FaceThumbnail) SetFaceThumbnail(v string) *FaceThumbnail {
	s.FaceThumbnail = &v
	return s
}

/**
 *
 */
type FileActivity struct {
	// Actors
	Actors              []*Actor      `json:"actors,omitempty" xml:"actors,omitempty" type:"Repeated"`
	PrimaryActionDetail *ActionDetail `json:"primary_action_detail,omitempty" xml:"primary_action_detail,omitempty"`
	// Targets
	Targets   []*Target  `json:"targets,omitempty" xml:"targets,omitempty" type:"Repeated"`
	TimeRange *TimeRange `json:"time_range,omitempty" xml:"time_range,omitempty"`
	// Timestamp
	Timestamp *string `json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

func (s FileActivity) String() string {
	return tea.Prettify(s)
}

func (s FileActivity) GoString() string {
	return s.String()
}

func (s *FileActivity) SetActors(v []*Actor) *FileActivity {
	s.Actors = v
	return s
}

func (s *FileActivity) SetPrimaryActionDetail(v *ActionDetail) *FileActivity {
	s.PrimaryActionDetail = v
	return s
}

func (s *FileActivity) SetTargets(v []*Target) *FileActivity {
	s.Targets = v
	return s
}

func (s *FileActivity) SetTimeRange(v *TimeRange) *FileActivity {
	s.TimeRange = v
	return s
}

func (s *FileActivity) SetTimestamp(v string) *FileActivity {
	s.Timestamp = &v
	return s
}

/**
 * /
 */
type FileAddPermissionRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	// 
	MemberList []*FilePermissionMember `json:"member_list,omitempty" xml:"member_list,omitempty" require:"true" type:"Repeated"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s FileAddPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s FileAddPermissionRequest) GoString() string {
	return s.String()
}

func (s *FileAddPermissionRequest) SetHttpheaders(v map[string]*string) *FileAddPermissionRequest {
	s.Httpheaders = v
	return s
}

func (s *FileAddPermissionRequest) SetDriveId(v string) *FileAddPermissionRequest {
	s.DriveId = &v
	return s
}

func (s *FileAddPermissionRequest) SetFileId(v string) *FileAddPermissionRequest {
	s.FileId = &v
	return s
}

func (s *FileAddPermissionRequest) SetMemberList(v []*FilePermissionMember) *FileAddPermissionRequest {
	s.MemberList = v
	return s
}

func (s *FileAddPermissionRequest) SetSubdomainId(v string) *FileAddPermissionRequest {
	s.SubdomainId = &v
	return s
}

/**
 * the file op info
 */
type FileDeltaResponse struct {
	CurrentCategory *string              `json:"current_category,omitempty" xml:"current_category,omitempty"`
	File            *BaseCCPFileResponse `json:"file,omitempty" xml:"file,omitempty"`
	FileId          *string              `json:"file_id,omitempty" xml:"file_id,omitempty"`
	Op              *string              `json:"op,omitempty" xml:"op,omitempty"`
}

func (s FileDeltaResponse) String() string {
	return tea.Prettify(s)
}

func (s FileDeltaResponse) GoString() string {
	return s.String()
}

func (s *FileDeltaResponse) SetCurrentCategory(v string) *FileDeltaResponse {
	s.CurrentCategory = &v
	return s
}

func (s *FileDeltaResponse) SetFile(v *BaseCCPFileResponse) *FileDeltaResponse {
	s.File = v
	return s
}

func (s *FileDeltaResponse) SetFileId(v string) *FileDeltaResponse {
	s.FileId = &v
	return s
}

func (s *FileDeltaResponse) SetOp(v string) *FileDeltaResponse {
	s.Op = &v
	return s
}

/**
 *
 */
type FileInfo struct {
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s FileInfo) String() string {
	return tea.Prettify(s)
}

func (s FileInfo) GoString() string {
	return s.String()
}

func (s *FileInfo) SetFileId(v string) *FileInfo {
	s.FileId = &v
	return s
}

/**
 * /
 */
type FileListInheritPermissionRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// file_id
	FileId      *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s FileListInheritPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s FileListInheritPermissionRequest) GoString() string {
	return s.String()
}

func (s *FileListInheritPermissionRequest) SetHttpheaders(v map[string]*string) *FileListInheritPermissionRequest {
	s.Httpheaders = v
	return s
}

func (s *FileListInheritPermissionRequest) SetDriveId(v string) *FileListInheritPermissionRequest {
	s.DriveId = &v
	return s
}

func (s *FileListInheritPermissionRequest) SetFileId(v string) *FileListInheritPermissionRequest {
	s.FileId = &v
	return s
}

func (s *FileListInheritPermissionRequest) SetSubdomainId(v string) *FileListInheritPermissionRequest {
	s.SubdomainId = &v
	return s
}

/**
 * /
 */
type FileListInheritPermissionResponse struct {
	Items []*BaseFileListInheritPermissionResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s FileListInheritPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s FileListInheritPermissionResponse) GoString() string {
	return s.String()
}

func (s *FileListInheritPermissionResponse) SetItems(v []*BaseFileListInheritPermissionResponse) *FileListInheritPermissionResponse {
	s.Items = v
	return s
}

/**
 * /
 */
type FileListPermissionRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// file_id
	FileId      *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s FileListPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s FileListPermissionRequest) GoString() string {
	return s.String()
}

func (s *FileListPermissionRequest) SetHttpheaders(v map[string]*string) *FileListPermissionRequest {
	s.Httpheaders = v
	return s
}

func (s *FileListPermissionRequest) SetDriveId(v string) *FileListPermissionRequest {
	s.DriveId = &v
	return s
}

func (s *FileListPermissionRequest) SetFileId(v string) *FileListPermissionRequest {
	s.FileId = &v
	return s
}

func (s *FileListPermissionRequest) SetSubdomainId(v string) *FileListPermissionRequest {
	s.SubdomainId = &v
	return s
}

/**
 * /
 */
type FileListUserPermissionRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	SubdomainId *string            `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s FileListUserPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s FileListUserPermissionRequest) GoString() string {
	return s.String()
}

func (s *FileListUserPermissionRequest) SetHttpheaders(v map[string]*string) *FileListUserPermissionRequest {
	s.Httpheaders = v
	return s
}

func (s *FileListUserPermissionRequest) SetSubdomainId(v string) *FileListUserPermissionRequest {
	s.SubdomainId = &v
	return s
}

func (s *FileListUserPermissionRequest) SetType(v string) *FileListUserPermissionRequest {
	s.Type = &v
	return s
}

func (s *FileListUserPermissionRequest) SetUserId(v string) *FileListUserPermissionRequest {
	s.UserId = &v
	return s
}

/**
 * /
 */
type FileListUserPermissionResponse struct {
	Items []*BaseFileUserPermissionResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s FileListUserPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s FileListUserPermissionResponse) GoString() string {
	return s.String()
}

func (s *FileListUserPermissionResponse) SetItems(v []*BaseFileUserPermissionResponse) *FileListUserPermissionResponse {
	s.Items = v
	return s
}

/**
 * /
 */
type FilePermissionMember struct {
	// 
	DisinheritSubGroup *bool `json:"disinherit_sub_group,omitempty" xml:"disinherit_sub_group,omitempty"`
	// 
	ExpireTime *int64    `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
	Identity   *Identity `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// SystemFileOwner()SystemFileDownloader()SystemFileEditor()SystemFileEditorWithoutDelete()SystemFileEditorWithoutShareLink()SystemFileMetaViewer()SystemFileUploader()SystemFileUploaderAndDownloader(/)SystemFileDownloaderWithShareLink(/)SystemFileUploaderAndDownloaderWithShareLink(//)SystemFileUploaderAndViewer(/)SystemFileUploaderWithShareLink(/)SystemFileViewer()
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty" require:"true"`
}

func (s FilePermissionMember) String() string {
	return tea.Prettify(s)
}

func (s FilePermissionMember) GoString() string {
	return s.String()
}

func (s *FilePermissionMember) SetDisinheritSubGroup(v bool) *FilePermissionMember {
	s.DisinheritSubGroup = &v
	return s
}

func (s *FilePermissionMember) SetExpireTime(v int64) *FilePermissionMember {
	s.ExpireTime = &v
	return s
}

func (s *FilePermissionMember) SetIdentity(v *Identity) *FilePermissionMember {
	s.Identity = v
	return s
}

func (s *FilePermissionMember) SetRoleId(v string) *FilePermissionMember {
	s.RoleId = &v
	return s
}

/**
 * /
 */
type FileRemovePermissionRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	// 
	MemberList []*FilePermissionMember `json:"member_list,omitempty" xml:"member_list,omitempty" require:"true" type:"Repeated"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s FileRemovePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s FileRemovePermissionRequest) GoString() string {
	return s.String()
}

func (s *FileRemovePermissionRequest) SetHttpheaders(v map[string]*string) *FileRemovePermissionRequest {
	s.Httpheaders = v
	return s
}

func (s *FileRemovePermissionRequest) SetDriveId(v string) *FileRemovePermissionRequest {
	s.DriveId = &v
	return s
}

func (s *FileRemovePermissionRequest) SetFileId(v string) *FileRemovePermissionRequest {
	s.FileId = &v
	return s
}

func (s *FileRemovePermissionRequest) SetMemberList(v []*FilePermissionMember) *FileRemovePermissionRequest {
	s.MemberList = v
	return s
}

func (s *FileRemovePermissionRequest) SetSubdomainId(v string) *FileRemovePermissionRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type FileStreamInfo struct {
	// content_hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// ContentMd5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" require:"true"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// pre_hash
	PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
	// proof_code
	ProofCode *string `json:"proof_code,omitempty" xml:"proof_code,omitempty"`
	// proof_version
	ProofVersion *string `json:"proof_version,omitempty" xml:"proof_version,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" require:"true" minimum:"0"`
}

func (s FileStreamInfo) String() string {
	return tea.Prettify(s)
}

func (s FileStreamInfo) GoString() string {
	return s.String()
}

func (s *FileStreamInfo) SetContentHash(v string) *FileStreamInfo {
	s.ContentHash = &v
	return s
}

func (s *FileStreamInfo) SetContentHashName(v string) *FileStreamInfo {
	s.ContentHashName = &v
	return s
}

func (s *FileStreamInfo) SetContentMd5(v string) *FileStreamInfo {
	s.ContentMd5 = &v
	return s
}

func (s *FileStreamInfo) SetPartInfoList(v []*UploadPartInfo) *FileStreamInfo {
	s.PartInfoList = v
	return s
}

func (s *FileStreamInfo) SetPreHash(v string) *FileStreamInfo {
	s.PreHash = &v
	return s
}

func (s *FileStreamInfo) SetProofCode(v string) *FileStreamInfo {
	s.ProofCode = &v
	return s
}

func (s *FileStreamInfo) SetProofVersion(v string) *FileStreamInfo {
	s.ProofVersion = &v
	return s
}

func (s *FileStreamInfo) SetSize(v int64) *FileStreamInfo {
	s.Size = &v
	return s
}

/**
 *
 */
type FpRef struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// file_revision_id
	FileRevisionId *string `json:"file_revision_id,omitempty" xml:"file_revision_id,omitempty"`
}

func (s FpRef) String() string {
	return tea.Prettify(s)
}

func (s FpRef) GoString() string {
	return s.String()
}

func (s *FpRef) SetDomainId(v string) *FpRef {
	s.DomainId = &v
	return s
}

func (s *FpRef) SetDriveId(v string) *FpRef {
	s.DriveId = &v
	return s
}

func (s *FpRef) SetFileId(v string) *FpRef {
	s.FileId = &v
	return s
}

func (s *FpRef) SetFileRevisionId(v string) *FpRef {
	s.FileRevisionId = &v
	return s
}

/**
 *
 */
type GetAccessTokenByLinkInfoRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s GetAccessTokenByLinkInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAccessTokenByLinkInfoRequest) GoString() string {
	return s.String()
}

func (s *GetAccessTokenByLinkInfoRequest) SetHttpheaders(v map[string]*string) *GetAccessTokenByLinkInfoRequest {
	s.Httpheaders = v
	return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetExtra(v string) *GetAccessTokenByLinkInfoRequest {
	s.Extra = &v
	return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetIdentity(v string) *GetAccessTokenByLinkInfoRequest {
	s.Identity = &v
	return s
}

func (s *GetAccessTokenByLinkInfoRequest) SetType(v string) *GetAccessTokenByLinkInfoRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type GetAppPublicKeyRequest struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetAppPublicKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppPublicKeyRequest) GoString() string {
	return s.String()
}

func (s *GetAppPublicKeyRequest) SetAppId(v string) *GetAppPublicKeyRequest {
	s.AppId = &v
	return s
}

/**
 *
 */
type GetAppRequest struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetAppRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppRequest) GoString() string {
	return s.String()
}

func (s *GetAppRequest) SetAppId(v string) *GetAppRequest {
	s.AppId = &v
	return s
}

/**
 * 
 */
type GetAsyncTaskRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// async_task_id
	// type:string
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s GetAsyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskRequest) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskRequest) SetHttpheaders(v map[string]*string) *GetAsyncTaskRequest {
	s.Httpheaders = v
	return s
}

func (s *GetAsyncTaskRequest) SetAsyncTaskId(v string) *GetAsyncTaskRequest {
	s.AsyncTaskId = &v
	return s
}

/**
 * Get AsyncTask Response
 */
type GetAsyncTaskResponse struct {
	// async_task_id
	// type:string
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// consumed_process
	ConsumedProcess *int64 `json:"consumed_process,omitempty" xml:"consumed_process,omitempty"`
	// err_code
	ErrCode *int64 `json:"err_code,omitempty" xml:"err_code,omitempty"`
	// message
	Message *string `json:"message,omitempty" xml:"message,omitempty"`
	// punished_file_count
	PunishedFileCount *int64 `json:"punished_file_count,omitempty" xml:"punished_file_count,omitempty"`
	// state
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// total_process
	TotalProcess *int64 `json:"total_process,omitempty" xml:"total_process,omitempty"`
	// download_url
	// example
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetAsyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskResponse) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskResponse) SetAsyncTaskId(v string) *GetAsyncTaskResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *GetAsyncTaskResponse) SetConsumedProcess(v int64) *GetAsyncTaskResponse {
	s.ConsumedProcess = &v
	return s
}

func (s *GetAsyncTaskResponse) SetErrCode(v int64) *GetAsyncTaskResponse {
	s.ErrCode = &v
	return s
}

func (s *GetAsyncTaskResponse) SetMessage(v string) *GetAsyncTaskResponse {
	s.Message = &v
	return s
}

func (s *GetAsyncTaskResponse) SetPunishedFileCount(v int64) *GetAsyncTaskResponse {
	s.PunishedFileCount = &v
	return s
}

func (s *GetAsyncTaskResponse) SetState(v string) *GetAsyncTaskResponse {
	s.State = &v
	return s
}

func (s *GetAsyncTaskResponse) SetTotalProcess(v int64) *GetAsyncTaskResponse {
	s.TotalProcess = &v
	return s
}

func (s *GetAsyncTaskResponse) SetUrl(v string) *GetAsyncTaskResponse {
	s.Url = &v
	return s
}

/**
 *
 */
type GetBizCNameInfoRequest struct {
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s GetBizCNameInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBizCNameInfoRequest) GoString() string {
	return s.String()
}

func (s *GetBizCNameInfoRequest) SetCnameType(v string) *GetBizCNameInfoRequest {
	s.CnameType = &v
	return s
}

func (s *GetBizCNameInfoRequest) SetDomainId(v string) *GetBizCNameInfoRequest {
	s.DomainId = &v
	return s
}

func (s *GetBizCNameInfoRequest) SetIsVpc(v bool) *GetBizCNameInfoRequest {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type GetByLinkInfoRequest struct {
	Httpheaders    map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	CustomIdentity *string            `json:"custom_identity,omitempty" xml:"custom_identity,omitempty"`
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s GetByLinkInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetByLinkInfoRequest) GoString() string {
	return s.String()
}

func (s *GetByLinkInfoRequest) SetHttpheaders(v map[string]*string) *GetByLinkInfoRequest {
	s.Httpheaders = v
	return s
}

func (s *GetByLinkInfoRequest) SetCustomIdentity(v string) *GetByLinkInfoRequest {
	s.CustomIdentity = &v
	return s
}

func (s *GetByLinkInfoRequest) SetExtra(v string) *GetByLinkInfoRequest {
	s.Extra = &v
	return s
}

func (s *GetByLinkInfoRequest) SetIdentity(v string) *GetByLinkInfoRequest {
	s.Identity = &v
	return s
}

func (s *GetByLinkInfoRequest) SetType(v string) *GetByLinkInfoRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type GetCaptchaRequest struct {
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
}

func (s GetCaptchaRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCaptchaRequest) GoString() string {
	return s.String()
}

func (s *GetCaptchaRequest) SetAppId(v string) *GetCaptchaRequest {
	s.AppId = &v
	return s
}

/**
 *
 */
type GetCorsRuleListRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s GetCorsRuleListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCorsRuleListRequest) GoString() string {
	return s.String()
}

func (s *GetCorsRuleListRequest) SetDomainId(v string) *GetCorsRuleListRequest {
	s.DomainId = &v
	return s
}

/**
 *
 */
type GetDataCNameInfoRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s GetDataCNameInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCNameInfoRequest) GoString() string {
	return s.String()
}

func (s *GetDataCNameInfoRequest) SetDomainId(v string) *GetDataCNameInfoRequest {
	s.DomainId = &v
	return s
}

/**
 * Get default drive request
 */
type GetDefaultDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetDefaultDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultDriveRequest) GoString() string {
	return s.String()
}

func (s *GetDefaultDriveRequest) SetHttpheaders(v map[string]*string) *GetDefaultDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *GetDefaultDriveRequest) SetSubdomainId(v string) *GetDefaultDriveRequest {
	s.SubdomainId = &v
	return s
}

func (s *GetDefaultDriveRequest) SetUserId(v string) *GetDefaultDriveRequest {
	s.UserId = &v
	return s
}

/**
 * size
 */
type GetDirSizeInfoResponse struct {
	// dir_count
	DirCount *int64 `json:"dir_count,omitempty" xml:"dir_count,omitempty"`
	// file_count
	FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
	// size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s GetDirSizeInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDirSizeInfoResponse) GoString() string {
	return s.String()
}

func (s *GetDirSizeInfoResponse) SetDirCount(v int64) *GetDirSizeInfoResponse {
	s.DirCount = &v
	return s
}

func (s *GetDirSizeInfoResponse) SetFileCount(v int64) *GetDirSizeInfoResponse {
	s.FileCount = &v
	return s
}

func (s *GetDirSizeInfoResponse) SetSize(v int64) *GetDirSizeInfoResponse {
	s.Size = &v
	return s
}

/**
 * get domain request
 */
type GetDomainRequest struct {
	// Domain ID
	DomainId   *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	GetBenefit *bool   `json:"get_benefit,omitempty" xml:"get_benefit,omitempty"`
	// share/share_link
	GetShareDetail *bool `json:"get_share_detail,omitempty" xml:"get_share_detail,omitempty"`
	//  merge parent 
	MergeParent *bool `json:"merge_parent,omitempty" xml:"merge_parent,omitempty"`
}

func (s GetDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDomainRequest) GoString() string {
	return s.String()
}

func (s *GetDomainRequest) SetDomainId(v string) *GetDomainRequest {
	s.DomainId = &v
	return s
}

func (s *GetDomainRequest) SetGetBenefit(v bool) *GetDomainRequest {
	s.GetBenefit = &v
	return s
}

func (s *GetDomainRequest) SetGetShareDetail(v bool) *GetDomainRequest {
	s.GetShareDetail = &v
	return s
}

func (s *GetDomainRequest) SetMergeParent(v bool) *GetDomainRequest {
	s.MergeParent = &v
	return s
}

/**
 * body
 */
type GetDownloadUrlRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"115200" minimum:"1"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty" maxLength:"1024" minLength:"1"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	Referer  *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	StaticUrl *bool   `json:"static_url,omitempty" xml:"static_url,omitempty"`
}

func (s GetDownloadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadUrlRequest) GoString() string {
	return s.String()
}

func (s *GetDownloadUrlRequest) SetHttpheaders(v map[string]*string) *GetDownloadUrlRequest {
	s.Httpheaders = v
	return s
}

func (s *GetDownloadUrlRequest) SetAdditionData(v map[string]interface{}) *GetDownloadUrlRequest {
	s.AdditionData = v
	return s
}

func (s *GetDownloadUrlRequest) SetDriveId(v string) *GetDownloadUrlRequest {
	s.DriveId = &v
	return s
}

func (s *GetDownloadUrlRequest) SetExpireSec(v int64) *GetDownloadUrlRequest {
	s.ExpireSec = &v
	return s
}

func (s *GetDownloadUrlRequest) SetFileId(v string) *GetDownloadUrlRequest {
	s.FileId = &v
	return s
}

func (s *GetDownloadUrlRequest) SetFileIdPath(v string) *GetDownloadUrlRequest {
	s.FileIdPath = &v
	return s
}

func (s *GetDownloadUrlRequest) SetFileName(v string) *GetDownloadUrlRequest {
	s.FileName = &v
	return s
}

func (s *GetDownloadUrlRequest) SetLocation(v string) *GetDownloadUrlRequest {
	s.Location = &v
	return s
}

func (s *GetDownloadUrlRequest) SetReferer(v string) *GetDownloadUrlRequest {
	s.Referer = &v
	return s
}

func (s *GetDownloadUrlRequest) SetShareId(v string) *GetDownloadUrlRequest {
	s.ShareId = &v
	return s
}

func (s *GetDownloadUrlRequest) SetSignToken(v string) *GetDownloadUrlRequest {
	s.SignToken = &v
	return s
}

func (s *GetDownloadUrlRequest) SetStaticUrl(v bool) *GetDownloadUrlRequest {
	s.StaticUrl = &v
	return s
}

/**
 * download url response
 */
type GetDownloadUrlResponse struct {
	// cdn_url
	CdnUrl *string `json:"cdn_url,omitempty" xml:"cdn_url,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// internal_url
	InternalUrl *string `json:"internal_url,omitempty" xml:"internal_url,omitempty"`
	// method
	Method *string `json:"method,omitempty" xml:"method,omitempty"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
	// streams info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// streams url info
	StreamsUrl map[string]interface{} `json:"streams_url,omitempty" xml:"streams_url,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetDownloadUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadUrlResponse) GoString() string {
	return s.String()
}

func (s *GetDownloadUrlResponse) SetCdnUrl(v string) *GetDownloadUrlResponse {
	s.CdnUrl = &v
	return s
}

func (s *GetDownloadUrlResponse) SetContentHash(v string) *GetDownloadUrlResponse {
	s.ContentHash = &v
	return s
}

func (s *GetDownloadUrlResponse) SetContentHashName(v string) *GetDownloadUrlResponse {
	s.ContentHashName = &v
	return s
}

func (s *GetDownloadUrlResponse) SetCrc64Hash(v string) *GetDownloadUrlResponse {
	s.Crc64Hash = &v
	return s
}

func (s *GetDownloadUrlResponse) SetExpiration(v string) *GetDownloadUrlResponse {
	s.Expiration = &v
	return s
}

func (s *GetDownloadUrlResponse) SetInternalUrl(v string) *GetDownloadUrlResponse {
	s.InternalUrl = &v
	return s
}

func (s *GetDownloadUrlResponse) SetMethod(v string) *GetDownloadUrlResponse {
	s.Method = &v
	return s
}

func (s *GetDownloadUrlResponse) SetPunishFlag(v int64) *GetDownloadUrlResponse {
	s.PunishFlag = &v
	return s
}

func (s *GetDownloadUrlResponse) SetSize(v int64) *GetDownloadUrlResponse {
	s.Size = &v
	return s
}

func (s *GetDownloadUrlResponse) SetStreamsInfo(v map[string]interface{}) *GetDownloadUrlResponse {
	s.StreamsInfo = v
	return s
}

func (s *GetDownloadUrlResponse) SetStreamsUrl(v map[string]interface{}) *GetDownloadUrlResponse {
	s.StreamsUrl = v
	return s
}

func (s *GetDownloadUrlResponse) SetUrl(v string) *GetDownloadUrlResponse {
	s.Url = &v
	return s
}

/**
 * Get drive request
 */
type GetDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDriveRequest) GoString() string {
	return s.String()
}

func (s *GetDriveRequest) SetHttpheaders(v map[string]*string) *GetDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *GetDriveRequest) SetDriveId(v string) *GetDriveRequest {
	s.DriveId = &v
	return s
}

func (s *GetDriveRequest) SetSubdomainId(v string) *GetDriveRequest {
	s.SubdomainId = &v
	return s
}

/**
 * Get drive response
 */
type GetDriveResponse struct {
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	CreatedAt  *string   `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Drive 
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// Drive 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// Drive 
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
	// Drive 
	DriveType         *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
	EncryptDataAccess *bool   `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
	EncryptMode       *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// Drive 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// Drive 
	OwnerType  *string                `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// DrivestoredomainPathTypeOSSPath
	RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
	// Drive 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	//  ID, domainPathTypeOSSPath
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// Drive 
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// Drive 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s GetDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDriveResponse) GoString() string {
	return s.String()
}

func (s *GetDriveResponse) SetActionList(v []*string) *GetDriveResponse {
	s.ActionList = v
	return s
}

func (s *GetDriveResponse) SetCreatedAt(v string) *GetDriveResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetDriveResponse) SetCreator(v string) *GetDriveResponse {
	s.Creator = &v
	return s
}

func (s *GetDriveResponse) SetDescription(v string) *GetDriveResponse {
	s.Description = &v
	return s
}

func (s *GetDriveResponse) SetDomainId(v string) *GetDriveResponse {
	s.DomainId = &v
	return s
}

func (s *GetDriveResponse) SetDriveId(v string) *GetDriveResponse {
	s.DriveId = &v
	return s
}

func (s *GetDriveResponse) SetDriveName(v string) *GetDriveResponse {
	s.DriveName = &v
	return s
}

func (s *GetDriveResponse) SetDriveType(v string) *GetDriveResponse {
	s.DriveType = &v
	return s
}

func (s *GetDriveResponse) SetEncryptDataAccess(v bool) *GetDriveResponse {
	s.EncryptDataAccess = &v
	return s
}

func (s *GetDriveResponse) SetEncryptMode(v string) *GetDriveResponse {
	s.EncryptMode = &v
	return s
}

func (s *GetDriveResponse) SetOwner(v string) *GetDriveResponse {
	s.Owner = &v
	return s
}

func (s *GetDriveResponse) SetOwnerType(v string) *GetDriveResponse {
	s.OwnerType = &v
	return s
}

func (s *GetDriveResponse) SetPermission(v map[string]interface{}) *GetDriveResponse {
	s.Permission = v
	return s
}

func (s *GetDriveResponse) SetRelativePath(v string) *GetDriveResponse {
	s.RelativePath = &v
	return s
}

func (s *GetDriveResponse) SetStatus(v string) *GetDriveResponse {
	s.Status = &v
	return s
}

func (s *GetDriveResponse) SetStoreId(v string) *GetDriveResponse {
	s.StoreId = &v
	return s
}

func (s *GetDriveResponse) SetSubdomainId(v string) *GetDriveResponse {
	s.SubdomainId = &v
	return s
}

func (s *GetDriveResponse) SetTotalSize(v int64) *GetDriveResponse {
	s.TotalSize = &v
	return s
}

func (s *GetDriveResponse) SetUsedSize(v int64) *GetDriveResponse {
	s.UsedSize = &v
	return s
}

/**
 *  File  body
 */
type GetFileByPathRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_path
	FilePath                  *string   `json:"file_path,omitempty" xml:"file_path,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	SignToken              *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetFileByPathRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileByPathRequest) GoString() string {
	return s.String()
}

func (s *GetFileByPathRequest) SetHttpheaders(v map[string]*string) *GetFileByPathRequest {
	s.Httpheaders = v
	return s
}

func (s *GetFileByPathRequest) SetAdditionData(v map[string]interface{}) *GetFileByPathRequest {
	s.AdditionData = v
	return s
}

func (s *GetFileByPathRequest) SetDriveId(v string) *GetFileByPathRequest {
	s.DriveId = &v
	return s
}

func (s *GetFileByPathRequest) SetFilePath(v string) *GetFileByPathRequest {
	s.FilePath = &v
	return s
}

func (s *GetFileByPathRequest) SetImageCroppingAspectRatios(v []*string) *GetFileByPathRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *GetFileByPathRequest) SetImageThumbnailProcess(v string) *GetFileByPathRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *GetFileByPathRequest) SetImageUrlProcess(v string) *GetFileByPathRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *GetFileByPathRequest) SetOfficeThumbnailProcess(v string) *GetFileByPathRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *GetFileByPathRequest) SetReferer(v string) *GetFileByPathRequest {
	s.Referer = &v
	return s
}

func (s *GetFileByPathRequest) SetSignToken(v string) *GetFileByPathRequest {
	s.SignToken = &v
	return s
}

func (s *GetFileByPathRequest) SetUrlExpireSec(v int64) *GetFileByPathRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *GetFileByPathRequest) SetVideoThumbnailProcess(v string) *GetFileByPathRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type GetFileByPathResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// Trashed
	// type: boolean
	Trashed *bool `json:"trashed,omitempty" xml:"trashed,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s GetFileByPathResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileByPathResponse) GoString() string {
	return s.String()
}

func (s *GetFileByPathResponse) SetActionList(v []*string) *GetFileByPathResponse {
	s.ActionList = v
	return s
}

func (s *GetFileByPathResponse) SetAutoDeleteLeftSec(v int64) *GetFileByPathResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *GetFileByPathResponse) SetCategory(v string) *GetFileByPathResponse {
	s.Category = &v
	return s
}

func (s *GetFileByPathResponse) SetCharacteristicHash(v string) *GetFileByPathResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *GetFileByPathResponse) SetContentHash(v string) *GetFileByPathResponse {
	s.ContentHash = &v
	return s
}

func (s *GetFileByPathResponse) SetContentHashName(v string) *GetFileByPathResponse {
	s.ContentHashName = &v
	return s
}

func (s *GetFileByPathResponse) SetContentType(v string) *GetFileByPathResponse {
	s.ContentType = &v
	return s
}

func (s *GetFileByPathResponse) SetCrc64Hash(v string) *GetFileByPathResponse {
	s.Crc64Hash = &v
	return s
}

func (s *GetFileByPathResponse) SetCreatedAt(v string) *GetFileByPathResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetFileByPathResponse) SetCreatorId(v string) *GetFileByPathResponse {
	s.CreatorId = &v
	return s
}

func (s *GetFileByPathResponse) SetCreatorName(v string) *GetFileByPathResponse {
	s.CreatorName = &v
	return s
}

func (s *GetFileByPathResponse) SetCreatorType(v string) *GetFileByPathResponse {
	s.CreatorType = &v
	return s
}

func (s *GetFileByPathResponse) SetCustomField1(v string) *GetFileByPathResponse {
	s.CustomField1 = &v
	return s
}

func (s *GetFileByPathResponse) SetCustomField2(v string) *GetFileByPathResponse {
	s.CustomField2 = &v
	return s
}

func (s *GetFileByPathResponse) SetCustomType(v string) *GetFileByPathResponse {
	s.CustomType = &v
	return s
}

func (s *GetFileByPathResponse) SetDescription(v string) *GetFileByPathResponse {
	s.Description = &v
	return s
}

func (s *GetFileByPathResponse) SetDomainId(v string) *GetFileByPathResponse {
	s.DomainId = &v
	return s
}

func (s *GetFileByPathResponse) SetDownloadUrl(v string) *GetFileByPathResponse {
	s.DownloadUrl = &v
	return s
}

func (s *GetFileByPathResponse) SetDriveId(v string) *GetFileByPathResponse {
	s.DriveId = &v
	return s
}

func (s *GetFileByPathResponse) SetEncryptMode(v string) *GetFileByPathResponse {
	s.EncryptMode = &v
	return s
}

func (s *GetFileByPathResponse) SetExFieldsInfo(v map[string]interface{}) *GetFileByPathResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *GetFileByPathResponse) SetFileExtension(v string) *GetFileByPathResponse {
	s.FileExtension = &v
	return s
}

func (s *GetFileByPathResponse) SetFileId(v string) *GetFileByPathResponse {
	s.FileId = &v
	return s
}

func (s *GetFileByPathResponse) SetFilePathType(v string) *GetFileByPathResponse {
	s.FilePathType = &v
	return s
}

func (s *GetFileByPathResponse) SetHidden(v bool) *GetFileByPathResponse {
	s.Hidden = &v
	return s
}

func (s *GetFileByPathResponse) SetImageMediaMetadata(v *ImageMediaResponse) *GetFileByPathResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *GetFileByPathResponse) SetLabels(v []*string) *GetFileByPathResponse {
	s.Labels = v
	return s
}

func (s *GetFileByPathResponse) SetLastModifierId(v string) *GetFileByPathResponse {
	s.LastModifierId = &v
	return s
}

func (s *GetFileByPathResponse) SetLastModifierName(v string) *GetFileByPathResponse {
	s.LastModifierName = &v
	return s
}

func (s *GetFileByPathResponse) SetLastModifierType(v string) *GetFileByPathResponse {
	s.LastModifierType = &v
	return s
}

func (s *GetFileByPathResponse) SetLocalCreatedAt(v string) *GetFileByPathResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *GetFileByPathResponse) SetLocalModifiedAt(v string) *GetFileByPathResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *GetFileByPathResponse) SetMeta(v string) *GetFileByPathResponse {
	s.Meta = &v
	return s
}

func (s *GetFileByPathResponse) SetMimeExtension(v string) *GetFileByPathResponse {
	s.MimeExtension = &v
	return s
}

func (s *GetFileByPathResponse) SetMimeType(v string) *GetFileByPathResponse {
	s.MimeType = &v
	return s
}

func (s *GetFileByPathResponse) SetName(v string) *GetFileByPathResponse {
	s.Name = &v
	return s
}

func (s *GetFileByPathResponse) SetParentFileId(v string) *GetFileByPathResponse {
	s.ParentFileId = &v
	return s
}

func (s *GetFileByPathResponse) SetPunishFlag(v int64) *GetFileByPathResponse {
	s.PunishFlag = &v
	return s
}

func (s *GetFileByPathResponse) SetRevisionId(v string) *GetFileByPathResponse {
	s.RevisionId = &v
	return s
}

func (s *GetFileByPathResponse) SetShareId(v string) *GetFileByPathResponse {
	s.ShareId = &v
	return s
}

func (s *GetFileByPathResponse) SetSize(v int64) *GetFileByPathResponse {
	s.Size = &v
	return s
}

func (s *GetFileByPathResponse) SetStarred(v bool) *GetFileByPathResponse {
	s.Starred = &v
	return s
}

func (s *GetFileByPathResponse) SetStatus(v string) *GetFileByPathResponse {
	s.Status = &v
	return s
}

func (s *GetFileByPathResponse) SetStreamsInfo(v map[string]interface{}) *GetFileByPathResponse {
	s.StreamsInfo = v
	return s
}

func (s *GetFileByPathResponse) SetSyncDeviceFlag(v bool) *GetFileByPathResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *GetFileByPathResponse) SetSyncFlag(v bool) *GetFileByPathResponse {
	s.SyncFlag = &v
	return s
}

func (s *GetFileByPathResponse) SetSyncMeta(v string) *GetFileByPathResponse {
	s.SyncMeta = &v
	return s
}

func (s *GetFileByPathResponse) SetThumbnail(v string) *GetFileByPathResponse {
	s.Thumbnail = &v
	return s
}

func (s *GetFileByPathResponse) SetTrashed(v bool) *GetFileByPathResponse {
	s.Trashed = &v
	return s
}

func (s *GetFileByPathResponse) SetTrashedAt(v string) *GetFileByPathResponse {
	s.TrashedAt = &v
	return s
}

func (s *GetFileByPathResponse) SetType(v string) *GetFileByPathResponse {
	s.Type = &v
	return s
}

func (s *GetFileByPathResponse) SetUpdatedAt(v string) *GetFileByPathResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetFileByPathResponse) SetUploadId(v string) *GetFileByPathResponse {
	s.UploadId = &v
	return s
}

func (s *GetFileByPathResponse) SetUrl(v string) *GetFileByPathResponse {
	s.Url = &v
	return s
}

func (s *GetFileByPathResponse) SetUserMeta(v string) *GetFileByPathResponse {
	s.UserMeta = &v
	return s
}

func (s *GetFileByPathResponse) SetUserTags(v map[string]interface{}) *GetFileByPathResponse {
	s.UserTags = v
	return s
}

func (s *GetFileByPathResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *GetFileByPathResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *GetFileByPathResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *GetFileByPathResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 * 
 */
type GetFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// fields
	Fields *string `json:"fields,omitempty" xml:"fields,omitempty"`
	// file_id
	FileId                    *string   `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath                *string   `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileRequest) GoString() string {
	return s.String()
}

func (s *GetFileRequest) SetHttpheaders(v map[string]*string) *GetFileRequest {
	s.Httpheaders = v
	return s
}

func (s *GetFileRequest) SetAdditionData(v map[string]interface{}) *GetFileRequest {
	s.AdditionData = v
	return s
}

func (s *GetFileRequest) SetDriveId(v string) *GetFileRequest {
	s.DriveId = &v
	return s
}

func (s *GetFileRequest) SetFields(v string) *GetFileRequest {
	s.Fields = &v
	return s
}

func (s *GetFileRequest) SetFileId(v string) *GetFileRequest {
	s.FileId = &v
	return s
}

func (s *GetFileRequest) SetFileIdPath(v string) *GetFileRequest {
	s.FileIdPath = &v
	return s
}

func (s *GetFileRequest) SetImageCroppingAspectRatios(v []*string) *GetFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *GetFileRequest) SetImageThumbnailProcess(v string) *GetFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *GetFileRequest) SetImageUrlProcess(v string) *GetFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *GetFileRequest) SetLocation(v string) *GetFileRequest {
	s.Location = &v
	return s
}

func (s *GetFileRequest) SetOfficeThumbnailProcess(v string) *GetFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *GetFileRequest) SetReferer(v string) *GetFileRequest {
	s.Referer = &v
	return s
}

func (s *GetFileRequest) SetRevisionId(v string) *GetFileRequest {
	s.RevisionId = &v
	return s
}

func (s *GetFileRequest) SetShareId(v string) *GetFileRequest {
	s.ShareId = &v
	return s
}

func (s *GetFileRequest) SetSignToken(v string) *GetFileRequest {
	s.SignToken = &v
	return s
}

func (s *GetFileRequest) SetUrlExpireSec(v int64) *GetFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *GetFileRequest) SetVideoThumbnailProcess(v string) *GetFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type GetFileResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// Trashed
	// type: boolean
	Trashed *bool `json:"trashed,omitempty" xml:"trashed,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s GetFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponse) GoString() string {
	return s.String()
}

func (s *GetFileResponse) SetActionList(v []*string) *GetFileResponse {
	s.ActionList = v
	return s
}

func (s *GetFileResponse) SetAutoDeleteLeftSec(v int64) *GetFileResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *GetFileResponse) SetCategory(v string) *GetFileResponse {
	s.Category = &v
	return s
}

func (s *GetFileResponse) SetCharacteristicHash(v string) *GetFileResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *GetFileResponse) SetContentHash(v string) *GetFileResponse {
	s.ContentHash = &v
	return s
}

func (s *GetFileResponse) SetContentHashName(v string) *GetFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *GetFileResponse) SetContentType(v string) *GetFileResponse {
	s.ContentType = &v
	return s
}

func (s *GetFileResponse) SetCrc64Hash(v string) *GetFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *GetFileResponse) SetCreatedAt(v string) *GetFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetFileResponse) SetCreatorId(v string) *GetFileResponse {
	s.CreatorId = &v
	return s
}

func (s *GetFileResponse) SetCreatorName(v string) *GetFileResponse {
	s.CreatorName = &v
	return s
}

func (s *GetFileResponse) SetCreatorType(v string) *GetFileResponse {
	s.CreatorType = &v
	return s
}

func (s *GetFileResponse) SetCustomField1(v string) *GetFileResponse {
	s.CustomField1 = &v
	return s
}

func (s *GetFileResponse) SetCustomField2(v string) *GetFileResponse {
	s.CustomField2 = &v
	return s
}

func (s *GetFileResponse) SetCustomType(v string) *GetFileResponse {
	s.CustomType = &v
	return s
}

func (s *GetFileResponse) SetDescription(v string) *GetFileResponse {
	s.Description = &v
	return s
}

func (s *GetFileResponse) SetDomainId(v string) *GetFileResponse {
	s.DomainId = &v
	return s
}

func (s *GetFileResponse) SetDownloadUrl(v string) *GetFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *GetFileResponse) SetDriveId(v string) *GetFileResponse {
	s.DriveId = &v
	return s
}

func (s *GetFileResponse) SetEncryptMode(v string) *GetFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *GetFileResponse) SetExFieldsInfo(v map[string]interface{}) *GetFileResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *GetFileResponse) SetFileExtension(v string) *GetFileResponse {
	s.FileExtension = &v
	return s
}

func (s *GetFileResponse) SetFileId(v string) *GetFileResponse {
	s.FileId = &v
	return s
}

func (s *GetFileResponse) SetFilePathType(v string) *GetFileResponse {
	s.FilePathType = &v
	return s
}

func (s *GetFileResponse) SetHidden(v bool) *GetFileResponse {
	s.Hidden = &v
	return s
}

func (s *GetFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *GetFileResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *GetFileResponse) SetLabels(v []*string) *GetFileResponse {
	s.Labels = v
	return s
}

func (s *GetFileResponse) SetLastModifierId(v string) *GetFileResponse {
	s.LastModifierId = &v
	return s
}

func (s *GetFileResponse) SetLastModifierName(v string) *GetFileResponse {
	s.LastModifierName = &v
	return s
}

func (s *GetFileResponse) SetLastModifierType(v string) *GetFileResponse {
	s.LastModifierType = &v
	return s
}

func (s *GetFileResponse) SetLocalCreatedAt(v string) *GetFileResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *GetFileResponse) SetLocalModifiedAt(v string) *GetFileResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *GetFileResponse) SetMeta(v string) *GetFileResponse {
	s.Meta = &v
	return s
}

func (s *GetFileResponse) SetMimeExtension(v string) *GetFileResponse {
	s.MimeExtension = &v
	return s
}

func (s *GetFileResponse) SetMimeType(v string) *GetFileResponse {
	s.MimeType = &v
	return s
}

func (s *GetFileResponse) SetName(v string) *GetFileResponse {
	s.Name = &v
	return s
}

func (s *GetFileResponse) SetParentFileId(v string) *GetFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *GetFileResponse) SetPunishFlag(v int64) *GetFileResponse {
	s.PunishFlag = &v
	return s
}

func (s *GetFileResponse) SetRevisionId(v string) *GetFileResponse {
	s.RevisionId = &v
	return s
}

func (s *GetFileResponse) SetShareId(v string) *GetFileResponse {
	s.ShareId = &v
	return s
}

func (s *GetFileResponse) SetSize(v int64) *GetFileResponse {
	s.Size = &v
	return s
}

func (s *GetFileResponse) SetStarred(v bool) *GetFileResponse {
	s.Starred = &v
	return s
}

func (s *GetFileResponse) SetStatus(v string) *GetFileResponse {
	s.Status = &v
	return s
}

func (s *GetFileResponse) SetStreamsInfo(v map[string]interface{}) *GetFileResponse {
	s.StreamsInfo = v
	return s
}

func (s *GetFileResponse) SetSyncDeviceFlag(v bool) *GetFileResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *GetFileResponse) SetSyncFlag(v bool) *GetFileResponse {
	s.SyncFlag = &v
	return s
}

func (s *GetFileResponse) SetSyncMeta(v string) *GetFileResponse {
	s.SyncMeta = &v
	return s
}

func (s *GetFileResponse) SetThumbnail(v string) *GetFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *GetFileResponse) SetTrashed(v bool) *GetFileResponse {
	s.Trashed = &v
	return s
}

func (s *GetFileResponse) SetTrashedAt(v string) *GetFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *GetFileResponse) SetType(v string) *GetFileResponse {
	s.Type = &v
	return s
}

func (s *GetFileResponse) SetUpdatedAt(v string) *GetFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetFileResponse) SetUploadId(v string) *GetFileResponse {
	s.UploadId = &v
	return s
}

func (s *GetFileResponse) SetUrl(v string) *GetFileResponse {
	s.Url = &v
	return s
}

func (s *GetFileResponse) SetUserMeta(v string) *GetFileResponse {
	s.UserMeta = &v
	return s
}

func (s *GetFileResponse) SetUserTags(v map[string]interface{}) *GetFileResponse {
	s.UserTags = v
	return s
}

func (s *GetFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *GetFileResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *GetFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *GetFileResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 * 
 */
type GetLastCursorRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// sync_root_id
	SyncRootId *string `json:"sync_root_id,omitempty" xml:"sync_root_id,omitempty"`
}

func (s GetLastCursorRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLastCursorRequest) GoString() string {
	return s.String()
}

func (s *GetLastCursorRequest) SetHttpheaders(v map[string]*string) *GetLastCursorRequest {
	s.Httpheaders = v
	return s
}

func (s *GetLastCursorRequest) SetDriveId(v string) *GetLastCursorRequest {
	s.DriveId = &v
	return s
}

func (s *GetLastCursorRequest) SetSyncRootId(v string) *GetLastCursorRequest {
	s.SyncRootId = &v
	return s
}

/**
 * get last file op cursor response
 */
type GetLastCursorResponse struct {
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
}

func (s GetLastCursorResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLastCursorResponse) GoString() string {
	return s.String()
}

func (s *GetLastCursorResponse) SetCursor(v string) *GetLastCursorResponse {
	s.Cursor = &v
	return s
}

/**
 *
 */
type GetLinkInfoByUserIDRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// user ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetLinkInfoByUserIDRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLinkInfoByUserIDRequest) GoString() string {
	return s.String()
}

func (s *GetLinkInfoByUserIDRequest) SetHttpheaders(v map[string]*string) *GetLinkInfoByUserIDRequest {
	s.Httpheaders = v
	return s
}

func (s *GetLinkInfoByUserIDRequest) SetUserId(v string) *GetLinkInfoByUserIDRequest {
	s.UserId = &v
	return s
}

/**
 * get_media_play_url request
 */
type GetMediaPlayURLRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
}

func (s GetMediaPlayURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaPlayURLRequest) GoString() string {
	return s.String()
}

func (s *GetMediaPlayURLRequest) SetHttpheaders(v map[string]*string) *GetMediaPlayURLRequest {
	s.Httpheaders = v
	return s
}

func (s *GetMediaPlayURLRequest) SetDriveId(v string) *GetMediaPlayURLRequest {
	s.DriveId = &v
	return s
}

func (s *GetMediaPlayURLRequest) SetFileId(v string) *GetMediaPlayURLRequest {
	s.FileId = &v
	return s
}

/**
 * get_media_play_url response
 */
type GetMediaPlayURLResponse struct {
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s GetMediaPlayURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaPlayURLResponse) GoString() string {
	return s.String()
}

func (s *GetMediaPlayURLResponse) SetUrl(v string) *GetMediaPlayURLResponse {
	s.Url = &v
	return s
}

/**
 * GetOfficeEditUrlOption 
 */
type GetOfficeEditUrlOption struct {
	// Copy
	Copy     *bool `json:"copy,omitempty" xml:"copy,omitempty"`
	Readonly *bool `json:"readonly,omitempty" xml:"readonly,omitempty"`
}

func (s GetOfficeEditUrlOption) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeEditUrlOption) GoString() string {
	return s.String()
}

func (s *GetOfficeEditUrlOption) SetCopy(v bool) *GetOfficeEditUrlOption {
	s.Copy = &v
	return s
}

func (s *GetOfficeEditUrlOption) SetReadonly(v bool) *GetOfficeEditUrlOption {
	s.Readonly = &v
	return s
}

/**
 * office
 */
type GetOfficeEditUrlRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId    *string                    `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	Option    *GetOfficeEditUrlOption    `json:"option,omitempty" xml:"option,omitempty"`
	Watermark *GetOfficeEditUrlWatermark `json:"watermark,omitempty" xml:"watermark,omitempty"`
}

func (s GetOfficeEditUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeEditUrlRequest) GoString() string {
	return s.String()
}

func (s *GetOfficeEditUrlRequest) SetHttpheaders(v map[string]*string) *GetOfficeEditUrlRequest {
	s.Httpheaders = v
	return s
}

func (s *GetOfficeEditUrlRequest) SetAdditionData(v map[string]interface{}) *GetOfficeEditUrlRequest {
	s.AdditionData = v
	return s
}

func (s *GetOfficeEditUrlRequest) SetDriveId(v string) *GetOfficeEditUrlRequest {
	s.DriveId = &v
	return s
}

func (s *GetOfficeEditUrlRequest) SetFileId(v string) *GetOfficeEditUrlRequest {
	s.FileId = &v
	return s
}

func (s *GetOfficeEditUrlRequest) SetOption(v *GetOfficeEditUrlOption) *GetOfficeEditUrlRequest {
	s.Option = v
	return s
}

func (s *GetOfficeEditUrlRequest) SetWatermark(v *GetOfficeEditUrlWatermark) *GetOfficeEditUrlRequest {
	s.Watermark = v
	return s
}

/**
 * office response
 */
type GetOfficeEditUrlResponse struct {
	// EditUrl
	EditUrl *string `json:"edit_url,omitempty" xml:"edit_url,omitempty"`
	// AccessToken
	OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty"`
	// RefreshToken
	OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty"`
}

func (s GetOfficeEditUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeEditUrlResponse) GoString() string {
	return s.String()
}

func (s *GetOfficeEditUrlResponse) SetEditUrl(v string) *GetOfficeEditUrlResponse {
	s.EditUrl = &v
	return s
}

func (s *GetOfficeEditUrlResponse) SetOfficeAccessToken(v string) *GetOfficeEditUrlResponse {
	s.OfficeAccessToken = &v
	return s
}

func (s *GetOfficeEditUrlResponse) SetOfficeRefreshToken(v string) *GetOfficeEditUrlResponse {
	s.OfficeRefreshToken = &v
	return s
}

/**
 * GetOfficeEditUrlWatermark 
 */
type GetOfficeEditUrlWatermark struct {
	// FillStyle
	Fillstyle *string `json:"fillstyle,omitempty" xml:"fillstyle,omitempty"`
	// Font
	Font *string `json:"font,omitempty" xml:"font,omitempty"`
	// Horizontal
	Horizontal *int64 `json:"horizontal,omitempty" xml:"horizontal,omitempty"`
	// Rotate
	Rotate *float64 `json:"rotate,omitempty" xml:"rotate,omitempty"`
	// Type
	Type *int32 `json:"type,omitempty" xml:"type,omitempty"`
	// Value
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
	// Vertical
	Vertical *int64 `json:"vertical,omitempty" xml:"vertical,omitempty"`
}

func (s GetOfficeEditUrlWatermark) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeEditUrlWatermark) GoString() string {
	return s.String()
}

func (s *GetOfficeEditUrlWatermark) SetFillstyle(v string) *GetOfficeEditUrlWatermark {
	s.Fillstyle = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetFont(v string) *GetOfficeEditUrlWatermark {
	s.Font = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetHorizontal(v int64) *GetOfficeEditUrlWatermark {
	s.Horizontal = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetRotate(v float64) *GetOfficeEditUrlWatermark {
	s.Rotate = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetType(v int32) *GetOfficeEditUrlWatermark {
	s.Type = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetValue(v string) *GetOfficeEditUrlWatermark {
	s.Value = &v
	return s
}

func (s *GetOfficeEditUrlWatermark) SetVertical(v int64) *GetOfficeEditUrlWatermark {
	s.Vertical = &v
	return s
}

/**
 * office
 */
type GetOfficePreviewUrlRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// allow_copy
	// default true
	AllowCopy *bool `json:"allow_copy,omitempty" xml:"allow_copy,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	// language
	Language *string `json:"language,omitempty" xml:"language,omitempty"`
	Referer  *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetOfficePreviewUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOfficePreviewUrlRequest) GoString() string {
	return s.String()
}

func (s *GetOfficePreviewUrlRequest) SetHttpheaders(v map[string]*string) *GetOfficePreviewUrlRequest {
	s.Httpheaders = v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetAdditionData(v map[string]interface{}) *GetOfficePreviewUrlRequest {
	s.AdditionData = v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetAllowCopy(v bool) *GetOfficePreviewUrlRequest {
	s.AllowCopy = &v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetDriveId(v string) *GetOfficePreviewUrlRequest {
	s.DriveId = &v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetFileId(v string) *GetOfficePreviewUrlRequest {
	s.FileId = &v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetLanguage(v string) *GetOfficePreviewUrlRequest {
	s.Language = &v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetReferer(v string) *GetOfficePreviewUrlRequest {
	s.Referer = &v
	return s
}

func (s *GetOfficePreviewUrlRequest) SetShareId(v string) *GetOfficePreviewUrlRequest {
	s.ShareId = &v
	return s
}

/**
 *  response
 */
type GetOfficePreviewUrlResponse struct {
	// AccessToken
	AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty"`
	// preview_url
	PreviewUrl *string `json:"preview_url,omitempty" xml:"preview_url,omitempty"`
}

func (s GetOfficePreviewUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOfficePreviewUrlResponse) GoString() string {
	return s.String()
}

func (s *GetOfficePreviewUrlResponse) SetAccessToken(v string) *GetOfficePreviewUrlResponse {
	s.AccessToken = &v
	return s
}

func (s *GetOfficePreviewUrlResponse) SetPreviewUrl(v string) *GetOfficePreviewUrlResponse {
	s.PreviewUrl = &v
	return s
}

/**
 *
 */
type GetPublicKeyRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
}

func (s GetPublicKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPublicKeyRequest) GoString() string {
	return s.String()
}

func (s *GetPublicKeyRequest) SetHttpheaders(v map[string]*string) *GetPublicKeyRequest {
	s.Httpheaders = v
	return s
}

func (s *GetPublicKeyRequest) SetAppId(v string) *GetPublicKeyRequest {
	s.AppId = &v
	return s
}

/**
 *
 */
type GetPublicKeyResponse struct {
	// App ID
	AppId     *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	KeyPairId *string `json:"key_pair_id,omitempty" xml:"key_pair_id,omitempty"`
	// RSA, PEM
	PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s GetPublicKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPublicKeyResponse) GoString() string {
	return s.String()
}

func (s *GetPublicKeyResponse) SetAppId(v string) *GetPublicKeyResponse {
	s.AppId = &v
	return s
}

func (s *GetPublicKeyResponse) SetKeyPairId(v string) *GetPublicKeyResponse {
	s.KeyPairId = &v
	return s
}

func (s *GetPublicKeyResponse) SetPublicKey(v string) *GetPublicKeyResponse {
	s.PublicKey = &v
	return s
}

/**
 *
 */
type GetRPVerifyInfoRequest struct {
	// Need Identity Info, 
	NeedIdentityInfo *bool `json:"need_identity_info,omitempty" xml:"need_identity_info,omitempty"`
	// User ID, 
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetRPVerifyInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRPVerifyInfoRequest) GoString() string {
	return s.String()
}

func (s *GetRPVerifyInfoRequest) SetNeedIdentityInfo(v bool) *GetRPVerifyInfoRequest {
	s.NeedIdentityInfo = &v
	return s
}

func (s *GetRPVerifyInfoRequest) SetUserId(v string) *GetRPVerifyInfoRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type GetRPVerifyResultRequest struct {
	// During Verify Process, 
	DuringVerifyProcess *bool `json:"during_verify_process,omitempty" xml:"during_verify_process,omitempty"`
	// User ID, 
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetRPVerifyResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRPVerifyResultRequest) GoString() string {
	return s.String()
}

func (s *GetRPVerifyResultRequest) SetDuringVerifyProcess(v bool) *GetRPVerifyResultRequest {
	s.DuringVerifyProcess = &v
	return s
}

func (s *GetRPVerifyResultRequest) SetUserId(v string) *GetRPVerifyResultRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type GetRPVerifyTokenRequest struct {
	// User ID, 
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetRPVerifyTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRPVerifyTokenRequest) GoString() string {
	return s.String()
}

func (s *GetRPVerifyTokenRequest) SetUserId(v string) *GetRPVerifyTokenRequest {
	s.UserId = &v
	return s
}

/**
 * get_share_link_by_anonymous request
 */
type GetShareLinkByAnonymousRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareLinkByAnonymousRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkByAnonymousRequest) GoString() string {
	return s.String()
}

func (s *GetShareLinkByAnonymousRequest) SetHttpheaders(v map[string]*string) *GetShareLinkByAnonymousRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareLinkByAnonymousRequest) SetShareId(v string) *GetShareLinkByAnonymousRequest {
	s.ShareId = &v
	return s
}

/**
 * get_share_link_by_anonymous response
 */
type GetShareLinkByAnonymousResponse struct {
	// access_count
	AccessCount *int64 `json:"access_count,omitempty" xml:"access_count,omitempty"`
	// avatar
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_phone
	CreatorPhone *string `json:"creator_phone,omitempty" xml:"creator_phone,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// file_count
	FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// 
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
}

func (s GetShareLinkByAnonymousResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkByAnonymousResponse) GoString() string {
	return s.String()
}

func (s *GetShareLinkByAnonymousResponse) SetAccessCount(v int64) *GetShareLinkByAnonymousResponse {
	s.AccessCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetAvatar(v string) *GetShareLinkByAnonymousResponse {
	s.Avatar = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetComments(v string) *GetShareLinkByAnonymousResponse {
	s.Comments = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorId(v string) *GetShareLinkByAnonymousResponse {
	s.CreatorId = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorName(v string) *GetShareLinkByAnonymousResponse {
	s.CreatorName = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetCreatorPhone(v string) *GetShareLinkByAnonymousResponse {
	s.CreatorPhone = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetDisableDownload(v bool) *GetShareLinkByAnonymousResponse {
	s.DisableDownload = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetDisablePreview(v bool) *GetShareLinkByAnonymousResponse {
	s.DisablePreview = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetDisableSave(v bool) *GetShareLinkByAnonymousResponse {
	s.DisableSave = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetDownloadCount(v int64) *GetShareLinkByAnonymousResponse {
	s.DownloadCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetDownloadLimit(v int64) *GetShareLinkByAnonymousResponse {
	s.DownloadLimit = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetExpiration(v string) *GetShareLinkByAnonymousResponse {
	s.Expiration = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetFileCount(v int64) *GetShareLinkByAnonymousResponse {
	s.FileCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetPreviewCount(v int64) *GetShareLinkByAnonymousResponse {
	s.PreviewCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetPreviewLimit(v int64) *GetShareLinkByAnonymousResponse {
	s.PreviewLimit = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetReportCount(v int64) *GetShareLinkByAnonymousResponse {
	s.ReportCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetRequireLogin(v bool) *GetShareLinkByAnonymousResponse {
	s.RequireLogin = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetSaveCount(v int64) *GetShareLinkByAnonymousResponse {
	s.SaveCount = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetSaveDownloadLimit(v int64) *GetShareLinkByAnonymousResponse {
	s.SaveDownloadLimit = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetSaveLimit(v int64) *GetShareLinkByAnonymousResponse {
	s.SaveLimit = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetShareIcon(v string) *GetShareLinkByAnonymousResponse {
	s.ShareIcon = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetShareName(v string) *GetShareLinkByAnonymousResponse {
	s.ShareName = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetUpdatedAt(v string) *GetShareLinkByAnonymousResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetShareLinkByAnonymousResponse) SetVideoPreviewCount(v int64) *GetShareLinkByAnonymousResponse {
	s.VideoPreviewCount = &v
	return s
}

/**
 * body
 */
type GetShareLinkDownloadURLRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id is optional
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"600" minimum:"1"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// get_audio_play_info
	GetAudioPlayInfo *bool `json:"get_audio_play_info,omitempty" xml:"get_audio_play_info,omitempty"`
	// get_streams_url
	GetStreamsUrl *bool `json:"get_streams_url,omitempty" xml:"get_streams_url,omitempty"`
	// get_video_play_info
	GetVideoPlayInfo *bool `json:"get_video_play_info,omitempty" xml:"get_video_play_info,omitempty"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetShareLinkDownloadURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkDownloadURLRequest) GoString() string {
	return s.String()
}

func (s *GetShareLinkDownloadURLRequest) SetHttpheaders(v map[string]*string) *GetShareLinkDownloadURLRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetAdditionData(v map[string]interface{}) *GetShareLinkDownloadURLRequest {
	s.AdditionData = v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetDriveId(v string) *GetShareLinkDownloadURLRequest {
	s.DriveId = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetExpireSec(v int64) *GetShareLinkDownloadURLRequest {
	s.ExpireSec = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetFileId(v string) *GetShareLinkDownloadURLRequest {
	s.FileId = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetFileIdPath(v string) *GetShareLinkDownloadURLRequest {
	s.FileIdPath = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetGetAudioPlayInfo(v bool) *GetShareLinkDownloadURLRequest {
	s.GetAudioPlayInfo = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetGetStreamsUrl(v bool) *GetShareLinkDownloadURLRequest {
	s.GetStreamsUrl = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetGetVideoPlayInfo(v bool) *GetShareLinkDownloadURLRequest {
	s.GetVideoPlayInfo = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetImageThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetImageUrlProcess(v string) *GetShareLinkDownloadURLRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetLocation(v string) *GetShareLinkDownloadURLRequest {
	s.Location = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetOfficeThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetReferer(v string) *GetShareLinkDownloadURLRequest {
	s.Referer = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetShareId(v string) *GetShareLinkDownloadURLRequest {
	s.ShareId = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetSignToken(v string) *GetShareLinkDownloadURLRequest {
	s.SignToken = &v
	return s
}

func (s *GetShareLinkDownloadURLRequest) SetVideoThumbnailProcess(v string) *GetShareLinkDownloadURLRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type GetShareLinkDownloadURLResponse struct {
	// audio_template_list
	AudioTemplateList []*MediaPlayInfoTemplate `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// streams url info
	StreamsUrl map[string]interface{} `json:"streams_url,omitempty" xml:"streams_url,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// video_template_list
	VideoTemplateList []*MediaPlayInfoTemplate `json:"video_template_list,omitempty" xml:"video_template_list,omitempty" type:"Repeated"`
}

func (s GetShareLinkDownloadURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkDownloadURLResponse) GoString() string {
	return s.String()
}

func (s *GetShareLinkDownloadURLResponse) SetAudioTemplateList(v []*MediaPlayInfoTemplate) *GetShareLinkDownloadURLResponse {
	s.AudioTemplateList = v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetDownloadUrl(v string) *GetShareLinkDownloadURLResponse {
	s.DownloadUrl = &v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetStreamsInfo(v map[string]interface{}) *GetShareLinkDownloadURLResponse {
	s.StreamsInfo = v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetStreamsUrl(v map[string]interface{}) *GetShareLinkDownloadURLResponse {
	s.StreamsUrl = v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetThumbnail(v string) *GetShareLinkDownloadURLResponse {
	s.Thumbnail = &v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetUrl(v string) *GetShareLinkDownloadURLResponse {
	s.Url = &v
	return s
}

func (s *GetShareLinkDownloadURLResponse) SetVideoTemplateList(v []*MediaPlayInfoTemplate) *GetShareLinkDownloadURLResponse {
	s.VideoTemplateList = v
	return s
}

/**
 * get_share_id request
 */
type GetShareLinkIDRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_msg
	ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
}

func (s GetShareLinkIDRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkIDRequest) GoString() string {
	return s.String()
}

func (s *GetShareLinkIDRequest) SetHttpheaders(v map[string]*string) *GetShareLinkIDRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareLinkIDRequest) SetShareMsg(v string) *GetShareLinkIDRequest {
	s.ShareMsg = &v
	return s
}

/**
 * get_share_id response
 */
type GetShareLinkIDResponse struct {
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
}

func (s GetShareLinkIDResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkIDResponse) GoString() string {
	return s.String()
}

func (s *GetShareLinkIDResponse) SetShareId(v string) *GetShareLinkIDResponse {
	s.ShareId = &v
	return s
}

func (s *GetShareLinkIDResponse) SetSharePwd(v string) *GetShareLinkIDResponse {
	s.SharePwd = &v
	return s
}

/**
 * get_share request
 */
type GetShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkRequest) GoString() string {
	return s.String()
}

func (s *GetShareLinkRequest) SetHttpheaders(v map[string]*string) *GetShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareLinkRequest) SetShareId(v string) *GetShareLinkRequest {
	s.ShareId = &v
	return s
}

/**
 * get_share_token request
 */
type GetShareLinkTokenRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// check_share_pwd, effective for creator, admin or aksk only
	CheckSharePwd *bool `json:"check_share_pwd,omitempty" xml:"check_share_pwd,omitempty"`
	// expire_sec
	ExpireSec *int64  `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"7200" minimum:"0"`
	Referer   *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
}

func (s GetShareLinkTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkTokenRequest) GoString() string {
	return s.String()
}

func (s *GetShareLinkTokenRequest) SetHttpheaders(v map[string]*string) *GetShareLinkTokenRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareLinkTokenRequest) SetAdditionData(v map[string]interface{}) *GetShareLinkTokenRequest {
	s.AdditionData = v
	return s
}

func (s *GetShareLinkTokenRequest) SetCheckSharePwd(v bool) *GetShareLinkTokenRequest {
	s.CheckSharePwd = &v
	return s
}

func (s *GetShareLinkTokenRequest) SetExpireSec(v int64) *GetShareLinkTokenRequest {
	s.ExpireSec = &v
	return s
}

func (s *GetShareLinkTokenRequest) SetReferer(v string) *GetShareLinkTokenRequest {
	s.Referer = &v
	return s
}

func (s *GetShareLinkTokenRequest) SetShareId(v string) *GetShareLinkTokenRequest {
	s.ShareId = &v
	return s
}

func (s *GetShareLinkTokenRequest) SetSharePwd(v string) *GetShareLinkTokenRequest {
	s.SharePwd = &v
	return s
}

/**
 * get_share_token response
 */
type GetShareLinkTokenResponse struct {
	// expire_time
	ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
	// expires_in
	ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty" require:"true"`
	// share_token
	ShareToken *string `json:"share_token,omitempty" xml:"share_token,omitempty" require:"true"`
}

func (s GetShareLinkTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareLinkTokenResponse) GoString() string {
	return s.String()
}

func (s *GetShareLinkTokenResponse) SetExpireTime(v string) *GetShareLinkTokenResponse {
	s.ExpireTime = &v
	return s
}

func (s *GetShareLinkTokenResponse) SetExpiresIn(v int64) *GetShareLinkTokenResponse {
	s.ExpiresIn = &v
	return s
}

func (s *GetShareLinkTokenResponse) SetShareToken(v string) *GetShareLinkTokenResponse {
	s.ShareToken = &v
	return s
}

/**
 * get share request
 */
type GetShareRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s GetShareRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareRequest) GoString() string {
	return s.String()
}

func (s *GetShareRequest) SetHttpheaders(v map[string]*string) *GetShareRequest {
	s.Httpheaders = v
	return s
}

func (s *GetShareRequest) SetShareId(v string) *GetShareRequest {
	s.ShareId = &v
	return s
}

/**
 * Get share response
 */
type GetShareResponse struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// share_file_id
	ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
	// share_path
	ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_name
	ShareName   *string                  `json:"share_name,omitempty" xml:"share_name,omitempty"`
	SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetShareResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareResponse) GoString() string {
	return s.String()
}

func (s *GetShareResponse) SetCreatedAt(v string) *GetShareResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetShareResponse) SetCreator(v string) *GetShareResponse {
	s.Creator = &v
	return s
}

func (s *GetShareResponse) SetDescription(v string) *GetShareResponse {
	s.Description = &v
	return s
}

func (s *GetShareResponse) SetDomainId(v string) *GetShareResponse {
	s.DomainId = &v
	return s
}

func (s *GetShareResponse) SetDriveId(v string) *GetShareResponse {
	s.DriveId = &v
	return s
}

func (s *GetShareResponse) SetExpiration(v string) *GetShareResponse {
	s.Expiration = &v
	return s
}

func (s *GetShareResponse) SetExpired(v bool) *GetShareResponse {
	s.Expired = &v
	return s
}

func (s *GetShareResponse) SetOwner(v string) *GetShareResponse {
	s.Owner = &v
	return s
}

func (s *GetShareResponse) SetOwnerType(v string) *GetShareResponse {
	s.OwnerType = &v
	return s
}

func (s *GetShareResponse) SetPermissions(v []*string) *GetShareResponse {
	s.Permissions = v
	return s
}

func (s *GetShareResponse) SetShareFileId(v string) *GetShareResponse {
	s.ShareFileId = &v
	return s
}

func (s *GetShareResponse) SetShareFilePath(v string) *GetShareResponse {
	s.ShareFilePath = &v
	return s
}

func (s *GetShareResponse) SetShareId(v string) *GetShareResponse {
	s.ShareId = &v
	return s
}

func (s *GetShareResponse) SetShareName(v string) *GetShareResponse {
	s.ShareName = &v
	return s
}

func (s *GetShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *GetShareResponse {
	s.SharePolicy = v
	return s
}

func (s *GetShareResponse) SetStatus(v string) *GetShareResponse {
	s.Status = &v
	return s
}

func (s *GetShareResponse) SetUpdatedAt(v string) *GetShareResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type GetSubdomainMgmtRequest struct {
	// domain
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// share/share_link
	GetShareDetail *bool `json:"get_share_detail,omitempty" xml:"get_share_detail,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s GetSubdomainMgmtRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainMgmtRequest) GoString() string {
	return s.String()
}

func (s *GetSubdomainMgmtRequest) SetDomainId(v string) *GetSubdomainMgmtRequest {
	s.DomainId = &v
	return s
}

func (s *GetSubdomainMgmtRequest) SetGetShareDetail(v bool) *GetSubdomainMgmtRequest {
	s.GetShareDetail = &v
	return s
}

func (s *GetSubdomainMgmtRequest) SetSubdomainId(v string) *GetSubdomainMgmtRequest {
	s.SubdomainId = &v
	return s
}

/**
 * URL
 */
type GetUploadUrlRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// content_md5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// upload_part_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s GetUploadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUploadUrlRequest) GoString() string {
	return s.String()
}

func (s *GetUploadUrlRequest) SetHttpheaders(v map[string]*string) *GetUploadUrlRequest {
	s.Httpheaders = v
	return s
}

func (s *GetUploadUrlRequest) SetContentMd5(v string) *GetUploadUrlRequest {
	s.ContentMd5 = &v
	return s
}

func (s *GetUploadUrlRequest) SetDriveId(v string) *GetUploadUrlRequest {
	s.DriveId = &v
	return s
}

func (s *GetUploadUrlRequest) SetFileId(v string) *GetUploadUrlRequest {
	s.FileId = &v
	return s
}

func (s *GetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *GetUploadUrlRequest {
	s.PartInfoList = v
	return s
}

func (s *GetUploadUrlRequest) SetShareId(v string) *GetUploadUrlRequest {
	s.ShareId = &v
	return s
}

func (s *GetUploadUrlRequest) SetUploadId(v string) *GetUploadUrlRequest {
	s.UploadId = &v
	return s
}

/**
 * Get UploadUrl Response
 */
type GetUploadUrlResponse struct {
	// created_at
	CreateAt *string `json:"create_at,omitempty" xml:"create_at,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s GetUploadUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUploadUrlResponse) GoString() string {
	return s.String()
}

func (s *GetUploadUrlResponse) SetCreateAt(v string) *GetUploadUrlResponse {
	s.CreateAt = &v
	return s
}

func (s *GetUploadUrlResponse) SetDomainId(v string) *GetUploadUrlResponse {
	s.DomainId = &v
	return s
}

func (s *GetUploadUrlResponse) SetDriveId(v string) *GetUploadUrlResponse {
	s.DriveId = &v
	return s
}

func (s *GetUploadUrlResponse) SetFileId(v string) *GetUploadUrlResponse {
	s.FileId = &v
	return s
}

func (s *GetUploadUrlResponse) SetPartInfoList(v []*UploadPartInfo) *GetUploadUrlResponse {
	s.PartInfoList = v
	return s
}

func (s *GetUploadUrlResponse) SetUploadId(v string) *GetUploadUrlResponse {
	s.UploadId = &v
	return s
}

/**
 * body
 */
type GetVideoPreviewSpriteURLRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"14400" minimum:"1"`
	// file_id
	FileId  *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s GetVideoPreviewSpriteURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteURLRequest) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewSpriteURLRequest) SetHttpheaders(v map[string]*string) *GetVideoPreviewSpriteURLRequest {
	s.Httpheaders = v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetAdditionData(v map[string]interface{}) *GetVideoPreviewSpriteURLRequest {
	s.AdditionData = v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetDriveId(v string) *GetVideoPreviewSpriteURLRequest {
	s.DriveId = &v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetExpireSec(v int64) *GetVideoPreviewSpriteURLRequest {
	s.ExpireSec = &v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetFileId(v string) *GetVideoPreviewSpriteURLRequest {
	s.FileId = &v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetReferer(v string) *GetVideoPreviewSpriteURLRequest {
	s.Referer = &v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetShareId(v string) *GetVideoPreviewSpriteURLRequest {
	s.ShareId = &v
	return s
}

func (s *GetVideoPreviewSpriteURLRequest) SetSignToken(v string) *GetVideoPreviewSpriteURLRequest {
	s.SignToken = &v
	return s
}

/**
 *  url response
 */
type GetVideoPreviewSpriteURLResponse struct {
	// col
	Col *int64 `json:"col,omitempty" xml:"col,omitempty"`
	// count
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// frame_count
	FrameCount *int64 `json:"frame_count,omitempty" xml:"frame_count,omitempty"`
	// frame_height
	FrameHeight *int64 `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
	// frame_width
	FrameWidth *int64 `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
	// row
	Row *int64 `json:"row,omitempty" xml:"row,omitempty"`
	// sprite_url_list
	SpriteUrlList []*string `json:"sprite_url_list,omitempty" xml:"sprite_url_list,omitempty" type:"Repeated"`
}

func (s GetVideoPreviewSpriteURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewSpriteURLResponse) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewSpriteURLResponse) SetCol(v int64) *GetVideoPreviewSpriteURLResponse {
	s.Col = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetCount(v int64) *GetVideoPreviewSpriteURLResponse {
	s.Count = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameCount(v int64) *GetVideoPreviewSpriteURLResponse {
	s.FrameCount = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameHeight(v int64) *GetVideoPreviewSpriteURLResponse {
	s.FrameHeight = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetFrameWidth(v int64) *GetVideoPreviewSpriteURLResponse {
	s.FrameWidth = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetRow(v int64) *GetVideoPreviewSpriteURLResponse {
	s.Row = &v
	return s
}

func (s *GetVideoPreviewSpriteURLResponse) SetSpriteUrlList(v []*string) *GetVideoPreviewSpriteURLResponse {
	s.SpriteUrlList = v
	return s
}

/**
 * body
 */
type GetVideoPreviewURLRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// audio_template_id
	AudioTemplateId *string `json:"audio_template_id,omitempty" xml:"audio_template_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"14400" minimum:"1"`
	// file_id
	FileId  *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
}

func (s GetVideoPreviewURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewURLRequest) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewURLRequest) SetHttpheaders(v map[string]*string) *GetVideoPreviewURLRequest {
	s.Httpheaders = v
	return s
}

func (s *GetVideoPreviewURLRequest) SetAdditionData(v map[string]interface{}) *GetVideoPreviewURLRequest {
	s.AdditionData = v
	return s
}

func (s *GetVideoPreviewURLRequest) SetAudioTemplateId(v string) *GetVideoPreviewURLRequest {
	s.AudioTemplateId = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetDriveId(v string) *GetVideoPreviewURLRequest {
	s.DriveId = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetExpireSec(v int64) *GetVideoPreviewURLRequest {
	s.ExpireSec = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetFileId(v string) *GetVideoPreviewURLRequest {
	s.FileId = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetReferer(v string) *GetVideoPreviewURLRequest {
	s.Referer = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetShareId(v string) *GetVideoPreviewURLRequest {
	s.ShareId = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetSignToken(v string) *GetVideoPreviewURLRequest {
	s.SignToken = &v
	return s
}

func (s *GetVideoPreviewURLRequest) SetTemplateId(v string) *GetVideoPreviewURLRequest {
	s.TemplateId = &v
	return s
}

/**
 *  url response
 */
type GetVideoPreviewURLResponse struct {
	// preview_url
	PreviewUrl *string `json:"preview_url,omitempty" xml:"preview_url,omitempty"`
}

func (s GetVideoPreviewURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPreviewURLResponse) GoString() string {
	return s.String()
}

func (s *GetVideoPreviewURLResponse) SetPreviewUrl(v string) *GetVideoPreviewURLResponse {
	s.PreviewUrl = &v
	return s
}

/**
 * complete file request
 */
type HostingCompleteFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// forbid_overwrite
	// type: boolean
	ForbidOverwrite *bool `json:"forbid_overwrite,omitempty" xml:"forbid_overwrite,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingCompleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingCompleteFileRequest) GoString() string {
	return s.String()
}

func (s *HostingCompleteFileRequest) SetAdditionData(v map[string]interface{}) *HostingCompleteFileRequest {
	s.AdditionData = v
	return s
}

func (s *HostingCompleteFileRequest) SetDriveId(v string) *HostingCompleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingCompleteFileRequest) SetFilePath(v string) *HostingCompleteFileRequest {
	s.FilePath = &v
	return s
}

func (s *HostingCompleteFileRequest) SetForbidOverwrite(v bool) *HostingCompleteFileRequest {
	s.ForbidOverwrite = &v
	return s
}

func (s *HostingCompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *HostingCompleteFileRequest {
	s.PartInfoList = v
	return s
}

func (s *HostingCompleteFileRequest) SetShareId(v string) *HostingCompleteFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingCompleteFileRequest) SetUploadId(v string) *HostingCompleteFileRequest {
	s.UploadId = &v
	return s
}

/**
 * complete file response
 */
type HostingCompleteFileResponse struct {
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc
	Crc *string `json:"crc,omitempty" xml:"crc,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingCompleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingCompleteFileResponse) GoString() string {
	return s.String()
}

func (s *HostingCompleteFileResponse) SetContentHash(v string) *HostingCompleteFileResponse {
	s.ContentHash = &v
	return s
}

func (s *HostingCompleteFileResponse) SetContentHashName(v string) *HostingCompleteFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *HostingCompleteFileResponse) SetContentType(v string) *HostingCompleteFileResponse {
	s.ContentType = &v
	return s
}

func (s *HostingCompleteFileResponse) SetCrc(v string) *HostingCompleteFileResponse {
	s.Crc = &v
	return s
}

func (s *HostingCompleteFileResponse) SetCrc64Hash(v string) *HostingCompleteFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *HostingCompleteFileResponse) SetCreatedAt(v string) *HostingCompleteFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *HostingCompleteFileResponse) SetDescription(v string) *HostingCompleteFileResponse {
	s.Description = &v
	return s
}

func (s *HostingCompleteFileResponse) SetDomainId(v string) *HostingCompleteFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingCompleteFileResponse) SetDownloadUrl(v string) *HostingCompleteFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *HostingCompleteFileResponse) SetDriveId(v string) *HostingCompleteFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingCompleteFileResponse) SetFileExtension(v string) *HostingCompleteFileResponse {
	s.FileExtension = &v
	return s
}

func (s *HostingCompleteFileResponse) SetFilePath(v string) *HostingCompleteFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingCompleteFileResponse) SetName(v string) *HostingCompleteFileResponse {
	s.Name = &v
	return s
}

func (s *HostingCompleteFileResponse) SetParentFilePath(v string) *HostingCompleteFileResponse {
	s.ParentFilePath = &v
	return s
}

func (s *HostingCompleteFileResponse) SetShareId(v string) *HostingCompleteFileResponse {
	s.ShareId = &v
	return s
}

func (s *HostingCompleteFileResponse) SetSize(v int64) *HostingCompleteFileResponse {
	s.Size = &v
	return s
}

func (s *HostingCompleteFileResponse) SetStatus(v string) *HostingCompleteFileResponse {
	s.Status = &v
	return s
}

func (s *HostingCompleteFileResponse) SetThumbnail(v string) *HostingCompleteFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *HostingCompleteFileResponse) SetTrashedAt(v string) *HostingCompleteFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *HostingCompleteFileResponse) SetType(v string) *HostingCompleteFileResponse {
	s.Type = &v
	return s
}

func (s *HostingCompleteFileResponse) SetUpdatedAt(v string) *HostingCompleteFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *HostingCompleteFileResponse) SetUploadId(v string) *HostingCompleteFileResponse {
	s.UploadId = &v
	return s
}

func (s *HostingCompleteFileResponse) SetUrl(v string) *HostingCompleteFileResponse {
	s.Url = &v
	return s
}

/**
 * copy file request
 */
type HostingCopyFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
	// overwrite
	// type: boolean
	Overwrite *bool   `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
	Referer   *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// to_drive_id
	ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
	// to_parent_file_path
	ToParentFilePath *string `json:"to_parent_file_path,omitempty" xml:"to_parent_file_path,omitempty" require:"true"`
	// share_id
	ToShareId *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty"`
}

func (s HostingCopyFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingCopyFileRequest) GoString() string {
	return s.String()
}

func (s *HostingCopyFileRequest) SetAdditionData(v map[string]interface{}) *HostingCopyFileRequest {
	s.AdditionData = v
	return s
}

func (s *HostingCopyFileRequest) SetDriveId(v string) *HostingCopyFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingCopyFileRequest) SetFilePath(v string) *HostingCopyFileRequest {
	s.FilePath = &v
	return s
}

func (s *HostingCopyFileRequest) SetNewName(v string) *HostingCopyFileRequest {
	s.NewName = &v
	return s
}

func (s *HostingCopyFileRequest) SetOverwrite(v bool) *HostingCopyFileRequest {
	s.Overwrite = &v
	return s
}

func (s *HostingCopyFileRequest) SetReferer(v string) *HostingCopyFileRequest {
	s.Referer = &v
	return s
}

func (s *HostingCopyFileRequest) SetShareId(v string) *HostingCopyFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingCopyFileRequest) SetToDriveId(v string) *HostingCopyFileRequest {
	s.ToDriveId = &v
	return s
}

func (s *HostingCopyFileRequest) SetToParentFilePath(v string) *HostingCopyFileRequest {
	s.ToParentFilePath = &v
	return s
}

func (s *HostingCopyFileRequest) SetToShareId(v string) *HostingCopyFileRequest {
	s.ToShareId = &v
	return s
}

/**
 *  response
 */
type HostingCopyFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z-]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// drive_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingCopyFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingCopyFileResponse) GoString() string {
	return s.String()
}

func (s *HostingCopyFileResponse) SetAsyncTaskId(v string) *HostingCopyFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *HostingCopyFileResponse) SetDomainId(v string) *HostingCopyFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingCopyFileResponse) SetDriveId(v string) *HostingCopyFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingCopyFileResponse) SetFilePath(v string) *HostingCopyFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingCopyFileResponse) SetShareId(v string) *HostingCopyFileResponse {
	s.ShareId = &v
	return s
}

/**
 * create file request
 */
type HostingCreateFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// ContentMd5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// ContentType
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// forbid_overwrite
	// type: boolean
	ForbidOverwrite *bool `json:"forbid_overwrite,omitempty" xml:"forbid_overwrite,omitempty"`
	// Name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
	// parent_file_path
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" require:"true"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// Type
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s HostingCreateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingCreateFileRequest) GoString() string {
	return s.String()
}

func (s *HostingCreateFileRequest) SetAdditionData(v map[string]interface{}) *HostingCreateFileRequest {
	s.AdditionData = v
	return s
}

func (s *HostingCreateFileRequest) SetContentMd5(v string) *HostingCreateFileRequest {
	s.ContentMd5 = &v
	return s
}

func (s *HostingCreateFileRequest) SetContentType(v string) *HostingCreateFileRequest {
	s.ContentType = &v
	return s
}

func (s *HostingCreateFileRequest) SetDriveId(v string) *HostingCreateFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingCreateFileRequest) SetForbidOverwrite(v bool) *HostingCreateFileRequest {
	s.ForbidOverwrite = &v
	return s
}

func (s *HostingCreateFileRequest) SetName(v string) *HostingCreateFileRequest {
	s.Name = &v
	return s
}

func (s *HostingCreateFileRequest) SetParentFilePath(v string) *HostingCreateFileRequest {
	s.ParentFilePath = &v
	return s
}

func (s *HostingCreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *HostingCreateFileRequest {
	s.PartInfoList = v
	return s
}

func (s *HostingCreateFileRequest) SetShareId(v string) *HostingCreateFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingCreateFileRequest) SetSize(v int64) *HostingCreateFileRequest {
	s.Size = &v
	return s
}

func (s *HostingCreateFileRequest) SetType(v string) *HostingCreateFileRequest {
	s.Type = &v
	return s
}

/**
 * Create file response
 */
type HostingCreateFileResponse struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingCreateFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingCreateFileResponse) GoString() string {
	return s.String()
}

func (s *HostingCreateFileResponse) SetDomainId(v string) *HostingCreateFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingCreateFileResponse) SetDriveId(v string) *HostingCreateFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingCreateFileResponse) SetFilePath(v string) *HostingCreateFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingCreateFileResponse) SetPartInfoList(v []*UploadPartInfo) *HostingCreateFileResponse {
	s.PartInfoList = v
	return s
}

func (s *HostingCreateFileResponse) SetShareId(v string) *HostingCreateFileResponse {
	s.ShareId = &v
	return s
}

func (s *HostingCreateFileResponse) SetType(v string) *HostingCreateFileResponse {
	s.Type = &v
	return s
}

func (s *HostingCreateFileResponse) SetUploadId(v string) *HostingCreateFileResponse {
	s.UploadId = &v
	return s
}

/**
 * 
 */
type HostingDeleteFileRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// permanently
	// type: false
	Permanently *bool `json:"permanently,omitempty" xml:"permanently,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingDeleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingDeleteFileRequest) GoString() string {
	return s.String()
}

func (s *HostingDeleteFileRequest) SetDriveId(v string) *HostingDeleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingDeleteFileRequest) SetFilePath(v string) *HostingDeleteFileRequest {
	s.FilePath = &v
	return s
}

func (s *HostingDeleteFileRequest) SetPermanently(v bool) *HostingDeleteFileRequest {
	s.Permanently = &v
	return s
}

func (s *HostingDeleteFileRequest) SetShareId(v string) *HostingDeleteFileRequest {
	s.ShareId = &v
	return s
}

/**
 *  response
 */
type HostingDeleteFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingDeleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingDeleteFileResponse) GoString() string {
	return s.String()
}

func (s *HostingDeleteFileResponse) SetAsyncTaskId(v string) *HostingDeleteFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *HostingDeleteFileResponse) SetDomainId(v string) *HostingDeleteFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingDeleteFileResponse) SetDriveId(v string) *HostingDeleteFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingDeleteFileResponse) SetFilePath(v string) *HostingDeleteFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingDeleteFileResponse) SetShareId(v string) *HostingDeleteFileResponse {
	s.ShareId = &v
	return s
}

/**
 *  response
 */
type HostingDeleteFilesResponse struct {
	// deleted_file_id_list
	DeletedFileIdList []*string `json:"deleted_file_id_list,omitempty" xml:"deleted_file_id_list,omitempty" type:"Repeated"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
}

func (s HostingDeleteFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingDeleteFilesResponse) GoString() string {
	return s.String()
}

func (s *HostingDeleteFilesResponse) SetDeletedFileIdList(v []*string) *HostingDeleteFilesResponse {
	s.DeletedFileIdList = v
	return s
}

func (s *HostingDeleteFilesResponse) SetDomainId(v string) *HostingDeleteFilesResponse {
	s.DomainId = &v
	return s
}

func (s *HostingDeleteFilesResponse) SetDriveId(v string) *HostingDeleteFilesResponse {
	s.DriveId = &v
	return s
}

func (s *HostingDeleteFilesResponse) SetShareId(v string) *HostingDeleteFilesResponse {
	s.ShareId = &v
	return s
}

/**
 * body
 */
type HostingGetDownloadUrlRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"115200" minimum:"10"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	Referer  *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
}

func (s HostingGetDownloadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingGetDownloadUrlRequest) GoString() string {
	return s.String()
}

func (s *HostingGetDownloadUrlRequest) SetAdditionData(v map[string]interface{}) *HostingGetDownloadUrlRequest {
	s.AdditionData = v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetDriveId(v string) *HostingGetDownloadUrlRequest {
	s.DriveId = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetExpireSec(v int64) *HostingGetDownloadUrlRequest {
	s.ExpireSec = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetFileName(v string) *HostingGetDownloadUrlRequest {
	s.FileName = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetFilePath(v string) *HostingGetDownloadUrlRequest {
	s.FilePath = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetReferer(v string) *HostingGetDownloadUrlRequest {
	s.Referer = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetShareId(v string) *HostingGetDownloadUrlRequest {
	s.ShareId = &v
	return s
}

func (s *HostingGetDownloadUrlRequest) SetSignToken(v string) *HostingGetDownloadUrlRequest {
	s.SignToken = &v
	return s
}

/**
 * download url response
 */
type HostingGetDownloadUrlResponse struct {
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// method
	Method *string `json:"method,omitempty" xml:"method,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetDownloadUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingGetDownloadUrlResponse) GoString() string {
	return s.String()
}

func (s *HostingGetDownloadUrlResponse) SetExpiration(v string) *HostingGetDownloadUrlResponse {
	s.Expiration = &v
	return s
}

func (s *HostingGetDownloadUrlResponse) SetMethod(v string) *HostingGetDownloadUrlResponse {
	s.Method = &v
	return s
}

func (s *HostingGetDownloadUrlResponse) SetUrl(v string) *HostingGetDownloadUrlResponse {
	s.Url = &v
	return s
}

/**
 * 
 */
type HostingGetFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	Referer                *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s HostingGetFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingGetFileRequest) GoString() string {
	return s.String()
}

func (s *HostingGetFileRequest) SetAdditionData(v map[string]interface{}) *HostingGetFileRequest {
	s.AdditionData = v
	return s
}

func (s *HostingGetFileRequest) SetDriveId(v string) *HostingGetFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingGetFileRequest) SetFilePath(v string) *HostingGetFileRequest {
	s.FilePath = &v
	return s
}

func (s *HostingGetFileRequest) SetImageThumbnailProcess(v string) *HostingGetFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *HostingGetFileRequest) SetImageUrlProcess(v string) *HostingGetFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *HostingGetFileRequest) SetOfficeThumbnailProcess(v string) *HostingGetFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *HostingGetFileRequest) SetReferer(v string) *HostingGetFileRequest {
	s.Referer = &v
	return s
}

func (s *HostingGetFileRequest) SetShareId(v string) *HostingGetFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingGetFileRequest) SetSignToken(v string) *HostingGetFileRequest {
	s.SignToken = &v
	return s
}

func (s *HostingGetFileRequest) SetUrlExpireSec(v int64) *HostingGetFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *HostingGetFileRequest) SetVideoThumbnailProcess(v string) *HostingGetFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * response
 */
type HostingGetFileResponse struct {
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingGetFileResponse) GoString() string {
	return s.String()
}

func (s *HostingGetFileResponse) SetContentHash(v string) *HostingGetFileResponse {
	s.ContentHash = &v
	return s
}

func (s *HostingGetFileResponse) SetContentHashName(v string) *HostingGetFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *HostingGetFileResponse) SetContentType(v string) *HostingGetFileResponse {
	s.ContentType = &v
	return s
}

func (s *HostingGetFileResponse) SetCrc64Hash(v string) *HostingGetFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *HostingGetFileResponse) SetCreatedAt(v string) *HostingGetFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *HostingGetFileResponse) SetDescription(v string) *HostingGetFileResponse {
	s.Description = &v
	return s
}

func (s *HostingGetFileResponse) SetDomainId(v string) *HostingGetFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingGetFileResponse) SetDownloadUrl(v string) *HostingGetFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *HostingGetFileResponse) SetDriveId(v string) *HostingGetFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingGetFileResponse) SetFileExtension(v string) *HostingGetFileResponse {
	s.FileExtension = &v
	return s
}

func (s *HostingGetFileResponse) SetFilePath(v string) *HostingGetFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingGetFileResponse) SetName(v string) *HostingGetFileResponse {
	s.Name = &v
	return s
}

func (s *HostingGetFileResponse) SetParentFilePath(v string) *HostingGetFileResponse {
	s.ParentFilePath = &v
	return s
}

func (s *HostingGetFileResponse) SetShareId(v string) *HostingGetFileResponse {
	s.ShareId = &v
	return s
}

func (s *HostingGetFileResponse) SetSize(v int64) *HostingGetFileResponse {
	s.Size = &v
	return s
}

func (s *HostingGetFileResponse) SetStatus(v string) *HostingGetFileResponse {
	s.Status = &v
	return s
}

func (s *HostingGetFileResponse) SetThumbnail(v string) *HostingGetFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *HostingGetFileResponse) SetTrashedAt(v string) *HostingGetFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *HostingGetFileResponse) SetType(v string) *HostingGetFileResponse {
	s.Type = &v
	return s
}

func (s *HostingGetFileResponse) SetUpdatedAt(v string) *HostingGetFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *HostingGetFileResponse) SetUploadId(v string) *HostingGetFileResponse {
	s.UploadId = &v
	return s
}

func (s *HostingGetFileResponse) SetUrl(v string) *HostingGetFileResponse {
	s.Url = &v
	return s
}

/**
 * body
 */
type HostingGetSecureUrlRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec 
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// secure_ip
	SecureIp *string `json:"secure_ip,omitempty" xml:"secure_ip,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingGetSecureUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingGetSecureUrlRequest) GoString() string {
	return s.String()
}

func (s *HostingGetSecureUrlRequest) SetDriveId(v string) *HostingGetSecureUrlRequest {
	s.DriveId = &v
	return s
}

func (s *HostingGetSecureUrlRequest) SetExpireSec(v int64) *HostingGetSecureUrlRequest {
	s.ExpireSec = &v
	return s
}

func (s *HostingGetSecureUrlRequest) SetFilePath(v string) *HostingGetSecureUrlRequest {
	s.FilePath = &v
	return s
}

func (s *HostingGetSecureUrlRequest) SetSecureIp(v string) *HostingGetSecureUrlRequest {
	s.SecureIp = &v
	return s
}

func (s *HostingGetSecureUrlRequest) SetShareId(v string) *HostingGetSecureUrlRequest {
	s.ShareId = &v
	return s
}

/**
 * secure url response
 */
type HostingGetSecureUrlResponse struct {
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingGetSecureUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingGetSecureUrlResponse) GoString() string {
	return s.String()
}

func (s *HostingGetSecureUrlResponse) SetExpiration(v string) *HostingGetSecureUrlResponse {
	s.Expiration = &v
	return s
}

func (s *HostingGetSecureUrlResponse) SetUrl(v string) *HostingGetSecureUrlResponse {
	s.Url = &v
	return s
}

/**
 * URL
 */
type HostingGetUploadUrlRequest struct {
	// content_md5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty" maxLength:"32"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
	// upload_part_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty" require:"true"`
}

func (s HostingGetUploadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingGetUploadUrlRequest) GoString() string {
	return s.String()
}

func (s *HostingGetUploadUrlRequest) SetContentMd5(v string) *HostingGetUploadUrlRequest {
	s.ContentMd5 = &v
	return s
}

func (s *HostingGetUploadUrlRequest) SetDriveId(v string) *HostingGetUploadUrlRequest {
	s.DriveId = &v
	return s
}

func (s *HostingGetUploadUrlRequest) SetFilePath(v string) *HostingGetUploadUrlRequest {
	s.FilePath = &v
	return s
}

func (s *HostingGetUploadUrlRequest) SetPartInfoList(v []*UploadPartInfo) *HostingGetUploadUrlRequest {
	s.PartInfoList = v
	return s
}

func (s *HostingGetUploadUrlRequest) SetShareId(v string) *HostingGetUploadUrlRequest {
	s.ShareId = &v
	return s
}

func (s *HostingGetUploadUrlRequest) SetUploadId(v string) *HostingGetUploadUrlRequest {
	s.UploadId = &v
	return s
}

/**
 * Get UploadUrl Response
 */
type HostingGetUploadUrlResponse struct {
	// created_at
	CreateAt *string `json:"create_at,omitempty" xml:"create_at,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingGetUploadUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingGetUploadUrlResponse) GoString() string {
	return s.String()
}

func (s *HostingGetUploadUrlResponse) SetCreateAt(v string) *HostingGetUploadUrlResponse {
	s.CreateAt = &v
	return s
}

func (s *HostingGetUploadUrlResponse) SetDomainId(v string) *HostingGetUploadUrlResponse {
	s.DomainId = &v
	return s
}

func (s *HostingGetUploadUrlResponse) SetDriveId(v string) *HostingGetUploadUrlResponse {
	s.DriveId = &v
	return s
}

func (s *HostingGetUploadUrlResponse) SetFilePath(v string) *HostingGetUploadUrlResponse {
	s.FilePath = &v
	return s
}

func (s *HostingGetUploadUrlResponse) SetPartInfoList(v []*UploadPartInfo) *HostingGetUploadUrlResponse {
	s.PartInfoList = v
	return s
}

func (s *HostingGetUploadUrlResponse) SetUploadId(v string) *HostingGetUploadUrlResponse {
	s.UploadId = &v
	return s
}

/**
 * list file request
 */
type HostingListFileRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId                   *string   `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// ParentFilePath
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" require:"true"`
	Referer        *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s HostingListFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingListFileRequest) GoString() string {
	return s.String()
}

func (s *HostingListFileRequest) SetAdditionData(v map[string]interface{}) *HostingListFileRequest {
	s.AdditionData = v
	return s
}

func (s *HostingListFileRequest) SetDriveId(v string) *HostingListFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingListFileRequest) SetImageCroppingAspectRatios(v []*string) *HostingListFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *HostingListFileRequest) SetImageThumbnailProcess(v string) *HostingListFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *HostingListFileRequest) SetImageUrlProcess(v string) *HostingListFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *HostingListFileRequest) SetLimit(v int64) *HostingListFileRequest {
	s.Limit = &v
	return s
}

func (s *HostingListFileRequest) SetMarker(v string) *HostingListFileRequest {
	s.Marker = &v
	return s
}

func (s *HostingListFileRequest) SetOfficeThumbnailProcess(v string) *HostingListFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *HostingListFileRequest) SetParentFilePath(v string) *HostingListFileRequest {
	s.ParentFilePath = &v
	return s
}

func (s *HostingListFileRequest) SetReferer(v string) *HostingListFileRequest {
	s.Referer = &v
	return s
}

func (s *HostingListFileRequest) SetShareId(v string) *HostingListFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingListFileRequest) SetSignToken(v string) *HostingListFileRequest {
	s.SignToken = &v
	return s
}

func (s *HostingListFileRequest) SetUrlExpireSec(v int64) *HostingListFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *HostingListFileRequest) SetVideoThumbnailProcess(v string) *HostingListFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * List file response
 */
type HostingListFileResponse struct {
	// items
	Items []*BaseHostingFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s HostingListFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingListFileResponse) GoString() string {
	return s.String()
}

func (s *HostingListFileResponse) SetItems(v []*BaseHostingFileResponse) *HostingListFileResponse {
	s.Items = v
	return s
}

func (s *HostingListFileResponse) SetNextMarker(v string) *HostingListFileResponse {
	s.NextMarker = &v
	return s
}

/**
 * uploadID
 */
type HostingListUploadedPartRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
	// part_number_marker
	PartNumberMarker *int64 `json:"part_number_marker,omitempty" xml:"part_number_marker,omitempty" minimum:"1"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s HostingListUploadedPartRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingListUploadedPartRequest) GoString() string {
	return s.String()
}

func (s *HostingListUploadedPartRequest) SetDriveId(v string) *HostingListUploadedPartRequest {
	s.DriveId = &v
	return s
}

func (s *HostingListUploadedPartRequest) SetFilePath(v string) *HostingListUploadedPartRequest {
	s.FilePath = &v
	return s
}

func (s *HostingListUploadedPartRequest) SetLimit(v int64) *HostingListUploadedPartRequest {
	s.Limit = &v
	return s
}

func (s *HostingListUploadedPartRequest) SetPartNumberMarker(v int64) *HostingListUploadedPartRequest {
	s.PartNumberMarker = &v
	return s
}

func (s *HostingListUploadedPartRequest) SetShareId(v string) *HostingListUploadedPartRequest {
	s.ShareId = &v
	return s
}

func (s *HostingListUploadedPartRequest) SetUploadId(v string) *HostingListUploadedPartRequest {
	s.UploadId = &v
	return s
}

/**
 *  response
 */
type HostingListUploadedPartResponse struct {
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// next_part_number_marker
	NextPartNumberMarker *string `json:"next_part_number_marker,omitempty" xml:"next_part_number_marker,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// uploaded_parts
	UploadedParts []*UploadPartInfo `json:"uploaded_parts,omitempty" xml:"uploaded_parts,omitempty" type:"Repeated"`
}

func (s HostingListUploadedPartResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingListUploadedPartResponse) GoString() string {
	return s.String()
}

func (s *HostingListUploadedPartResponse) SetFilePath(v string) *HostingListUploadedPartResponse {
	s.FilePath = &v
	return s
}

func (s *HostingListUploadedPartResponse) SetNextPartNumberMarker(v string) *HostingListUploadedPartResponse {
	s.NextPartNumberMarker = &v
	return s
}

func (s *HostingListUploadedPartResponse) SetUploadId(v string) *HostingListUploadedPartResponse {
	s.UploadId = &v
	return s
}

func (s *HostingListUploadedPartResponse) SetUploadedParts(v []*UploadPartInfo) *HostingListUploadedPartResponse {
	s.UploadedParts = v
	return s
}

/**
 * 
 */
type HostingMoveFileRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty"`
	// overwrite
	// type: boolean
	Overwrite *bool `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// file_path
	ToParentFilePath *string `json:"to_parent_file_path,omitempty" xml:"to_parent_file_path,omitempty"`
}

func (s HostingMoveFileRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingMoveFileRequest) GoString() string {
	return s.String()
}

func (s *HostingMoveFileRequest) SetDriveId(v string) *HostingMoveFileRequest {
	s.DriveId = &v
	return s
}

func (s *HostingMoveFileRequest) SetFilePath(v string) *HostingMoveFileRequest {
	s.FilePath = &v
	return s
}

func (s *HostingMoveFileRequest) SetNewName(v string) *HostingMoveFileRequest {
	s.NewName = &v
	return s
}

func (s *HostingMoveFileRequest) SetOverwrite(v bool) *HostingMoveFileRequest {
	s.Overwrite = &v
	return s
}

func (s *HostingMoveFileRequest) SetShareId(v string) *HostingMoveFileRequest {
	s.ShareId = &v
	return s
}

func (s *HostingMoveFileRequest) SetToParentFilePath(v string) *HostingMoveFileRequest {
	s.ToParentFilePath = &v
	return s
}

/**
 *  response
 */
type HostingMoveFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z-]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// drive_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[a-z0-9A-Z]+"`
}

func (s HostingMoveFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingMoveFileResponse) GoString() string {
	return s.String()
}

func (s *HostingMoveFileResponse) SetAsyncTaskId(v string) *HostingMoveFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *HostingMoveFileResponse) SetDomainId(v string) *HostingMoveFileResponse {
	s.DomainId = &v
	return s
}

func (s *HostingMoveFileResponse) SetDriveId(v string) *HostingMoveFileResponse {
	s.DriveId = &v
	return s
}

func (s *HostingMoveFileResponse) SetFilePath(v string) *HostingMoveFileResponse {
	s.FilePath = &v
	return s
}

func (s *HostingMoveFileResponse) SetShareId(v string) *HostingMoveFileResponse {
	s.ShareId = &v
	return s
}

/**
 * search file response
 */
type HostingSearchFileResponse struct {
	// items
	Items []*BaseHostingFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s HostingSearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingSearchFileResponse) GoString() string {
	return s.String()
}

func (s *HostingSearchFileResponse) SetItems(v []*BaseHostingFileResponse) *HostingSearchFileResponse {
	s.Items = v
	return s
}

func (s *HostingSearchFileResponse) SetNextMarker(v string) *HostingSearchFileResponse {
	s.NextMarker = &v
	return s
}

/**
 *  response
 */
type HostingUpdateFileMetaResponse struct {
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9]+"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s HostingUpdateFileMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingUpdateFileMetaResponse) GoString() string {
	return s.String()
}

func (s *HostingUpdateFileMetaResponse) SetContentHash(v string) *HostingUpdateFileMetaResponse {
	s.ContentHash = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetContentHashName(v string) *HostingUpdateFileMetaResponse {
	s.ContentHashName = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetContentType(v string) *HostingUpdateFileMetaResponse {
	s.ContentType = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetCrc64Hash(v string) *HostingUpdateFileMetaResponse {
	s.Crc64Hash = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetCreatedAt(v string) *HostingUpdateFileMetaResponse {
	s.CreatedAt = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetDescription(v string) *HostingUpdateFileMetaResponse {
	s.Description = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetDomainId(v string) *HostingUpdateFileMetaResponse {
	s.DomainId = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetDownloadUrl(v string) *HostingUpdateFileMetaResponse {
	s.DownloadUrl = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetDriveId(v string) *HostingUpdateFileMetaResponse {
	s.DriveId = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetFileExtension(v string) *HostingUpdateFileMetaResponse {
	s.FileExtension = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetFilePath(v string) *HostingUpdateFileMetaResponse {
	s.FilePath = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetName(v string) *HostingUpdateFileMetaResponse {
	s.Name = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetParentFilePath(v string) *HostingUpdateFileMetaResponse {
	s.ParentFilePath = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetShareId(v string) *HostingUpdateFileMetaResponse {
	s.ShareId = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetSize(v int64) *HostingUpdateFileMetaResponse {
	s.Size = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetStatus(v string) *HostingUpdateFileMetaResponse {
	s.Status = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetThumbnail(v string) *HostingUpdateFileMetaResponse {
	s.Thumbnail = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetTrashedAt(v string) *HostingUpdateFileMetaResponse {
	s.TrashedAt = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetType(v string) *HostingUpdateFileMetaResponse {
	s.Type = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetUpdatedAt(v string) *HostingUpdateFileMetaResponse {
	s.UpdatedAt = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetUploadId(v string) *HostingUpdateFileMetaResponse {
	s.UploadId = &v
	return s
}

func (s *HostingUpdateFileMetaResponse) SetUrl(v string) *HostingUpdateFileMetaResponse {
	s.Url = &v
	return s
}

/**
 * DRM License
 */
type HostingVideoDRMLicenseRequest struct {
	// drmType
	DrmType *string `json:"drmType,omitempty" xml:"drmType,omitempty" require:"true"`
	// licenseRequest
	LicenseRequest *string `json:"licenseRequest,omitempty" xml:"licenseRequest,omitempty" require:"true"`
}

func (s HostingVideoDRMLicenseRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoDRMLicenseRequest) GoString() string {
	return s.String()
}

func (s *HostingVideoDRMLicenseRequest) SetDrmType(v string) *HostingVideoDRMLicenseRequest {
	s.DrmType = &v
	return s
}

func (s *HostingVideoDRMLicenseRequest) SetLicenseRequest(v string) *HostingVideoDRMLicenseRequest {
	s.LicenseRequest = &v
	return s
}

/**
 * DRM License response
 */
type HostingVideoDRMLicenseResponse struct {
	// drm_data
	Data *string `json:"data,omitempty" xml:"data,omitempty" require:"true"`
	// device_info
	DeviceInfo *string `json:"device_info,omitempty" xml:"device_info,omitempty" require:"true"`
	// states
	States *int64 `json:"states,omitempty" xml:"states,omitempty" require:"true"`
}

func (s HostingVideoDRMLicenseResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoDRMLicenseResponse) GoString() string {
	return s.String()
}

func (s *HostingVideoDRMLicenseResponse) SetData(v string) *HostingVideoDRMLicenseResponse {
	s.Data = &v
	return s
}

func (s *HostingVideoDRMLicenseResponse) SetDeviceInfo(v string) *HostingVideoDRMLicenseResponse {
	s.DeviceInfo = &v
	return s
}

func (s *HostingVideoDRMLicenseResponse) SetStates(v int64) *HostingVideoDRMLicenseResponse {
	s.States = &v
	return s
}

/**
 * 
 */
type HostingVideoDefinitionRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// protection_scheme
	ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
}

func (s HostingVideoDefinitionRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoDefinitionRequest) GoString() string {
	return s.String()
}

func (s *HostingVideoDefinitionRequest) SetDriveId(v string) *HostingVideoDefinitionRequest {
	s.DriveId = &v
	return s
}

func (s *HostingVideoDefinitionRequest) SetFilePath(v string) *HostingVideoDefinitionRequest {
	s.FilePath = &v
	return s
}

func (s *HostingVideoDefinitionRequest) SetProtectionScheme(v string) *HostingVideoDefinitionRequest {
	s.ProtectionScheme = &v
	return s
}

func (s *HostingVideoDefinitionRequest) SetShareId(v string) *HostingVideoDefinitionRequest {
	s.ShareId = &v
	return s
}

/**
 * response
 */
type HostingVideoDefinitionResponse struct {
	// definition_list
	DefinitionList []*string `json:"definition_list,omitempty" xml:"definition_list,omitempty" type:"Repeated"`
	// frame_rate
	FrameRate *string `json:"frame_rate,omitempty" xml:"frame_rate,omitempty"`
}

func (s HostingVideoDefinitionResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoDefinitionResponse) GoString() string {
	return s.String()
}

func (s *HostingVideoDefinitionResponse) SetDefinitionList(v []*string) *HostingVideoDefinitionResponse {
	s.DefinitionList = v
	return s
}

func (s *HostingVideoDefinitionResponse) SetFrameRate(v string) *HostingVideoDefinitionResponse {
	s.FrameRate = &v
	return s
}

/**
 * m3u8
 */
type HostingVideoM3U8Request struct {
	// definition
	Definition *string `json:"definition,omitempty" xml:"definition,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// expire_sec
	ExpireSec *int64 `json:"expire_sec,omitempty" xml:"expire_sec,omitempty" maximum:"86400" minimum:"60"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// protection_scheme
	ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// sign_token
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty" require:"true"`
}

func (s HostingVideoM3U8Request) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoM3U8Request) GoString() string {
	return s.String()
}

func (s *HostingVideoM3U8Request) SetDefinition(v string) *HostingVideoM3U8Request {
	s.Definition = &v
	return s
}

func (s *HostingVideoM3U8Request) SetDriveId(v string) *HostingVideoM3U8Request {
	s.DriveId = &v
	return s
}

func (s *HostingVideoM3U8Request) SetExpireSec(v int64) *HostingVideoM3U8Request {
	s.ExpireSec = &v
	return s
}

func (s *HostingVideoM3U8Request) SetFilePath(v string) *HostingVideoM3U8Request {
	s.FilePath = &v
	return s
}

func (s *HostingVideoM3U8Request) SetProtectionScheme(v string) *HostingVideoM3U8Request {
	s.ProtectionScheme = &v
	return s
}

func (s *HostingVideoM3U8Request) SetShareId(v string) *HostingVideoM3U8Request {
	s.ShareId = &v
	return s
}

func (s *HostingVideoM3U8Request) SetSignToken(v string) *HostingVideoM3U8Request {
	s.SignToken = &v
	return s
}

/**
 * 
 */
type HostingVideoTranscodeRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_path
	FilePath *string `json:"file_path,omitempty" xml:"file_path,omitempty" require:"true" maxLength:"1000" minLength:"1"`
	// hls_time
	HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
	// protection_scheme
	ProtectionScheme *string `json:"protection_scheme,omitempty" xml:"protection_scheme,omitempty"`
	// remarks
	Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" pattern:"[0-9a-zA-Z-]+"`
	// transcode
	Transcode *bool `json:"transcode,omitempty" xml:"transcode,omitempty"`
}

func (s HostingVideoTranscodeRequest) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoTranscodeRequest) GoString() string {
	return s.String()
}

func (s *HostingVideoTranscodeRequest) SetDriveId(v string) *HostingVideoTranscodeRequest {
	s.DriveId = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetFilePath(v string) *HostingVideoTranscodeRequest {
	s.FilePath = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetHlsTime(v int64) *HostingVideoTranscodeRequest {
	s.HlsTime = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetProtectionScheme(v string) *HostingVideoTranscodeRequest {
	s.ProtectionScheme = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetRemarks(v string) *HostingVideoTranscodeRequest {
	s.Remarks = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetShareId(v string) *HostingVideoTranscodeRequest {
	s.ShareId = &v
	return s
}

func (s *HostingVideoTranscodeRequest) SetTranscode(v bool) *HostingVideoTranscodeRequest {
	s.Transcode = &v
	return s
}

/**
 * response
 */
type HostingVideoTranscodeResponse struct {
	// definition_list
	DefinitionList []*string `json:"definition_list,omitempty" xml:"definition_list,omitempty" type:"Repeated"`
	// duration
	Duration *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
	// hls_time
	HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
}

func (s HostingVideoTranscodeResponse) String() string {
	return tea.Prettify(s)
}

func (s HostingVideoTranscodeResponse) GoString() string {
	return s.String()
}

func (s *HostingVideoTranscodeResponse) SetDefinitionList(v []*string) *HostingVideoTranscodeResponse {
	s.DefinitionList = v
	return s
}

func (s *HostingVideoTranscodeResponse) SetDuration(v int64) *HostingVideoTranscodeResponse {
	s.Duration = &v
	return s
}

func (s *HostingVideoTranscodeResponse) SetHlsTime(v int64) *HostingVideoTranscodeResponse {
	s.HlsTime = &v
	return s
}

/**
 *
 */
type IDPermission struct {
	ActionList         []*ActionItem `json:"ActionList,omitempty" xml:"ActionList,omitempty" type:"Repeated"`
	CreatedAt          *int64        `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty"`
	Deleted            *string       `json:"Deleted,omitempty" xml:"Deleted,omitempty"`
	DisinheritSubGroup *bool         `json:"DisinheritSubGroup,omitempty" xml:"DisinheritSubGroup,omitempty"`
	DomainID           *string       `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
	ExpireTime         *int64        `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	IdentityID         *string       `json:"IdentityID,omitempty" xml:"IdentityID,omitempty"`
	IdentityType       *string       `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	Resource           *string       `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType       *string       `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Roles              []*string     `json:"Roles,omitempty" xml:"Roles,omitempty" type:"Repeated"`
	SequenceNumber     *int64        `json:"SequenceNumber,omitempty" xml:"SequenceNumber,omitempty"`
	UpdatedAt          *int64        `json:"UpdatedAt,omitempty" xml:"UpdatedAt,omitempty"`
	UpdatedBy          *string       `json:"UpdatedBy,omitempty" xml:"UpdatedBy,omitempty"`
}

func (s IDPermission) String() string {
	return tea.Prettify(s)
}

func (s IDPermission) GoString() string {
	return s.String()
}

func (s *IDPermission) SetActionList(v []*ActionItem) *IDPermission {
	s.ActionList = v
	return s
}

func (s *IDPermission) SetCreatedAt(v int64) *IDPermission {
	s.CreatedAt = &v
	return s
}

func (s *IDPermission) SetDeleted(v string) *IDPermission {
	s.Deleted = &v
	return s
}

func (s *IDPermission) SetDisinheritSubGroup(v bool) *IDPermission {
	s.DisinheritSubGroup = &v
	return s
}

func (s *IDPermission) SetDomainID(v string) *IDPermission {
	s.DomainID = &v
	return s
}

func (s *IDPermission) SetExpireTime(v int64) *IDPermission {
	s.ExpireTime = &v
	return s
}

func (s *IDPermission) SetIdentityID(v string) *IDPermission {
	s.IdentityID = &v
	return s
}

func (s *IDPermission) SetIdentityType(v string) *IDPermission {
	s.IdentityType = &v
	return s
}

func (s *IDPermission) SetResource(v string) *IDPermission {
	s.Resource = &v
	return s
}

func (s *IDPermission) SetResourceType(v string) *IDPermission {
	s.ResourceType = &v
	return s
}

func (s *IDPermission) SetRoles(v []*string) *IDPermission {
	s.Roles = v
	return s
}

func (s *IDPermission) SetSequenceNumber(v int64) *IDPermission {
	s.SequenceNumber = &v
	return s
}

func (s *IDPermission) SetUpdatedAt(v int64) *IDPermission {
	s.UpdatedAt = &v
	return s
}

func (s *IDPermission) SetUpdatedBy(v string) *IDPermission {
	s.UpdatedBy = &v
	return s
}

/**
 * 
 */
type Identity struct {
	// ID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// 
	IdentityName *string `json:"identity_name,omitempty" xml:"identity_name,omitempty"`
	// IT_User()IT_Group()
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
}

func (s Identity) String() string {
	return tea.Prettify(s)
}

func (s Identity) GoString() string {
	return s.String()
}

func (s *Identity) SetIdentityId(v string) *Identity {
	s.IdentityId = &v
	return s
}

func (s *Identity) SetIdentityName(v string) *Identity {
	s.IdentityName = &v
	return s
}

func (s *Identity) SetIdentityType(v string) *Identity {
	s.IdentityType = &v
	return s
}

/**
 *
 */
type ImageMediaMetadata struct {
	// height
	Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
	// taken_at
	TakenAt *string `json:"taken_at,omitempty" xml:"taken_at,omitempty"`
	// width
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s ImageMediaMetadata) String() string {
	return tea.Prettify(s)
}

func (s ImageMediaMetadata) GoString() string {
	return s.String()
}

func (s *ImageMediaMetadata) SetHeight(v int64) *ImageMediaMetadata {
	s.Height = &v
	return s
}

func (s *ImageMediaMetadata) SetTakenAt(v string) *ImageMediaMetadata {
	s.TakenAt = &v
	return s
}

func (s *ImageMediaMetadata) SetWidth(v int64) *ImageMediaMetadata {
	s.Width = &v
	return s
}

/**
 *
 */
type ImageMediaResponse struct {
	// address_line
	AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
	// city
	City *string `json:"city,omitempty" xml:"city,omitempty"`
	// country
	Country *string `json:"country,omitempty" xml:"country,omitempty"`
	// cropping_suggestion
	CroppingSuggestion []*CroppingSuggestionItem `json:"cropping_suggestion,omitempty" xml:"cropping_suggestion,omitempty" type:"Repeated"`
	// district
	District *string `json:"district,omitempty" xml:"district,omitempty"`
	// exif json string
	Exif *string `json:"exif,omitempty" xml:"exif,omitempty"`
	// faces json string
	Faces *string `json:"faces,omitempty" xml:"faces,omitempty"`
	// faces_thumbnail_list
	FacesThumbnail []*FaceThumbnail `json:"faces_thumbnail,omitempty" xml:"faces_thumbnail,omitempty" type:"Repeated"`
	// height
	Height       *int64        `json:"height,omitempty" xml:"height,omitempty"`
	ImageQuality *ImageQuality `json:"image_quality,omitempty" xml:"image_quality,omitempty"`
	// system_tags
	ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// province
	Province *string `json:"province,omitempty" xml:"province,omitempty"`
	// time
	Time *string `json:"time,omitempty" xml:"time,omitempty"`
	// township
	Township *string `json:"township,omitempty" xml:"township,omitempty"`
	// width
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s ImageMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s ImageMediaResponse) GoString() string {
	return s.String()
}

func (s *ImageMediaResponse) SetAddressLine(v string) *ImageMediaResponse {
	s.AddressLine = &v
	return s
}

func (s *ImageMediaResponse) SetCity(v string) *ImageMediaResponse {
	s.City = &v
	return s
}

func (s *ImageMediaResponse) SetCountry(v string) *ImageMediaResponse {
	s.Country = &v
	return s
}

func (s *ImageMediaResponse) SetCroppingSuggestion(v []*CroppingSuggestionItem) *ImageMediaResponse {
	s.CroppingSuggestion = v
	return s
}

func (s *ImageMediaResponse) SetDistrict(v string) *ImageMediaResponse {
	s.District = &v
	return s
}

func (s *ImageMediaResponse) SetExif(v string) *ImageMediaResponse {
	s.Exif = &v
	return s
}

func (s *ImageMediaResponse) SetFaces(v string) *ImageMediaResponse {
	s.Faces = &v
	return s
}

func (s *ImageMediaResponse) SetFacesThumbnail(v []*FaceThumbnail) *ImageMediaResponse {
	s.FacesThumbnail = v
	return s
}

func (s *ImageMediaResponse) SetHeight(v int64) *ImageMediaResponse {
	s.Height = &v
	return s
}

func (s *ImageMediaResponse) SetImageQuality(v *ImageQuality) *ImageMediaResponse {
	s.ImageQuality = v
	return s
}

func (s *ImageMediaResponse) SetImageTags(v []*SystemTag) *ImageMediaResponse {
	s.ImageTags = v
	return s
}

func (s *ImageMediaResponse) SetLocation(v string) *ImageMediaResponse {
	s.Location = &v
	return s
}

func (s *ImageMediaResponse) SetProvince(v string) *ImageMediaResponse {
	s.Province = &v
	return s
}

func (s *ImageMediaResponse) SetTime(v string) *ImageMediaResponse {
	s.Time = &v
	return s
}

func (s *ImageMediaResponse) SetTownship(v string) *ImageMediaResponse {
	s.Township = &v
	return s
}

func (s *ImageMediaResponse) SetWidth(v int64) *ImageMediaResponse {
	s.Width = &v
	return s
}

/**
 *
 */
type ImageQuality struct {
	Clarity          *float64 `json:"clarity,omitempty" xml:"clarity,omitempty"`
	ClarityScore     *float64 `json:"clarity_score,omitempty" xml:"clarity_score,omitempty"`
	Color            *float64 `json:"color,omitempty" xml:"color,omitempty"`
	ColorScore       *float64 `json:"color_score,omitempty" xml:"color_score,omitempty"`
	CompositionScore *float64 `json:"composition_score,omitempty" xml:"composition_score,omitempty"`
	Contrast         *float64 `json:"contrast,omitempty" xml:"contrast,omitempty"`
	ContrastScore    *float64 `json:"contrast_score,omitempty" xml:"contrast_score,omitempty"`
	Exposure         *float64 `json:"exposure,omitempty" xml:"exposure,omitempty"`
	ExposureScore    *float64 `json:"exposure_score,omitempty" xml:"exposure_score,omitempty"`
	OverallScore     *float64 `json:"overall_score,omitempty" xml:"overall_score,omitempty"`
}

func (s ImageQuality) String() string {
	return tea.Prettify(s)
}

func (s ImageQuality) GoString() string {
	return s.String()
}

func (s *ImageQuality) SetClarity(v float64) *ImageQuality {
	s.Clarity = &v
	return s
}

func (s *ImageQuality) SetClarityScore(v float64) *ImageQuality {
	s.ClarityScore = &v
	return s
}

func (s *ImageQuality) SetColor(v float64) *ImageQuality {
	s.Color = &v
	return s
}

func (s *ImageQuality) SetColorScore(v float64) *ImageQuality {
	s.ColorScore = &v
	return s
}

func (s *ImageQuality) SetCompositionScore(v float64) *ImageQuality {
	s.CompositionScore = &v
	return s
}

func (s *ImageQuality) SetContrast(v float64) *ImageQuality {
	s.Contrast = &v
	return s
}

func (s *ImageQuality) SetContrastScore(v float64) *ImageQuality {
	s.ContrastScore = &v
	return s
}

func (s *ImageQuality) SetExposure(v float64) *ImageQuality {
	s.Exposure = &v
	return s
}

func (s *ImageQuality) SetExposureScore(v float64) *ImageQuality {
	s.ExposureScore = &v
	return s
}

func (s *ImageQuality) SetOverallScore(v float64) *ImageQuality {
	s.OverallScore = &v
	return s
}

/**
 *
 */
type LDAPSyncConfig struct {
	Cron             *string `json:"cron,omitempty" xml:"cron,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	GroupFilter      *string `json:"group_filter,omitempty" xml:"group_filter,omitempty"`
	GroupObjectClass *string `json:"group_object_class,omitempty" xml:"group_object_class,omitempty"`
	UserFilter       *string `json:"user_filter,omitempty" xml:"user_filter,omitempty"`
	UserObjectClass  *string `json:"user_object_class,omitempty" xml:"user_object_class,omitempty"`
}

func (s LDAPSyncConfig) String() string {
	return tea.Prettify(s)
}

func (s LDAPSyncConfig) GoString() string {
	return s.String()
}

func (s *LDAPSyncConfig) SetCron(v string) *LDAPSyncConfig {
	s.Cron = &v
	return s
}

func (s *LDAPSyncConfig) SetEnabled(v bool) *LDAPSyncConfig {
	s.Enabled = &v
	return s
}

func (s *LDAPSyncConfig) SetGroupFilter(v string) *LDAPSyncConfig {
	s.GroupFilter = &v
	return s
}

func (s *LDAPSyncConfig) SetGroupObjectClass(v string) *LDAPSyncConfig {
	s.GroupObjectClass = &v
	return s
}

func (s *LDAPSyncConfig) SetUserFilter(v string) *LDAPSyncConfig {
	s.UserFilter = &v
	return s
}

func (s *LDAPSyncConfig) SetUserObjectClass(v string) *LDAPSyncConfig {
	s.UserObjectClass = &v
	return s
}

/**
 *
 */
type LdapConfig struct {
	AdminDn        *string         `json:"admin_dn,omitempty" xml:"admin_dn,omitempty"`
	AdminPassword  *string         `json:"admin_password,omitempty" xml:"admin_password,omitempty"`
	BaseDn         *string         `json:"base_dn,omitempty" xml:"base_dn,omitempty"`
	DisplayNameKey *string         `json:"display_name_key,omitempty" xml:"display_name_key,omitempty"`
	GlobalUid      *string         `json:"global_uid,omitempty" xml:"global_uid,omitempty"`
	Host           *string         `json:"host,omitempty" xml:"host,omitempty"`
	Port           *int64          `json:"port,omitempty" xml:"port,omitempty"`
	SyncConfig     *LDAPSyncConfig `json:"sync_config,omitempty" xml:"sync_config,omitempty"`
	Type           *string         `json:"type,omitempty" xml:"type,omitempty"`
	Uid            *string         `json:"uid,omitempty" xml:"uid,omitempty"`
	Version        *string         `json:"version,omitempty" xml:"version,omitempty"`
}

func (s LdapConfig) String() string {
	return tea.Prettify(s)
}

func (s LdapConfig) GoString() string {
	return s.String()
}

func (s *LdapConfig) SetAdminDn(v string) *LdapConfig {
	s.AdminDn = &v
	return s
}

func (s *LdapConfig) SetAdminPassword(v string) *LdapConfig {
	s.AdminPassword = &v
	return s
}

func (s *LdapConfig) SetBaseDn(v string) *LdapConfig {
	s.BaseDn = &v
	return s
}

func (s *LdapConfig) SetDisplayNameKey(v string) *LdapConfig {
	s.DisplayNameKey = &v
	return s
}

func (s *LdapConfig) SetGlobalUid(v string) *LdapConfig {
	s.GlobalUid = &v
	return s
}

func (s *LdapConfig) SetHost(v string) *LdapConfig {
	s.Host = &v
	return s
}

func (s *LdapConfig) SetPort(v int64) *LdapConfig {
	s.Port = &v
	return s
}

func (s *LdapConfig) SetSyncConfig(v *LDAPSyncConfig) *LdapConfig {
	s.SyncConfig = v
	return s
}

func (s *LdapConfig) SetType(v string) *LdapConfig {
	s.Type = &v
	return s
}

func (s *LdapConfig) SetUid(v string) *LdapConfig {
	s.Uid = &v
	return s
}

func (s *LdapConfig) SetVersion(v string) *LdapConfig {
	s.Version = &v
	return s
}

/**
 *
 */
type LinkInfo struct {
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s LinkInfo) String() string {
	return tea.Prettify(s)
}

func (s LinkInfo) GoString() string {
	return s.String()
}

func (s *LinkInfo) SetExtra(v string) *LinkInfo {
	s.Extra = &v
	return s
}

func (s *LinkInfo) SetIdentity(v string) *LinkInfo {
	s.Identity = &v
	return s
}

func (s *LinkInfo) SetType(v string) *LinkInfo {
	s.Type = &v
	return s
}

/**
 *
 */
type LinkInfoListResponse struct {
	// items
	Items []*LinkInfoResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
}

func (s LinkInfoListResponse) String() string {
	return tea.Prettify(s)
}

func (s LinkInfoListResponse) GoString() string {
	return s.String()
}

func (s *LinkInfoListResponse) SetItems(v []*LinkInfoResponse) *LinkInfoListResponse {
	s.Items = v
	return s
}

/**
 *
 */
type LinkInfoResponse struct {
	// 
	AuthenticationType *string `json:"authentication_type,omitempty" xml:"authentication_type,omitempty" require:"true"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// 
	DisplayName *string `json:"display_name,omitempty" xml:"display_name,omitempty" require:"true"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	LastLoginTime *int64 `json:"last_login_time,omitempty" xml:"last_login_time,omitempty" require:"true"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty" require:"true"`
	// ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s LinkInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s LinkInfoResponse) GoString() string {
	return s.String()
}

func (s *LinkInfoResponse) SetAuthenticationType(v string) *LinkInfoResponse {
	s.AuthenticationType = &v
	return s
}

func (s *LinkInfoResponse) SetCreatedAt(v int64) *LinkInfoResponse {
	s.CreatedAt = &v
	return s
}

func (s *LinkInfoResponse) SetDisplayName(v string) *LinkInfoResponse {
	s.DisplayName = &v
	return s
}

func (s *LinkInfoResponse) SetDomainId(v string) *LinkInfoResponse {
	s.DomainId = &v
	return s
}

func (s *LinkInfoResponse) SetExtra(v string) *LinkInfoResponse {
	s.Extra = &v
	return s
}

func (s *LinkInfoResponse) SetIdentity(v string) *LinkInfoResponse {
	s.Identity = &v
	return s
}

func (s *LinkInfoResponse) SetLastLoginTime(v int64) *LinkInfoResponse {
	s.LastLoginTime = &v
	return s
}

func (s *LinkInfoResponse) SetStatus(v string) *LinkInfoResponse {
	s.Status = &v
	return s
}

func (s *LinkInfoResponse) SetUserId(v string) *LinkInfoResponse {
	s.UserId = &v
	return s
}

/**
 *
 */
type ListAppsRequest struct {
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListAppsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppsRequest) GoString() string {
	return s.String()
}

func (s *ListAppsRequest) SetLimit(v int32) *ListAppsRequest {
	s.Limit = &v
	return s
}

func (s *ListAppsRequest) SetMarker(v string) *ListAppsRequest {
	s.Marker = &v
	return s
}

/**
 * list_file_by_anonymous request
 */
type ListByAnonymousRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9]{1,50}"`
	Referer      *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListByAnonymousRequest) String() string {
	return tea.Prettify(s)
}

func (s ListByAnonymousRequest) GoString() string {
	return s.String()
}

func (s *ListByAnonymousRequest) SetHttpheaders(v map[string]*string) *ListByAnonymousRequest {
	s.Httpheaders = v
	return s
}

func (s *ListByAnonymousRequest) SetAdditionData(v map[string]interface{}) *ListByAnonymousRequest {
	s.AdditionData = v
	return s
}

func (s *ListByAnonymousRequest) SetImageThumbnailProcess(v string) *ListByAnonymousRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListByAnonymousRequest) SetImageUrlProcess(v string) *ListByAnonymousRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListByAnonymousRequest) SetLimit(v int64) *ListByAnonymousRequest {
	s.Limit = &v
	return s
}

func (s *ListByAnonymousRequest) SetMarker(v string) *ListByAnonymousRequest {
	s.Marker = &v
	return s
}

func (s *ListByAnonymousRequest) SetOfficeThumbnailProcess(v string) *ListByAnonymousRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListByAnonymousRequest) SetParentFileId(v string) *ListByAnonymousRequest {
	s.ParentFileId = &v
	return s
}

func (s *ListByAnonymousRequest) SetReferer(v string) *ListByAnonymousRequest {
	s.Referer = &v
	return s
}

func (s *ListByAnonymousRequest) SetShareId(v string) *ListByAnonymousRequest {
	s.ShareId = &v
	return s
}

func (s *ListByAnonymousRequest) SetSignToken(v string) *ListByAnonymousRequest {
	s.SignToken = &v
	return s
}

func (s *ListByAnonymousRequest) SetVideoThumbnailProcess(v string) *ListByAnonymousRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * list_file_by_anonymous response
 */
type ListByAnonymousResponse struct {
	// items
	Items []*BaseFileAnonymousResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	// punished_file_count
	PunishedFileCount *int64 `json:"punished_file_count,omitempty" xml:"punished_file_count,omitempty"`
}

func (s ListByAnonymousResponse) String() string {
	return tea.Prettify(s)
}

func (s ListByAnonymousResponse) GoString() string {
	return s.String()
}

func (s *ListByAnonymousResponse) SetItems(v []*BaseFileAnonymousResponse) *ListByAnonymousResponse {
	s.Items = v
	return s
}

func (s *ListByAnonymousResponse) SetNextMarker(v string) *ListByAnonymousResponse {
	s.NextMarker = &v
	return s
}

func (s *ListByAnonymousResponse) SetPunishedFileCount(v int64) *ListByAnonymousResponse {
	s.PunishedFileCount = &v
	return s
}

/**
 * list domain request
 */
type ListDomainsRequest struct {
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker         *string `json:"marker,omitempty" xml:"marker,omitempty"`
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
}

func (s ListDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsRequest) GoString() string {
	return s.String()
}

func (s *ListDomainsRequest) SetLimit(v int32) *ListDomainsRequest {
	s.Limit = &v
	return s
}

func (s *ListDomainsRequest) SetMarker(v string) *ListDomainsRequest {
	s.Marker = &v
	return s
}

func (s *ListDomainsRequest) SetParentDomainId(v string) *ListDomainsRequest {
	s.ParentDomainId = &v
	return s
}

/**
 * List drive request
 */
type ListDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// , 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner_type
	// 
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDriveRequest) GoString() string {
	return s.String()
}

func (s *ListDriveRequest) SetHttpheaders(v map[string]*string) *ListDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *ListDriveRequest) SetLimit(v int32) *ListDriveRequest {
	s.Limit = &v
	return s
}

func (s *ListDriveRequest) SetMarker(v string) *ListDriveRequest {
	s.Marker = &v
	return s
}

func (s *ListDriveRequest) SetOwner(v string) *ListDriveRequest {
	s.Owner = &v
	return s
}

func (s *ListDriveRequest) SetOwnerType(v string) *ListDriveRequest {
	s.OwnerType = &v
	return s
}

func (s *ListDriveRequest) SetSubdomainId(v string) *ListDriveRequest {
	s.SubdomainId = &v
	return s
}

/**
 * list drive response
 */
type ListDriveResponse struct {
	// Drive 
	Items []*BaseDriveResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDriveResponse) GoString() string {
	return s.String()
}

func (s *ListDriveResponse) SetItems(v []*BaseDriveResponse) *ListDriveResponse {
	s.Items = v
	return s
}

func (s *ListDriveResponse) SetNextMarker(v string) *ListDriveResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type ListFileActivityRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// DriveID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// FileID
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// Limit, default
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// Marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListFileActivityRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileActivityRequest) GoString() string {
	return s.String()
}

func (s *ListFileActivityRequest) SetHttpheaders(v map[string]*string) *ListFileActivityRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileActivityRequest) SetAdditionData(v map[string]interface{}) *ListFileActivityRequest {
	s.AdditionData = v
	return s
}

func (s *ListFileActivityRequest) SetDriveId(v string) *ListFileActivityRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileActivityRequest) SetFileId(v string) *ListFileActivityRequest {
	s.FileId = &v
	return s
}

func (s *ListFileActivityRequest) SetLimit(v int32) *ListFileActivityRequest {
	s.Limit = &v
	return s
}

func (s *ListFileActivityRequest) SetMarker(v string) *ListFileActivityRequest {
	s.Marker = &v
	return s
}

/**
 * list file activity response
 */
type ListFileActivityResponse struct {
	// Activities
	Activities []*FileActivity `json:"activities,omitempty" xml:"activities,omitempty" type:"Repeated"`
	// NextMarker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListFileActivityResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileActivityResponse) GoString() string {
	return s.String()
}

func (s *ListFileActivityResponse) SetActivities(v []*FileActivity) *ListFileActivityResponse {
	s.Activities = v
	return s
}

func (s *ListFileActivityResponse) SetNextMarker(v string) *ListFileActivityResponse {
	s.NextMarker = &v
	return s
}

/**
 * 
 */
type ListFileByCustomIndexKeyRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// starred
	Starred *bool `json:"Starred,omitempty" xml:"Starred,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// custom_index_key
	CustomIndexKey *string `json:"custom_index_key,omitempty" xml:"custom_index_key,omitempty" require:"true"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	Referer        *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileByCustomIndexKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileByCustomIndexKeyRequest) GoString() string {
	return s.String()
}

func (s *ListFileByCustomIndexKeyRequest) SetHttpheaders(v map[string]*string) *ListFileByCustomIndexKeyRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetStarred(v bool) *ListFileByCustomIndexKeyRequest {
	s.Starred = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetAdditionData(v map[string]interface{}) *ListFileByCustomIndexKeyRequest {
	s.AdditionData = v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetCategory(v string) *ListFileByCustomIndexKeyRequest {
	s.Category = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetCustomIndexKey(v string) *ListFileByCustomIndexKeyRequest {
	s.CustomIndexKey = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetDriveId(v string) *ListFileByCustomIndexKeyRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetEncryptMode(v string) *ListFileByCustomIndexKeyRequest {
	s.EncryptMode = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetFields(v string) *ListFileByCustomIndexKeyRequest {
	s.Fields = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageCroppingAspectRatios(v []*string) *ListFileByCustomIndexKeyRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetImageUrlProcess(v string) *ListFileByCustomIndexKeyRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetLimit(v int64) *ListFileByCustomIndexKeyRequest {
	s.Limit = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetMarker(v string) *ListFileByCustomIndexKeyRequest {
	s.Marker = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetOfficeThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetOrderDirection(v string) *ListFileByCustomIndexKeyRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetReferer(v string) *ListFileByCustomIndexKeyRequest {
	s.Referer = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetShareId(v string) *ListFileByCustomIndexKeyRequest {
	s.ShareId = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetSignToken(v string) *ListFileByCustomIndexKeyRequest {
	s.SignToken = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetStatus(v string) *ListFileByCustomIndexKeyRequest {
	s.Status = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetType(v string) *ListFileByCustomIndexKeyRequest {
	s.Type = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetUrlExpireSec(v int64) *ListFileByCustomIndexKeyRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *ListFileByCustomIndexKeyRequest) SetVideoThumbnailProcess(v string) *ListFileByCustomIndexKeyRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * 
 */
type ListFileDeltaRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// cursor 
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
	// disable_characteristic_hash
	// default false
	DisableCharacteristicHash *bool `json:"disable_characteristic_hash,omitempty" xml:"disable_characteristic_hash,omitempty"`
	// drive_id
	DriveId                   *string   `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	// default 100
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// sync_root_id
	SyncRootId *string `json:"sync_root_id,omitempty" xml:"sync_root_id,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileDeltaRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileDeltaRequest) GoString() string {
	return s.String()
}

func (s *ListFileDeltaRequest) SetHttpheaders(v map[string]*string) *ListFileDeltaRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileDeltaRequest) SetCursor(v string) *ListFileDeltaRequest {
	s.Cursor = &v
	return s
}

func (s *ListFileDeltaRequest) SetDisableCharacteristicHash(v bool) *ListFileDeltaRequest {
	s.DisableCharacteristicHash = &v
	return s
}

func (s *ListFileDeltaRequest) SetDriveId(v string) *ListFileDeltaRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileDeltaRequest) SetImageCroppingAspectRatios(v []*string) *ListFileDeltaRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *ListFileDeltaRequest) SetImageThumbnailProcess(v string) *ListFileDeltaRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListFileDeltaRequest) SetImageUrlProcess(v string) *ListFileDeltaRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListFileDeltaRequest) SetLimit(v int32) *ListFileDeltaRequest {
	s.Limit = &v
	return s
}

func (s *ListFileDeltaRequest) SetOfficeThumbnailProcess(v string) *ListFileDeltaRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListFileDeltaRequest) SetSyncRootId(v string) *ListFileDeltaRequest {
	s.SyncRootId = &v
	return s
}

func (s *ListFileDeltaRequest) SetVideoThumbnailProcess(v string) *ListFileDeltaRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * list file op response
 */
type ListFileDeltaResponse struct {
	// cursor
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
	// has_more
	HasMore *bool `json:"has_more,omitempty" xml:"has_more,omitempty"`
	// items
	Items []*FileDeltaResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListFileDeltaResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileDeltaResponse) GoString() string {
	return s.String()
}

func (s *ListFileDeltaResponse) SetCursor(v string) *ListFileDeltaResponse {
	s.Cursor = &v
	return s
}

func (s *ListFileDeltaResponse) SetHasMore(v bool) *ListFileDeltaResponse {
	s.HasMore = &v
	return s
}

func (s *ListFileDeltaResponse) SetItems(v []*FileDeltaResponse) *ListFileDeltaResponse {
	s.Items = v
	return s
}

/**
 * 
 */
type ListFileInRecycleBinRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// starred
	Starred *bool `json:"Starred,omitempty" xml:"Starred,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// all
	All *bool `json:"all,omitempty" xml:"all,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// ParentFileID
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
	Referer      *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileInRecycleBinRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileInRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *ListFileInRecycleBinRequest) SetHttpheaders(v map[string]*string) *ListFileInRecycleBinRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileInRecycleBinRequest) SetStarred(v bool) *ListFileInRecycleBinRequest {
	s.Starred = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetAdditionData(v map[string]interface{}) *ListFileInRecycleBinRequest {
	s.AdditionData = v
	return s
}

func (s *ListFileInRecycleBinRequest) SetAll(v bool) *ListFileInRecycleBinRequest {
	s.All = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetCategory(v string) *ListFileInRecycleBinRequest {
	s.Category = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetDriveId(v string) *ListFileInRecycleBinRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetFields(v string) *ListFileInRecycleBinRequest {
	s.Fields = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetImageCroppingAspectRatios(v []*string) *ListFileInRecycleBinRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *ListFileInRecycleBinRequest) SetImageThumbnailProcess(v string) *ListFileInRecycleBinRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetImageUrlProcess(v string) *ListFileInRecycleBinRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetLimit(v int64) *ListFileInRecycleBinRequest {
	s.Limit = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetMarker(v string) *ListFileInRecycleBinRequest {
	s.Marker = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetOfficeThumbnailProcess(v string) *ListFileInRecycleBinRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetOrderBy(v string) *ListFileInRecycleBinRequest {
	s.OrderBy = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetOrderDirection(v string) *ListFileInRecycleBinRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetParentFileId(v string) *ListFileInRecycleBinRequest {
	s.ParentFileId = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetReferer(v string) *ListFileInRecycleBinRequest {
	s.Referer = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetShareId(v string) *ListFileInRecycleBinRequest {
	s.ShareId = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetSignToken(v string) *ListFileInRecycleBinRequest {
	s.SignToken = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetStatus(v string) *ListFileInRecycleBinRequest {
	s.Status = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetType(v string) *ListFileInRecycleBinRequest {
	s.Type = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetUrlExpireSec(v int64) *ListFileInRecycleBinRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *ListFileInRecycleBinRequest) SetVideoThumbnailProcess(v string) *ListFileInRecycleBinRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * ListFileInRecycleBinResponse
 */
type ListFileInRecycleBinResponse struct {
	// items
	Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListFileInRecycleBinResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileInRecycleBinResponse) GoString() string {
	return s.String()
}

func (s *ListFileInRecycleBinResponse) SetItems(v []*BaseCCPFileResponse) *ListFileInRecycleBinResponse {
	s.Items = v
	return s
}

func (s *ListFileInRecycleBinResponse) SetNextMarker(v string) *ListFileInRecycleBinResponse {
	s.NextMarker = &v
	return s
}

/**
 * 
 */
type ListFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// all
	All *bool `json:"all,omitempty" xml:"all,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"0"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// ParentFileID
	ParentFileId     *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
	ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
	Referer          *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id, either share_id or drive_id is required
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// starred
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileRequest) GoString() string {
	return s.String()
}

func (s *ListFileRequest) SetHttpheaders(v map[string]*string) *ListFileRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileRequest) SetAdditionData(v map[string]interface{}) *ListFileRequest {
	s.AdditionData = v
	return s
}

func (s *ListFileRequest) SetAll(v bool) *ListFileRequest {
	s.All = &v
	return s
}

func (s *ListFileRequest) SetCategory(v string) *ListFileRequest {
	s.Category = &v
	return s
}

func (s *ListFileRequest) SetDriveId(v string) *ListFileRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileRequest) SetFields(v string) *ListFileRequest {
	s.Fields = &v
	return s
}

func (s *ListFileRequest) SetImageCroppingAspectRatios(v []*string) *ListFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *ListFileRequest) SetImageThumbnailProcess(v string) *ListFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListFileRequest) SetImageUrlProcess(v string) *ListFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListFileRequest) SetLimit(v int64) *ListFileRequest {
	s.Limit = &v
	return s
}

func (s *ListFileRequest) SetLocation(v string) *ListFileRequest {
	s.Location = &v
	return s
}

func (s *ListFileRequest) SetMarker(v string) *ListFileRequest {
	s.Marker = &v
	return s
}

func (s *ListFileRequest) SetOfficeThumbnailProcess(v string) *ListFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListFileRequest) SetOrderBy(v string) *ListFileRequest {
	s.OrderBy = &v
	return s
}

func (s *ListFileRequest) SetOrderDirection(v string) *ListFileRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListFileRequest) SetParentFileId(v string) *ListFileRequest {
	s.ParentFileId = &v
	return s
}

func (s *ListFileRequest) SetParentFileIdPath(v string) *ListFileRequest {
	s.ParentFileIdPath = &v
	return s
}

func (s *ListFileRequest) SetReferer(v string) *ListFileRequest {
	s.Referer = &v
	return s
}

func (s *ListFileRequest) SetShareId(v string) *ListFileRequest {
	s.ShareId = &v
	return s
}

func (s *ListFileRequest) SetSignToken(v string) *ListFileRequest {
	s.SignToken = &v
	return s
}

func (s *ListFileRequest) SetStarred(v bool) *ListFileRequest {
	s.Starred = &v
	return s
}

func (s *ListFileRequest) SetStatus(v string) *ListFileRequest {
	s.Status = &v
	return s
}

func (s *ListFileRequest) SetType(v string) *ListFileRequest {
	s.Type = &v
	return s
}

func (s *ListFileRequest) SetUrlExpireSec(v int64) *ListFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *ListFileRequest) SetVideoThumbnailProcess(v string) *ListFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * List file response
 */
type ListFileResponse struct {
	// items
	Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	// punished_file_count
	PunishedFileCount *int64 `json:"punished_file_count,omitempty" xml:"punished_file_count,omitempty"`
}

func (s ListFileResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileResponse) GoString() string {
	return s.String()
}

func (s *ListFileResponse) SetItems(v []*BaseCCPFileResponse) *ListFileResponse {
	s.Items = v
	return s
}

func (s *ListFileResponse) SetNextMarker(v string) *ListFileResponse {
	s.NextMarker = &v
	return s
}

func (s *ListFileResponse) SetPunishedFileCount(v int64) *ListFileResponse {
	s.PunishedFileCount = &v
	return s
}

/**
 * 
 */
type ListMangeSharingFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// ID
	CreatorList []*string `json:"creator_list,omitempty" xml:"creator_list,omitempty" type:"Repeated"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" require:"true"`
	// 
	Marker      *string `json:"marker,omitempty" xml:"marker,omitempty"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListMangeSharingFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMangeSharingFileRequest) GoString() string {
	return s.String()
}

func (s *ListMangeSharingFileRequest) SetHttpheaders(v map[string]*string) *ListMangeSharingFileRequest {
	s.Httpheaders = v
	return s
}

func (s *ListMangeSharingFileRequest) SetCreatorList(v []*string) *ListMangeSharingFileRequest {
	s.CreatorList = v
	return s
}

func (s *ListMangeSharingFileRequest) SetLimit(v int32) *ListMangeSharingFileRequest {
	s.Limit = &v
	return s
}

func (s *ListMangeSharingFileRequest) SetMarker(v string) *ListMangeSharingFileRequest {
	s.Marker = &v
	return s
}

func (s *ListMangeSharingFileRequest) SetSubdomainId(v string) *ListMangeSharingFileRequest {
	s.SubdomainId = &v
	return s
}

/**
 * List my drive request
 */
type ListMyDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// , 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListMyDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMyDriveRequest) GoString() string {
	return s.String()
}

func (s *ListMyDriveRequest) SetHttpheaders(v map[string]*string) *ListMyDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *ListMyDriveRequest) SetLimit(v int32) *ListMyDriveRequest {
	s.Limit = &v
	return s
}

func (s *ListMyDriveRequest) SetMarker(v string) *ListMyDriveRequest {
	s.Marker = &v
	return s
}

/**
 * 
 */
type ListReceivedFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" require:"true"`
	// 
	Marker      *string `json:"marker,omitempty" xml:"marker,omitempty"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListReceivedFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ListReceivedFileRequest) GoString() string {
	return s.String()
}

func (s *ListReceivedFileRequest) SetHttpheaders(v map[string]*string) *ListReceivedFileRequest {
	s.Httpheaders = v
	return s
}

func (s *ListReceivedFileRequest) SetLimit(v int32) *ListReceivedFileRequest {
	s.Limit = &v
	return s
}

func (s *ListReceivedFileRequest) SetMarker(v string) *ListReceivedFileRequest {
	s.Marker = &v
	return s
}

func (s *ListReceivedFileRequest) SetSubdomainId(v string) *ListReceivedFileRequest {
	s.SubdomainId = &v
	return s
}

/**
 * list_share_link request
 */
type ListShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// include_cancelled
	IncludeCancelled *bool `json:"include_cancelled,omitempty" xml:"include_cancelled,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s ListShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListShareLinkRequest) GoString() string {
	return s.String()
}

func (s *ListShareLinkRequest) SetHttpheaders(v map[string]*string) *ListShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *ListShareLinkRequest) SetCategory(v string) *ListShareLinkRequest {
	s.Category = &v
	return s
}

func (s *ListShareLinkRequest) SetCreator(v string) *ListShareLinkRequest {
	s.Creator = &v
	return s
}

func (s *ListShareLinkRequest) SetIncludeCancelled(v bool) *ListShareLinkRequest {
	s.IncludeCancelled = &v
	return s
}

func (s *ListShareLinkRequest) SetLimit(v int32) *ListShareLinkRequest {
	s.Limit = &v
	return s
}

func (s *ListShareLinkRequest) SetMarker(v string) *ListShareLinkRequest {
	s.Marker = &v
	return s
}

func (s *ListShareLinkRequest) SetOrderBy(v string) *ListShareLinkRequest {
	s.OrderBy = &v
	return s
}

func (s *ListShareLinkRequest) SetOrderDirection(v string) *ListShareLinkRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListShareLinkRequest) SetViewId(v string) *ListShareLinkRequest {
	s.ViewId = &v
	return s
}

/**
 * list_share_link response
 */
type ListShareLinkResponse struct {
	// items
	Items []*BaseShareLinkResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShareLinkResponse) GoString() string {
	return s.String()
}

func (s *ListShareLinkResponse) SetItems(v []*BaseShareLinkResponse) *ListShareLinkResponse {
	s.Items = v
	return s
}

func (s *ListShareLinkResponse) SetNextMarker(v string) *ListShareLinkResponse {
	s.NextMarker = &v
	return s
}

/**
 * list share request
 */
type ListShareRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// Owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner_type
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// share_file_path
	ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
}

func (s ListShareRequest) String() string {
	return tea.Prettify(s)
}

func (s ListShareRequest) GoString() string {
	return s.String()
}

func (s *ListShareRequest) SetHttpheaders(v map[string]*string) *ListShareRequest {
	s.Httpheaders = v
	return s
}

func (s *ListShareRequest) SetCreator(v string) *ListShareRequest {
	s.Creator = &v
	return s
}

func (s *ListShareRequest) SetDriveId(v string) *ListShareRequest {
	s.DriveId = &v
	return s
}

func (s *ListShareRequest) SetLimit(v int32) *ListShareRequest {
	s.Limit = &v
	return s
}

func (s *ListShareRequest) SetMarker(v string) *ListShareRequest {
	s.Marker = &v
	return s
}

func (s *ListShareRequest) SetOwner(v string) *ListShareRequest {
	s.Owner = &v
	return s
}

func (s *ListShareRequest) SetOwnerType(v string) *ListShareRequest {
	s.OwnerType = &v
	return s
}

func (s *ListShareRequest) SetShareFilePath(v string) *ListShareRequest {
	s.ShareFilePath = &v
	return s
}

/**
 * List share response
 */
type ListShareResponse struct {
	// items
	Items []*BaseShareResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListShareResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShareResponse) GoString() string {
	return s.String()
}

func (s *ListShareResponse) SetItems(v []*BaseShareResponse) *ListShareResponse {
	s.Items = v
	return s
}

func (s *ListShareResponse) SetNextMarker(v string) *ListShareResponse {
	s.NextMarker = &v
	return s
}

/**
 * 
 */
type ListSharingFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" require:"true"`
	// 
	Marker      *string `json:"marker,omitempty" xml:"marker,omitempty"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListSharingFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSharingFileRequest) GoString() string {
	return s.String()
}

func (s *ListSharingFileRequest) SetHttpheaders(v map[string]*string) *ListSharingFileRequest {
	s.Httpheaders = v
	return s
}

func (s *ListSharingFileRequest) SetLimit(v int32) *ListSharingFileRequest {
	s.Limit = &v
	return s
}

func (s *ListSharingFileRequest) SetMarker(v string) *ListSharingFileRequest {
	s.Marker = &v
	return s
}

func (s *ListSharingFileRequest) SetSubdomainId(v string) *ListSharingFileRequest {
	s.SubdomainId = &v
	return s
}

/**
 * list store file
 */
type ListStoreFileRequest struct {
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// parent_file_path
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty"`
	// store_id
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListStoreFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ListStoreFileRequest) GoString() string {
	return s.String()
}

func (s *ListStoreFileRequest) SetLimit(v int64) *ListStoreFileRequest {
	s.Limit = &v
	return s
}

func (s *ListStoreFileRequest) SetMarker(v string) *ListStoreFileRequest {
	s.Marker = &v
	return s
}

func (s *ListStoreFileRequest) SetParentFilePath(v string) *ListStoreFileRequest {
	s.ParentFilePath = &v
	return s
}

func (s *ListStoreFileRequest) SetStoreId(v string) *ListStoreFileRequest {
	s.StoreId = &v
	return s
}

func (s *ListStoreFileRequest) SetType(v string) *ListStoreFileRequest {
	s.Type = &v
	return s
}

/**
 * List storage file
 */
type ListStoreFileResponse struct {
	// items
	// file list
	Items      []*StoreFile `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string      `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListStoreFileResponse) String() string {
	return tea.Prettify(s)
}

func (s ListStoreFileResponse) GoString() string {
	return s.String()
}

func (s *ListStoreFileResponse) SetItems(v []*StoreFile) *ListStoreFileResponse {
	s.Items = v
	return s
}

func (s *ListStoreFileResponse) SetNextMarker(v string) *ListStoreFileResponse {
	s.NextMarker = &v
	return s
}

/**
 * list storage file
 */
type ListStoreRequest struct {
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
}

func (s ListStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s ListStoreRequest) GoString() string {
	return s.String()
}

func (s *ListStoreRequest) SetDomainId(v string) *ListStoreRequest {
	s.DomainId = &v
	return s
}

/**
 * List storage
 */
type ListStoreResponse struct {
	// items
	Items []*StoreItemResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s ListStoreResponse) GoString() string {
	return s.String()
}

func (s *ListStoreResponse) SetItems(v []*StoreItemResponse) *ListStoreResponse {
	s.Items = v
	return s
}

/**
 *
 */
type ListStoresRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s ListStoresRequest) String() string {
	return tea.Prettify(s)
}

func (s ListStoresRequest) GoString() string {
	return s.String()
}

func (s *ListStoresRequest) SetDomainId(v string) *ListStoresRequest {
	s.DomainId = &v
	return s
}

/**
 * uploadID
 */
type ListUploadedPartRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"1000" minimum:"1"`
	// part_number_marker
	PartNumberMarker *int64  `json:"part_number_marker,omitempty" xml:"part_number_marker,omitempty" minimum:"1"`
	ShareId          *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s ListUploadedPartRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUploadedPartRequest) GoString() string {
	return s.String()
}

func (s *ListUploadedPartRequest) SetHttpheaders(v map[string]*string) *ListUploadedPartRequest {
	s.Httpheaders = v
	return s
}

func (s *ListUploadedPartRequest) SetDriveId(v string) *ListUploadedPartRequest {
	s.DriveId = &v
	return s
}

func (s *ListUploadedPartRequest) SetFileId(v string) *ListUploadedPartRequest {
	s.FileId = &v
	return s
}

func (s *ListUploadedPartRequest) SetFileIdPath(v string) *ListUploadedPartRequest {
	s.FileIdPath = &v
	return s
}

func (s *ListUploadedPartRequest) SetLimit(v int64) *ListUploadedPartRequest {
	s.Limit = &v
	return s
}

func (s *ListUploadedPartRequest) SetPartNumberMarker(v int64) *ListUploadedPartRequest {
	s.PartNumberMarker = &v
	return s
}

func (s *ListUploadedPartRequest) SetShareId(v string) *ListUploadedPartRequest {
	s.ShareId = &v
	return s
}

func (s *ListUploadedPartRequest) SetUploadId(v string) *ListUploadedPartRequest {
	s.UploadId = &v
	return s
}

/**
 *  response
 */
type ListUploadedPartResponse struct {
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// next_part_number_marker
	NextPartNumberMarker *string `json:"next_part_number_marker,omitempty" xml:"next_part_number_marker,omitempty"`
	ParallelUpload       *bool   `json:"parallel_upload,omitempty" xml:"parallel_upload,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// uploaded_parts
	UploadedParts []*UploadPartInfo `json:"uploaded_parts,omitempty" xml:"uploaded_parts,omitempty" type:"Repeated"`
}

func (s ListUploadedPartResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUploadedPartResponse) GoString() string {
	return s.String()
}

func (s *ListUploadedPartResponse) SetFileId(v string) *ListUploadedPartResponse {
	s.FileId = &v
	return s
}

func (s *ListUploadedPartResponse) SetNextPartNumberMarker(v string) *ListUploadedPartResponse {
	s.NextPartNumberMarker = &v
	return s
}

func (s *ListUploadedPartResponse) SetParallelUpload(v bool) *ListUploadedPartResponse {
	s.ParallelUpload = &v
	return s
}

func (s *ListUploadedPartResponse) SetUploadId(v string) *ListUploadedPartResponse {
	s.UploadId = &v
	return s
}

func (s *ListUploadedPartResponse) SetUploadedParts(v []*UploadPartInfo) *ListUploadedPartResponse {
	s.UploadedParts = v
	return s
}

/**
 * meta
 */
type LiveTranscodingMetaResponse struct {
	// ts_pre_count
	TsPreCount *int64 `json:"ts_pre_count,omitempty" xml:"ts_pre_count,omitempty"`
	// ts_segment
	TsSegment *int64 `json:"ts_segment,omitempty" xml:"ts_segment,omitempty"`
	// ts_total_count
	TsTotalCount *int64 `json:"ts_total_count,omitempty" xml:"ts_total_count,omitempty"`
}

func (s LiveTranscodingMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s LiveTranscodingMetaResponse) GoString() string {
	return s.String()
}

func (s *LiveTranscodingMetaResponse) SetTsPreCount(v int64) *LiveTranscodingMetaResponse {
	s.TsPreCount = &v
	return s
}

func (s *LiveTranscodingMetaResponse) SetTsSegment(v int64) *LiveTranscodingMetaResponse {
	s.TsSegment = &v
	return s
}

func (s *LiveTranscodingMetaResponse) SetTsTotalCount(v int64) *LiveTranscodingMetaResponse {
	s.TsTotalCount = &v
	return s
}

/**
 *
 */
type LiveTranscodingSubtitleTaskResponse struct {
	// language, 
	Language *string `json:"language,omitempty" xml:"language,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// url, finished 
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s LiveTranscodingSubtitleTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s LiveTranscodingSubtitleTaskResponse) GoString() string {
	return s.String()
}

func (s *LiveTranscodingSubtitleTaskResponse) SetLanguage(v string) *LiveTranscodingSubtitleTaskResponse {
	s.Language = &v
	return s
}

func (s *LiveTranscodingSubtitleTaskResponse) SetStatus(v string) *LiveTranscodingSubtitleTaskResponse {
	s.Status = &v
	return s
}

func (s *LiveTranscodingSubtitleTaskResponse) SetUrl(v string) *LiveTranscodingSubtitleTaskResponse {
	s.Url = &v
	return s
}

/**
 * task
 */
type LiveTranscodingTaskResponse struct {
	// keep_original_resolution (template)
	KeepOriginalResolution *bool `json:"keep_original_resolution,omitempty" xml:"keep_original_resolution,omitempty"`
	// preview_url, 
	PreviewUrl *string `json:"preview_url,omitempty" xml:"preview_url,omitempty"`
	// stage, (Deprecated)
	Stage *string `json:"stage,omitempty" xml:"stage,omitempty"`
	// status, 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// template_id, id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
	// template_name, id
	TemplateName *string `json:"template_name,omitempty" xml:"template_name,omitempty"`
	// url, 
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s LiveTranscodingTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s LiveTranscodingTaskResponse) GoString() string {
	return s.String()
}

func (s *LiveTranscodingTaskResponse) SetKeepOriginalResolution(v bool) *LiveTranscodingTaskResponse {
	s.KeepOriginalResolution = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetPreviewUrl(v string) *LiveTranscodingTaskResponse {
	s.PreviewUrl = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetStage(v string) *LiveTranscodingTaskResponse {
	s.Stage = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetStatus(v string) *LiveTranscodingTaskResponse {
	s.Status = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetTemplateId(v string) *LiveTranscodingTaskResponse {
	s.TemplateId = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetTemplateName(v string) *LiveTranscodingTaskResponse {
	s.TemplateName = &v
	return s
}

func (s *LiveTranscodingTaskResponse) SetUrl(v string) *LiveTranscodingTaskResponse {
	s.Url = &v
	return s
}

/**
 *
 */
type LoginByCodeRequest struct {
	// accessToken
	AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// AuthCode
	AuthCode *string `json:"auth_code,omitempty" xml:"auth_code,omitempty"`
	// 
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s LoginByCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s LoginByCodeRequest) GoString() string {
	return s.String()
}

func (s *LoginByCodeRequest) SetAccessToken(v string) *LoginByCodeRequest {
	s.AccessToken = &v
	return s
}

func (s *LoginByCodeRequest) SetAppId(v string) *LoginByCodeRequest {
	s.AppId = &v
	return s
}

func (s *LoginByCodeRequest) SetAuthCode(v string) *LoginByCodeRequest {
	s.AuthCode = &v
	return s
}

func (s *LoginByCodeRequest) SetType(v string) *LoginByCodeRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type LoginRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// 
	AutoRegister *bool `json:"auto_register,omitempty" xml:"auto_register,omitempty"`
	// ID, 
	CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty"`
	// , 
	CaptchaText *string `json:"captcha_text,omitempty" xml:"captcha_text,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// AES-256App
	EncryptedKey *string `json:"encrypted_key,omitempty" xml:"encrypted_key,omitempty"`
	// 
	NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
	// , 
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	// 
	SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty"`
	// ID
	SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty"`
}

func (s LoginRequest) String() string {
	return tea.Prettify(s)
}

func (s LoginRequest) GoString() string {
	return s.String()
}

func (s *LoginRequest) SetHttpheaders(v map[string]*string) *LoginRequest {
	s.Httpheaders = v
	return s
}

func (s *LoginRequest) SetAppId(v string) *LoginRequest {
	s.AppId = &v
	return s
}

func (s *LoginRequest) SetAutoRegister(v bool) *LoginRequest {
	s.AutoRegister = &v
	return s
}

func (s *LoginRequest) SetCaptchaId(v string) *LoginRequest {
	s.CaptchaId = &v
	return s
}

func (s *LoginRequest) SetCaptchaText(v string) *LoginRequest {
	s.CaptchaText = &v
	return s
}

func (s *LoginRequest) SetEmail(v string) *LoginRequest {
	s.Email = &v
	return s
}

func (s *LoginRequest) SetEncryptedKey(v string) *LoginRequest {
	s.EncryptedKey = &v
	return s
}

func (s *LoginRequest) SetNvcParam(v string) *LoginRequest {
	s.NvcParam = &v
	return s
}

func (s *LoginRequest) SetPassword(v string) *LoginRequest {
	s.Password = &v
	return s
}

func (s *LoginRequest) SetPhoneNumber(v string) *LoginRequest {
	s.PhoneNumber = &v
	return s
}

func (s *LoginRequest) SetPhoneRegion(v string) *LoginRequest {
	s.PhoneRegion = &v
	return s
}

func (s *LoginRequest) SetSmsCode(v string) *LoginRequest {
	s.SmsCode = &v
	return s
}

func (s *LoginRequest) SetSmsCodeId(v string) *LoginRequest {
	s.SmsCodeId = &v
	return s
}

/**
 *
 */
type LogoutRequest struct {
	// App
	BackUrl *string `json:"BackUrl,omitempty" xml:"BackUrl,omitempty"`
	// Client ID, AppAppID
	ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
	// callback
	LoginType *string `json:"LoginType,omitempty" xml:"LoginType,omitempty"`
}

func (s LogoutRequest) String() string {
	return tea.Prettify(s)
}

func (s LogoutRequest) GoString() string {
	return s.String()
}

func (s *LogoutRequest) SetBackUrl(v string) *LogoutRequest {
	s.BackUrl = &v
	return s
}

func (s *LogoutRequest) SetClientID(v string) *LogoutRequest {
	s.ClientID = &v
	return s
}

func (s *LogoutRequest) SetLoginType(v string) *LogoutRequest {
	s.LoginType = &v
	return s
}

/**
 *
 */
type MediaPlayInfoTemplate struct {
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s MediaPlayInfoTemplate) String() string {
	return tea.Prettify(s)
}

func (s MediaPlayInfoTemplate) GoString() string {
	return s.String()
}

func (s *MediaPlayInfoTemplate) SetStatus(v string) *MediaPlayInfoTemplate {
	s.Status = &v
	return s
}

func (s *MediaPlayInfoTemplate) SetTemplateId(v string) *MediaPlayInfoTemplate {
	s.TemplateId = &v
	return s
}

func (s *MediaPlayInfoTemplate) SetUrl(v string) *MediaPlayInfoTemplate {
	s.Url = &v
	return s
}

/**
 *
 */
type MoveDetail struct {
	// SrcParentFileID
	SrcParentFileId *string `json:"src_parent_file_id,omitempty" xml:"src_parent_file_id,omitempty"`
	// TgtParentFileID
	TgtParentFileId *string `json:"tgt_parent_file_id,omitempty" xml:"tgt_parent_file_id,omitempty"`
}

func (s MoveDetail) String() string {
	return tea.Prettify(s)
}

func (s MoveDetail) GoString() string {
	return s.String()
}

func (s *MoveDetail) SetSrcParentFileId(v string) *MoveDetail {
	s.SrcParentFileId = &v
	return s
}

func (s *MoveDetail) SetTgtParentFileId(v string) *MoveDetail {
	s.TgtParentFileId = &v
	return s
}

/**
 * 
 */
type MoveFileRequest struct {
	Httpheaders  map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	AutoRename   *bool              `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
	CategoryList []*string          `json:"category_list,omitempty" xml:"category_list,omitempty" type:"Repeated"`
	// check_name_mode
	CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty" maxLength:"1024" minLength:"1"`
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// to_drive_id
	ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
	// to_parent_file_id
	ToParentFileId *string `json:"to_parent_file_id,omitempty" xml:"to_parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4"`
	ToShareId      *string `json:"to_share_id,omitempty" xml:"to_share_id,omitempty" pattern:"[0-9]+"`
}

func (s MoveFileRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveFileRequest) GoString() string {
	return s.String()
}

func (s *MoveFileRequest) SetHttpheaders(v map[string]*string) *MoveFileRequest {
	s.Httpheaders = v
	return s
}

func (s *MoveFileRequest) SetAutoRename(v bool) *MoveFileRequest {
	s.AutoRename = &v
	return s
}

func (s *MoveFileRequest) SetCategoryList(v []*string) *MoveFileRequest {
	s.CategoryList = v
	return s
}

func (s *MoveFileRequest) SetCheckNameMode(v string) *MoveFileRequest {
	s.CheckNameMode = &v
	return s
}

func (s *MoveFileRequest) SetDriveId(v string) *MoveFileRequest {
	s.DriveId = &v
	return s
}

func (s *MoveFileRequest) SetFileId(v string) *MoveFileRequest {
	s.FileId = &v
	return s
}

func (s *MoveFileRequest) SetFileIdPath(v string) *MoveFileRequest {
	s.FileIdPath = &v
	return s
}

func (s *MoveFileRequest) SetNewName(v string) *MoveFileRequest {
	s.NewName = &v
	return s
}

func (s *MoveFileRequest) SetShareId(v string) *MoveFileRequest {
	s.ShareId = &v
	return s
}

func (s *MoveFileRequest) SetToDriveId(v string) *MoveFileRequest {
	s.ToDriveId = &v
	return s
}

func (s *MoveFileRequest) SetToParentFileId(v string) *MoveFileRequest {
	s.ToParentFileId = &v
	return s
}

func (s *MoveFileRequest) SetToShareId(v string) *MoveFileRequest {
	s.ToShareId = &v
	return s
}

/**
 *  response
 */
type MoveFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// exist
	// type: boolean
	Exist *bool `json:"exist,omitempty" xml:"exist,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s MoveFileResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveFileResponse) GoString() string {
	return s.String()
}

func (s *MoveFileResponse) SetAsyncTaskId(v string) *MoveFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *MoveFileResponse) SetDomainId(v string) *MoveFileResponse {
	s.DomainId = &v
	return s
}

func (s *MoveFileResponse) SetDriveId(v string) *MoveFileResponse {
	s.DriveId = &v
	return s
}

func (s *MoveFileResponse) SetExist(v bool) *MoveFileResponse {
	s.Exist = &v
	return s
}

func (s *MoveFileResponse) SetFileId(v string) *MoveFileResponse {
	s.FileId = &v
	return s
}

/**
 *
 */
type Permission struct {
	ActionList     []*ActionItem `json:"ActionList,omitempty" xml:"ActionList,omitempty" type:"Repeated"`
	CreatedAt      *int64        `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty"`
	Deleted        *string       `json:"Deleted,omitempty" xml:"Deleted,omitempty"`
	DomainID       *string       `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
	IdentityID     *string       `json:"IdentityID,omitempty" xml:"IdentityID,omitempty"`
	IdentityType   *string       `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	Resource       *string       `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType   *string       `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	SequenceNumber *int64        `json:"SequenceNumber,omitempty" xml:"SequenceNumber,omitempty"`
	UpdatedAt      *int64        `json:"UpdatedAt,omitempty" xml:"UpdatedAt,omitempty"`
	UpdatedBy      *string       `json:"UpdatedBy,omitempty" xml:"UpdatedBy,omitempty"`
}

func (s Permission) String() string {
	return tea.Prettify(s)
}

func (s Permission) GoString() string {
	return s.String()
}

func (s *Permission) SetActionList(v []*ActionItem) *Permission {
	s.ActionList = v
	return s
}

func (s *Permission) SetCreatedAt(v int64) *Permission {
	s.CreatedAt = &v
	return s
}

func (s *Permission) SetDeleted(v string) *Permission {
	s.Deleted = &v
	return s
}

func (s *Permission) SetDomainID(v string) *Permission {
	s.DomainID = &v
	return s
}

func (s *Permission) SetIdentityID(v string) *Permission {
	s.IdentityID = &v
	return s
}

func (s *Permission) SetIdentityType(v string) *Permission {
	s.IdentityType = &v
	return s
}

func (s *Permission) SetResource(v string) *Permission {
	s.Resource = &v
	return s
}

func (s *Permission) SetResourceType(v string) *Permission {
	s.ResourceType = &v
	return s
}

func (s *Permission) SetSequenceNumber(v int64) *Permission {
	s.SequenceNumber = &v
	return s
}

func (s *Permission) SetUpdatedAt(v int64) *Permission {
	s.UpdatedAt = &v
	return s
}

func (s *Permission) SetUpdatedBy(v string) *Permission {
	s.UpdatedBy = &v
	return s
}

/**
 * play_media request
 */
type PlayMediaRequest struct {
	// auth_key
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty" require:"true" pattern:"[a-z0-9]+"`
	// drive_id
	DriveID *string `json:"DriveID,omitempty" xml:"DriveID,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileID *string `json:"FileID,omitempty" xml:"FileID,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
}

func (s PlayMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s PlayMediaRequest) GoString() string {
	return s.String()
}

func (s *PlayMediaRequest) SetAuthKey(v string) *PlayMediaRequest {
	s.AuthKey = &v
	return s
}

func (s *PlayMediaRequest) SetDriveID(v string) *PlayMediaRequest {
	s.DriveID = &v
	return s
}

func (s *PlayMediaRequest) SetFileID(v string) *PlayMediaRequest {
	s.FileID = &v
	return s
}

/**
 * Pre hash check Response
 */
type PreHashCheckSuccessResponse struct {
	// code
	Code *string `json:"code,omitempty" xml:"code,omitempty"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
	// message
	Message *string `json:"message,omitempty" xml:"message,omitempty"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// pre_hash
	PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
}

func (s PreHashCheckSuccessResponse) String() string {
	return tea.Prettify(s)
}

func (s PreHashCheckSuccessResponse) GoString() string {
	return s.String()
}

func (s *PreHashCheckSuccessResponse) SetCode(v string) *PreHashCheckSuccessResponse {
	s.Code = &v
	return s
}

func (s *PreHashCheckSuccessResponse) SetFileName(v string) *PreHashCheckSuccessResponse {
	s.FileName = &v
	return s
}

func (s *PreHashCheckSuccessResponse) SetMessage(v string) *PreHashCheckSuccessResponse {
	s.Message = &v
	return s
}

func (s *PreHashCheckSuccessResponse) SetParentFileId(v string) *PreHashCheckSuccessResponse {
	s.ParentFileId = &v
	return s
}

func (s *PreHashCheckSuccessResponse) SetPreHash(v string) *PreHashCheckSuccessResponse {
	s.PreHash = &v
	return s
}

/**
 *  user_tags 
 */
type PutFileUserTagsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	// user_tags
	UserTags []*UserTag `json:"user_tags,omitempty" xml:"user_tags,omitempty" type:"Repeated"`
}

func (s PutFileUserTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s PutFileUserTagsRequest) GoString() string {
	return s.String()
}

func (s *PutFileUserTagsRequest) SetHttpheaders(v map[string]*string) *PutFileUserTagsRequest {
	s.Httpheaders = v
	return s
}

func (s *PutFileUserTagsRequest) SetDriveId(v string) *PutFileUserTagsRequest {
	s.DriveId = &v
	return s
}

func (s *PutFileUserTagsRequest) SetFileId(v string) *PutFileUserTagsRequest {
	s.FileId = &v
	return s
}

func (s *PutFileUserTagsRequest) SetUserTags(v []*UserTag) *PutFileUserTagsRequest {
	s.UserTags = v
	return s
}

/**
 *  user tags response
 */
type PutFileUserTagsResponse struct {
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" pattern:"[a-z0-9]{1,50}"`
}

func (s PutFileUserTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s PutFileUserTagsResponse) GoString() string {
	return s.String()
}

func (s *PutFileUserTagsResponse) SetFileId(v string) *PutFileUserTagsResponse {
	s.FileId = &v
	return s
}

/**
 *
 */
type RPVerifyBaseRequest struct {
	// User ID, 
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s RPVerifyBaseRequest) String() string {
	return tea.Prettify(s)
}

func (s RPVerifyBaseRequest) GoString() string {
	return s.String()
}

func (s *RPVerifyBaseRequest) SetUserId(v string) *RPVerifyBaseRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type RPVerifyTokenResponse struct {
	// false
	NeedRpVerify *bool                `json:"need_rp_verify,omitempty" xml:"need_rp_verify,omitempty" require:"true"`
	VerifyToken  *VerifyTokenResponse `json:"verify_token,omitempty" xml:"verify_token,omitempty" require:"true"`
}

func (s RPVerifyTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s RPVerifyTokenResponse) GoString() string {
	return s.String()
}

func (s *RPVerifyTokenResponse) SetNeedRpVerify(v bool) *RPVerifyTokenResponse {
	s.NeedRpVerify = &v
	return s
}

func (s *RPVerifyTokenResponse) SetVerifyToken(v *VerifyTokenResponse) *RPVerifyTokenResponse {
	s.VerifyToken = v
	return s
}

/**
 * 
 */
type RateLimit struct {
	PartSize  *int64 `json:"part_size,omitempty" xml:"part_size,omitempty"`
	PartSpeed *int64 `json:"part_speed,omitempty" xml:"part_speed,omitempty"`
}

func (s RateLimit) String() string {
	return tea.Prettify(s)
}

func (s RateLimit) GoString() string {
	return s.String()
}

func (s *RateLimit) SetPartSize(v int64) *RateLimit {
	s.PartSize = &v
	return s
}

func (s *RateLimit) SetPartSpeed(v int64) *RateLimit {
	s.PartSpeed = &v
	return s
}

/**
 * office
 */
type RefreshOfficeEditTokenRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// AccessToken
	OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty" require:"true"`
	// RefreshToken
	OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty" require:"true"`
}

func (s RefreshOfficeEditTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshOfficeEditTokenRequest) GoString() string {
	return s.String()
}

func (s *RefreshOfficeEditTokenRequest) SetHttpheaders(v map[string]*string) *RefreshOfficeEditTokenRequest {
	s.Httpheaders = v
	return s
}

func (s *RefreshOfficeEditTokenRequest) SetAdditionData(v map[string]interface{}) *RefreshOfficeEditTokenRequest {
	s.AdditionData = v
	return s
}

func (s *RefreshOfficeEditTokenRequest) SetLocation(v string) *RefreshOfficeEditTokenRequest {
	s.Location = &v
	return s
}

func (s *RefreshOfficeEditTokenRequest) SetOfficeAccessToken(v string) *RefreshOfficeEditTokenRequest {
	s.OfficeAccessToken = &v
	return s
}

func (s *RefreshOfficeEditTokenRequest) SetOfficeRefreshToken(v string) *RefreshOfficeEditTokenRequest {
	s.OfficeRefreshToken = &v
	return s
}

/**
 * office response
 */
type RefreshOfficeEditTokenResponse struct {
	// AccessToken
	OfficeAccessToken *string `json:"office_access_token,omitempty" xml:"office_access_token,omitempty"`
	// RefreshToken
	OfficeRefreshToken *string `json:"office_refresh_token,omitempty" xml:"office_refresh_token,omitempty"`
}

func (s RefreshOfficeEditTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshOfficeEditTokenResponse) GoString() string {
	return s.String()
}

func (s *RefreshOfficeEditTokenResponse) SetOfficeAccessToken(v string) *RefreshOfficeEditTokenResponse {
	s.OfficeAccessToken = &v
	return s
}

func (s *RefreshOfficeEditTokenResponse) SetOfficeRefreshToken(v string) *RefreshOfficeEditTokenResponse {
	s.OfficeRefreshToken = &v
	return s
}

/**
 *
 */
type RegisterRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	// 
	SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty" require:"true"`
	// ID
	SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
}

func (s RegisterRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterRequest) GoString() string {
	return s.String()
}

func (s *RegisterRequest) SetHttpheaders(v map[string]*string) *RegisterRequest {
	s.Httpheaders = v
	return s
}

func (s *RegisterRequest) SetAppId(v string) *RegisterRequest {
	s.AppId = &v
	return s
}

func (s *RegisterRequest) SetEmail(v string) *RegisterRequest {
	s.Email = &v
	return s
}

func (s *RegisterRequest) SetNvcParam(v string) *RegisterRequest {
	s.NvcParam = &v
	return s
}

func (s *RegisterRequest) SetPhoneNumber(v string) *RegisterRequest {
	s.PhoneNumber = &v
	return s
}

func (s *RegisterRequest) SetPhoneRegion(v string) *RegisterRequest {
	s.PhoneRegion = &v
	return s
}

func (s *RegisterRequest) SetSmsCode(v string) *RegisterRequest {
	s.SmsCode = &v
	return s
}

func (s *RegisterRequest) SetSmsCodeId(v string) *RegisterRequest {
	s.SmsCodeId = &v
	return s
}

/**
 *
 */
type RemoveStoreRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// store ID
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
}

func (s RemoveStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveStoreRequest) GoString() string {
	return s.String()
}

func (s *RemoveStoreRequest) SetDomainId(v string) *RemoveStoreRequest {
	s.DomainId = &v
	return s
}

func (s *RemoveStoreRequest) SetStoreId(v string) *RemoveStoreRequest {
	s.StoreId = &v
	return s
}

/**
 *
 */
type RenameDetail struct {
	// NewName
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty"`
	// OldName
	OldName *string `json:"old_name,omitempty" xml:"old_name,omitempty"`
}

func (s RenameDetail) String() string {
	return tea.Prettify(s)
}

func (s RenameDetail) GoString() string {
	return s.String()
}

func (s *RenameDetail) SetNewName(v string) *RenameDetail {
	s.NewName = &v
	return s
}

func (s *RenameDetail) SetOldName(v string) *RenameDetail {
	s.OldName = &v
	return s
}

/**
 * report_event request
 */
type ReportEventRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// event_type
	EventType       *string                            `json:"event_type,omitempty" xml:"event_type,omitempty"`
	MediaPlay       *ReportMediaPlayEventRequest       `json:"media_play,omitempty" xml:"media_play,omitempty"`
	ShareLink       *ReportShareLinkEventRequest       `json:"share_link,omitempty" xml:"share_link,omitempty"`
	ShareLinkAccess *ReportShareLinkAccessEventRequest `json:"share_link_access,omitempty" xml:"share_link_access,omitempty"`
}

func (s ReportEventRequest) String() string {
	return tea.Prettify(s)
}

func (s ReportEventRequest) GoString() string {
	return s.String()
}

func (s *ReportEventRequest) SetHttpheaders(v map[string]*string) *ReportEventRequest {
	s.Httpheaders = v
	return s
}

func (s *ReportEventRequest) SetEventType(v string) *ReportEventRequest {
	s.EventType = &v
	return s
}

func (s *ReportEventRequest) SetMediaPlay(v *ReportMediaPlayEventRequest) *ReportEventRequest {
	s.MediaPlay = v
	return s
}

func (s *ReportEventRequest) SetShareLink(v *ReportShareLinkEventRequest) *ReportEventRequest {
	s.ShareLink = v
	return s
}

func (s *ReportEventRequest) SetShareLinkAccess(v *ReportShareLinkAccessEventRequest) *ReportEventRequest {
	s.ShareLinkAccess = v
	return s
}

/**
 * report_event operation response
 */
type ReportEventResponse struct {
}

func (s ReportEventResponse) String() string {
	return tea.Prettify(s)
}

func (s ReportEventResponse) GoString() string {
	return s.String()
}

/**
 * report_media_play_event request
 */
type ReportMediaPlayEventRequest struct {
	// duration
	Duration *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
	// error
	Error *string `json:"error,omitempty" xml:"error,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// player_version
	PlayerVersion *string `json:"player_version,omitempty" xml:"player_version,omitempty"`
	// sub_type
	SubType *string `json:"sub_type,omitempty" xml:"sub_type,omitempty"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
	// wait_count
	WaitCount *int64 `json:"wait_count,omitempty" xml:"wait_count,omitempty"`
}

func (s ReportMediaPlayEventRequest) String() string {
	return tea.Prettify(s)
}

func (s ReportMediaPlayEventRequest) GoString() string {
	return s.String()
}

func (s *ReportMediaPlayEventRequest) SetDuration(v int64) *ReportMediaPlayEventRequest {
	s.Duration = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetError(v string) *ReportMediaPlayEventRequest {
	s.Error = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetFileId(v string) *ReportMediaPlayEventRequest {
	s.FileId = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetPlayerVersion(v string) *ReportMediaPlayEventRequest {
	s.PlayerVersion = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetSubType(v string) *ReportMediaPlayEventRequest {
	s.SubType = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetTemplateId(v string) *ReportMediaPlayEventRequest {
	s.TemplateId = &v
	return s
}

func (s *ReportMediaPlayEventRequest) SetWaitCount(v int64) *ReportMediaPlayEventRequest {
	s.WaitCount = &v
	return s
}

/**
 * report_share_link_access_event request
 */
type ReportShareLinkAccessEventRequest struct {
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// sub_type
	SubType *string `json:"sub_type,omitempty" xml:"sub_type,omitempty"`
}

func (s ReportShareLinkAccessEventRequest) String() string {
	return tea.Prettify(s)
}

func (s ReportShareLinkAccessEventRequest) GoString() string {
	return s.String()
}

func (s *ReportShareLinkAccessEventRequest) SetShareId(v string) *ReportShareLinkAccessEventRequest {
	s.ShareId = &v
	return s
}

func (s *ReportShareLinkAccessEventRequest) SetSubType(v string) *ReportShareLinkAccessEventRequest {
	s.SubType = &v
	return s
}

/**
 * report_share_link_event request
 */
type ReportShareLinkEventRequest struct {
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// sub_type
	SubType *string `json:"sub_type,omitempty" xml:"sub_type,omitempty"`
}

func (s ReportShareLinkEventRequest) String() string {
	return tea.Prettify(s)
}

func (s ReportShareLinkEventRequest) GoString() string {
	return s.String()
}

func (s *ReportShareLinkEventRequest) SetShareId(v string) *ReportShareLinkEventRequest {
	s.ShareId = &v
	return s
}

func (s *ReportShareLinkEventRequest) SetSubType(v string) *ReportShareLinkEventRequest {
	s.SubType = &v
	return s
}

/**
 *
 */
type RestoreDetail struct {
}

func (s RestoreDetail) String() string {
	return tea.Prettify(s)
}

func (s RestoreDetail) GoString() string {
	return s.String()
}

/**
 * 
 */
type RestoreFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
}

func (s RestoreFileRequest) String() string {
	return tea.Prettify(s)
}

func (s RestoreFileRequest) GoString() string {
	return s.String()
}

func (s *RestoreFileRequest) SetHttpheaders(v map[string]*string) *RestoreFileRequest {
	s.Httpheaders = v
	return s
}

func (s *RestoreFileRequest) SetDriveId(v string) *RestoreFileRequest {
	s.DriveId = &v
	return s
}

func (s *RestoreFileRequest) SetFileId(v string) *RestoreFileRequest {
	s.FileId = &v
	return s
}

/**
 * response
 */
type RestoreFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s RestoreFileResponse) String() string {
	return tea.Prettify(s)
}

func (s RestoreFileResponse) GoString() string {
	return s.String()
}

func (s *RestoreFileResponse) SetAsyncTaskId(v string) *RestoreFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *RestoreFileResponse) SetDomainId(v string) *RestoreFileResponse {
	s.DomainId = &v
	return s
}

func (s *RestoreFileResponse) SetDriveId(v string) *RestoreFileResponse {
	s.DriveId = &v
	return s
}

func (s *RestoreFileResponse) SetFileId(v string) *RestoreFileResponse {
	s.FileId = &v
	return s
}

/**
 *
 */
type RevokeRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// refresh token, 
	RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty" require:"true"`
}

func (s RevokeRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeRequest) GoString() string {
	return s.String()
}

func (s *RevokeRequest) SetHttpheaders(v map[string]*string) *RevokeRequest {
	s.Httpheaders = v
	return s
}

func (s *RevokeRequest) SetAppId(v string) *RevokeRequest {
	s.AppId = &v
	return s
}

func (s *RevokeRequest) SetRefreshToken(v string) *RevokeRequest {
	s.RefreshToken = &v
	return s
}

/**
 * OSS Sha1 gitlab.alibaba-inc.com/oss/parallel_hash.go OSSSha1Digest
type OSSSha1Digest struct {
h   [5]uint32         // hsha1Sha1Sha1
x   [BlockSize]byte   // 6464
nx  int               // 64640
len uint64            //  OSSRequestSha1Ctx Nl, Nh
}

SHA1CTX  OSSSha1Digest 
Sha164nx0x0hlenpart_offsetOSSSha1Digestlen
*/
type SHA1CTX struct {
	H          []*int `json:"h,omitempty" xml:"h,omitempty" type:"Repeated"`
	PartOffset *int64 `json:"part_offset,omitempty" xml:"part_offset,omitempty"`
}

func (s SHA1CTX) String() string {
	return tea.Prettify(s)
}

func (s SHA1CTX) GoString() string {
	return s.String()
}

func (s *SHA1CTX) SetH(v []*int) *SHA1CTX {
	s.H = v
	return s
}

func (s *SHA1CTX) SetPartOffset(v int64) *SHA1CTX {
	s.PartOffset = &v
	return s
}

/**
 * filebody
 */
type ScanFileMetaRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"5000" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ScanFileMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s ScanFileMetaRequest) GoString() string {
	return s.String()
}

func (s *ScanFileMetaRequest) SetHttpheaders(v map[string]*string) *ScanFileMetaRequest {
	s.Httpheaders = v
	return s
}

func (s *ScanFileMetaRequest) SetAdditionData(v map[string]interface{}) *ScanFileMetaRequest {
	s.AdditionData = v
	return s
}

func (s *ScanFileMetaRequest) SetCategory(v string) *ScanFileMetaRequest {
	s.Category = &v
	return s
}

func (s *ScanFileMetaRequest) SetDriveId(v string) *ScanFileMetaRequest {
	s.DriveId = &v
	return s
}

func (s *ScanFileMetaRequest) SetFields(v string) *ScanFileMetaRequest {
	s.Fields = &v
	return s
}

func (s *ScanFileMetaRequest) SetImageCroppingAspectRatios(v []*string) *ScanFileMetaRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *ScanFileMetaRequest) SetImageThumbnailProcess(v string) *ScanFileMetaRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ScanFileMetaRequest) SetImageUrlProcess(v string) *ScanFileMetaRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ScanFileMetaRequest) SetLimit(v int32) *ScanFileMetaRequest {
	s.Limit = &v
	return s
}

func (s *ScanFileMetaRequest) SetMarker(v string) *ScanFileMetaRequest {
	s.Marker = &v
	return s
}

func (s *ScanFileMetaRequest) SetOfficeThumbnailProcess(v string) *ScanFileMetaRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ScanFileMetaRequest) SetVideoThumbnailProcess(v string) *ScanFileMetaRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * scan file meta response
 */
type ScanFileMetaResponse struct {
	// items
	Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ScanFileMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s ScanFileMetaResponse) GoString() string {
	return s.String()
}

func (s *ScanFileMetaResponse) SetItems(v []*BaseCCPFileResponse) *ScanFileMetaResponse {
	s.Items = v
	return s
}

func (s *ScanFileMetaResponse) SetNextMarker(v string) *ScanFileMetaResponse {
	s.NextMarker = &v
	return s
}

/**
 * search domain request
 */
type SearchDomainsRequest struct {
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// domain
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// 
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
}

func (s SearchDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchDomainsRequest) GoString() string {
	return s.String()
}

func (s *SearchDomainsRequest) SetLimit(v int32) *SearchDomainsRequest {
	s.Limit = &v
	return s
}

func (s *SearchDomainsRequest) SetMarker(v string) *SearchDomainsRequest {
	s.Marker = &v
	return s
}

func (s *SearchDomainsRequest) SetName(v string) *SearchDomainsRequest {
	s.Name = &v
	return s
}

func (s *SearchDomainsRequest) SetOrderBy(v string) *SearchDomainsRequest {
	s.OrderBy = &v
	return s
}

/**
 * Search drive request
 */
type SearchDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// Drive Fuzz Name
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty" require:"true"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// , 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner_type
	// 
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s SearchDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchDriveRequest) GoString() string {
	return s.String()
}

func (s *SearchDriveRequest) SetHttpheaders(v map[string]*string) *SearchDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchDriveRequest) SetDriveName(v string) *SearchDriveRequest {
	s.DriveName = &v
	return s
}

func (s *SearchDriveRequest) SetLimit(v int32) *SearchDriveRequest {
	s.Limit = &v
	return s
}

func (s *SearchDriveRequest) SetMarker(v string) *SearchDriveRequest {
	s.Marker = &v
	return s
}

func (s *SearchDriveRequest) SetOwner(v string) *SearchDriveRequest {
	s.Owner = &v
	return s
}

func (s *SearchDriveRequest) SetOwnerType(v string) *SearchDriveRequest {
	s.OwnerType = &v
	return s
}

func (s *SearchDriveRequest) SetSubdomainId(v string) *SearchDriveRequest {
	s.SubdomainId = &v
	return s
}

/**
 * search drive response
 */
type SearchDriveResponse struct {
	// Drive 
	Items []*BaseDriveResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s SearchDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchDriveResponse) GoString() string {
	return s.String()
}

func (s *SearchDriveResponse) SetItems(v []*BaseDriveResponse) *SearchDriveResponse {
	s.Items = v
	return s
}

func (s *SearchDriveResponse) SetNextMarker(v string) *SearchDriveResponse {
	s.NextMarker = &v
	return s
}

/**
 * search file request
 */
type SearchFileFpRefsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
	// file_revision_id
	FileRevisionId *string `json:"file_revision_id,omitempty" xml:"file_revision_id,omitempty" require:"true"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s SearchFileFpRefsRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchFileFpRefsRequest) GoString() string {
	return s.String()
}

func (s *SearchFileFpRefsRequest) SetHttpheaders(v map[string]*string) *SearchFileFpRefsRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchFileFpRefsRequest) SetDriveId(v string) *SearchFileFpRefsRequest {
	s.DriveId = &v
	return s
}

func (s *SearchFileFpRefsRequest) SetFileId(v string) *SearchFileFpRefsRequest {
	s.FileId = &v
	return s
}

func (s *SearchFileFpRefsRequest) SetFileRevisionId(v string) *SearchFileFpRefsRequest {
	s.FileRevisionId = &v
	return s
}

func (s *SearchFileFpRefsRequest) SetMarker(v string) *SearchFileFpRefsRequest {
	s.Marker = &v
	return s
}

/**
 * search file response
 */
type SearchFileFpRefsResponse struct {
	Items      []*FpRef `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string  `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s SearchFileFpRefsResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchFileFpRefsResponse) GoString() string {
	return s.String()
}

func (s *SearchFileFpRefsResponse) SetItems(v []*FpRef) *SearchFileFpRefsResponse {
	s.Items = v
	return s
}

func (s *SearchFileFpRefsResponse) SetNextMarker(v string) *SearchFileFpRefsResponse {
	s.NextMarker = &v
	return s
}

/**
 * 
 */
type SearchFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// drive_ids
	DriveIdList               []*string `json:"drive_id_list,omitempty" xml:"drive_id_list,omitempty" type:"Repeated"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// Marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
	// referer
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// return_total_count 
	ReturnTotalCount *bool `json:"return_total_count,omitempty" xml:"return_total_count,omitempty"`
	// sign_token
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s SearchFileRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchFileRequest) GoString() string {
	return s.String()
}

func (s *SearchFileRequest) SetHttpheaders(v map[string]*string) *SearchFileRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchFileRequest) SetAdditionData(v map[string]interface{}) *SearchFileRequest {
	s.AdditionData = v
	return s
}

func (s *SearchFileRequest) SetDriveId(v string) *SearchFileRequest {
	s.DriveId = &v
	return s
}

func (s *SearchFileRequest) SetDriveIdList(v []*string) *SearchFileRequest {
	s.DriveIdList = v
	return s
}

func (s *SearchFileRequest) SetImageCroppingAspectRatios(v []*string) *SearchFileRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *SearchFileRequest) SetImageThumbnailProcess(v string) *SearchFileRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *SearchFileRequest) SetImageUrlProcess(v string) *SearchFileRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *SearchFileRequest) SetLimit(v int32) *SearchFileRequest {
	s.Limit = &v
	return s
}

func (s *SearchFileRequest) SetLocation(v string) *SearchFileRequest {
	s.Location = &v
	return s
}

func (s *SearchFileRequest) SetMarker(v string) *SearchFileRequest {
	s.Marker = &v
	return s
}

func (s *SearchFileRequest) SetOfficeThumbnailProcess(v string) *SearchFileRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *SearchFileRequest) SetOrderBy(v string) *SearchFileRequest {
	s.OrderBy = &v
	return s
}

func (s *SearchFileRequest) SetQuery(v string) *SearchFileRequest {
	s.Query = &v
	return s
}

func (s *SearchFileRequest) SetReferer(v string) *SearchFileRequest {
	s.Referer = &v
	return s
}

func (s *SearchFileRequest) SetReturnTotalCount(v bool) *SearchFileRequest {
	s.ReturnTotalCount = &v
	return s
}

func (s *SearchFileRequest) SetSignToken(v string) *SearchFileRequest {
	s.SignToken = &v
	return s
}

func (s *SearchFileRequest) SetUrlExpireSec(v int64) *SearchFileRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *SearchFileRequest) SetVideoThumbnailProcess(v string) *SearchFileRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * search file response
 */
type SearchFileResponse struct {
	// items
	Items []*BaseCCPFileResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	// total_count
	TotalCount *int64 `json:"total_count,omitempty" xml:"total_count,omitempty"`
}

func (s SearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchFileResponse) GoString() string {
	return s.String()
}

func (s *SearchFileResponse) SetItems(v []*BaseCCPFileResponse) *SearchFileResponse {
	s.Items = v
	return s
}

func (s *SearchFileResponse) SetNextMarker(v string) *SearchFileResponse {
	s.NextMarker = &v
	return s
}

func (s *SearchFileResponse) SetTotalCount(v int64) *SearchFileResponse {
	s.TotalCount = &v
	return s
}

/**
 * search_share_link request
 */
type SearchShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// creators
	// type: string
	Creators []*string `json:"creators,omitempty" xml:"creators,omitempty" type:"Repeated"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
	// return_total_count 
	ReturnTotalCount *bool `json:"return_total_count,omitempty" xml:"return_total_count,omitempty"`
}

func (s SearchShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchShareLinkRequest) GoString() string {
	return s.String()
}

func (s *SearchShareLinkRequest) SetHttpheaders(v map[string]*string) *SearchShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchShareLinkRequest) SetCreators(v []*string) *SearchShareLinkRequest {
	s.Creators = v
	return s
}

func (s *SearchShareLinkRequest) SetLimit(v int32) *SearchShareLinkRequest {
	s.Limit = &v
	return s
}

func (s *SearchShareLinkRequest) SetMarker(v string) *SearchShareLinkRequest {
	s.Marker = &v
	return s
}

func (s *SearchShareLinkRequest) SetOrderBy(v string) *SearchShareLinkRequest {
	s.OrderBy = &v
	return s
}

func (s *SearchShareLinkRequest) SetOrderDirection(v string) *SearchShareLinkRequest {
	s.OrderDirection = &v
	return s
}

func (s *SearchShareLinkRequest) SetQuery(v string) *SearchShareLinkRequest {
	s.Query = &v
	return s
}

func (s *SearchShareLinkRequest) SetReturnTotalCount(v bool) *SearchShareLinkRequest {
	s.ReturnTotalCount = &v
	return s
}

/**
 * search_share_link response
 */
type SearchShareLinkResponse struct {
	// items
	Items []*BaseShareLinkResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	// total_count
	TotalCount *int64 `json:"total_count,omitempty" xml:"total_count,omitempty"`
}

func (s SearchShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchShareLinkResponse) GoString() string {
	return s.String()
}

func (s *SearchShareLinkResponse) SetItems(v []*BaseShareLinkResponse) *SearchShareLinkResponse {
	s.Items = v
	return s
}

func (s *SearchShareLinkResponse) SetNextMarker(v string) *SearchShareLinkResponse {
	s.NextMarker = &v
	return s
}

func (s *SearchShareLinkResponse) SetTotalCount(v int64) *SearchShareLinkResponse {
	s.TotalCount = &v
	return s
}

/**
 *
 */
type SendSmsCodeRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// ID
	CaptchaId *string `json:"captcha_id,omitempty" xml:"captcha_id,omitempty"`
	// 
	CaptchaText *string `json:"captcha_text,omitempty" xml:"captcha_text,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NvcParam *string `json:"nvc_param,omitempty" xml:"nvc_param,omitempty" require:"true"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	// , : loginregisterchange_password
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s SendSmsCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s SendSmsCodeRequest) GoString() string {
	return s.String()
}

func (s *SendSmsCodeRequest) SetHttpheaders(v map[string]*string) *SendSmsCodeRequest {
	s.Httpheaders = v
	return s
}

func (s *SendSmsCodeRequest) SetAppId(v string) *SendSmsCodeRequest {
	s.AppId = &v
	return s
}

func (s *SendSmsCodeRequest) SetCaptchaId(v string) *SendSmsCodeRequest {
	s.CaptchaId = &v
	return s
}

func (s *SendSmsCodeRequest) SetCaptchaText(v string) *SendSmsCodeRequest {
	s.CaptchaText = &v
	return s
}

func (s *SendSmsCodeRequest) SetEmail(v string) *SendSmsCodeRequest {
	s.Email = &v
	return s
}

func (s *SendSmsCodeRequest) SetNvcParam(v string) *SendSmsCodeRequest {
	s.NvcParam = &v
	return s
}

func (s *SendSmsCodeRequest) SetPhoneNumber(v string) *SendSmsCodeRequest {
	s.PhoneNumber = &v
	return s
}

func (s *SendSmsCodeRequest) SetPhoneRegion(v string) *SendSmsCodeRequest {
	s.PhoneRegion = &v
	return s
}

func (s *SendSmsCodeRequest) SetType(v string) *SendSmsCodeRequest {
	s.Type = &v
	return s
}

/**
 *
 */
type SendSmsCodeResponse struct {
	// ID
	SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
}

func (s SendSmsCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s SendSmsCodeResponse) GoString() string {
	return s.String()
}

func (s *SendSmsCodeResponse) SetSmsCodeId(v string) *SendSmsCodeResponse {
	s.SmsCodeId = &v
	return s
}

/**
 *
 */
type SetAppPublicKeyRequest struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// RSA, PEM
	PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s SetAppPublicKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s SetAppPublicKeyRequest) GoString() string {
	return s.String()
}

func (s *SetAppPublicKeyRequest) SetAppId(v string) *SetAppPublicKeyRequest {
	s.AppId = &v
	return s
}

func (s *SetAppPublicKeyRequest) SetPublicKey(v string) *SetAppPublicKeyRequest {
	s.PublicKey = &v
	return s
}

/**
 *
 */
type SetBizCNameCertRequest struct {
	CertID *string `json:"CertID,omitempty" xml:"CertID,omitempty"`
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert body
	CertBody *string `json:"cert_body,omitempty" xml:"cert_body,omitempty" require:"true"`
	// cert name
	CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty" require:"true"`
	// cert privatekey
	CertPrivatekey *string `json:"cert_privatekey,omitempty" xml:"cert_privatekey,omitempty" require:"true"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// biz cname
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameCertRequest) String() string {
	return tea.Prettify(s)
}

func (s SetBizCNameCertRequest) GoString() string {
	return s.String()
}

func (s *SetBizCNameCertRequest) SetCertID(v string) *SetBizCNameCertRequest {
	s.CertID = &v
	return s
}

func (s *SetBizCNameCertRequest) SetBizCname(v string) *SetBizCNameCertRequest {
	s.BizCname = &v
	return s
}

func (s *SetBizCNameCertRequest) SetCertBody(v string) *SetBizCNameCertRequest {
	s.CertBody = &v
	return s
}

func (s *SetBizCNameCertRequest) SetCertName(v string) *SetBizCNameCertRequest {
	s.CertName = &v
	return s
}

func (s *SetBizCNameCertRequest) SetCertPrivatekey(v string) *SetBizCNameCertRequest {
	s.CertPrivatekey = &v
	return s
}

func (s *SetBizCNameCertRequest) SetCnameType(v string) *SetBizCNameCertRequest {
	s.CnameType = &v
	return s
}

func (s *SetBizCNameCertRequest) SetDomainId(v string) *SetBizCNameCertRequest {
	s.DomainId = &v
	return s
}

func (s *SetBizCNameCertRequest) SetIsVpc(v bool) *SetBizCNameCertRequest {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type SetBizCNameRequest struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty" require:"true"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// biz cname
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SetBizCNameRequest) GoString() string {
	return s.String()
}

func (s *SetBizCNameRequest) SetBizCname(v string) *SetBizCNameRequest {
	s.BizCname = &v
	return s
}

func (s *SetBizCNameRequest) SetCnameType(v string) *SetBizCNameRequest {
	s.CnameType = &v
	return s
}

func (s *SetBizCNameRequest) SetDomainId(v string) *SetBizCNameRequest {
	s.DomainId = &v
	return s
}

func (s *SetBizCNameRequest) SetIsVpc(v bool) *SetBizCNameRequest {
	s.IsVpc = &v
	return s
}

/**
 * list cors rule request
 */
type SetCorsRuleListRequest struct {
	// cors rule list
	CorsRuleList []*CorsRule `json:"cors_rule_list,omitempty" xml:"cors_rule_list,omitempty" require:"true" type:"Repeated"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s SetCorsRuleListRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCorsRuleListRequest) GoString() string {
	return s.String()
}

func (s *SetCorsRuleListRequest) SetCorsRuleList(v []*CorsRule) *SetCorsRuleListRequest {
	s.CorsRuleList = v
	return s
}

func (s *SetCorsRuleListRequest) SetDomainId(v string) *SetCorsRuleListRequest {
	s.DomainId = &v
	return s
}

/**
 *
 */
type SetDataCNameRequest struct {
	// cn-shanghai data cname
	DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s SetDataCNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDataCNameRequest) GoString() string {
	return s.String()
}

func (s *SetDataCNameRequest) SetDataCname(v string) *SetDataCNameRequest {
	s.DataCname = &v
	return s
}

func (s *SetDataCNameRequest) SetDomainId(v string) *SetDataCNameRequest {
	s.DomainId = &v
	return s
}

func (s *SetDataCNameRequest) SetLocation(v string) *SetDataCNameRequest {
	s.Location = &v
	return s
}

/**
 *
 */
type SetShareLinkStatusRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// enabled
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty" require:"true"`
}

func (s SetShareLinkStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetShareLinkStatusRequest) GoString() string {
	return s.String()
}

func (s *SetShareLinkStatusRequest) SetDomainId(v string) *SetShareLinkStatusRequest {
	s.DomainId = &v
	return s
}

func (s *SetShareLinkStatusRequest) SetEnabled(v bool) *SetShareLinkStatusRequest {
	s.Enabled = &v
	return s
}

/**
 *
 */
type SetShareStatusRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// enabled
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty" require:"true"`
}

func (s SetShareStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetShareStatusRequest) GoString() string {
	return s.String()
}

func (s *SetShareStatusRequest) SetDomainId(v string) *SetShareStatusRequest {
	s.DomainId = &v
	return s
}

func (s *SetShareStatusRequest) SetEnabled(v bool) *SetShareStatusRequest {
	s.Enabled = &v
	return s
}

/**
 *
 */
type ShareFile struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s ShareFile) String() string {
	return tea.Prettify(s)
}

func (s ShareFile) GoString() string {
	return s.String()
}

func (s *ShareFile) SetDriveId(v string) *ShareFile {
	s.DriveId = &v
	return s
}

func (s *ShareFile) SetFileId(v string) *ShareFile {
	s.FileId = &v
	return s
}

/**
 *
 */
type ShareLinkCountResponse struct {
	// access_count
	AccessCount *int64 `json:"access_count,omitempty" xml:"access_count,omitempty"`
	// 
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// 
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
}

func (s ShareLinkCountResponse) String() string {
	return tea.Prettify(s)
}

func (s ShareLinkCountResponse) GoString() string {
	return s.String()
}

func (s *ShareLinkCountResponse) SetAccessCount(v int64) *ShareLinkCountResponse {
	s.AccessCount = &v
	return s
}

func (s *ShareLinkCountResponse) SetDownloadCount(v int64) *ShareLinkCountResponse {
	s.DownloadCount = &v
	return s
}

func (s *ShareLinkCountResponse) SetPreviewCount(v int64) *ShareLinkCountResponse {
	s.PreviewCount = &v
	return s
}

func (s *ShareLinkCountResponse) SetReportCount(v int64) *ShareLinkCountResponse {
	s.ReportCount = &v
	return s
}

func (s *ShareLinkCountResponse) SetSaveCount(v int64) *ShareLinkCountResponse {
	s.SaveCount = &v
	return s
}

func (s *ShareLinkCountResponse) SetVideoPreviewCount(v int64) *ShareLinkCountResponse {
	s.VideoPreviewCount = &v
	return s
}

/**
 *
 */
type ShareLinkPermissionResponse struct {
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
}

func (s ShareLinkPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s ShareLinkPermissionResponse) GoString() string {
	return s.String()
}

func (s *ShareLinkPermissionResponse) SetDisableDownload(v bool) *ShareLinkPermissionResponse {
	s.DisableDownload = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetDisablePreview(v bool) *ShareLinkPermissionResponse {
	s.DisablePreview = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetDisableSave(v bool) *ShareLinkPermissionResponse {
	s.DisableSave = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetDownloadLimit(v int64) *ShareLinkPermissionResponse {
	s.DownloadLimit = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetPreviewLimit(v int64) *ShareLinkPermissionResponse {
	s.PreviewLimit = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetRequireLogin(v bool) *ShareLinkPermissionResponse {
	s.RequireLogin = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetSaveDownloadLimit(v int64) *ShareLinkPermissionResponse {
	s.SaveDownloadLimit = &v
	return s
}

func (s *ShareLinkPermissionResponse) SetSaveLimit(v int64) *ShareLinkPermissionResponse {
	s.SaveLimit = &v
	return s
}

/**
 *
 */
type SharePermissionPolicy struct {
	FileId                *string   `json:"file_id,omitempty" xml:"file_id,omitempty"`
	FilePath              *string   `json:"file_path,omitempty" xml:"file_path,omitempty"`
	PermissionInheritable *bool     `json:"permission_inheritable,omitempty" xml:"permission_inheritable,omitempty"`
	PermissionList        []*string `json:"permission_list,omitempty" xml:"permission_list,omitempty" type:"Repeated"`
	PermissionType        *string   `json:"permission_type,omitempty" xml:"permission_type,omitempty"`
}

func (s SharePermissionPolicy) String() string {
	return tea.Prettify(s)
}

func (s SharePermissionPolicy) GoString() string {
	return s.String()
}

func (s *SharePermissionPolicy) SetFileId(v string) *SharePermissionPolicy {
	s.FileId = &v
	return s
}

func (s *SharePermissionPolicy) SetFilePath(v string) *SharePermissionPolicy {
	s.FilePath = &v
	return s
}

func (s *SharePermissionPolicy) SetPermissionInheritable(v bool) *SharePermissionPolicy {
	s.PermissionInheritable = &v
	return s
}

func (s *SharePermissionPolicy) SetPermissionList(v []*string) *SharePermissionPolicy {
	s.PermissionList = v
	return s
}

func (s *SharePermissionPolicy) SetPermissionType(v string) *SharePermissionPolicy {
	s.PermissionType = &v
	return s
}

/**
 *
 */
type SignatureInfo struct {
	Bucket                *string                `json:"bucket,omitempty" xml:"bucket,omitempty"`
	CanonicalizedResource *string                `json:"canonicalized_resource,omitempty" xml:"canonicalized_resource,omitempty"`
	Endpoint              *string                `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	Headers               map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
	ObjectKey             *string                `json:"object_key,omitempty" xml:"object_key,omitempty"`
	Signature             *string                `json:"signature,omitempty" xml:"signature,omitempty"`
	StrToSign             *string                `json:"str_to_sign,omitempty" xml:"str_to_sign,omitempty"`
}

func (s SignatureInfo) String() string {
	return tea.Prettify(s)
}

func (s SignatureInfo) GoString() string {
	return s.String()
}

func (s *SignatureInfo) SetBucket(v string) *SignatureInfo {
	s.Bucket = &v
	return s
}

func (s *SignatureInfo) SetCanonicalizedResource(v string) *SignatureInfo {
	s.CanonicalizedResource = &v
	return s
}

func (s *SignatureInfo) SetEndpoint(v string) *SignatureInfo {
	s.Endpoint = &v
	return s
}

func (s *SignatureInfo) SetHeaders(v map[string]interface{}) *SignatureInfo {
	s.Headers = v
	return s
}

func (s *SignatureInfo) SetObjectKey(v string) *SignatureInfo {
	s.ObjectKey = &v
	return s
}

func (s *SignatureInfo) SetSignature(v string) *SignatureInfo {
	s.Signature = &v
	return s
}

func (s *SignatureInfo) SetStrToSign(v string) *SignatureInfo {
	s.StrToSign = &v
	return s
}

/**
 *
 */
type SimpleStreamInfo struct {
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s SimpleStreamInfo) String() string {
	return tea.Prettify(s)
}

func (s SimpleStreamInfo) GoString() string {
	return s.String()
}

func (s *SimpleStreamInfo) SetCrc64Hash(v string) *SimpleStreamInfo {
	s.Crc64Hash = &v
	return s
}

func (s *SimpleStreamInfo) SetDownloadUrl(v string) *SimpleStreamInfo {
	s.DownloadUrl = &v
	return s
}

func (s *SimpleStreamInfo) SetSize(v int64) *SimpleStreamInfo {
	s.Size = &v
	return s
}

func (s *SimpleStreamInfo) SetThumbnail(v string) *SimpleStreamInfo {
	s.Thumbnail = &v
	return s
}

func (s *SimpleStreamInfo) SetUrl(v string) *SimpleStreamInfo {
	s.Url = &v
	return s
}

/**
 *
 */
type Store struct {
	// 
	AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
	// 
	BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
	// bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
	// 
	CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
	// CDNkey
	CdnUrlAuthKey *string `json:"cdn_url_auth_key,omitempty" xml:"cdn_url_auth_key,omitempty"`
	// 
	CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
	// 
	CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
	// Public
	CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
	// vpc
	CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
	// Public
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
	// vpc
	InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
	// 
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// systemcustom
	Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
	// Policy,systemstorebucket
	Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
	// BucketARN
	RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
	// store ID
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
	// oss
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s Store) String() string {
	return tea.Prettify(s)
}

func (s Store) GoString() string {
	return s.String()
}

func (s *Store) SetAccelerateEndpoint(v string) *Store {
	s.AccelerateEndpoint = &v
	return s
}

func (s *Store) SetBasePath(v string) *Store {
	s.BasePath = &v
	return s
}

func (s *Store) SetBucket(v string) *Store {
	s.Bucket = &v
	return s
}

func (s *Store) SetCdnEndpoint(v string) *Store {
	s.CdnEndpoint = &v
	return s
}

func (s *Store) SetCdnUrlAuthKey(v string) *Store {
	s.CdnUrlAuthKey = &v
	return s
}

func (s *Store) SetCustomizedAccelerateEndpoint(v string) *Store {
	s.CustomizedAccelerateEndpoint = &v
	return s
}

func (s *Store) SetCustomizedCdnEndpoint(v string) *Store {
	s.CustomizedCdnEndpoint = &v
	return s
}

func (s *Store) SetCustomizedEndpoint(v string) *Store {
	s.CustomizedEndpoint = &v
	return s
}

func (s *Store) SetCustomizedInternalEndpoint(v string) *Store {
	s.CustomizedInternalEndpoint = &v
	return s
}

func (s *Store) SetEndpoint(v string) *Store {
	s.Endpoint = &v
	return s
}

func (s *Store) SetInternalEndpoint(v string) *Store {
	s.InternalEndpoint = &v
	return s
}

func (s *Store) SetLocation(v string) *Store {
	s.Location = &v
	return s
}

func (s *Store) SetOwnership(v string) *Store {
	s.Ownership = &v
	return s
}

func (s *Store) SetPolicy(v string) *Store {
	s.Policy = &v
	return s
}

func (s *Store) SetRoleArn(v string) *Store {
	s.RoleArn = &v
	return s
}

func (s *Store) SetStoreId(v string) *Store {
	s.StoreId = &v
	return s
}

func (s *Store) SetType(v string) *Store {
	s.Type = &v
	return s
}

/**
 *
 */
type StoreFile struct {
	DomainId       *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	Name           *string `json:"name,omitempty" xml:"name,omitempty"`
	ParentFilePath *string `json:"parent_file_path,omitempty" xml:"parent_file_path,omitempty"`
	StoreId        *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	Type           *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s StoreFile) String() string {
	return tea.Prettify(s)
}

func (s StoreFile) GoString() string {
	return s.String()
}

func (s *StoreFile) SetDomainId(v string) *StoreFile {
	s.DomainId = &v
	return s
}

func (s *StoreFile) SetName(v string) *StoreFile {
	s.Name = &v
	return s
}

func (s *StoreFile) SetParentFilePath(v string) *StoreFile {
	s.ParentFilePath = &v
	return s
}

func (s *StoreFile) SetStoreId(v string) *StoreFile {
	s.StoreId = &v
	return s
}

func (s *StoreFile) SetType(v string) *StoreFile {
	s.Type = &v
	return s
}

/**
 *
 */
type StoreItemResponse struct {
	// 
	AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
	// 
	BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
	// bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
	// 
	CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
	// CDNkey
	CdnUrlAuthKey *string `json:"cdn_url_auth_key,omitempty" xml:"cdn_url_auth_key,omitempty"`
	// 
	CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
	// 
	CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
	// Public
	CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
	// vpc
	CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
	DomainId                   *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Public
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
	// vpc
	InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
	// 
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// systemcustom
	Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
	// Policy,systemstorebucket
	Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
	// BucketARN
	RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
	// store ID
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
	// oss
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s StoreItemResponse) String() string {
	return tea.Prettify(s)
}

func (s StoreItemResponse) GoString() string {
	return s.String()
}

func (s *StoreItemResponse) SetAccelerateEndpoint(v string) *StoreItemResponse {
	s.AccelerateEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetBasePath(v string) *StoreItemResponse {
	s.BasePath = &v
	return s
}

func (s *StoreItemResponse) SetBucket(v string) *StoreItemResponse {
	s.Bucket = &v
	return s
}

func (s *StoreItemResponse) SetCdnEndpoint(v string) *StoreItemResponse {
	s.CdnEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetCdnUrlAuthKey(v string) *StoreItemResponse {
	s.CdnUrlAuthKey = &v
	return s
}

func (s *StoreItemResponse) SetCustomizedAccelerateEndpoint(v string) *StoreItemResponse {
	s.CustomizedAccelerateEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetCustomizedCdnEndpoint(v string) *StoreItemResponse {
	s.CustomizedCdnEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetCustomizedEndpoint(v string) *StoreItemResponse {
	s.CustomizedEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetCustomizedInternalEndpoint(v string) *StoreItemResponse {
	s.CustomizedInternalEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetDomainId(v string) *StoreItemResponse {
	s.DomainId = &v
	return s
}

func (s *StoreItemResponse) SetEndpoint(v string) *StoreItemResponse {
	s.Endpoint = &v
	return s
}

func (s *StoreItemResponse) SetInternalEndpoint(v string) *StoreItemResponse {
	s.InternalEndpoint = &v
	return s
}

func (s *StoreItemResponse) SetLocation(v string) *StoreItemResponse {
	s.Location = &v
	return s
}

func (s *StoreItemResponse) SetOwnership(v string) *StoreItemResponse {
	s.Ownership = &v
	return s
}

func (s *StoreItemResponse) SetPolicy(v string) *StoreItemResponse {
	s.Policy = &v
	return s
}

func (s *StoreItemResponse) SetRoleArn(v string) *StoreItemResponse {
	s.RoleArn = &v
	return s
}

func (s *StoreItemResponse) SetStoreId(v string) *StoreItemResponse {
	s.StoreId = &v
	return s
}

func (s *StoreItemResponse) SetType(v string) *StoreItemResponse {
	s.Type = &v
	return s
}

/**
 *
 */
type StreamUploadInfo struct {
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// pre_rapid_upload
	// type: boolean
	PreRapidUpload *bool `json:"pre_rapid_upload,omitempty" xml:"pre_rapid_upload,omitempty"`
	// rapid_upload
	// type: boolean
	RapidUpload *bool `json:"rapid_upload,omitempty" xml:"rapid_upload,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s StreamUploadInfo) String() string {
	return tea.Prettify(s)
}

func (s StreamUploadInfo) GoString() string {
	return s.String()
}

func (s *StreamUploadInfo) SetLocation(v string) *StreamUploadInfo {
	s.Location = &v
	return s
}

func (s *StreamUploadInfo) SetPartInfoList(v []*UploadPartInfo) *StreamUploadInfo {
	s.PartInfoList = v
	return s
}

func (s *StreamUploadInfo) SetPreRapidUpload(v bool) *StreamUploadInfo {
	s.PreRapidUpload = &v
	return s
}

func (s *StreamUploadInfo) SetRapidUpload(v bool) *StreamUploadInfo {
	s.RapidUpload = &v
	return s
}

func (s *StreamUploadInfo) SetUploadId(v string) *StreamUploadInfo {
	s.UploadId = &v
	return s
}

/**
 *
 */
type SubdomainDeleteBizCNameAndCertRequest struct {
	// api cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainDeleteBizCNameAndCertRequest) String() string {
	return tea.Prettify(s)
}

func (s SubdomainDeleteBizCNameAndCertRequest) GoString() string {
	return s.String()
}

func (s *SubdomainDeleteBizCNameAndCertRequest) SetBizCname(v string) *SubdomainDeleteBizCNameAndCertRequest {
	s.BizCname = &v
	return s
}

func (s *SubdomainDeleteBizCNameAndCertRequest) SetCnameType(v string) *SubdomainDeleteBizCNameAndCertRequest {
	s.CnameType = &v
	return s
}

func (s *SubdomainDeleteBizCNameAndCertRequest) SetDomainId(v string) *SubdomainDeleteBizCNameAndCertRequest {
	s.DomainId = &v
	return s
}

func (s *SubdomainDeleteBizCNameAndCertRequest) SetIsVpc(v bool) *SubdomainDeleteBizCNameAndCertRequest {
	s.IsVpc = &v
	return s
}

func (s *SubdomainDeleteBizCNameAndCertRequest) SetSubdomainId(v string) *SubdomainDeleteBizCNameAndCertRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type SubdomainDeleteBizCNameCertRequest struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert id
	CertId *string `json:"cert_id,omitempty" xml:"cert_id,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainDeleteBizCNameCertRequest) String() string {
	return tea.Prettify(s)
}

func (s SubdomainDeleteBizCNameCertRequest) GoString() string {
	return s.String()
}

func (s *SubdomainDeleteBizCNameCertRequest) SetBizCname(v string) *SubdomainDeleteBizCNameCertRequest {
	s.BizCname = &v
	return s
}

func (s *SubdomainDeleteBizCNameCertRequest) SetCertId(v string) *SubdomainDeleteBizCNameCertRequest {
	s.CertId = &v
	return s
}

func (s *SubdomainDeleteBizCNameCertRequest) SetCnameType(v string) *SubdomainDeleteBizCNameCertRequest {
	s.CnameType = &v
	return s
}

func (s *SubdomainDeleteBizCNameCertRequest) SetDomainId(v string) *SubdomainDeleteBizCNameCertRequest {
	s.DomainId = &v
	return s
}

func (s *SubdomainDeleteBizCNameCertRequest) SetIsVpc(v bool) *SubdomainDeleteBizCNameCertRequest {
	s.IsVpc = &v
	return s
}

func (s *SubdomainDeleteBizCNameCertRequest) SetSubdomainId(v string) *SubdomainDeleteBizCNameCertRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type SubdomainGetBizCNameInfoRequest struct {
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainGetBizCNameInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s SubdomainGetBizCNameInfoRequest) GoString() string {
	return s.String()
}

func (s *SubdomainGetBizCNameInfoRequest) SetCnameType(v string) *SubdomainGetBizCNameInfoRequest {
	s.CnameType = &v
	return s
}

func (s *SubdomainGetBizCNameInfoRequest) SetDomainId(v string) *SubdomainGetBizCNameInfoRequest {
	s.DomainId = &v
	return s
}

func (s *SubdomainGetBizCNameInfoRequest) SetIsVpc(v bool) *SubdomainGetBizCNameInfoRequest {
	s.IsVpc = &v
	return s
}

func (s *SubdomainGetBizCNameInfoRequest) SetSubdomainId(v string) *SubdomainGetBizCNameInfoRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type SubdomainSetBizCNameCertRequest struct {
	CertID *string `json:"CertID,omitempty" xml:"CertID,omitempty"`
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert body
	CertBody *string `json:"cert_body,omitempty" xml:"cert_body,omitempty" require:"true"`
	// cert name
	CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty" require:"true"`
	// cert privatekey
	CertPrivatekey *string `json:"cert_privatekey,omitempty" xml:"cert_privatekey,omitempty" require:"true"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// biz cname
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainSetBizCNameCertRequest) String() string {
	return tea.Prettify(s)
}

func (s SubdomainSetBizCNameCertRequest) GoString() string {
	return s.String()
}

func (s *SubdomainSetBizCNameCertRequest) SetCertID(v string) *SubdomainSetBizCNameCertRequest {
	s.CertID = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetBizCname(v string) *SubdomainSetBizCNameCertRequest {
	s.BizCname = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetCertBody(v string) *SubdomainSetBizCNameCertRequest {
	s.CertBody = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetCertName(v string) *SubdomainSetBizCNameCertRequest {
	s.CertName = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetCertPrivatekey(v string) *SubdomainSetBizCNameCertRequest {
	s.CertPrivatekey = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetCnameType(v string) *SubdomainSetBizCNameCertRequest {
	s.CnameType = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetDomainId(v string) *SubdomainSetBizCNameCertRequest {
	s.DomainId = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetIsVpc(v bool) *SubdomainSetBizCNameCertRequest {
	s.IsVpc = &v
	return s
}

func (s *SubdomainSetBizCNameCertRequest) SetSubdomainId(v string) *SubdomainSetBizCNameCertRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type SubdomainSetBizCNameRequest struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty" require:"true"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// biz cname
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// domain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainSetBizCNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SubdomainSetBizCNameRequest) GoString() string {
	return s.String()
}

func (s *SubdomainSetBizCNameRequest) SetBizCname(v string) *SubdomainSetBizCNameRequest {
	s.BizCname = &v
	return s
}

func (s *SubdomainSetBizCNameRequest) SetCnameType(v string) *SubdomainSetBizCNameRequest {
	s.CnameType = &v
	return s
}

func (s *SubdomainSetBizCNameRequest) SetDomainId(v string) *SubdomainSetBizCNameRequest {
	s.DomainId = &v
	return s
}

func (s *SubdomainSetBizCNameRequest) SetIsVpc(v bool) *SubdomainSetBizCNameRequest {
	s.IsVpc = &v
	return s
}

func (s *SubdomainSetBizCNameRequest) SetSubdomainId(v string) *SubdomainSetBizCNameRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type SystemTag struct {
	CentricScore *float32 `json:"centric_score,omitempty" xml:"centric_score,omitempty"`
	Confidence   *float64 `json:"confidence,omitempty" xml:"confidence,omitempty"`
	EnName       *string  `json:"en_name,omitempty" xml:"en_name,omitempty"`
	Name         *string  `json:"name,omitempty" xml:"name,omitempty"`
	ParentEnName *string  `json:"parent_en_name,omitempty" xml:"parent_en_name,omitempty"`
	ParentName   *string  `json:"parent_name,omitempty" xml:"parent_name,omitempty"`
	Source       *string  `json:"source,omitempty" xml:"source,omitempty"`
	TagLevel     *int64   `json:"tag_level,omitempty" xml:"tag_level,omitempty"`
}

func (s SystemTag) String() string {
	return tea.Prettify(s)
}

func (s SystemTag) GoString() string {
	return s.String()
}

func (s *SystemTag) SetCentricScore(v float32) *SystemTag {
	s.CentricScore = &v
	return s
}

func (s *SystemTag) SetConfidence(v float64) *SystemTag {
	s.Confidence = &v
	return s
}

func (s *SystemTag) SetEnName(v string) *SystemTag {
	s.EnName = &v
	return s
}

func (s *SystemTag) SetName(v string) *SystemTag {
	s.Name = &v
	return s
}

func (s *SystemTag) SetParentEnName(v string) *SystemTag {
	s.ParentEnName = &v
	return s
}

func (s *SystemTag) SetParentName(v string) *SystemTag {
	s.ParentName = &v
	return s
}

func (s *SystemTag) SetSource(v string) *SystemTag {
	s.Source = &v
	return s
}

func (s *SystemTag) SetTagLevel(v int64) *SystemTag {
	s.TagLevel = &v
	return s
}

/**
 *
 */
type Target struct {
	// FileID
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// FileName
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
	// FileType
	FileType *string `json:"file_type,omitempty" xml:"file_type,omitempty"`
}

func (s Target) String() string {
	return tea.Prettify(s)
}

func (s Target) GoString() string {
	return s.String()
}

func (s *Target) SetFileId(v string) *Target {
	s.FileId = &v
	return s
}

func (s *Target) SetFileName(v string) *Target {
	s.FileName = &v
	return s
}

func (s *Target) SetFileType(v string) *Target {
	s.FileType = &v
	return s
}

/**
 *
 */
type TimeRange struct {
	// EndTime
	EndTime *string `json:"end_time,omitempty" xml:"end_time,omitempty"`
	// StartTime
	StartTime *string `json:"start_time,omitempty" xml:"start_time,omitempty"`
}

func (s TimeRange) String() string {
	return tea.Prettify(s)
}

func (s TimeRange) GoString() string {
	return s.String()
}

func (s *TimeRange) SetEndTime(v string) *TimeRange {
	s.EndTime = &v
	return s
}

func (s *TimeRange) SetStartTime(v string) *TimeRange {
	s.StartTime = &v
	return s
}

/**
 *
 */
type TokenRequest struct {
	// JWTJWTaccessToken
	Assertion *string `json:"Assertion,omitempty" xml:"Assertion,omitempty"`
	// Client ID, AppAppID
	ClientID *string `json:"ClientID,omitempty" xml:"ClientID,omitempty" require:"true"`
	// Client ID, AppAppSecret
	ClientSecret *string `json:"ClientSecret,omitempty" xml:"ClientSecret,omitempty" require:"true"`
	// code
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// OAuth2.0 device flowtoken
	DeviceCode *string `json:"DeviceCode,omitempty" xml:"DeviceCode,omitempty"`
	// codeaccessTokenrefresh_tokenaccessToken
	GrantType *string `json:"GrantType,omitempty" xml:"GrantType,omitempty" require:"true"`
	// , AppOAuth
	RedirectUri *string `json:"RedirectUri,omitempty" xml:"RedirectUri,omitempty"`
	// accessTokenrefreshToken
	RefreshToken *string `json:"RefreshToken,omitempty" xml:"RefreshToken,omitempty"`
	// SubDomainID
	SubDomainID *string `json:"SubDomainID,omitempty" xml:"SubDomainID,omitempty"`
}

func (s TokenRequest) String() string {
	return tea.Prettify(s)
}

func (s TokenRequest) GoString() string {
	return s.String()
}

func (s *TokenRequest) SetAssertion(v string) *TokenRequest {
	s.Assertion = &v
	return s
}

func (s *TokenRequest) SetClientID(v string) *TokenRequest {
	s.ClientID = &v
	return s
}

func (s *TokenRequest) SetClientSecret(v string) *TokenRequest {
	s.ClientSecret = &v
	return s
}

func (s *TokenRequest) SetCode(v string) *TokenRequest {
	s.Code = &v
	return s
}

func (s *TokenRequest) SetDeviceCode(v string) *TokenRequest {
	s.DeviceCode = &v
	return s
}

func (s *TokenRequest) SetGrantType(v string) *TokenRequest {
	s.GrantType = &v
	return s
}

func (s *TokenRequest) SetRedirectUri(v string) *TokenRequest {
	s.RedirectUri = &v
	return s
}

func (s *TokenRequest) SetRefreshToken(v string) *TokenRequest {
	s.RefreshToken = &v
	return s
}

func (s *TokenRequest) SetSubDomainID(v string) *TokenRequest {
	s.SubDomainID = &v
	return s
}

/**
 *
 */
type TrashDetail struct {
	// ParentFileID
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty"`
}

func (s TrashDetail) String() string {
	return tea.Prettify(s)
}

func (s TrashDetail) GoString() string {
	return s.String()
}

func (s *TrashDetail) SetParentFileId(v string) *TrashDetail {
	s.ParentFileId = &v
	return s
}

/**
 * 
 */
type TrashFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// share_id, either share_id or drive_id is required
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
}

func (s TrashFileRequest) String() string {
	return tea.Prettify(s)
}

func (s TrashFileRequest) GoString() string {
	return s.String()
}

func (s *TrashFileRequest) SetHttpheaders(v map[string]*string) *TrashFileRequest {
	s.Httpheaders = v
	return s
}

func (s *TrashFileRequest) SetDriveId(v string) *TrashFileRequest {
	s.DriveId = &v
	return s
}

func (s *TrashFileRequest) SetFileId(v string) *TrashFileRequest {
	s.FileId = &v
	return s
}

func (s *TrashFileRequest) SetShareId(v string) *TrashFileRequest {
	s.ShareId = &v
	return s
}

/**
 * response
 */
type TrashFileResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s TrashFileResponse) String() string {
	return tea.Prettify(s)
}

func (s TrashFileResponse) GoString() string {
	return s.String()
}

func (s *TrashFileResponse) SetAsyncTaskId(v string) *TrashFileResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *TrashFileResponse) SetDomainId(v string) *TrashFileResponse {
	s.DomainId = &v
	return s
}

func (s *TrashFileResponse) SetDriveId(v string) *TrashFileResponse {
	s.DriveId = &v
	return s
}

func (s *TrashFileResponse) SetFileId(v string) *TrashFileResponse {
	s.FileId = &v
	return s
}

/**
 * UCCompleteFileRequest complete with store exist
 */
type UCCompleteFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	ShareId      *string           `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s UCCompleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s UCCompleteFileRequest) GoString() string {
	return s.String()
}

func (s *UCCompleteFileRequest) SetHttpheaders(v map[string]*string) *UCCompleteFileRequest {
	s.Httpheaders = v
	return s
}

func (s *UCCompleteFileRequest) SetAdditionData(v map[string]interface{}) *UCCompleteFileRequest {
	s.AdditionData = v
	return s
}

func (s *UCCompleteFileRequest) SetDriveId(v string) *UCCompleteFileRequest {
	s.DriveId = &v
	return s
}

func (s *UCCompleteFileRequest) SetFileId(v string) *UCCompleteFileRequest {
	s.FileId = &v
	return s
}

func (s *UCCompleteFileRequest) SetPartInfoList(v []*UploadPartInfo) *UCCompleteFileRequest {
	s.PartInfoList = v
	return s
}

func (s *UCCompleteFileRequest) SetShareId(v string) *UCCompleteFileRequest {
	s.ShareId = &v
	return s
}

func (s *UCCompleteFileRequest) SetUploadId(v string) *UCCompleteFileRequest {
	s.UploadId = &v
	return s
}

/**
 * UCCompleteFileResponse
 */
type UCCompleteFileResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// bucket_name
	BucketName *string `json:"bucket_name,omitempty" xml:"bucket_name,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// endpoint
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// object_key
	ObjectKey *string `json:"object_key,omitempty" xml:"object_key,omitempty"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s UCCompleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s UCCompleteFileResponse) GoString() string {
	return s.String()
}

func (s *UCCompleteFileResponse) SetActionList(v []*string) *UCCompleteFileResponse {
	s.ActionList = v
	return s
}

func (s *UCCompleteFileResponse) SetAutoDeleteLeftSec(v int64) *UCCompleteFileResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *UCCompleteFileResponse) SetBucketName(v string) *UCCompleteFileResponse {
	s.BucketName = &v
	return s
}

func (s *UCCompleteFileResponse) SetCategory(v string) *UCCompleteFileResponse {
	s.Category = &v
	return s
}

func (s *UCCompleteFileResponse) SetCharacteristicHash(v string) *UCCompleteFileResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *UCCompleteFileResponse) SetContentHash(v string) *UCCompleteFileResponse {
	s.ContentHash = &v
	return s
}

func (s *UCCompleteFileResponse) SetContentHashName(v string) *UCCompleteFileResponse {
	s.ContentHashName = &v
	return s
}

func (s *UCCompleteFileResponse) SetContentType(v string) *UCCompleteFileResponse {
	s.ContentType = &v
	return s
}

func (s *UCCompleteFileResponse) SetCrc64Hash(v string) *UCCompleteFileResponse {
	s.Crc64Hash = &v
	return s
}

func (s *UCCompleteFileResponse) SetCreatedAt(v string) *UCCompleteFileResponse {
	s.CreatedAt = &v
	return s
}

func (s *UCCompleteFileResponse) SetCreatorId(v string) *UCCompleteFileResponse {
	s.CreatorId = &v
	return s
}

func (s *UCCompleteFileResponse) SetCreatorName(v string) *UCCompleteFileResponse {
	s.CreatorName = &v
	return s
}

func (s *UCCompleteFileResponse) SetCreatorType(v string) *UCCompleteFileResponse {
	s.CreatorType = &v
	return s
}

func (s *UCCompleteFileResponse) SetCustomField1(v string) *UCCompleteFileResponse {
	s.CustomField1 = &v
	return s
}

func (s *UCCompleteFileResponse) SetCustomField2(v string) *UCCompleteFileResponse {
	s.CustomField2 = &v
	return s
}

func (s *UCCompleteFileResponse) SetCustomType(v string) *UCCompleteFileResponse {
	s.CustomType = &v
	return s
}

func (s *UCCompleteFileResponse) SetDescription(v string) *UCCompleteFileResponse {
	s.Description = &v
	return s
}

func (s *UCCompleteFileResponse) SetDomainId(v string) *UCCompleteFileResponse {
	s.DomainId = &v
	return s
}

func (s *UCCompleteFileResponse) SetDownloadUrl(v string) *UCCompleteFileResponse {
	s.DownloadUrl = &v
	return s
}

func (s *UCCompleteFileResponse) SetDriveId(v string) *UCCompleteFileResponse {
	s.DriveId = &v
	return s
}

func (s *UCCompleteFileResponse) SetEncryptMode(v string) *UCCompleteFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *UCCompleteFileResponse) SetEndpoint(v string) *UCCompleteFileResponse {
	s.Endpoint = &v
	return s
}

func (s *UCCompleteFileResponse) SetExFieldsInfo(v map[string]interface{}) *UCCompleteFileResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *UCCompleteFileResponse) SetFileExtension(v string) *UCCompleteFileResponse {
	s.FileExtension = &v
	return s
}

func (s *UCCompleteFileResponse) SetFileId(v string) *UCCompleteFileResponse {
	s.FileId = &v
	return s
}

func (s *UCCompleteFileResponse) SetFilePathType(v string) *UCCompleteFileResponse {
	s.FilePathType = &v
	return s
}

func (s *UCCompleteFileResponse) SetHidden(v bool) *UCCompleteFileResponse {
	s.Hidden = &v
	return s
}

func (s *UCCompleteFileResponse) SetImageMediaMetadata(v *ImageMediaResponse) *UCCompleteFileResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *UCCompleteFileResponse) SetLabels(v []*string) *UCCompleteFileResponse {
	s.Labels = v
	return s
}

func (s *UCCompleteFileResponse) SetLastModifierId(v string) *UCCompleteFileResponse {
	s.LastModifierId = &v
	return s
}

func (s *UCCompleteFileResponse) SetLastModifierName(v string) *UCCompleteFileResponse {
	s.LastModifierName = &v
	return s
}

func (s *UCCompleteFileResponse) SetLastModifierType(v string) *UCCompleteFileResponse {
	s.LastModifierType = &v
	return s
}

func (s *UCCompleteFileResponse) SetLocalCreatedAt(v string) *UCCompleteFileResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *UCCompleteFileResponse) SetLocalModifiedAt(v string) *UCCompleteFileResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *UCCompleteFileResponse) SetMeta(v string) *UCCompleteFileResponse {
	s.Meta = &v
	return s
}

func (s *UCCompleteFileResponse) SetMimeExtension(v string) *UCCompleteFileResponse {
	s.MimeExtension = &v
	return s
}

func (s *UCCompleteFileResponse) SetMimeType(v string) *UCCompleteFileResponse {
	s.MimeType = &v
	return s
}

func (s *UCCompleteFileResponse) SetName(v string) *UCCompleteFileResponse {
	s.Name = &v
	return s
}

func (s *UCCompleteFileResponse) SetObjectKey(v string) *UCCompleteFileResponse {
	s.ObjectKey = &v
	return s
}

func (s *UCCompleteFileResponse) SetParentFileId(v string) *UCCompleteFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *UCCompleteFileResponse) SetPunishFlag(v int64) *UCCompleteFileResponse {
	s.PunishFlag = &v
	return s
}

func (s *UCCompleteFileResponse) SetRevisionId(v string) *UCCompleteFileResponse {
	s.RevisionId = &v
	return s
}

func (s *UCCompleteFileResponse) SetShareId(v string) *UCCompleteFileResponse {
	s.ShareId = &v
	return s
}

func (s *UCCompleteFileResponse) SetSize(v int64) *UCCompleteFileResponse {
	s.Size = &v
	return s
}

func (s *UCCompleteFileResponse) SetStarred(v bool) *UCCompleteFileResponse {
	s.Starred = &v
	return s
}

func (s *UCCompleteFileResponse) SetStatus(v string) *UCCompleteFileResponse {
	s.Status = &v
	return s
}

func (s *UCCompleteFileResponse) SetStreamsInfo(v map[string]interface{}) *UCCompleteFileResponse {
	s.StreamsInfo = v
	return s
}

func (s *UCCompleteFileResponse) SetSyncDeviceFlag(v bool) *UCCompleteFileResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *UCCompleteFileResponse) SetSyncFlag(v bool) *UCCompleteFileResponse {
	s.SyncFlag = &v
	return s
}

func (s *UCCompleteFileResponse) SetSyncMeta(v string) *UCCompleteFileResponse {
	s.SyncMeta = &v
	return s
}

func (s *UCCompleteFileResponse) SetThumbnail(v string) *UCCompleteFileResponse {
	s.Thumbnail = &v
	return s
}

func (s *UCCompleteFileResponse) SetTrashedAt(v string) *UCCompleteFileResponse {
	s.TrashedAt = &v
	return s
}

func (s *UCCompleteFileResponse) SetType(v string) *UCCompleteFileResponse {
	s.Type = &v
	return s
}

func (s *UCCompleteFileResponse) SetUpdatedAt(v string) *UCCompleteFileResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UCCompleteFileResponse) SetUploadId(v string) *UCCompleteFileResponse {
	s.UploadId = &v
	return s
}

func (s *UCCompleteFileResponse) SetUrl(v string) *UCCompleteFileResponse {
	s.Url = &v
	return s
}

func (s *UCCompleteFileResponse) SetUserMeta(v string) *UCCompleteFileResponse {
	s.UserMeta = &v
	return s
}

func (s *UCCompleteFileResponse) SetUserTags(v map[string]interface{}) *UCCompleteFileResponse {
	s.UserTags = v
	return s
}

func (s *UCCompleteFileResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *UCCompleteFileResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *UCCompleteFileResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *UCCompleteFileResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 * UCCreateFileRequest create file with signature
 */
type UCCreateFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	AutoRename   *bool                  `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
	Callback     *CcpCallback           `json:"callback,omitempty" xml:"callback,omitempty"`
	// check_name_mode
	CheckNameMode *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
	// content_hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_mutable
	ContentHashMutable *bool `json:"content_hash_mutable,omitempty" xml:"content_hash_mutable,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// ContentMd5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// ContentType
	ContentType  *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	CreateReason *string `json:"create_reason,omitempty" xml:"create_reason,omitempty"`
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	CustomType   *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// date
	Date *string `json:"date,omitempty" xml:"date,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024" minLength:"0"`
	// drive_id
	DriveId     *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// force_upload_to_location
	ForceUploadToLocation *bool `json:"force_upload_to_location,omitempty" xml:"force_upload_to_location,omitempty"`
	// headers
	Headers map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
	// hidden
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaMetadata `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_updated_at
	LastUpdatedAt *string `json:"last_updated_at,omitempty" xml:"last_updated_at,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	Meta     *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// Name
	Name                    *string `json:"name,omitempty" xml:"name,omitempty" require:"true" maxLength:"1024" minLength:"1"`
	NeedMergePeriodRevision *bool   `json:"need_merge_period_revision,omitempty" xml:"need_merge_period_revision,omitempty"`
	// overwrite
	Overwrite      *bool `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
	ParallelUpload *bool `json:"parallel_upload,omitempty" xml:"parallel_upload,omitempty"`
	// parameters
	Parameters map[string]interface{} `json:"parameters,omitempty" xml:"parameters,omitempty"`
	// parent_file_id
	ParentFileId     *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9]{1,50}"`
	ParentFileIdPath *string `json:"parent_file_id_path,omitempty" xml:"parent_file_id_path,omitempty"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// pre_hash
	PreHash *string `json:"pre_hash,omitempty" xml:"pre_hash,omitempty"`
	// proof_code
	ProofCode *string `json:"proof_code,omitempty" xml:"proof_code,omitempty"`
	// proof_version
	ProofVersion *string `json:"proof_version,omitempty" xml:"proof_version,omitempty"`
	// share_id
	// example
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// streams_info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// Type
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
	// upload_type
	UploadType *string `json:"upload_type,omitempty" xml:"upload_type,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags           []*UserTag          `json:"user_tags,omitempty" xml:"user_tags,omitempty" type:"Repeated"`
	VideoMediaMetadata *VideoMediaMetadata `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
}

func (s UCCreateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s UCCreateFileRequest) GoString() string {
	return s.String()
}

func (s *UCCreateFileRequest) SetHttpheaders(v map[string]*string) *UCCreateFileRequest {
	s.Httpheaders = v
	return s
}

func (s *UCCreateFileRequest) SetAdditionData(v map[string]interface{}) *UCCreateFileRequest {
	s.AdditionData = v
	return s
}

func (s *UCCreateFileRequest) SetAutoRename(v bool) *UCCreateFileRequest {
	s.AutoRename = &v
	return s
}

func (s *UCCreateFileRequest) SetCallback(v *CcpCallback) *UCCreateFileRequest {
	s.Callback = v
	return s
}

func (s *UCCreateFileRequest) SetCheckNameMode(v string) *UCCreateFileRequest {
	s.CheckNameMode = &v
	return s
}

func (s *UCCreateFileRequest) SetContentHash(v string) *UCCreateFileRequest {
	s.ContentHash = &v
	return s
}

func (s *UCCreateFileRequest) SetContentHashMutable(v bool) *UCCreateFileRequest {
	s.ContentHashMutable = &v
	return s
}

func (s *UCCreateFileRequest) SetContentHashName(v string) *UCCreateFileRequest {
	s.ContentHashName = &v
	return s
}

func (s *UCCreateFileRequest) SetContentMd5(v string) *UCCreateFileRequest {
	s.ContentMd5 = &v
	return s
}

func (s *UCCreateFileRequest) SetContentType(v string) *UCCreateFileRequest {
	s.ContentType = &v
	return s
}

func (s *UCCreateFileRequest) SetCreateReason(v string) *UCCreateFileRequest {
	s.CreateReason = &v
	return s
}

func (s *UCCreateFileRequest) SetCustomField1(v string) *UCCreateFileRequest {
	s.CustomField1 = &v
	return s
}

func (s *UCCreateFileRequest) SetCustomField2(v string) *UCCreateFileRequest {
	s.CustomField2 = &v
	return s
}

func (s *UCCreateFileRequest) SetCustomType(v string) *UCCreateFileRequest {
	s.CustomType = &v
	return s
}

func (s *UCCreateFileRequest) SetDate(v string) *UCCreateFileRequest {
	s.Date = &v
	return s
}

func (s *UCCreateFileRequest) SetDescription(v string) *UCCreateFileRequest {
	s.Description = &v
	return s
}

func (s *UCCreateFileRequest) SetDriveId(v string) *UCCreateFileRequest {
	s.DriveId = &v
	return s
}

func (s *UCCreateFileRequest) SetEncryptMode(v string) *UCCreateFileRequest {
	s.EncryptMode = &v
	return s
}

func (s *UCCreateFileRequest) SetFileId(v string) *UCCreateFileRequest {
	s.FileId = &v
	return s
}

func (s *UCCreateFileRequest) SetForceUploadToLocation(v bool) *UCCreateFileRequest {
	s.ForceUploadToLocation = &v
	return s
}

func (s *UCCreateFileRequest) SetHeaders(v map[string]interface{}) *UCCreateFileRequest {
	s.Headers = v
	return s
}

func (s *UCCreateFileRequest) SetHidden(v bool) *UCCreateFileRequest {
	s.Hidden = &v
	return s
}

func (s *UCCreateFileRequest) SetImageMediaMetadata(v *ImageMediaMetadata) *UCCreateFileRequest {
	s.ImageMediaMetadata = v
	return s
}

func (s *UCCreateFileRequest) SetLabels(v []*string) *UCCreateFileRequest {
	s.Labels = v
	return s
}

func (s *UCCreateFileRequest) SetLastUpdatedAt(v string) *UCCreateFileRequest {
	s.LastUpdatedAt = &v
	return s
}

func (s *UCCreateFileRequest) SetLocalCreatedAt(v string) *UCCreateFileRequest {
	s.LocalCreatedAt = &v
	return s
}

func (s *UCCreateFileRequest) SetLocalModifiedAt(v string) *UCCreateFileRequest {
	s.LocalModifiedAt = &v
	return s
}

func (s *UCCreateFileRequest) SetLocation(v string) *UCCreateFileRequest {
	s.Location = &v
	return s
}

func (s *UCCreateFileRequest) SetMeta(v string) *UCCreateFileRequest {
	s.Meta = &v
	return s
}

func (s *UCCreateFileRequest) SetName(v string) *UCCreateFileRequest {
	s.Name = &v
	return s
}

func (s *UCCreateFileRequest) SetNeedMergePeriodRevision(v bool) *UCCreateFileRequest {
	s.NeedMergePeriodRevision = &v
	return s
}

func (s *UCCreateFileRequest) SetOverwrite(v bool) *UCCreateFileRequest {
	s.Overwrite = &v
	return s
}

func (s *UCCreateFileRequest) SetParallelUpload(v bool) *UCCreateFileRequest {
	s.ParallelUpload = &v
	return s
}

func (s *UCCreateFileRequest) SetParameters(v map[string]interface{}) *UCCreateFileRequest {
	s.Parameters = v
	return s
}

func (s *UCCreateFileRequest) SetParentFileId(v string) *UCCreateFileRequest {
	s.ParentFileId = &v
	return s
}

func (s *UCCreateFileRequest) SetParentFileIdPath(v string) *UCCreateFileRequest {
	s.ParentFileIdPath = &v
	return s
}

func (s *UCCreateFileRequest) SetPartInfoList(v []*UploadPartInfo) *UCCreateFileRequest {
	s.PartInfoList = v
	return s
}

func (s *UCCreateFileRequest) SetPreHash(v string) *UCCreateFileRequest {
	s.PreHash = &v
	return s
}

func (s *UCCreateFileRequest) SetProofCode(v string) *UCCreateFileRequest {
	s.ProofCode = &v
	return s
}

func (s *UCCreateFileRequest) SetProofVersion(v string) *UCCreateFileRequest {
	s.ProofVersion = &v
	return s
}

func (s *UCCreateFileRequest) SetShareId(v string) *UCCreateFileRequest {
	s.ShareId = &v
	return s
}

func (s *UCCreateFileRequest) SetSize(v int64) *UCCreateFileRequest {
	s.Size = &v
	return s
}

func (s *UCCreateFileRequest) SetStreamsInfo(v map[string]interface{}) *UCCreateFileRequest {
	s.StreamsInfo = v
	return s
}

func (s *UCCreateFileRequest) SetType(v string) *UCCreateFileRequest {
	s.Type = &v
	return s
}

func (s *UCCreateFileRequest) SetUploadType(v string) *UCCreateFileRequest {
	s.UploadType = &v
	return s
}

func (s *UCCreateFileRequest) SetUserMeta(v string) *UCCreateFileRequest {
	s.UserMeta = &v
	return s
}

func (s *UCCreateFileRequest) SetUserTags(v []*UserTag) *UCCreateFileRequest {
	s.UserTags = v
	return s
}

func (s *UCCreateFileRequest) SetVideoMediaMetadata(v *VideoMediaMetadata) *UCCreateFileRequest {
	s.VideoMediaMetadata = v
	return s
}

/**
 * UCCreateFileResponse
 */
type UCCreateFileResponse struct {
	Callback *Callback `json:"callback,omitempty" xml:"callback,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// exist
	// type: boolean
	Exist *bool `json:"exist,omitempty" xml:"exist,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty" maxLength:"255" minLength:"1"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// part_info_list
	PartInfoList []*UploadPartInfo `json:"part_info_list,omitempty" xml:"part_info_list,omitempty" type:"Repeated"`
	// rapid_upload
	// type: boolean
	RapidUpload *bool          `json:"rapid_upload,omitempty" xml:"rapid_upload,omitempty"`
	Signature   *SignatureInfo `json:"signature,omitempty" xml:"signature,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// streams_upload_info
	StreamsUploadInfo map[string]interface{} `json:"streams_upload_info,omitempty" xml:"streams_upload_info,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// upload_type
	UploadType *string `json:"upload_type,omitempty" xml:"upload_type,omitempty"`
}

func (s UCCreateFileResponse) String() string {
	return tea.Prettify(s)
}

func (s UCCreateFileResponse) GoString() string {
	return s.String()
}

func (s *UCCreateFileResponse) SetCallback(v *Callback) *UCCreateFileResponse {
	s.Callback = v
	return s
}

func (s *UCCreateFileResponse) SetDomainId(v string) *UCCreateFileResponse {
	s.DomainId = &v
	return s
}

func (s *UCCreateFileResponse) SetDriveId(v string) *UCCreateFileResponse {
	s.DriveId = &v
	return s
}

func (s *UCCreateFileResponse) SetEncryptMode(v string) *UCCreateFileResponse {
	s.EncryptMode = &v
	return s
}

func (s *UCCreateFileResponse) SetExist(v bool) *UCCreateFileResponse {
	s.Exist = &v
	return s
}

func (s *UCCreateFileResponse) SetFileId(v string) *UCCreateFileResponse {
	s.FileId = &v
	return s
}

func (s *UCCreateFileResponse) SetFileName(v string) *UCCreateFileResponse {
	s.FileName = &v
	return s
}

func (s *UCCreateFileResponse) SetLocation(v string) *UCCreateFileResponse {
	s.Location = &v
	return s
}

func (s *UCCreateFileResponse) SetParentFileId(v string) *UCCreateFileResponse {
	s.ParentFileId = &v
	return s
}

func (s *UCCreateFileResponse) SetPartInfoList(v []*UploadPartInfo) *UCCreateFileResponse {
	s.PartInfoList = v
	return s
}

func (s *UCCreateFileResponse) SetRapidUpload(v bool) *UCCreateFileResponse {
	s.RapidUpload = &v
	return s
}

func (s *UCCreateFileResponse) SetSignature(v *SignatureInfo) *UCCreateFileResponse {
	s.Signature = v
	return s
}

func (s *UCCreateFileResponse) SetStatus(v string) *UCCreateFileResponse {
	s.Status = &v
	return s
}

func (s *UCCreateFileResponse) SetStreamsUploadInfo(v map[string]interface{}) *UCCreateFileResponse {
	s.StreamsUploadInfo = v
	return s
}

func (s *UCCreateFileResponse) SetType(v string) *UCCreateFileResponse {
	s.Type = &v
	return s
}

func (s *UCCreateFileResponse) SetUploadId(v string) *UCCreateFileResponse {
	s.UploadId = &v
	return s
}

func (s *UCCreateFileResponse) SetUploadType(v string) *UCCreateFileResponse {
	s.UploadType = &v
	return s
}

/**
 * UCFileGetSignatureRequest get file upload signature
 */
type UCFileGetSignatureRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// action
	Action *string `json:"action,omitempty" xml:"action,omitempty"`
	// bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// content_md5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// date
	Date *string `json:"date,omitempty" xml:"date,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// headers
	Headers map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
	// object_key
	ObjectKey *string `json:"object_key,omitempty" xml:"object_key,omitempty"`
	// parameters
	Parameters map[string]interface{} `json:"parameters,omitempty" xml:"parameters,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s UCFileGetSignatureRequest) String() string {
	return tea.Prettify(s)
}

func (s UCFileGetSignatureRequest) GoString() string {
	return s.String()
}

func (s *UCFileGetSignatureRequest) SetHttpheaders(v map[string]*string) *UCFileGetSignatureRequest {
	s.Httpheaders = v
	return s
}

func (s *UCFileGetSignatureRequest) SetAction(v string) *UCFileGetSignatureRequest {
	s.Action = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetBucket(v string) *UCFileGetSignatureRequest {
	s.Bucket = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetContentMd5(v string) *UCFileGetSignatureRequest {
	s.ContentMd5 = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetContentType(v string) *UCFileGetSignatureRequest {
	s.ContentType = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetDate(v string) *UCFileGetSignatureRequest {
	s.Date = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetDriveId(v string) *UCFileGetSignatureRequest {
	s.DriveId = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetHeaders(v map[string]interface{}) *UCFileGetSignatureRequest {
	s.Headers = v
	return s
}

func (s *UCFileGetSignatureRequest) SetObjectKey(v string) *UCFileGetSignatureRequest {
	s.ObjectKey = &v
	return s
}

func (s *UCFileGetSignatureRequest) SetParameters(v map[string]interface{}) *UCFileGetSignatureRequest {
	s.Parameters = v
	return s
}

func (s *UCFileGetSignatureRequest) SetUploadId(v string) *UCFileGetSignatureRequest {
	s.UploadId = &v
	return s
}

/**
 * UCGetObjectInfoByObjectKeyRequest
 */
type UCGetObjectInfoByObjectKeyRequest struct {
	ObjectKey *string `json:"object_key,omitempty" xml:"object_key,omitempty"`
}

func (s UCGetObjectInfoByObjectKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s UCGetObjectInfoByObjectKeyRequest) GoString() string {
	return s.String()
}

func (s *UCGetObjectInfoByObjectKeyRequest) SetObjectKey(v string) *UCGetObjectInfoByObjectKeyRequest {
	s.ObjectKey = &v
	return s
}

/**
 * UCGetObjectInfoBySha1Request
 */
type UCGetObjectInfoBySha1Request struct {
	Sha1 *string `json:"sha1,omitempty" xml:"sha1,omitempty"`
}

func (s UCGetObjectInfoBySha1Request) String() string {
	return tea.Prettify(s)
}

func (s UCGetObjectInfoBySha1Request) GoString() string {
	return s.String()
}

func (s *UCGetObjectInfoBySha1Request) SetSha1(v string) *UCGetObjectInfoBySha1Request {
	s.Sha1 = &v
	return s
}

/**
 * UCGetSignatureResponse
 */
type UCGetSignatureResponse struct {
	Bucket                *string                `json:"bucket,omitempty" xml:"bucket,omitempty"`
	CanonicalizedResource *string                `json:"canonicalized_resource,omitempty" xml:"canonicalized_resource,omitempty"`
	Endpoint              *string                `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	Headers               map[string]interface{} `json:"headers,omitempty" xml:"headers,omitempty"`
	ObjectKey             *string                `json:"object_key,omitempty" xml:"object_key,omitempty"`
	Signature             *string                `json:"signature,omitempty" xml:"signature,omitempty"`
	StrToSign             *string                `json:"str_to_sign,omitempty" xml:"str_to_sign,omitempty"`
}

func (s UCGetSignatureResponse) String() string {
	return tea.Prettify(s)
}

func (s UCGetSignatureResponse) GoString() string {
	return s.String()
}

func (s *UCGetSignatureResponse) SetBucket(v string) *UCGetSignatureResponse {
	s.Bucket = &v
	return s
}

func (s *UCGetSignatureResponse) SetCanonicalizedResource(v string) *UCGetSignatureResponse {
	s.CanonicalizedResource = &v
	return s
}

func (s *UCGetSignatureResponse) SetEndpoint(v string) *UCGetSignatureResponse {
	s.Endpoint = &v
	return s
}

func (s *UCGetSignatureResponse) SetHeaders(v map[string]interface{}) *UCGetSignatureResponse {
	s.Headers = v
	return s
}

func (s *UCGetSignatureResponse) SetObjectKey(v string) *UCGetSignatureResponse {
	s.ObjectKey = &v
	return s
}

func (s *UCGetSignatureResponse) SetSignature(v string) *UCGetSignatureResponse {
	s.Signature = &v
	return s
}

func (s *UCGetSignatureResponse) SetStrToSign(v string) *UCGetSignatureResponse {
	s.StrToSign = &v
	return s
}

/**
 * UCUpdateUploadContentHashRequest update upload info
 */
type UCUpdateUploadContentHashRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// content_hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_md5
	ContentMd5 *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// overwrite
	Overwrite *bool `json:"overwrite,omitempty" xml:"overwrite,omitempty"`
	// size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s UCUpdateUploadContentHashRequest) String() string {
	return tea.Prettify(s)
}

func (s UCUpdateUploadContentHashRequest) GoString() string {
	return s.String()
}

func (s *UCUpdateUploadContentHashRequest) SetHttpheaders(v map[string]*string) *UCUpdateUploadContentHashRequest {
	s.Httpheaders = v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetContentHash(v string) *UCUpdateUploadContentHashRequest {
	s.ContentHash = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetContentHashName(v string) *UCUpdateUploadContentHashRequest {
	s.ContentHashName = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetContentMd5(v string) *UCUpdateUploadContentHashRequest {
	s.ContentMd5 = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetDriveId(v string) *UCUpdateUploadContentHashRequest {
	s.DriveId = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetFileId(v string) *UCUpdateUploadContentHashRequest {
	s.FileId = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetOverwrite(v bool) *UCUpdateUploadContentHashRequest {
	s.Overwrite = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetSize(v int64) *UCUpdateUploadContentHashRequest {
	s.Size = &v
	return s
}

func (s *UCUpdateUploadContentHashRequest) SetUploadId(v string) *UCUpdateUploadContentHashRequest {
	s.UploadId = &v
	return s
}

/**
 * UCUpdateUploadContentHashResponse
 */
type UCUpdateUploadContentHashResponse struct {
	ContentHash     *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	ContentMd5      *string `json:"content_md5,omitempty" xml:"content_md5,omitempty"`
	DriveId         *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId          *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	IsRapidUpload   *bool   `json:"is_rapid_upload,omitempty" xml:"is_rapid_upload,omitempty"`
	Size            *int64  `json:"size,omitempty" xml:"size,omitempty"`
	UpdateTime      *string `json:"update_time,omitempty" xml:"update_time,omitempty"`
	UploadId        *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
}

func (s UCUpdateUploadContentHashResponse) String() string {
	return tea.Prettify(s)
}

func (s UCUpdateUploadContentHashResponse) GoString() string {
	return s.String()
}

func (s *UCUpdateUploadContentHashResponse) SetContentHash(v string) *UCUpdateUploadContentHashResponse {
	s.ContentHash = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetContentHashName(v string) *UCUpdateUploadContentHashResponse {
	s.ContentHashName = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetContentMd5(v string) *UCUpdateUploadContentHashResponse {
	s.ContentMd5 = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetDriveId(v string) *UCUpdateUploadContentHashResponse {
	s.DriveId = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetFileId(v string) *UCUpdateUploadContentHashResponse {
	s.FileId = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetIsRapidUpload(v bool) *UCUpdateUploadContentHashResponse {
	s.IsRapidUpload = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetSize(v int64) *UCUpdateUploadContentHashResponse {
	s.Size = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetUpdateTime(v string) *UCUpdateUploadContentHashResponse {
	s.UpdateTime = &v
	return s
}

func (s *UCUpdateUploadContentHashResponse) SetUploadId(v string) *UCUpdateUploadContentHashResponse {
	s.UploadId = &v
	return s
}

/**
 *
 */
type UnionAuthentication struct {
	AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty"`
	CreatedAt          *int64  `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty"`
	Extra              *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
	Identity           *string `json:"Identity,omitempty" xml:"Identity,omitempty"`
	Status             *string `json:"Status,omitempty" xml:"Status,omitempty"`
	UnionID            *string `json:"UnionID,omitempty" xml:"UnionID,omitempty"`
}

func (s UnionAuthentication) String() string {
	return tea.Prettify(s)
}

func (s UnionAuthentication) GoString() string {
	return s.String()
}

func (s *UnionAuthentication) SetAuthenticationType(v string) *UnionAuthentication {
	s.AuthenticationType = &v
	return s
}

func (s *UnionAuthentication) SetCreatedAt(v int64) *UnionAuthentication {
	s.CreatedAt = &v
	return s
}

func (s *UnionAuthentication) SetExtra(v string) *UnionAuthentication {
	s.Extra = &v
	return s
}

func (s *UnionAuthentication) SetIdentity(v string) *UnionAuthentication {
	s.Identity = &v
	return s
}

func (s *UnionAuthentication) SetStatus(v string) *UnionAuthentication {
	s.Status = &v
	return s
}

func (s *UnionAuthentication) SetUnionID(v string) *UnionAuthentication {
	s.UnionID = &v
	return s
}

/**
 *
 */
type UnionDomainUserBind struct {
	AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty"`
	DomainID           *string `json:"DomainID,omitempty" xml:"DomainID,omitempty"`
	Extra              *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
	Identity           *string `json:"Identity,omitempty" xml:"Identity,omitempty"`
	UnionID            *string `json:"UnionID,omitempty" xml:"UnionID,omitempty"`
	UserID             *string `json:"UserID,omitempty" xml:"UserID,omitempty"`
}

func (s UnionDomainUserBind) String() string {
	return tea.Prettify(s)
}

func (s UnionDomainUserBind) GoString() string {
	return s.String()
}

func (s *UnionDomainUserBind) SetAuthenticationType(v string) *UnionDomainUserBind {
	s.AuthenticationType = &v
	return s
}

func (s *UnionDomainUserBind) SetDomainID(v string) *UnionDomainUserBind {
	s.DomainID = &v
	return s
}

func (s *UnionDomainUserBind) SetExtra(v string) *UnionDomainUserBind {
	s.Extra = &v
	return s
}

func (s *UnionDomainUserBind) SetIdentity(v string) *UnionDomainUserBind {
	s.Identity = &v
	return s
}

func (s *UnionDomainUserBind) SetUnionID(v string) *UnionDomainUserBind {
	s.UnionID = &v
	return s
}

func (s *UnionDomainUserBind) SetUserID(v string) *UnionDomainUserBind {
	s.UserID = &v
	return s
}

/**
 *
 */
type UpdateAppRequest struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// App
	AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" maxLength:"128" minLength:"1"`
	// App
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024" minLength:"0"`
	// App
	Logo *string `json:"logo,omitempty" xml:"logo,omitempty"`
	// App
	RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
	// App
	Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" type:"Repeated"`
	// App
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateAppRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppRequest) GoString() string {
	return s.String()
}

func (s *UpdateAppRequest) SetAppId(v string) *UpdateAppRequest {
	s.AppId = &v
	return s
}

func (s *UpdateAppRequest) SetAppName(v string) *UpdateAppRequest {
	s.AppName = &v
	return s
}

func (s *UpdateAppRequest) SetDescription(v string) *UpdateAppRequest {
	s.Description = &v
	return s
}

func (s *UpdateAppRequest) SetLogo(v string) *UpdateAppRequest {
	s.Logo = &v
	return s
}

func (s *UpdateAppRequest) SetRedirectUri(v string) *UpdateAppRequest {
	s.RedirectUri = &v
	return s
}

func (s *UpdateAppRequest) SetScope(v []*string) *UpdateAppRequest {
	s.Scope = v
	return s
}

func (s *UpdateAppRequest) SetType(v string) *UpdateAppRequest {
	s.Type = &v
	return s
}

/**
 * update domain request
 */
type UpdateDomainRequest struct {
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable  *bool                  `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	CustomBenefits map[string]interface{} `json:"custom_benefits,omitempty" xml:"custom_benefits,omitempty"`
	//  Hash 
	DataHashName *string `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	GetBenefit   *bool   `json:"get_benefit,omitempty" xml:"get_benefit,omitempty"`
	// drive
	GroupSingleDriveEnabled *bool `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	//  Drive  Store ID
	InitDriveStoreId           *string            `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	// 
	Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
	// quota-1
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// drive
	UserSingleDriveEnabled *bool `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
}

func (s UpdateDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainRequest) SetAuthConfig(v map[string]interface{}) *UpdateDomainRequest {
	s.AuthConfig = v
	return s
}

func (s *UpdateDomainRequest) SetAuthDingdingAppId(v string) *UpdateDomainRequest {
	s.AuthDingdingAppId = &v
	return s
}

func (s *UpdateDomainRequest) SetAuthDingdingAppSecret(v string) *UpdateDomainRequest {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *UpdateDomainRequest) SetAuthDingdingEnable(v bool) *UpdateDomainRequest {
	s.AuthDingdingEnable = &v
	return s
}

func (s *UpdateDomainRequest) SetAuthRamAppId(v string) *UpdateDomainRequest {
	s.AuthRamAppId = &v
	return s
}

func (s *UpdateDomainRequest) SetAuthRamAppSecret(v string) *UpdateDomainRequest {
	s.AuthRamAppSecret = &v
	return s
}

func (s *UpdateDomainRequest) SetAuthRamEnable(v bool) *UpdateDomainRequest {
	s.AuthRamEnable = &v
	return s
}

func (s *UpdateDomainRequest) SetCustomBenefits(v map[string]interface{}) *UpdateDomainRequest {
	s.CustomBenefits = v
	return s
}

func (s *UpdateDomainRequest) SetDataHashName(v string) *UpdateDomainRequest {
	s.DataHashName = &v
	return s
}

func (s *UpdateDomainRequest) SetDescription(v string) *UpdateDomainRequest {
	s.Description = &v
	return s
}

func (s *UpdateDomainRequest) SetDomainId(v string) *UpdateDomainRequest {
	s.DomainId = &v
	return s
}

func (s *UpdateDomainRequest) SetDomainName(v string) *UpdateDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDomainRequest) SetEventFilenameMatches(v string) *UpdateDomainRequest {
	s.EventFilenameMatches = &v
	return s
}

func (s *UpdateDomainRequest) SetEventMnsEndpoint(v string) *UpdateDomainRequest {
	s.EventMnsEndpoint = &v
	return s
}

func (s *UpdateDomainRequest) SetEventMnsTopic(v string) *UpdateDomainRequest {
	s.EventMnsTopic = &v
	return s
}

func (s *UpdateDomainRequest) SetEventNames(v []*string) *UpdateDomainRequest {
	s.EventNames = v
	return s
}

func (s *UpdateDomainRequest) SetEventRoleArn(v string) *UpdateDomainRequest {
	s.EventRoleArn = &v
	return s
}

func (s *UpdateDomainRequest) SetGetBenefit(v bool) *UpdateDomainRequest {
	s.GetBenefit = &v
	return s
}

func (s *UpdateDomainRequest) SetGroupSingleDriveEnabled(v bool) *UpdateDomainRequest {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *UpdateDomainRequest) SetInitDriveEnable(v bool) *UpdateDomainRequest {
	s.InitDriveEnable = &v
	return s
}

func (s *UpdateDomainRequest) SetInitDriveSize(v int64) *UpdateDomainRequest {
	s.InitDriveSize = &v
	return s
}

func (s *UpdateDomainRequest) SetInitDriveStoreId(v string) *UpdateDomainRequest {
	s.InitDriveStoreId = &v
	return s
}

func (s *UpdateDomainRequest) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *UpdateDomainRequest {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *UpdateDomainRequest) SetSharable(v bool) *UpdateDomainRequest {
	s.Sharable = &v
	return s
}

func (s *UpdateDomainRequest) SetSizeQuota(v int64) *UpdateDomainRequest {
	s.SizeQuota = &v
	return s
}

func (s *UpdateDomainRequest) SetStatus(v int64) *UpdateDomainRequest {
	s.Status = &v
	return s
}

func (s *UpdateDomainRequest) SetUsedSizeRefreshInterval(v int64) *UpdateDomainRequest {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *UpdateDomainRequest) SetUserCountQuota(v int64) *UpdateDomainRequest {
	s.UserCountQuota = &v
	return s
}

func (s *UpdateDomainRequest) SetUserSingleDriveEnabled(v bool) *UpdateDomainRequest {
	s.UserSingleDriveEnabled = &v
	return s
}

/**
 * Update drive request
 */
type UpdateDriveRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true"`
	// Drive 
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty" maxLength:"1024"`
	// 
	EncryptDataAccess *bool `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
	// 
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// Subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// ,Byte [ -1 ]
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
}

func (s UpdateDriveRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDriveRequest) GoString() string {
	return s.String()
}

func (s *UpdateDriveRequest) SetHttpheaders(v map[string]*string) *UpdateDriveRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateDriveRequest) SetDescription(v string) *UpdateDriveRequest {
	s.Description = &v
	return s
}

func (s *UpdateDriveRequest) SetDriveId(v string) *UpdateDriveRequest {
	s.DriveId = &v
	return s
}

func (s *UpdateDriveRequest) SetDriveName(v string) *UpdateDriveRequest {
	s.DriveName = &v
	return s
}

func (s *UpdateDriveRequest) SetEncryptDataAccess(v bool) *UpdateDriveRequest {
	s.EncryptDataAccess = &v
	return s
}

func (s *UpdateDriveRequest) SetEncryptMode(v string) *UpdateDriveRequest {
	s.EncryptMode = &v
	return s
}

func (s *UpdateDriveRequest) SetStatus(v string) *UpdateDriveRequest {
	s.Status = &v
	return s
}

func (s *UpdateDriveRequest) SetSubdomainId(v string) *UpdateDriveRequest {
	s.SubdomainId = &v
	return s
}

func (s *UpdateDriveRequest) SetTotalSize(v int64) *UpdateDriveRequest {
	s.TotalSize = &v
	return s
}

/**
 * Update drive response
 */
type UpdateDriveResponse struct {
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	CreatedAt  *string   `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Drive 
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// Drive 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Drive ID
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// Drive 
	DriveName *string `json:"drive_name,omitempty" xml:"drive_name,omitempty"`
	// Drive 
	DriveType         *string `json:"drive_type,omitempty" xml:"drive_type,omitempty"`
	EncryptDataAccess *bool   `json:"encrypt_data_access,omitempty" xml:"encrypt_data_access,omitempty"`
	EncryptMode       *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// Drive 
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// Drive 
	OwnerType  *string                `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// DrivestoredomainPathTypeOSSPath
	RelativePath *string `json:"relative_path,omitempty" xml:"relative_path,omitempty"`
	// Drive 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	//  ID, domainPathTypeOSSPath
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// Drive 
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// Drive 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s UpdateDriveResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDriveResponse) GoString() string {
	return s.String()
}

func (s *UpdateDriveResponse) SetActionList(v []*string) *UpdateDriveResponse {
	s.ActionList = v
	return s
}

func (s *UpdateDriveResponse) SetCreatedAt(v string) *UpdateDriveResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateDriveResponse) SetCreator(v string) *UpdateDriveResponse {
	s.Creator = &v
	return s
}

func (s *UpdateDriveResponse) SetDescription(v string) *UpdateDriveResponse {
	s.Description = &v
	return s
}

func (s *UpdateDriveResponse) SetDomainId(v string) *UpdateDriveResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateDriveResponse) SetDriveId(v string) *UpdateDriveResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateDriveResponse) SetDriveName(v string) *UpdateDriveResponse {
	s.DriveName = &v
	return s
}

func (s *UpdateDriveResponse) SetDriveType(v string) *UpdateDriveResponse {
	s.DriveType = &v
	return s
}

func (s *UpdateDriveResponse) SetEncryptDataAccess(v bool) *UpdateDriveResponse {
	s.EncryptDataAccess = &v
	return s
}

func (s *UpdateDriveResponse) SetEncryptMode(v string) *UpdateDriveResponse {
	s.EncryptMode = &v
	return s
}

func (s *UpdateDriveResponse) SetOwner(v string) *UpdateDriveResponse {
	s.Owner = &v
	return s
}

func (s *UpdateDriveResponse) SetOwnerType(v string) *UpdateDriveResponse {
	s.OwnerType = &v
	return s
}

func (s *UpdateDriveResponse) SetPermission(v map[string]interface{}) *UpdateDriveResponse {
	s.Permission = v
	return s
}

func (s *UpdateDriveResponse) SetRelativePath(v string) *UpdateDriveResponse {
	s.RelativePath = &v
	return s
}

func (s *UpdateDriveResponse) SetStatus(v string) *UpdateDriveResponse {
	s.Status = &v
	return s
}

func (s *UpdateDriveResponse) SetStoreId(v string) *UpdateDriveResponse {
	s.StoreId = &v
	return s
}

func (s *UpdateDriveResponse) SetSubdomainId(v string) *UpdateDriveResponse {
	s.SubdomainId = &v
	return s
}

func (s *UpdateDriveResponse) SetTotalSize(v int64) *UpdateDriveResponse {
	s.TotalSize = &v
	return s
}

func (s *UpdateDriveResponse) SetUsedSize(v int64) *UpdateDriveResponse {
	s.UsedSize = &v
	return s
}

/**
 * 
 */
type UpdateFileMetaRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// check_name_mode
	CheckNameMode  *string `json:"check_name_mode,omitempty" xml:"check_name_mode,omitempty"`
	CustomField1   *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	CustomField2   *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	CustomIndexKey *string `json:"custom_index_key,omitempty" xml:"custom_index_key,omitempty"`
	CustomType     *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	// type: string
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// drive_id
	DriveId     *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_id
	FileId     *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true" maxLength:"50" minLength:"40" pattern:"[a-z0-9.-_]{1,50}"`
	FileIdPath *string `json:"file_id_path,omitempty" xml:"file_id_path,omitempty"`
	// hidden
	// type: boolean
	Hidden *bool `json:"hidden,omitempty" xml:"hidden,omitempty"`
	// labels
	Labels          []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	LocalModifiedAt *string   `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string   `json:"meta,omitempty" xml:"meta,omitempty"`
	MimeExtension   *string   `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	MimeType        *string   `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name      *string `json:"name,omitempty" xml:"name,omitempty" maxLength:"1024" minLength:"1"`
	Referer   *string `json:"referer,omitempty" xml:"referer,omitempty"`
	ShareId   *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// starred
	// type: boolean
	Starred *bool   `json:"starred,omitempty" xml:"starred,omitempty"`
	TakenAt *string `json:"taken_at,omitempty" xml:"taken_at,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
}

func (s UpdateFileMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileMetaRequest) GoString() string {
	return s.String()
}

func (s *UpdateFileMetaRequest) SetHttpheaders(v map[string]*string) *UpdateFileMetaRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateFileMetaRequest) SetCheckNameMode(v string) *UpdateFileMetaRequest {
	s.CheckNameMode = &v
	return s
}

func (s *UpdateFileMetaRequest) SetCustomField1(v string) *UpdateFileMetaRequest {
	s.CustomField1 = &v
	return s
}

func (s *UpdateFileMetaRequest) SetCustomField2(v string) *UpdateFileMetaRequest {
	s.CustomField2 = &v
	return s
}

func (s *UpdateFileMetaRequest) SetCustomIndexKey(v string) *UpdateFileMetaRequest {
	s.CustomIndexKey = &v
	return s
}

func (s *UpdateFileMetaRequest) SetCustomType(v string) *UpdateFileMetaRequest {
	s.CustomType = &v
	return s
}

func (s *UpdateFileMetaRequest) SetDescription(v string) *UpdateFileMetaRequest {
	s.Description = &v
	return s
}

func (s *UpdateFileMetaRequest) SetDriveId(v string) *UpdateFileMetaRequest {
	s.DriveId = &v
	return s
}

func (s *UpdateFileMetaRequest) SetEncryptMode(v string) *UpdateFileMetaRequest {
	s.EncryptMode = &v
	return s
}

func (s *UpdateFileMetaRequest) SetExFieldsInfo(v map[string]interface{}) *UpdateFileMetaRequest {
	s.ExFieldsInfo = v
	return s
}

func (s *UpdateFileMetaRequest) SetFileId(v string) *UpdateFileMetaRequest {
	s.FileId = &v
	return s
}

func (s *UpdateFileMetaRequest) SetFileIdPath(v string) *UpdateFileMetaRequest {
	s.FileIdPath = &v
	return s
}

func (s *UpdateFileMetaRequest) SetHidden(v bool) *UpdateFileMetaRequest {
	s.Hidden = &v
	return s
}

func (s *UpdateFileMetaRequest) SetLabels(v []*string) *UpdateFileMetaRequest {
	s.Labels = v
	return s
}

func (s *UpdateFileMetaRequest) SetLocalModifiedAt(v string) *UpdateFileMetaRequest {
	s.LocalModifiedAt = &v
	return s
}

func (s *UpdateFileMetaRequest) SetMeta(v string) *UpdateFileMetaRequest {
	s.Meta = &v
	return s
}

func (s *UpdateFileMetaRequest) SetMimeExtension(v string) *UpdateFileMetaRequest {
	s.MimeExtension = &v
	return s
}

func (s *UpdateFileMetaRequest) SetMimeType(v string) *UpdateFileMetaRequest {
	s.MimeType = &v
	return s
}

func (s *UpdateFileMetaRequest) SetName(v string) *UpdateFileMetaRequest {
	s.Name = &v
	return s
}

func (s *UpdateFileMetaRequest) SetReferer(v string) *UpdateFileMetaRequest {
	s.Referer = &v
	return s
}

func (s *UpdateFileMetaRequest) SetShareId(v string) *UpdateFileMetaRequest {
	s.ShareId = &v
	return s
}

func (s *UpdateFileMetaRequest) SetSignToken(v string) *UpdateFileMetaRequest {
	s.SignToken = &v
	return s
}

func (s *UpdateFileMetaRequest) SetStarred(v bool) *UpdateFileMetaRequest {
	s.Starred = &v
	return s
}

func (s *UpdateFileMetaRequest) SetTakenAt(v string) *UpdateFileMetaRequest {
	s.TakenAt = &v
	return s
}

func (s *UpdateFileMetaRequest) SetUserMeta(v string) *UpdateFileMetaRequest {
	s.UserMeta = &v
	return s
}

/**
 *  response
 */
type UpdateFileMetaResponse struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
}

func (s UpdateFileMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileMetaResponse) GoString() string {
	return s.String()
}

func (s *UpdateFileMetaResponse) SetActionList(v []*string) *UpdateFileMetaResponse {
	s.ActionList = v
	return s
}

func (s *UpdateFileMetaResponse) SetAutoDeleteLeftSec(v int64) *UpdateFileMetaResponse {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCategory(v string) *UpdateFileMetaResponse {
	s.Category = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCharacteristicHash(v string) *UpdateFileMetaResponse {
	s.CharacteristicHash = &v
	return s
}

func (s *UpdateFileMetaResponse) SetContentHash(v string) *UpdateFileMetaResponse {
	s.ContentHash = &v
	return s
}

func (s *UpdateFileMetaResponse) SetContentHashName(v string) *UpdateFileMetaResponse {
	s.ContentHashName = &v
	return s
}

func (s *UpdateFileMetaResponse) SetContentType(v string) *UpdateFileMetaResponse {
	s.ContentType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCrc64Hash(v string) *UpdateFileMetaResponse {
	s.Crc64Hash = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCreatedAt(v string) *UpdateFileMetaResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCreatorId(v string) *UpdateFileMetaResponse {
	s.CreatorId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCreatorName(v string) *UpdateFileMetaResponse {
	s.CreatorName = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCreatorType(v string) *UpdateFileMetaResponse {
	s.CreatorType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCustomField1(v string) *UpdateFileMetaResponse {
	s.CustomField1 = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCustomField2(v string) *UpdateFileMetaResponse {
	s.CustomField2 = &v
	return s
}

func (s *UpdateFileMetaResponse) SetCustomType(v string) *UpdateFileMetaResponse {
	s.CustomType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetDescription(v string) *UpdateFileMetaResponse {
	s.Description = &v
	return s
}

func (s *UpdateFileMetaResponse) SetDomainId(v string) *UpdateFileMetaResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetDownloadUrl(v string) *UpdateFileMetaResponse {
	s.DownloadUrl = &v
	return s
}

func (s *UpdateFileMetaResponse) SetDriveId(v string) *UpdateFileMetaResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetEncryptMode(v string) *UpdateFileMetaResponse {
	s.EncryptMode = &v
	return s
}

func (s *UpdateFileMetaResponse) SetExFieldsInfo(v map[string]interface{}) *UpdateFileMetaResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *UpdateFileMetaResponse) SetFileExtension(v string) *UpdateFileMetaResponse {
	s.FileExtension = &v
	return s
}

func (s *UpdateFileMetaResponse) SetFileId(v string) *UpdateFileMetaResponse {
	s.FileId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetFilePathType(v string) *UpdateFileMetaResponse {
	s.FilePathType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetHidden(v bool) *UpdateFileMetaResponse {
	s.Hidden = &v
	return s
}

func (s *UpdateFileMetaResponse) SetImageMediaMetadata(v *ImageMediaResponse) *UpdateFileMetaResponse {
	s.ImageMediaMetadata = v
	return s
}

func (s *UpdateFileMetaResponse) SetLabels(v []*string) *UpdateFileMetaResponse {
	s.Labels = v
	return s
}

func (s *UpdateFileMetaResponse) SetLastModifierId(v string) *UpdateFileMetaResponse {
	s.LastModifierId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetLastModifierName(v string) *UpdateFileMetaResponse {
	s.LastModifierName = &v
	return s
}

func (s *UpdateFileMetaResponse) SetLastModifierType(v string) *UpdateFileMetaResponse {
	s.LastModifierType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetLocalCreatedAt(v string) *UpdateFileMetaResponse {
	s.LocalCreatedAt = &v
	return s
}

func (s *UpdateFileMetaResponse) SetLocalModifiedAt(v string) *UpdateFileMetaResponse {
	s.LocalModifiedAt = &v
	return s
}

func (s *UpdateFileMetaResponse) SetMeta(v string) *UpdateFileMetaResponse {
	s.Meta = &v
	return s
}

func (s *UpdateFileMetaResponse) SetMimeExtension(v string) *UpdateFileMetaResponse {
	s.MimeExtension = &v
	return s
}

func (s *UpdateFileMetaResponse) SetMimeType(v string) *UpdateFileMetaResponse {
	s.MimeType = &v
	return s
}

func (s *UpdateFileMetaResponse) SetName(v string) *UpdateFileMetaResponse {
	s.Name = &v
	return s
}

func (s *UpdateFileMetaResponse) SetParentFileId(v string) *UpdateFileMetaResponse {
	s.ParentFileId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetPunishFlag(v int64) *UpdateFileMetaResponse {
	s.PunishFlag = &v
	return s
}

func (s *UpdateFileMetaResponse) SetRevisionId(v string) *UpdateFileMetaResponse {
	s.RevisionId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetShareId(v string) *UpdateFileMetaResponse {
	s.ShareId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetSize(v int64) *UpdateFileMetaResponse {
	s.Size = &v
	return s
}

func (s *UpdateFileMetaResponse) SetStarred(v bool) *UpdateFileMetaResponse {
	s.Starred = &v
	return s
}

func (s *UpdateFileMetaResponse) SetStatus(v string) *UpdateFileMetaResponse {
	s.Status = &v
	return s
}

func (s *UpdateFileMetaResponse) SetStreamsInfo(v map[string]interface{}) *UpdateFileMetaResponse {
	s.StreamsInfo = v
	return s
}

func (s *UpdateFileMetaResponse) SetSyncDeviceFlag(v bool) *UpdateFileMetaResponse {
	s.SyncDeviceFlag = &v
	return s
}

func (s *UpdateFileMetaResponse) SetSyncFlag(v bool) *UpdateFileMetaResponse {
	s.SyncFlag = &v
	return s
}

func (s *UpdateFileMetaResponse) SetSyncMeta(v string) *UpdateFileMetaResponse {
	s.SyncMeta = &v
	return s
}

func (s *UpdateFileMetaResponse) SetThumbnail(v string) *UpdateFileMetaResponse {
	s.Thumbnail = &v
	return s
}

func (s *UpdateFileMetaResponse) SetTrashedAt(v string) *UpdateFileMetaResponse {
	s.TrashedAt = &v
	return s
}

func (s *UpdateFileMetaResponse) SetType(v string) *UpdateFileMetaResponse {
	s.Type = &v
	return s
}

func (s *UpdateFileMetaResponse) SetUpdatedAt(v string) *UpdateFileMetaResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UpdateFileMetaResponse) SetUploadId(v string) *UpdateFileMetaResponse {
	s.UploadId = &v
	return s
}

func (s *UpdateFileMetaResponse) SetUrl(v string) *UpdateFileMetaResponse {
	s.Url = &v
	return s
}

func (s *UpdateFileMetaResponse) SetUserMeta(v string) *UpdateFileMetaResponse {
	s.UserMeta = &v
	return s
}

func (s *UpdateFileMetaResponse) SetUserTags(v map[string]interface{}) *UpdateFileMetaResponse {
	s.UserTags = v
	return s
}

func (s *UpdateFileMetaResponse) SetVideoMediaMetadata(v *VideoMediaResponse) *UpdateFileMetaResponse {
	s.VideoMediaMetadata = v
	return s
}

func (s *UpdateFileMetaResponse) SetVideoPreviewMetadata(v *VideoPreviewResponse) *UpdateFileMetaResponse {
	s.VideoPreviewMetadata = v
	return s
}

/**
 *
 */
type UpdateShareLinkPermissionRequest struct {
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// 
	EnableUpload *bool `json:"enable_upload,omitempty" xml:"enable_upload,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
}

func (s UpdateShareLinkPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareLinkPermissionRequest) GoString() string {
	return s.String()
}

func (s *UpdateShareLinkPermissionRequest) SetDisableDownload(v bool) *UpdateShareLinkPermissionRequest {
	s.DisableDownload = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetDisablePreview(v bool) *UpdateShareLinkPermissionRequest {
	s.DisablePreview = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetDisableSave(v bool) *UpdateShareLinkPermissionRequest {
	s.DisableSave = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetDownloadLimit(v int64) *UpdateShareLinkPermissionRequest {
	s.DownloadLimit = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetEnableUpload(v bool) *UpdateShareLinkPermissionRequest {
	s.EnableUpload = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetPreviewLimit(v int64) *UpdateShareLinkPermissionRequest {
	s.PreviewLimit = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetRequireLogin(v bool) *UpdateShareLinkPermissionRequest {
	s.RequireLogin = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetSaveDownloadLimit(v int64) *UpdateShareLinkPermissionRequest {
	s.SaveDownloadLimit = &v
	return s
}

func (s *UpdateShareLinkPermissionRequest) SetSaveLimit(v int64) *UpdateShareLinkPermissionRequest {
	s.SaveLimit = &v
	return s
}

/**
 * update_share_link request
 */
type UpdateShareLinkRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// download_count
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// enable_file_changed_notify
	EnableFileChangedNotify *bool `json:"enable_file_changed_notify,omitempty" xml:"enable_file_changed_notify,omitempty"`
	// 
	EnableUpload *bool `json:"enable_upload,omitempty" xml:"enable_upload,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// is_subscribed
	IsSubscribed *bool `json:"is_subscribed,omitempty" xml:"is_subscribed,omitempty"`
	// num_of_subscribers
	NumOfSubscribers *int64 `json:"num_of_subscribers,omitempty" xml:"num_of_subscribers,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// report_count
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// save_count
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// video_preview_count
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
}

func (s UpdateShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareLinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateShareLinkRequest) SetHttpheaders(v map[string]*string) *UpdateShareLinkRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateShareLinkRequest) SetComments(v string) *UpdateShareLinkRequest {
	s.Comments = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDescription(v string) *UpdateShareLinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDisableDownload(v bool) *UpdateShareLinkRequest {
	s.DisableDownload = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDisablePreview(v bool) *UpdateShareLinkRequest {
	s.DisablePreview = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDisableSave(v bool) *UpdateShareLinkRequest {
	s.DisableSave = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDownloadCount(v int64) *UpdateShareLinkRequest {
	s.DownloadCount = &v
	return s
}

func (s *UpdateShareLinkRequest) SetDownloadLimit(v int64) *UpdateShareLinkRequest {
	s.DownloadLimit = &v
	return s
}

func (s *UpdateShareLinkRequest) SetEnableFileChangedNotify(v bool) *UpdateShareLinkRequest {
	s.EnableFileChangedNotify = &v
	return s
}

func (s *UpdateShareLinkRequest) SetEnableUpload(v bool) *UpdateShareLinkRequest {
	s.EnableUpload = &v
	return s
}

func (s *UpdateShareLinkRequest) SetExpiration(v string) *UpdateShareLinkRequest {
	s.Expiration = &v
	return s
}

func (s *UpdateShareLinkRequest) SetIsSubscribed(v bool) *UpdateShareLinkRequest {
	s.IsSubscribed = &v
	return s
}

func (s *UpdateShareLinkRequest) SetNumOfSubscribers(v int64) *UpdateShareLinkRequest {
	s.NumOfSubscribers = &v
	return s
}

func (s *UpdateShareLinkRequest) SetPreviewCount(v int64) *UpdateShareLinkRequest {
	s.PreviewCount = &v
	return s
}

func (s *UpdateShareLinkRequest) SetPreviewLimit(v int64) *UpdateShareLinkRequest {
	s.PreviewLimit = &v
	return s
}

func (s *UpdateShareLinkRequest) SetReportCount(v int64) *UpdateShareLinkRequest {
	s.ReportCount = &v
	return s
}

func (s *UpdateShareLinkRequest) SetRequireLogin(v bool) *UpdateShareLinkRequest {
	s.RequireLogin = &v
	return s
}

func (s *UpdateShareLinkRequest) SetSaveCount(v int64) *UpdateShareLinkRequest {
	s.SaveCount = &v
	return s
}

func (s *UpdateShareLinkRequest) SetSaveDownloadLimit(v int64) *UpdateShareLinkRequest {
	s.SaveDownloadLimit = &v
	return s
}

func (s *UpdateShareLinkRequest) SetSaveLimit(v int64) *UpdateShareLinkRequest {
	s.SaveLimit = &v
	return s
}

func (s *UpdateShareLinkRequest) SetShareIcon(v string) *UpdateShareLinkRequest {
	s.ShareIcon = &v
	return s
}

func (s *UpdateShareLinkRequest) SetShareId(v string) *UpdateShareLinkRequest {
	s.ShareId = &v
	return s
}

func (s *UpdateShareLinkRequest) SetShareName(v string) *UpdateShareLinkRequest {
	s.ShareName = &v
	return s
}

func (s *UpdateShareLinkRequest) SetSharePwd(v string) *UpdateShareLinkRequest {
	s.SharePwd = &v
	return s
}

func (s *UpdateShareLinkRequest) SetStatus(v string) *UpdateShareLinkRequest {
	s.Status = &v
	return s
}

func (s *UpdateShareLinkRequest) SetVideoPreviewCount(v int64) *UpdateShareLinkRequest {
	s.VideoPreviewCount = &v
	return s
}

/**
 * update_share_link response
 */
type UpdateShareLinkResponse struct {
	// access_count
	AccessCount *int64 `json:"access_count,omitempty" xml:"access_count,omitempty"`
	// Category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// comments
	Comments *string `json:"comments,omitempty" xml:"comments,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	DisableDownload *bool `json:"disable_download,omitempty" xml:"disable_download,omitempty"`
	// 
	DisablePreview *bool `json:"disable_preview,omitempty" xml:"disable_preview,omitempty"`
	// 
	DisableSave *bool `json:"disable_save,omitempty" xml:"disable_save,omitempty"`
	// 
	DownloadCount *int64 `json:"download_count,omitempty" xml:"download_count,omitempty"`
	// 
	DownloadLimit *int64 `json:"download_limit,omitempty" xml:"download_limit,omitempty"`
	// file_list
	DriveFileList []*ShareFile `json:"drive_file_list,omitempty" xml:"drive_file_list,omitempty" type:"Repeated"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// enable_file_changed_notify
	EnableFileChangedNotify *bool `json:"enable_file_changed_notify,omitempty" xml:"enable_file_changed_notify,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// file_id_list
	FileIdList []*string `json:"file_id_list,omitempty" xml:"file_id_list,omitempty" type:"Repeated"`
	// file_id_list
	FilePathList []*string `json:"file_path_list,omitempty" xml:"file_path_list,omitempty" type:"Repeated"`
	// is_subscribed
	IsSubscribed *bool `json:"is_subscribed,omitempty" xml:"is_subscribed,omitempty"`
	// num_of_subscribers
	NumOfSubscribers *int64 `json:"num_of_subscribers,omitempty" xml:"num_of_subscribers,omitempty"`
	// preview_count
	PreviewCount *int64 `json:"preview_count,omitempty" xml:"preview_count,omitempty"`
	// 
	PreviewLimit *int64 `json:"preview_limit,omitempty" xml:"preview_limit,omitempty"`
	// 
	ReportCount *int64 `json:"report_count,omitempty" xml:"report_count,omitempty"`
	// (domain)
	RequireLogin *bool `json:"require_login,omitempty" xml:"require_login,omitempty"`
	// 
	SaveCount *int64 `json:"save_count,omitempty" xml:"save_count,omitempty"`
	// 
	SaveDownloadLimit *int64 `json:"save_download_limit,omitempty" xml:"save_download_limit,omitempty"`
	// 
	SaveLimit *int64 `json:"save_limit,omitempty" xml:"save_limit,omitempty"`
	// share_icon
	ShareIcon *string `json:"share_icon,omitempty" xml:"share_icon,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_msg
	ShareMsg *string `json:"share_msg,omitempty" xml:"share_msg,omitempty"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_policy
	SharePolicy *string `json:"share_policy,omitempty" xml:"share_policy,omitempty"`
	// share_pwd
	SharePwd *string `json:"share_pwd,omitempty" xml:"share_pwd,omitempty"`
	// share_url
	ShareUrl *string `json:"share_url,omitempty" xml:"share_url,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	VideoPreviewCount *int64 `json:"video_preview_count,omitempty" xml:"video_preview_count,omitempty"`
	// ViewID
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s UpdateShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareLinkResponse) GoString() string {
	return s.String()
}

func (s *UpdateShareLinkResponse) SetAccessCount(v int64) *UpdateShareLinkResponse {
	s.AccessCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetCategory(v string) *UpdateShareLinkResponse {
	s.Category = &v
	return s
}

func (s *UpdateShareLinkResponse) SetComments(v string) *UpdateShareLinkResponse {
	s.Comments = &v
	return s
}

func (s *UpdateShareLinkResponse) SetCreatedAt(v string) *UpdateShareLinkResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateShareLinkResponse) SetCreator(v string) *UpdateShareLinkResponse {
	s.Creator = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDescription(v string) *UpdateShareLinkResponse {
	s.Description = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDisableDownload(v bool) *UpdateShareLinkResponse {
	s.DisableDownload = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDisablePreview(v bool) *UpdateShareLinkResponse {
	s.DisablePreview = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDisableSave(v bool) *UpdateShareLinkResponse {
	s.DisableSave = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDownloadCount(v int64) *UpdateShareLinkResponse {
	s.DownloadCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDownloadLimit(v int64) *UpdateShareLinkResponse {
	s.DownloadLimit = &v
	return s
}

func (s *UpdateShareLinkResponse) SetDriveFileList(v []*ShareFile) *UpdateShareLinkResponse {
	s.DriveFileList = v
	return s
}

func (s *UpdateShareLinkResponse) SetDriveId(v string) *UpdateShareLinkResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateShareLinkResponse) SetEnableFileChangedNotify(v bool) *UpdateShareLinkResponse {
	s.EnableFileChangedNotify = &v
	return s
}

func (s *UpdateShareLinkResponse) SetExpiration(v string) *UpdateShareLinkResponse {
	s.Expiration = &v
	return s
}

func (s *UpdateShareLinkResponse) SetExpired(v bool) *UpdateShareLinkResponse {
	s.Expired = &v
	return s
}

func (s *UpdateShareLinkResponse) SetFileId(v string) *UpdateShareLinkResponse {
	s.FileId = &v
	return s
}

func (s *UpdateShareLinkResponse) SetFileIdList(v []*string) *UpdateShareLinkResponse {
	s.FileIdList = v
	return s
}

func (s *UpdateShareLinkResponse) SetFilePathList(v []*string) *UpdateShareLinkResponse {
	s.FilePathList = v
	return s
}

func (s *UpdateShareLinkResponse) SetIsSubscribed(v bool) *UpdateShareLinkResponse {
	s.IsSubscribed = &v
	return s
}

func (s *UpdateShareLinkResponse) SetNumOfSubscribers(v int64) *UpdateShareLinkResponse {
	s.NumOfSubscribers = &v
	return s
}

func (s *UpdateShareLinkResponse) SetPreviewCount(v int64) *UpdateShareLinkResponse {
	s.PreviewCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetPreviewLimit(v int64) *UpdateShareLinkResponse {
	s.PreviewLimit = &v
	return s
}

func (s *UpdateShareLinkResponse) SetReportCount(v int64) *UpdateShareLinkResponse {
	s.ReportCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetRequireLogin(v bool) *UpdateShareLinkResponse {
	s.RequireLogin = &v
	return s
}

func (s *UpdateShareLinkResponse) SetSaveCount(v int64) *UpdateShareLinkResponse {
	s.SaveCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetSaveDownloadLimit(v int64) *UpdateShareLinkResponse {
	s.SaveDownloadLimit = &v
	return s
}

func (s *UpdateShareLinkResponse) SetSaveLimit(v int64) *UpdateShareLinkResponse {
	s.SaveLimit = &v
	return s
}

func (s *UpdateShareLinkResponse) SetShareIcon(v string) *UpdateShareLinkResponse {
	s.ShareIcon = &v
	return s
}

func (s *UpdateShareLinkResponse) SetShareId(v string) *UpdateShareLinkResponse {
	s.ShareId = &v
	return s
}

func (s *UpdateShareLinkResponse) SetShareMsg(v string) *UpdateShareLinkResponse {
	s.ShareMsg = &v
	return s
}

func (s *UpdateShareLinkResponse) SetShareName(v string) *UpdateShareLinkResponse {
	s.ShareName = &v
	return s
}

func (s *UpdateShareLinkResponse) SetSharePolicy(v string) *UpdateShareLinkResponse {
	s.SharePolicy = &v
	return s
}

func (s *UpdateShareLinkResponse) SetSharePwd(v string) *UpdateShareLinkResponse {
	s.SharePwd = &v
	return s
}

func (s *UpdateShareLinkResponse) SetShareUrl(v string) *UpdateShareLinkResponse {
	s.ShareUrl = &v
	return s
}

func (s *UpdateShareLinkResponse) SetStatus(v string) *UpdateShareLinkResponse {
	s.Status = &v
	return s
}

func (s *UpdateShareLinkResponse) SetUpdatedAt(v string) *UpdateShareLinkResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UpdateShareLinkResponse) SetVideoPreviewCount(v int64) *UpdateShareLinkResponse {
	s.VideoPreviewCount = &v
	return s
}

func (s *UpdateShareLinkResponse) SetViewId(v string) *UpdateShareLinkResponse {
	s.ViewId = &v
	return s
}

/**
 * update share request
 */
type UpdateShareRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty" require:"true"`
	// share_name
	ShareName *string `json:"share_name,omitempty" xml:"share_name,omitempty"`
	// share_policy
	SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s UpdateShareRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareRequest) GoString() string {
	return s.String()
}

func (s *UpdateShareRequest) SetHttpheaders(v map[string]*string) *UpdateShareRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateShareRequest) SetDescription(v string) *UpdateShareRequest {
	s.Description = &v
	return s
}

func (s *UpdateShareRequest) SetExpiration(v string) *UpdateShareRequest {
	s.Expiration = &v
	return s
}

func (s *UpdateShareRequest) SetPermissions(v []*string) *UpdateShareRequest {
	s.Permissions = v
	return s
}

func (s *UpdateShareRequest) SetShareId(v string) *UpdateShareRequest {
	s.ShareId = &v
	return s
}

func (s *UpdateShareRequest) SetShareName(v string) *UpdateShareRequest {
	s.ShareName = &v
	return s
}

func (s *UpdateShareRequest) SetSharePolicy(v []*SharePermissionPolicy) *UpdateShareRequest {
	s.SharePolicy = v
	return s
}

func (s *UpdateShareRequest) SetStatus(v string) *UpdateShareRequest {
	s.Status = &v
	return s
}

/**
 * Update share response
 */
type UpdateShareResponse struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain_id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// expired
	Expired *bool `json:"expired,omitempty" xml:"expired,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// owner
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// share_file_id
	ShareFileId *string `json:"share_file_id,omitempty" xml:"share_file_id,omitempty"`
	// share_path
	ShareFilePath *string `json:"share_file_path,omitempty" xml:"share_file_path,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// share_name
	ShareName   *string                  `json:"share_name,omitempty" xml:"share_name,omitempty"`
	SharePolicy []*SharePermissionPolicy `json:"share_policy,omitempty" xml:"share_policy,omitempty" type:"Repeated"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s UpdateShareResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateShareResponse) GoString() string {
	return s.String()
}

func (s *UpdateShareResponse) SetCreatedAt(v string) *UpdateShareResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateShareResponse) SetCreator(v string) *UpdateShareResponse {
	s.Creator = &v
	return s
}

func (s *UpdateShareResponse) SetDescription(v string) *UpdateShareResponse {
	s.Description = &v
	return s
}

func (s *UpdateShareResponse) SetDomainId(v string) *UpdateShareResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateShareResponse) SetDriveId(v string) *UpdateShareResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateShareResponse) SetExpiration(v string) *UpdateShareResponse {
	s.Expiration = &v
	return s
}

func (s *UpdateShareResponse) SetExpired(v bool) *UpdateShareResponse {
	s.Expired = &v
	return s
}

func (s *UpdateShareResponse) SetOwner(v string) *UpdateShareResponse {
	s.Owner = &v
	return s
}

func (s *UpdateShareResponse) SetOwnerType(v string) *UpdateShareResponse {
	s.OwnerType = &v
	return s
}

func (s *UpdateShareResponse) SetPermissions(v []*string) *UpdateShareResponse {
	s.Permissions = v
	return s
}

func (s *UpdateShareResponse) SetShareFileId(v string) *UpdateShareResponse {
	s.ShareFileId = &v
	return s
}

func (s *UpdateShareResponse) SetShareFilePath(v string) *UpdateShareResponse {
	s.ShareFilePath = &v
	return s
}

func (s *UpdateShareResponse) SetShareId(v string) *UpdateShareResponse {
	s.ShareId = &v
	return s
}

func (s *UpdateShareResponse) SetShareName(v string) *UpdateShareResponse {
	s.ShareName = &v
	return s
}

func (s *UpdateShareResponse) SetSharePolicy(v []*SharePermissionPolicy) *UpdateShareResponse {
	s.SharePolicy = v
	return s
}

func (s *UpdateShareResponse) SetStatus(v string) *UpdateShareResponse {
	s.Status = &v
	return s
}

func (s *UpdateShareResponse) SetUpdatedAt(v string) *UpdateShareResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type UpdateSubdomainMgmtRequest struct {
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// subdomain
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// 
	Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
	// quota-1
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty"`
}

func (s UpdateSubdomainMgmtRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubdomainMgmtRequest) GoString() string {
	return s.String()
}

func (s *UpdateSubdomainMgmtRequest) SetDescription(v string) *UpdateSubdomainMgmtRequest {
	s.Description = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetDomainId(v string) *UpdateSubdomainMgmtRequest {
	s.DomainId = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetName(v string) *UpdateSubdomainMgmtRequest {
	s.Name = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetSharable(v bool) *UpdateSubdomainMgmtRequest {
	s.Sharable = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetShareLinkEnabled(v bool) *UpdateSubdomainMgmtRequest {
	s.ShareLinkEnabled = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetStatus(v int64) *UpdateSubdomainMgmtRequest {
	s.Status = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetSubdomainId(v string) *UpdateSubdomainMgmtRequest {
	s.SubdomainId = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetTotalSize(v int64) *UpdateSubdomainMgmtRequest {
	s.TotalSize = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetUsedSizeRefreshInterval(v int64) *UpdateSubdomainMgmtRequest {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *UpdateSubdomainMgmtRequest) SetUserQuota(v int64) *UpdateSubdomainMgmtRequest {
	s.UserQuota = &v
	return s
}

/**
 * form
 */
type UploadFormInfo struct {
	BucketName       *string `json:"bucket_name,omitempty" xml:"bucket_name,omitempty"`
	ObjectKey        *string `json:"object_key,omitempty" xml:"object_key,omitempty"`
	OssAccessKeyId   *string `json:"oss_access_key_id,omitempty" xml:"oss_access_key_id,omitempty"`
	OssEndPoint      *string `json:"oss_end_point,omitempty" xml:"oss_end_point,omitempty"`
	OssSecurityToken *string `json:"oss_security_token,omitempty" xml:"oss_security_token,omitempty"`
	Policy           *string `json:"policy,omitempty" xml:"policy,omitempty"`
	Signature        *string `json:"signature,omitempty" xml:"signature,omitempty"`
}

func (s UploadFormInfo) String() string {
	return tea.Prettify(s)
}

func (s UploadFormInfo) GoString() string {
	return s.String()
}

func (s *UploadFormInfo) SetBucketName(v string) *UploadFormInfo {
	s.BucketName = &v
	return s
}

func (s *UploadFormInfo) SetObjectKey(v string) *UploadFormInfo {
	s.ObjectKey = &v
	return s
}

func (s *UploadFormInfo) SetOssAccessKeyId(v string) *UploadFormInfo {
	s.OssAccessKeyId = &v
	return s
}

func (s *UploadFormInfo) SetOssEndPoint(v string) *UploadFormInfo {
	s.OssEndPoint = &v
	return s
}

func (s *UploadFormInfo) SetOssSecurityToken(v string) *UploadFormInfo {
	s.OssSecurityToken = &v
	return s
}

func (s *UploadFormInfo) SetPolicy(v string) *UploadFormInfo {
	s.Policy = &v
	return s
}

func (s *UploadFormInfo) SetSignature(v string) *UploadFormInfo {
	s.Signature = &v
	return s
}

/**
 *
 */
type UploadPartInfo struct {
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// etag
	Etag                   *string         `json:"etag,omitempty" xml:"etag,omitempty"`
	InternalUploadFormInfo *UploadFormInfo `json:"internal_upload_form_info,omitempty" xml:"internal_upload_form_info,omitempty"`
	// internal_upload_url
	InternalUploadUrl *string  `json:"internal_upload_url,omitempty" xml:"internal_upload_url,omitempty"`
	ParallelSha1Ctx   *SHA1CTX `json:"parallel_sha1_ctx,omitempty" xml:"parallel_sha1_ctx,omitempty"`
	// PartNumber
	PartNumber *int64 `json:"part_number,omitempty" xml:"part_number,omitempty" maximum:"10000" minimum:"1"`
	// PartSize
	PartSize       *int64          `json:"part_size,omitempty" xml:"part_size,omitempty" maximum:"5368709120"`
	UploadFormInfo *UploadFormInfo `json:"upload_form_info,omitempty" xml:"upload_form_info,omitempty"`
	// upload_url
	UploadUrl *string `json:"upload_url,omitempty" xml:"upload_url,omitempty"`
}

func (s UploadPartInfo) String() string {
	return tea.Prettify(s)
}

func (s UploadPartInfo) GoString() string {
	return s.String()
}

func (s *UploadPartInfo) SetContentType(v string) *UploadPartInfo {
	s.ContentType = &v
	return s
}

func (s *UploadPartInfo) SetEtag(v string) *UploadPartInfo {
	s.Etag = &v
	return s
}

func (s *UploadPartInfo) SetInternalUploadFormInfo(v *UploadFormInfo) *UploadPartInfo {
	s.InternalUploadFormInfo = v
	return s
}

func (s *UploadPartInfo) SetInternalUploadUrl(v string) *UploadPartInfo {
	s.InternalUploadUrl = &v
	return s
}

func (s *UploadPartInfo) SetParallelSha1Ctx(v *SHA1CTX) *UploadPartInfo {
	s.ParallelSha1Ctx = v
	return s
}

func (s *UploadPartInfo) SetPartNumber(v int64) *UploadPartInfo {
	s.PartNumber = &v
	return s
}

func (s *UploadPartInfo) SetPartSize(v int64) *UploadPartInfo {
	s.PartSize = &v
	return s
}

func (s *UploadPartInfo) SetUploadFormInfo(v *UploadFormInfo) *UploadPartInfo {
	s.UploadFormInfo = v
	return s
}

func (s *UploadPartInfo) SetUploadUrl(v string) *UploadPartInfo {
	s.UploadUrl = &v
	return s
}

/**
 *
 */
type UrlInfo struct {
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
}

func (s UrlInfo) String() string {
	return tea.Prettify(s)
}

func (s UrlInfo) GoString() string {
	return s.String()
}

func (s *UrlInfo) SetDownloadUrl(v string) *UrlInfo {
	s.DownloadUrl = &v
	return s
}

func (s *UrlInfo) SetThumbnail(v string) *UrlInfo {
	s.Thumbnail = &v
	return s
}

func (s *UrlInfo) SetUrl(v string) *UrlInfo {
	s.Url = &v
	return s
}

/**
 *
 */
type UserAuthentication struct {
	// 
	AuthenticationType *string `json:"AuthenticationType,omitempty" xml:"AuthenticationType,omitempty" require:"true"`
	// 
	CreatedAt *int64 `json:"CreatedAt,omitempty" xml:"CreatedAt,omitempty" require:"true"`
	// 
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty" require:"true"`
	// Domain ID
	DomainID *string `json:"DomainID,omitempty" xml:"DomainID,omitempty" require:"true"`
	// typemobile86
	Extra *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
	// 
	Identity *string `json:"Identity,omitempty" xml:"Identity,omitempty" require:"true"`
	// 
	LastLoginTime *int64 `json:"LastLoginTime,omitempty" xml:"LastLoginTime,omitempty" require:"true"`
	// 
	Status *string `json:"Status,omitempty" xml:"Status,omitempty" require:"true"`
	// ID
	UserID *string `json:"UserID,omitempty" xml:"UserID,omitempty" require:"true"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s UserAuthentication) String() string {
	return tea.Prettify(s)
}

func (s UserAuthentication) GoString() string {
	return s.String()
}

func (s *UserAuthentication) SetAuthenticationType(v string) *UserAuthentication {
	s.AuthenticationType = &v
	return s
}

func (s *UserAuthentication) SetCreatedAt(v int64) *UserAuthentication {
	s.CreatedAt = &v
	return s
}

func (s *UserAuthentication) SetDetail(v string) *UserAuthentication {
	s.Detail = &v
	return s
}

func (s *UserAuthentication) SetDomainID(v string) *UserAuthentication {
	s.DomainID = &v
	return s
}

func (s *UserAuthentication) SetExtra(v string) *UserAuthentication {
	s.Extra = &v
	return s
}

func (s *UserAuthentication) SetIdentity(v string) *UserAuthentication {
	s.Identity = &v
	return s
}

func (s *UserAuthentication) SetLastLoginTime(v int64) *UserAuthentication {
	s.LastLoginTime = &v
	return s
}

func (s *UserAuthentication) SetStatus(v string) *UserAuthentication {
	s.Status = &v
	return s
}

func (s *UserAuthentication) SetUserID(v string) *UserAuthentication {
	s.UserID = &v
	return s
}

func (s *UserAuthentication) SetSubdomainId(v string) *UserAuthentication {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type UserTag struct {
	// key
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// value
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s UserTag) String() string {
	return tea.Prettify(s)
}

func (s UserTag) GoString() string {
	return s.String()
}

func (s *UserTag) SetKey(v string) *UserTag {
	s.Key = &v
	return s
}

func (s *UserTag) SetValue(v string) *UserTag {
	s.Value = &v
	return s
}

/**
 *
 */
type VerifyCodeRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// App ID, App
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// 
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty" require:"true"`
	// 86+
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	// 
	SmsCode *string `json:"sms_code,omitempty" xml:"sms_code,omitempty" require:"true"`
	// ID
	SmsCodeId *string `json:"sms_code_id,omitempty" xml:"sms_code_id,omitempty" require:"true"`
	// 
	VerifyType *string `json:"verify_type,omitempty" xml:"verify_type,omitempty"`
}

func (s VerifyCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyCodeRequest) GoString() string {
	return s.String()
}

func (s *VerifyCodeRequest) SetHttpheaders(v map[string]*string) *VerifyCodeRequest {
	s.Httpheaders = v
	return s
}

func (s *VerifyCodeRequest) SetAppId(v string) *VerifyCodeRequest {
	s.AppId = &v
	return s
}

func (s *VerifyCodeRequest) SetPhoneNumber(v string) *VerifyCodeRequest {
	s.PhoneNumber = &v
	return s
}

func (s *VerifyCodeRequest) SetPhoneRegion(v string) *VerifyCodeRequest {
	s.PhoneRegion = &v
	return s
}

func (s *VerifyCodeRequest) SetSmsCode(v string) *VerifyCodeRequest {
	s.SmsCode = &v
	return s
}

func (s *VerifyCodeRequest) SetSmsCodeId(v string) *VerifyCodeRequest {
	s.SmsCodeId = &v
	return s
}

func (s *VerifyCodeRequest) SetVerifyType(v string) *VerifyCodeRequest {
	s.VerifyType = &v
	return s
}

/**
 *
 */
type VerifyCodeResponse struct {
	// 
	State *string `json:"state,omitempty" xml:"state,omitempty" require:"true"`
}

func (s VerifyCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyCodeResponse) GoString() string {
	return s.String()
}

func (s *VerifyCodeResponse) SetState(v string) *VerifyCodeResponse {
	s.State = &v
	return s
}

/**
 *
 */
type VerifyTokenResponse struct {
	// Token
	Token *string `json:"token,omitempty" xml:"token,omitempty" require:"true"`
	// token1800
	Ttl *int64 `json:"ttl,omitempty" xml:"ttl,omitempty" require:"true"`
	// URLToken
	Url *string `json:"url,omitempty" xml:"url,omitempty" require:"true"`
}

func (s VerifyTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyTokenResponse) GoString() string {
	return s.String()
}

func (s *VerifyTokenResponse) SetToken(v string) *VerifyTokenResponse {
	s.Token = &v
	return s
}

func (s *VerifyTokenResponse) SetTtl(v int64) *VerifyTokenResponse {
	s.Ttl = &v
	return s
}

func (s *VerifyTokenResponse) SetUrl(v string) *VerifyTokenResponse {
	s.Url = &v
	return s
}

/**
 *
 */
type VideoMediaAudioStream struct {
	// bit_rate  bps
	BitRate *string `json:"bit_rate,omitempty" xml:"bit_rate,omitempty"`
	// channel_layout 
	ChannelLayout *string `json:"channel_layout,omitempty" xml:"channel_layout,omitempty"`
	// channels /
	Channels *int64 `json:"channels,omitempty" xml:"channels,omitempty"`
	// code_name 
	CodeName *string `json:"code_name,omitempty" xml:"code_name,omitempty"`
	// duration  
	Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
	// sample_rate 
	SampleRate *string `json:"sample_rate,omitempty" xml:"sample_rate,omitempty"`
}

func (s VideoMediaAudioStream) String() string {
	return tea.Prettify(s)
}

func (s VideoMediaAudioStream) GoString() string {
	return s.String()
}

func (s *VideoMediaAudioStream) SetBitRate(v string) *VideoMediaAudioStream {
	s.BitRate = &v
	return s
}

func (s *VideoMediaAudioStream) SetChannelLayout(v string) *VideoMediaAudioStream {
	s.ChannelLayout = &v
	return s
}

func (s *VideoMediaAudioStream) SetChannels(v int64) *VideoMediaAudioStream {
	s.Channels = &v
	return s
}

func (s *VideoMediaAudioStream) SetCodeName(v string) *VideoMediaAudioStream {
	s.CodeName = &v
	return s
}

func (s *VideoMediaAudioStream) SetDuration(v string) *VideoMediaAudioStream {
	s.Duration = &v
	return s
}

func (s *VideoMediaAudioStream) SetSampleRate(v string) *VideoMediaAudioStream {
	s.SampleRate = &v
	return s
}

/**
 *
 */
type VideoMediaMetadata struct {
	// Duration
	Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
	// taken_at
	TakenAt *string `json:"taken_at,omitempty" xml:"taken_at,omitempty"`
}

func (s VideoMediaMetadata) String() string {
	return tea.Prettify(s)
}

func (s VideoMediaMetadata) GoString() string {
	return s.String()
}

func (s *VideoMediaMetadata) SetDuration(v string) *VideoMediaMetadata {
	s.Duration = &v
	return s
}

func (s *VideoMediaMetadata) SetTakenAt(v string) *VideoMediaMetadata {
	s.TakenAt = &v
	return s
}

/**
 *
 */
type VideoMediaResponse struct {
	// address_line
	AddressLine *string `json:"address_line,omitempty" xml:"address_line,omitempty"`
	// city
	City *string `json:"city,omitempty" xml:"city,omitempty"`
	// country
	Country *string `json:"country,omitempty" xml:"country,omitempty"`
	// district
	District *string `json:"district,omitempty" xml:"district,omitempty"`
	// duration  
	Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
	// height
	Height *int64 `json:"height,omitempty" xml:"height,omitempty"`
	// system_tags
	ImageTags []*SystemTag `json:"image_tags,omitempty" xml:"image_tags,omitempty" type:"Repeated"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// province
	Province *string `json:"province,omitempty" xml:"province,omitempty"`
	// time
	Time *string `json:"time,omitempty" xml:"time,omitempty"`
	// township
	Township              *string                  `json:"township,omitempty" xml:"township,omitempty"`
	VideoMediaAudioStream []*VideoMediaAudioStream `json:"video_media_audio_stream,omitempty" xml:"video_media_audio_stream,omitempty" type:"Repeated"`
	VideoMediaVideoStream []*VideoMediaVideoStream `json:"video_media_video_stream,omitempty" xml:"video_media_video_stream,omitempty" type:"Repeated"`
	// width
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s VideoMediaResponse) GoString() string {
	return s.String()
}

func (s *VideoMediaResponse) SetAddressLine(v string) *VideoMediaResponse {
	s.AddressLine = &v
	return s
}

func (s *VideoMediaResponse) SetCity(v string) *VideoMediaResponse {
	s.City = &v
	return s
}

func (s *VideoMediaResponse) SetCountry(v string) *VideoMediaResponse {
	s.Country = &v
	return s
}

func (s *VideoMediaResponse) SetDistrict(v string) *VideoMediaResponse {
	s.District = &v
	return s
}

func (s *VideoMediaResponse) SetDuration(v string) *VideoMediaResponse {
	s.Duration = &v
	return s
}

func (s *VideoMediaResponse) SetHeight(v int64) *VideoMediaResponse {
	s.Height = &v
	return s
}

func (s *VideoMediaResponse) SetImageTags(v []*SystemTag) *VideoMediaResponse {
	s.ImageTags = v
	return s
}

func (s *VideoMediaResponse) SetLocation(v string) *VideoMediaResponse {
	s.Location = &v
	return s
}

func (s *VideoMediaResponse) SetProvince(v string) *VideoMediaResponse {
	s.Province = &v
	return s
}

func (s *VideoMediaResponse) SetTime(v string) *VideoMediaResponse {
	s.Time = &v
	return s
}

func (s *VideoMediaResponse) SetTownship(v string) *VideoMediaResponse {
	s.Township = &v
	return s
}

func (s *VideoMediaResponse) SetVideoMediaAudioStream(v []*VideoMediaAudioStream) *VideoMediaResponse {
	s.VideoMediaAudioStream = v
	return s
}

func (s *VideoMediaResponse) SetVideoMediaVideoStream(v []*VideoMediaVideoStream) *VideoMediaResponse {
	s.VideoMediaVideoStream = v
	return s
}

func (s *VideoMediaResponse) SetWidth(v int64) *VideoMediaResponse {
	s.Width = &v
	return s
}

/**
 *
 */
type VideoMediaVideoStream struct {
	// bitrate  bps
	Bitrate *string `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
	// clarity 
	Clarity *string `json:"clarity,omitempty" xml:"clarity,omitempty"`
	// code_name 
	CodeName *string `json:"code_name,omitempty" xml:"code_name,omitempty"`
	// duration  
	Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
	// fps 
	Fps *string `json:"fps,omitempty" xml:"fps,omitempty"`
	// rotate  
	Rotate *string `json:"rotate,omitempty" xml:"rotate,omitempty"`
}

func (s VideoMediaVideoStream) String() string {
	return tea.Prettify(s)
}

func (s VideoMediaVideoStream) GoString() string {
	return s.String()
}

func (s *VideoMediaVideoStream) SetBitrate(v string) *VideoMediaVideoStream {
	s.Bitrate = &v
	return s
}

func (s *VideoMediaVideoStream) SetClarity(v string) *VideoMediaVideoStream {
	s.Clarity = &v
	return s
}

func (s *VideoMediaVideoStream) SetCodeName(v string) *VideoMediaVideoStream {
	s.CodeName = &v
	return s
}

func (s *VideoMediaVideoStream) SetDuration(v string) *VideoMediaVideoStream {
	s.Duration = &v
	return s
}

func (s *VideoMediaVideoStream) SetFps(v string) *VideoMediaVideoStream {
	s.Fps = &v
	return s
}

func (s *VideoMediaVideoStream) SetRotate(v string) *VideoMediaVideoStream {
	s.Rotate = &v
	return s
}

/**
 *
 */
type VideoPreviewAudioMeta struct {
	// bitrate
	Bitrate *float64 `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
	// channels
	Channels *int64 `json:"channels,omitempty" xml:"channels,omitempty"`
	// duration
	Duration *float64 `json:"duration,omitempty" xml:"duration,omitempty"`
	// sample_rate
	SampleRate *float64 `json:"sample_rate,omitempty" xml:"sample_rate,omitempty"`
}

func (s VideoPreviewAudioMeta) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAudioMeta) GoString() string {
	return s.String()
}

func (s *VideoPreviewAudioMeta) SetBitrate(v float64) *VideoPreviewAudioMeta {
	s.Bitrate = &v
	return s
}

func (s *VideoPreviewAudioMeta) SetChannels(v int64) *VideoPreviewAudioMeta {
	s.Channels = &v
	return s
}

func (s *VideoPreviewAudioMeta) SetDuration(v float64) *VideoPreviewAudioMeta {
	s.Duration = &v
	return s
}

func (s *VideoPreviewAudioMeta) SetSampleRate(v float64) *VideoPreviewAudioMeta {
	s.SampleRate = &v
	return s
}

/**
 *
 */
type VideoPreviewAudioMusicMeta struct {
	// album
	Album *string `json:"album,omitempty" xml:"album,omitempty"`
	// artist
	Artist *string `json:"artist,omitempty" xml:"artist,omitempty"`
	// cover_url
	CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
	// title
	Title *string `json:"title,omitempty" xml:"title,omitempty"`
}

func (s VideoPreviewAudioMusicMeta) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAudioMusicMeta) GoString() string {
	return s.String()
}

func (s *VideoPreviewAudioMusicMeta) SetAlbum(v string) *VideoPreviewAudioMusicMeta {
	s.Album = &v
	return s
}

func (s *VideoPreviewAudioMusicMeta) SetArtist(v string) *VideoPreviewAudioMusicMeta {
	s.Artist = &v
	return s
}

func (s *VideoPreviewAudioMusicMeta) SetCoverUrl(v string) *VideoPreviewAudioMusicMeta {
	s.CoverUrl = &v
	return s
}

func (s *VideoPreviewAudioMusicMeta) SetTitle(v string) *VideoPreviewAudioMusicMeta {
	s.Title = &v
	return s
}

/**
 * meta
 */
type VideoPreviewPlayInfoMetaResponse struct {
	// duration, 
	Duration *float64 `json:"duration,omitempty" xml:"duration,omitempty"`
	// height, 
	Height              *int64                       `json:"height,omitempty" xml:"height,omitempty"`
	LiveTranscodingMeta *LiveTranscodingMetaResponse `json:"live_transcoding_meta,omitempty" xml:"live_transcoding_meta,omitempty"`
	// width, 
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewPlayInfoMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewPlayInfoMetaResponse) GoString() string {
	return s.String()
}

func (s *VideoPreviewPlayInfoMetaResponse) SetDuration(v float64) *VideoPreviewPlayInfoMetaResponse {
	s.Duration = &v
	return s
}

func (s *VideoPreviewPlayInfoMetaResponse) SetHeight(v int64) *VideoPreviewPlayInfoMetaResponse {
	s.Height = &v
	return s
}

func (s *VideoPreviewPlayInfoMetaResponse) SetLiveTranscodingMeta(v *LiveTranscodingMetaResponse) *VideoPreviewPlayInfoMetaResponse {
	s.LiveTranscodingMeta = v
	return s
}

func (s *VideoPreviewPlayInfoMetaResponse) SetWidth(v int64) *VideoPreviewPlayInfoMetaResponse {
	s.Width = &v
	return s
}

/**
 * 
 */
type VideoPreviewPlayInfoResponse struct {
	// category
	Category                        *string                                `json:"category,omitempty" xml:"category,omitempty"`
	LiveTranscodingSubtitleTaskList []*LiveTranscodingSubtitleTaskResponse `json:"live_transcoding_subtitle_task_list,omitempty" xml:"live_transcoding_subtitle_task_list,omitempty" type:"Repeated"`
	LiveTranscodingTaskList         []*LiveTranscodingTaskResponse         `json:"live_transcoding_task_list,omitempty" xml:"live_transcoding_task_list,omitempty" type:"Repeated"`
	Meta                            *VideoPreviewPlayInfoMetaResponse      `json:"meta,omitempty" xml:"meta,omitempty"`
}

func (s VideoPreviewPlayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewPlayInfoResponse) GoString() string {
	return s.String()
}

func (s *VideoPreviewPlayInfoResponse) SetCategory(v string) *VideoPreviewPlayInfoResponse {
	s.Category = &v
	return s
}

func (s *VideoPreviewPlayInfoResponse) SetLiveTranscodingSubtitleTaskList(v []*LiveTranscodingSubtitleTaskResponse) *VideoPreviewPlayInfoResponse {
	s.LiveTranscodingSubtitleTaskList = v
	return s
}

func (s *VideoPreviewPlayInfoResponse) SetLiveTranscodingTaskList(v []*LiveTranscodingTaskResponse) *VideoPreviewPlayInfoResponse {
	s.LiveTranscodingTaskList = v
	return s
}

func (s *VideoPreviewPlayInfoResponse) SetMeta(v *VideoPreviewPlayInfoMetaResponse) *VideoPreviewPlayInfoResponse {
	s.Meta = v
	return s
}

/**
 *
 */
type VideoPreviewResponse struct {
	// audio_channels
	AudioChannels *int64 `json:"audio_channels,omitempty" xml:"audio_channels,omitempty"`
	// audio_format
	AudioFormat    *string                     `json:"audio_format,omitempty" xml:"audio_format,omitempty"`
	AudioMeta      *VideoPreviewAudioMeta      `json:"audio_meta,omitempty" xml:"audio_meta,omitempty"`
	AudioMusicMeta *VideoPreviewAudioMusicMeta `json:"audio_music_meta,omitempty" xml:"audio_music_meta,omitempty"`
	// audio_sample_rate
	AudioSampleRate *string `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
	// audio_template_list
	AudioTemplateList []*VideoPreviewTranscode `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
	// bitrate
	Bitrate *string `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
	// duration
	Duration *string `json:"duration,omitempty" xml:"duration,omitempty"`
	// frame_rate
	FrameRate *string `json:"frame_rate,omitempty" xml:"frame_rate,omitempty"`
	// height
	Height     *int64                      `json:"height,omitempty" xml:"height,omitempty"`
	SpriteInfo *VideoPreviewSpriteResponse `json:"sprite_info,omitempty" xml:"sprite_info,omitempty"`
	// template_list
	TemplateList []*VideoPreviewTranscode `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// video_format
	VideoFormat *string `json:"video_format,omitempty" xml:"video_format,omitempty"`
	// width
	Width *int64 `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewResponse) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewResponse) GoString() string {
	return s.String()
}

func (s *VideoPreviewResponse) SetAudioChannels(v int64) *VideoPreviewResponse {
	s.AudioChannels = &v
	return s
}

func (s *VideoPreviewResponse) SetAudioFormat(v string) *VideoPreviewResponse {
	s.AudioFormat = &v
	return s
}

func (s *VideoPreviewResponse) SetAudioMeta(v *VideoPreviewAudioMeta) *VideoPreviewResponse {
	s.AudioMeta = v
	return s
}

func (s *VideoPreviewResponse) SetAudioMusicMeta(v *VideoPreviewAudioMusicMeta) *VideoPreviewResponse {
	s.AudioMusicMeta = v
	return s
}

func (s *VideoPreviewResponse) SetAudioSampleRate(v string) *VideoPreviewResponse {
	s.AudioSampleRate = &v
	return s
}

func (s *VideoPreviewResponse) SetAudioTemplateList(v []*VideoPreviewTranscode) *VideoPreviewResponse {
	s.AudioTemplateList = v
	return s
}

func (s *VideoPreviewResponse) SetBitrate(v string) *VideoPreviewResponse {
	s.Bitrate = &v
	return s
}

func (s *VideoPreviewResponse) SetDuration(v string) *VideoPreviewResponse {
	s.Duration = &v
	return s
}

func (s *VideoPreviewResponse) SetFrameRate(v string) *VideoPreviewResponse {
	s.FrameRate = &v
	return s
}

func (s *VideoPreviewResponse) SetHeight(v int64) *VideoPreviewResponse {
	s.Height = &v
	return s
}

func (s *VideoPreviewResponse) SetSpriteInfo(v *VideoPreviewSpriteResponse) *VideoPreviewResponse {
	s.SpriteInfo = v
	return s
}

func (s *VideoPreviewResponse) SetTemplateList(v []*VideoPreviewTranscode) *VideoPreviewResponse {
	s.TemplateList = v
	return s
}

func (s *VideoPreviewResponse) SetThumbnail(v string) *VideoPreviewResponse {
	s.Thumbnail = &v
	return s
}

func (s *VideoPreviewResponse) SetVideoFormat(v string) *VideoPreviewResponse {
	s.VideoFormat = &v
	return s
}

func (s *VideoPreviewResponse) SetWidth(v int64) *VideoPreviewResponse {
	s.Width = &v
	return s
}

/**
 *
 */
type VideoPreviewSpriteResponse struct {
	// col
	Col *int64 `json:"col,omitempty" xml:"col,omitempty"`
	// count
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// frame_count
	FrameCount *int64 `json:"frame_count,omitempty" xml:"frame_count,omitempty"`
	// frame_height
	FrameHeight *int64 `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
	// frame_width
	FrameWidth *int64 `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
	// row
	Row *int64 `json:"row,omitempty" xml:"row,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s VideoPreviewSpriteResponse) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewSpriteResponse) GoString() string {
	return s.String()
}

func (s *VideoPreviewSpriteResponse) SetCol(v int64) *VideoPreviewSpriteResponse {
	s.Col = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetCount(v int64) *VideoPreviewSpriteResponse {
	s.Count = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetFrameCount(v int64) *VideoPreviewSpriteResponse {
	s.FrameCount = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetFrameHeight(v int64) *VideoPreviewSpriteResponse {
	s.FrameHeight = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetFrameWidth(v int64) *VideoPreviewSpriteResponse {
	s.FrameWidth = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetRow(v int64) *VideoPreviewSpriteResponse {
	s.Row = &v
	return s
}

func (s *VideoPreviewSpriteResponse) SetStatus(v string) *VideoPreviewSpriteResponse {
	s.Status = &v
	return s
}

/**
 *
 */
type VideoPreviewTranscode struct {
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// template_id
	TemplateId *string `json:"template_id,omitempty" xml:"template_id,omitempty"`
}

func (s VideoPreviewTranscode) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewTranscode) GoString() string {
	return s.String()
}

func (s *VideoPreviewTranscode) SetStatus(v string) *VideoPreviewTranscode {
	s.Status = &v
	return s
}

func (s *VideoPreviewTranscode) SetTemplateId(v string) *VideoPreviewTranscode {
	s.TemplateId = &v
	return s
}

/**
 *
 */
type WeChatSyncConfig struct {
	Cron    *string `json:"cron,omitempty" xml:"cron,omitempty"`
	Enabled *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	TagId   *string `json:"tag_id,omitempty" xml:"tag_id,omitempty"`
}

func (s WeChatSyncConfig) String() string {
	return tea.Prettify(s)
}

func (s WeChatSyncConfig) GoString() string {
	return s.String()
}

func (s *WeChatSyncConfig) SetCron(v string) *WeChatSyncConfig {
	s.Cron = &v
	return s
}

func (s *WeChatSyncConfig) SetEnabled(v bool) *WeChatSyncConfig {
	s.Enabled = &v
	return s
}

func (s *WeChatSyncConfig) SetTagId(v string) *WeChatSyncConfig {
	s.TagId = &v
	return s
}

/**
 *
 */
type AccountLogDetail struct {
	// authentication_type
	AuthenticationType *string `json:"authentication_type,omitempty" xml:"authentication_type,omitempty"`
	// login_type
	LoginType *string `json:"login_type,omitempty" xml:"login_type,omitempty"`
}

func (s AccountLogDetail) String() string {
	return tea.Prettify(s)
}

func (s AccountLogDetail) GoString() string {
	return s.String()
}

func (s *AccountLogDetail) SetAuthenticationType(v string) *AccountLogDetail {
	s.AuthenticationType = &v
	return s
}

func (s *AccountLogDetail) SetLoginType(v string) *AccountLogDetail {
	s.LoginType = &v
	return s
}

/**
 *
 */
type AddStoreResponse struct {
	// 
	AccelerateEndpoint *string `json:"accelerate_endpoint,omitempty" xml:"accelerate_endpoint,omitempty"`
	// 
	BasePath *string `json:"base_path,omitempty" xml:"base_path,omitempty"`
	// bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty" require:"true"`
	// 
	CdnEndpoint *string `json:"cdn_endpoint,omitempty" xml:"cdn_endpoint,omitempty"`
	// CDNkey
	CdnUrlAuthKey *string `json:"cdn_url_auth_key,omitempty" xml:"cdn_url_auth_key,omitempty"`
	// 
	CustomizedAccelerateEndpoint *string `json:"customized_accelerate_endpoint,omitempty" xml:"customized_accelerate_endpoint,omitempty"`
	// 
	CustomizedCdnEndpoint *string `json:"customized_cdn_endpoint,omitempty" xml:"customized_cdn_endpoint,omitempty"`
	// Public
	CustomizedEndpoint *string `json:"customized_endpoint,omitempty" xml:"customized_endpoint,omitempty"`
	// vpc
	CustomizedInternalEndpoint *string `json:"customized_internal_endpoint,omitempty" xml:"customized_internal_endpoint,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// Public
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty" require:"true"`
	// vpc
	InternalEndpoint *string `json:"internal_endpoint,omitempty" xml:"internal_endpoint,omitempty"`
	// 
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// systemcustom
	Ownership *string `json:"ownership,omitempty" xml:"ownership,omitempty" require:"true"`
	// Policy,systemstorebucket
	Policy *string `json:"policy,omitempty" xml:"policy,omitempty" require:"true"`
	// BucketARN
	RoleArn *string `json:"role_arn,omitempty" xml:"role_arn,omitempty"`
	// store ID
	StoreId *string `json:"store_id,omitempty" xml:"store_id,omitempty" require:"true"`
	// oss
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
}

func (s AddStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s AddStoreResponse) GoString() string {
	return s.String()
}

func (s *AddStoreResponse) SetAccelerateEndpoint(v string) *AddStoreResponse {
	s.AccelerateEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetBasePath(v string) *AddStoreResponse {
	s.BasePath = &v
	return s
}

func (s *AddStoreResponse) SetBucket(v string) *AddStoreResponse {
	s.Bucket = &v
	return s
}

func (s *AddStoreResponse) SetCdnEndpoint(v string) *AddStoreResponse {
	s.CdnEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetCdnUrlAuthKey(v string) *AddStoreResponse {
	s.CdnUrlAuthKey = &v
	return s
}

func (s *AddStoreResponse) SetCustomizedAccelerateEndpoint(v string) *AddStoreResponse {
	s.CustomizedAccelerateEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetCustomizedCdnEndpoint(v string) *AddStoreResponse {
	s.CustomizedCdnEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetCustomizedEndpoint(v string) *AddStoreResponse {
	s.CustomizedEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetCustomizedInternalEndpoint(v string) *AddStoreResponse {
	s.CustomizedInternalEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetDomainId(v string) *AddStoreResponse {
	s.DomainId = &v
	return s
}

func (s *AddStoreResponse) SetEndpoint(v string) *AddStoreResponse {
	s.Endpoint = &v
	return s
}

func (s *AddStoreResponse) SetInternalEndpoint(v string) *AddStoreResponse {
	s.InternalEndpoint = &v
	return s
}

func (s *AddStoreResponse) SetLocation(v string) *AddStoreResponse {
	s.Location = &v
	return s
}

func (s *AddStoreResponse) SetOwnership(v string) *AddStoreResponse {
	s.Ownership = &v
	return s
}

func (s *AddStoreResponse) SetPolicy(v string) *AddStoreResponse {
	s.Policy = &v
	return s
}

func (s *AddStoreResponse) SetRoleArn(v string) *AddStoreResponse {
	s.RoleArn = &v
	return s
}

func (s *AddStoreResponse) SetStoreId(v string) *AddStoreResponse {
	s.StoreId = &v
	return s
}

func (s *AddStoreResponse) SetType(v string) *AddStoreResponse {
	s.Type = &v
	return s
}

/**
 * Add user to subdomain request
 */
type AddUserToSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	Role        *string            `json:"role,omitempty" xml:"role,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s AddUserToSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddUserToSubdomainRequest) GoString() string {
	return s.String()
}

func (s *AddUserToSubdomainRequest) SetHttpheaders(v map[string]*string) *AddUserToSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *AddUserToSubdomainRequest) SetRole(v string) *AddUserToSubdomainRequest {
	s.Role = &v
	return s
}

func (s *AddUserToSubdomainRequest) SetSubdomainId(v string) *AddUserToSubdomainRequest {
	s.SubdomainId = &v
	return s
}

func (s *AddUserToSubdomainRequest) SetUserId(v string) *AddUserToSubdomainRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type AdminListStoresRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
}

func (s AdminListStoresRequest) String() string {
	return tea.Prettify(s)
}

func (s AdminListStoresRequest) GoString() string {
	return s.String()
}

func (s *AdminListStoresRequest) SetHttpheaders(v map[string]*string) *AdminListStoresRequest {
	s.Httpheaders = v
	return s
}

/**
 *
 */
type AppConfig struct {
	AudioPlayEnable              *bool   `json:"audio_play_enable,omitempty" xml:"audio_play_enable,omitempty"`
	BlackAdminMenuItems          *string `json:"black_admin_menu_items,omitempty" xml:"black_admin_menu_items,omitempty"`
	CustomAccountIdentityBase64  *bool   `json:"custom_account_identity_base_64,omitempty" xml:"custom_account_identity_base_64,omitempty"`
	DisableGroup                 *bool   `json:"disable_group,omitempty" xml:"disable_group,omitempty"`
	EnableHiddenFile             *bool   `json:"enable_hidden_file,omitempty" xml:"enable_hidden_file,omitempty"`
	EnableShareLinkCountLimit    *bool   `json:"enable_share_link_count_limit,omitempty" xml:"enable_share_link_count_limit,omitempty"`
	EnableSseOss                 *bool   `json:"enable_sse_oss,omitempty" xml:"enable_sse_oss,omitempty"`
	EnableTransferAcceleration   *bool   `json:"enable_transfer_acceleration,omitempty" xml:"enable_transfer_acceleration,omitempty"`
	EnableUpdateShareLinkByAdmin *bool   `json:"enable_update_share_link_by_admin,omitempty" xml:"enable_update_share_link_by_admin,omitempty"`
	HiddenSwitchUserRoleEntry    *bool   `json:"hidden_switch_user_role_entry,omitempty" xml:"hidden_switch_user_role_entry,omitempty"`
	HideAdminEntry               *bool   `json:"hide_admin_entry,omitempty" xml:"hide_admin_entry,omitempty"`
	HideClientDownloadEntry      *bool   `json:"hide_client_download_entry,omitempty" xml:"hide_client_download_entry,omitempty"`
	HideDriveFileEntry           *bool   `json:"hide_drive_file_entry,omitempty" xml:"hide_drive_file_entry,omitempty"`
	HideLogoutEntry              *bool   `json:"hide_logout_entry,omitempty" xml:"hide_logout_entry,omitempty"`
	HideShareAdminEntry          *bool   `json:"hide_share_admin_entry,omitempty" xml:"hide_share_admin_entry,omitempty"`
	HideSharelinkLogin           *bool   `json:"hide_sharelink_login,omitempty" xml:"hide_sharelink_login,omitempty"`
	HideUserEntry                *bool   `json:"hide_user_entry,omitempty" xml:"hide_user_entry,omitempty"`
	MountAppEnable               *bool   `json:"mount_app_enable,omitempty" xml:"mount_app_enable,omitempty"`
	SameNameFileUploadMode       *string `json:"same_name_file_upload_mode,omitempty" xml:"same_name_file_upload_mode,omitempty"`
	ShowCustomizedLoginConfig    *bool   `json:"show_customized_login_config,omitempty" xml:"show_customized_login_config,omitempty"`
	SyncAppEnable                *bool   `json:"sync_app_enable,omitempty" xml:"sync_app_enable,omitempty"`
	UserCanAccessGroupRecycleBin *bool   `json:"user_can_access_group_recycle_bin,omitempty" xml:"user_can_access_group_recycle_bin,omitempty"`
	VideoPlayEnable              *bool   `json:"video_play_enable,omitempty" xml:"video_play_enable,omitempty"`
	WebClientDownloadMode        *string `json:"web_client_download_mode,omitempty" xml:"web_client_download_mode,omitempty"`
	WebVersion                   *string `json:"web_version,omitempty" xml:"web_version,omitempty"`
	WhiteAdminMenuItems          *string `json:"white_admin_menu_items,omitempty" xml:"white_admin_menu_items,omitempty"`
}

func (s AppConfig) String() string {
	return tea.Prettify(s)
}

func (s AppConfig) GoString() string {
	return s.String()
}

func (s *AppConfig) SetAudioPlayEnable(v bool) *AppConfig {
	s.AudioPlayEnable = &v
	return s
}

func (s *AppConfig) SetBlackAdminMenuItems(v string) *AppConfig {
	s.BlackAdminMenuItems = &v
	return s
}

func (s *AppConfig) SetCustomAccountIdentityBase64(v bool) *AppConfig {
	s.CustomAccountIdentityBase64 = &v
	return s
}

func (s *AppConfig) SetDisableGroup(v bool) *AppConfig {
	s.DisableGroup = &v
	return s
}

func (s *AppConfig) SetEnableHiddenFile(v bool) *AppConfig {
	s.EnableHiddenFile = &v
	return s
}

func (s *AppConfig) SetEnableShareLinkCountLimit(v bool) *AppConfig {
	s.EnableShareLinkCountLimit = &v
	return s
}

func (s *AppConfig) SetEnableSseOss(v bool) *AppConfig {
	s.EnableSseOss = &v
	return s
}

func (s *AppConfig) SetEnableTransferAcceleration(v bool) *AppConfig {
	s.EnableTransferAcceleration = &v
	return s
}

func (s *AppConfig) SetEnableUpdateShareLinkByAdmin(v bool) *AppConfig {
	s.EnableUpdateShareLinkByAdmin = &v
	return s
}

func (s *AppConfig) SetHiddenSwitchUserRoleEntry(v bool) *AppConfig {
	s.HiddenSwitchUserRoleEntry = &v
	return s
}

func (s *AppConfig) SetHideAdminEntry(v bool) *AppConfig {
	s.HideAdminEntry = &v
	return s
}

func (s *AppConfig) SetHideClientDownloadEntry(v bool) *AppConfig {
	s.HideClientDownloadEntry = &v
	return s
}

func (s *AppConfig) SetHideDriveFileEntry(v bool) *AppConfig {
	s.HideDriveFileEntry = &v
	return s
}

func (s *AppConfig) SetHideLogoutEntry(v bool) *AppConfig {
	s.HideLogoutEntry = &v
	return s
}

func (s *AppConfig) SetHideShareAdminEntry(v bool) *AppConfig {
	s.HideShareAdminEntry = &v
	return s
}

func (s *AppConfig) SetHideSharelinkLogin(v bool) *AppConfig {
	s.HideSharelinkLogin = &v
	return s
}

func (s *AppConfig) SetHideUserEntry(v bool) *AppConfig {
	s.HideUserEntry = &v
	return s
}

func (s *AppConfig) SetMountAppEnable(v bool) *AppConfig {
	s.MountAppEnable = &v
	return s
}

func (s *AppConfig) SetSameNameFileUploadMode(v string) *AppConfig {
	s.SameNameFileUploadMode = &v
	return s
}

func (s *AppConfig) SetShowCustomizedLoginConfig(v bool) *AppConfig {
	s.ShowCustomizedLoginConfig = &v
	return s
}

func (s *AppConfig) SetSyncAppEnable(v bool) *AppConfig {
	s.SyncAppEnable = &v
	return s
}

func (s *AppConfig) SetUserCanAccessGroupRecycleBin(v bool) *AppConfig {
	s.UserCanAccessGroupRecycleBin = &v
	return s
}

func (s *AppConfig) SetVideoPlayEnable(v bool) *AppConfig {
	s.VideoPlayEnable = &v
	return s
}

func (s *AppConfig) SetWebClientDownloadMode(v string) *AppConfig {
	s.WebClientDownloadMode = &v
	return s
}

func (s *AppConfig) SetWebVersion(v string) *AppConfig {
	s.WebVersion = &v
	return s
}

func (s *AppConfig) SetWhiteAdminMenuItems(v string) *AppConfig {
	s.WhiteAdminMenuItems = &v
	return s
}

/**
 *
 */
type AssignRoleSettingDetail struct {
	// manage_resource_id
	ManageResourceId *string `json:"manage_resource_id,omitempty" xml:"manage_resource_id,omitempty"`
	// manage_resource_name
	ManageResourceName *string `json:"manage_resource_name,omitempty" xml:"manage_resource_name,omitempty"`
	// manage_resource_type
	ManageResourceType *string `json:"manage_resource_type,omitempty" xml:"manage_resource_type,omitempty"`
	// role_id
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty"`
}

func (s AssignRoleSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s AssignRoleSettingDetail) GoString() string {
	return s.String()
}

func (s *AssignRoleSettingDetail) SetManageResourceId(v string) *AssignRoleSettingDetail {
	s.ManageResourceId = &v
	return s
}

func (s *AssignRoleSettingDetail) SetManageResourceName(v string) *AssignRoleSettingDetail {
	s.ManageResourceName = &v
	return s
}

func (s *AssignRoleSettingDetail) SetManageResourceType(v string) *AssignRoleSettingDetail {
	s.ManageResourceType = &v
	return s
}

func (s *AssignRoleSettingDetail) SetRoleId(v string) *AssignRoleSettingDetail {
	s.RoleId = &v
	return s
}

/**
 * Get AsyncTask Response
 */
type AsyncTaskResponse struct {
	// async_task_id
	// type:string
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// err_code
	ErrCode *int64 `json:"err_code,omitempty" xml:"err_code,omitempty"`
	// message
	Message *string `json:"message,omitempty" xml:"message,omitempty"`
	// state
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s AsyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s AsyncTaskResponse) GoString() string {
	return s.String()
}

func (s *AsyncTaskResponse) SetAsyncTaskId(v string) *AsyncTaskResponse {
	s.AsyncTaskId = &v
	return s
}

func (s *AsyncTaskResponse) SetCreatedAt(v int64) *AsyncTaskResponse {
	s.CreatedAt = &v
	return s
}

func (s *AsyncTaskResponse) SetErrCode(v int64) *AsyncTaskResponse {
	s.ErrCode = &v
	return s
}

func (s *AsyncTaskResponse) SetMessage(v string) *AsyncTaskResponse {
	s.Message = &v
	return s
}

func (s *AsyncTaskResponse) SetState(v string) *AsyncTaskResponse {
	s.State = &v
	return s
}

func (s *AsyncTaskResponse) SetType(v string) *AsyncTaskResponse {
	s.Type = &v
	return s
}

/**
 *
 */
type AuditLogConfig struct {
	ActiveLogKeepDays *int64 `json:"active_log_keep_days,omitempty" xml:"active_log_keep_days,omitempty"`
	Enabled           *bool  `json:"enabled,omitempty" xml:"enabled,omitempty"`
	RedirectEnabled   *bool  `json:"redirect_enabled,omitempty" xml:"redirect_enabled,omitempty"`
}

func (s AuditLogConfig) String() string {
	return tea.Prettify(s)
}

func (s AuditLogConfig) GoString() string {
	return s.String()
}

func (s *AuditLogConfig) SetActiveLogKeepDays(v int64) *AuditLogConfig {
	s.ActiveLogKeepDays = &v
	return s
}

func (s *AuditLogConfig) SetEnabled(v bool) *AuditLogConfig {
	s.Enabled = &v
	return s
}

func (s *AuditLogConfig) SetRedirectEnabled(v bool) *AuditLogConfig {
	s.RedirectEnabled = &v
	return s
}

/**
 *
 */
type AuditMgmtLogDetail struct {
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
}

func (s AuditMgmtLogDetail) String() string {
	return tea.Prettify(s)
}

func (s AuditMgmtLogDetail) GoString() string {
	return s.String()
}

func (s *AuditMgmtLogDetail) SetFileName(v string) *AuditMgmtLogDetail {
	s.FileName = &v
	return s
}

func (s *AuditMgmtLogDetail) SetQuery(v string) *AuditMgmtLogDetail {
	s.Query = &v
	return s
}

/**
 *
 */
type BaseAuditLogRequest struct {
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
}

func (s BaseAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseAuditLogRequest) GoString() string {
	return s.String()
}

func (s *BaseAuditLogRequest) SetOrderBy(v string) *BaseAuditLogRequest {
	s.OrderBy = &v
	return s
}

func (s *BaseAuditLogRequest) SetQuery(v string) *BaseAuditLogRequest {
	s.Query = &v
	return s
}

/**
 *
 */
type BaseAuditLogResponse struct {
	// 
	ClientDevice *string `json:"ClientDevice,omitempty" xml:"ClientDevice,omitempty"`
	// IP
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
	// 
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// 
	ClientVersion *string `json:"ClientVersion,omitempty" xml:"ClientVersion,omitempty"`
	// 
	ActedAt *string `json:"acted_at,omitempty" xml:"acted_at,omitempty"`
	// 
	ActionCategory *string `json:"action_category,omitempty" xml:"action_category,omitempty"`
	// 
	ActionType *string `json:"action_type,omitempty" xml:"action_type,omitempty"`
	// ID
	ActorId *string `json:"actor_id,omitempty" xml:"actor_id,omitempty"`
	// 
	ActorName *string `json:"actor_name,omitempty" xml:"actor_name,omitempty"`
	// 
	ActorType *string    `json:"actor_type,omitempty" xml:"actor_type,omitempty"`
	Detail    *LogDetail `json:"detail,omitempty" xml:"detail,omitempty"`
	// 
	FilePathType *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	// 
	LogId *string `json:"log_id,omitempty" xml:"log_id,omitempty"`
	// ID
	ObjectId *string `json:"object_id,omitempty" xml:"object_id,omitempty"`
	// 
	ObjectName *string `json:"object_name,omitempty" xml:"object_name,omitempty"`
}

func (s BaseAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseAuditLogResponse) GoString() string {
	return s.String()
}

func (s *BaseAuditLogResponse) SetClientDevice(v string) *BaseAuditLogResponse {
	s.ClientDevice = &v
	return s
}

func (s *BaseAuditLogResponse) SetClientIP(v string) *BaseAuditLogResponse {
	s.ClientIP = &v
	return s
}

func (s *BaseAuditLogResponse) SetClientType(v string) *BaseAuditLogResponse {
	s.ClientType = &v
	return s
}

func (s *BaseAuditLogResponse) SetClientVersion(v string) *BaseAuditLogResponse {
	s.ClientVersion = &v
	return s
}

func (s *BaseAuditLogResponse) SetActedAt(v string) *BaseAuditLogResponse {
	s.ActedAt = &v
	return s
}

func (s *BaseAuditLogResponse) SetActionCategory(v string) *BaseAuditLogResponse {
	s.ActionCategory = &v
	return s
}

func (s *BaseAuditLogResponse) SetActionType(v string) *BaseAuditLogResponse {
	s.ActionType = &v
	return s
}

func (s *BaseAuditLogResponse) SetActorId(v string) *BaseAuditLogResponse {
	s.ActorId = &v
	return s
}

func (s *BaseAuditLogResponse) SetActorName(v string) *BaseAuditLogResponse {
	s.ActorName = &v
	return s
}

func (s *BaseAuditLogResponse) SetActorType(v string) *BaseAuditLogResponse {
	s.ActorType = &v
	return s
}

func (s *BaseAuditLogResponse) SetDetail(v *LogDetail) *BaseAuditLogResponse {
	s.Detail = v
	return s
}

func (s *BaseAuditLogResponse) SetFilePathType(v string) *BaseAuditLogResponse {
	s.FilePathType = &v
	return s
}

func (s *BaseAuditLogResponse) SetLogId(v string) *BaseAuditLogResponse {
	s.LogId = &v
	return s
}

func (s *BaseAuditLogResponse) SetObjectId(v string) *BaseAuditLogResponse {
	s.ObjectId = &v
	return s
}

func (s *BaseAuditLogResponse) SetObjectName(v string) *BaseAuditLogResponse {
	s.ObjectName = &v
	return s
}

/**
 * base domain response
 */
type BaseDomainResponse struct {
	// Domain APICName
	ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
	// Domain AppCName
	AppCname  *string    `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
	AppConfig *AppConfig `json:"app_config,omitempty" xml:"app_config,omitempty"`
	// 
	ArchiveFilesEnable *bool           `json:"archive_files_enable,omitempty" xml:"archive_files_enable,omitempty"`
	AuditLogConfig     *AuditLogConfig `json:"audit_log_config,omitempty" xml:"audit_log_config,omitempty"`
	// Domain AuthCName
	AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
	// 
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable *bool                  `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	Benefits      map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
	// Domain 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	//  Hash 
	DataHashName            *string                 `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// 
	EnterpriseCustomizedLogin *bool `json:"enterprise_customized_login,omitempty" xml:"enterprise_customized_login,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	// domain
	ExpireTime              *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	GroupSingleDriveEnabled *bool  `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	//  Drive  Store ID
	InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
	// Domain 
	Mode                  *string              `json:"mode,omitempty" xml:"mode,omitempty"`
	OfficeEditConfig      *OfficeEditConfig    `json:"office_edit_config,omitempty" xml:"office_edit_config,omitempty"`
	OfficePreviewConfig   *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
	ParallelUploadEnabled *bool                `json:"parallel_upload_enabled,omitempty" xml:"parallel_upload_enabled,omitempty"`
	// Parent Domain ID
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
	// Domain 
	PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
	// 
	PrepaidPackage             *string            `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	RecycleBinConfig           *RecycleBinConfig  `json:"recycle_bin_config,omitempty" xml:"recycle_bin_config,omitempty"`
	RoleConfig                 *RoleConfig        `json:"role_config,omitempty" xml:"role_config,omitempty"`
	// Domain ServiceCode
	ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// SPI  id
	SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
	// domain
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// 
	StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
	//  Region 
	StoreRegionList []*string        `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
	SubdomainConfig *SubdomainConfig `json:"subdomain_config,omitempty" xml:"subdomain_config,omitempty"`
	// Domain 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// 
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// usergroupdrive
	UserSingleDriveEnabled *bool                        `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
	VideoPreviewAppConfig  *VideoPreviewAppConfig       `json:"video_preview_app_config,omitempty" xml:"video_preview_app_config,omitempty"`
	VideoPreviewConfig     *VideoPreviewConfig          `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
	WatermarkConfig        *BaseWatermarkConfigResponse `json:"watermark_config,omitempty" xml:"watermark_config,omitempty"`
}

func (s BaseDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseDomainResponse) GoString() string {
	return s.String()
}

func (s *BaseDomainResponse) SetApiCname(v string) *BaseDomainResponse {
	s.ApiCname = &v
	return s
}

func (s *BaseDomainResponse) SetAppCname(v string) *BaseDomainResponse {
	s.AppCname = &v
	return s
}

func (s *BaseDomainResponse) SetAppConfig(v *AppConfig) *BaseDomainResponse {
	s.AppConfig = v
	return s
}

func (s *BaseDomainResponse) SetArchiveFilesEnable(v bool) *BaseDomainResponse {
	s.ArchiveFilesEnable = &v
	return s
}

func (s *BaseDomainResponse) SetAuditLogConfig(v *AuditLogConfig) *BaseDomainResponse {
	s.AuditLogConfig = v
	return s
}

func (s *BaseDomainResponse) SetAuthCname(v string) *BaseDomainResponse {
	s.AuthCname = &v
	return s
}

func (s *BaseDomainResponse) SetAuthConfig(v map[string]interface{}) *BaseDomainResponse {
	s.AuthConfig = v
	return s
}

func (s *BaseDomainResponse) SetAuthDingdingAppId(v string) *BaseDomainResponse {
	s.AuthDingdingAppId = &v
	return s
}

func (s *BaseDomainResponse) SetAuthDingdingAppSecret(v string) *BaseDomainResponse {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *BaseDomainResponse) SetAuthDingdingEnable(v bool) *BaseDomainResponse {
	s.AuthDingdingEnable = &v
	return s
}

func (s *BaseDomainResponse) SetAuthRamAppId(v string) *BaseDomainResponse {
	s.AuthRamAppId = &v
	return s
}

func (s *BaseDomainResponse) SetAuthRamAppSecret(v string) *BaseDomainResponse {
	s.AuthRamAppSecret = &v
	return s
}

func (s *BaseDomainResponse) SetAuthRamEnable(v bool) *BaseDomainResponse {
	s.AuthRamEnable = &v
	return s
}

func (s *BaseDomainResponse) SetBenefits(v map[string]interface{}) *BaseDomainResponse {
	s.Benefits = v
	return s
}

func (s *BaseDomainResponse) SetCreatedAt(v string) *BaseDomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseDomainResponse) SetDataHashName(v string) *BaseDomainResponse {
	s.DataHashName = &v
	return s
}

func (s *BaseDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *BaseDomainResponse {
	s.DefaultSuperAdminConfig = v
	return s
}

func (s *BaseDomainResponse) SetDescription(v string) *BaseDomainResponse {
	s.Description = &v
	return s
}

func (s *BaseDomainResponse) SetDomainId(v string) *BaseDomainResponse {
	s.DomainId = &v
	return s
}

func (s *BaseDomainResponse) SetDomainName(v string) *BaseDomainResponse {
	s.DomainName = &v
	return s
}

func (s *BaseDomainResponse) SetEnterpriseCustomizedLogin(v bool) *BaseDomainResponse {
	s.EnterpriseCustomizedLogin = &v
	return s
}

func (s *BaseDomainResponse) SetEventFilenameMatches(v string) *BaseDomainResponse {
	s.EventFilenameMatches = &v
	return s
}

func (s *BaseDomainResponse) SetEventMnsEndpoint(v string) *BaseDomainResponse {
	s.EventMnsEndpoint = &v
	return s
}

func (s *BaseDomainResponse) SetEventMnsTopic(v string) *BaseDomainResponse {
	s.EventMnsTopic = &v
	return s
}

func (s *BaseDomainResponse) SetEventNames(v []*string) *BaseDomainResponse {
	s.EventNames = v
	return s
}

func (s *BaseDomainResponse) SetEventRoleArn(v string) *BaseDomainResponse {
	s.EventRoleArn = &v
	return s
}

func (s *BaseDomainResponse) SetExpireTime(v int64) *BaseDomainResponse {
	s.ExpireTime = &v
	return s
}

func (s *BaseDomainResponse) SetGroupSingleDriveEnabled(v bool) *BaseDomainResponse {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *BaseDomainResponse) SetInitDriveEnable(v bool) *BaseDomainResponse {
	s.InitDriveEnable = &v
	return s
}

func (s *BaseDomainResponse) SetInitDriveSize(v int64) *BaseDomainResponse {
	s.InitDriveSize = &v
	return s
}

func (s *BaseDomainResponse) SetInitDriveStoreId(v string) *BaseDomainResponse {
	s.InitDriveStoreId = &v
	return s
}

func (s *BaseDomainResponse) SetMode(v string) *BaseDomainResponse {
	s.Mode = &v
	return s
}

func (s *BaseDomainResponse) SetOfficeEditConfig(v *OfficeEditConfig) *BaseDomainResponse {
	s.OfficeEditConfig = v
	return s
}

func (s *BaseDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *BaseDomainResponse {
	s.OfficePreviewConfig = v
	return s
}

func (s *BaseDomainResponse) SetParallelUploadEnabled(v bool) *BaseDomainResponse {
	s.ParallelUploadEnabled = &v
	return s
}

func (s *BaseDomainResponse) SetParentDomainId(v string) *BaseDomainResponse {
	s.ParentDomainId = &v
	return s
}

func (s *BaseDomainResponse) SetPathType(v string) *BaseDomainResponse {
	s.PathType = &v
	return s
}

func (s *BaseDomainResponse) SetPrepaidPackage(v string) *BaseDomainResponse {
	s.PrepaidPackage = &v
	return s
}

func (s *BaseDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *BaseDomainResponse {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *BaseDomainResponse) SetRecycleBinConfig(v *RecycleBinConfig) *BaseDomainResponse {
	s.RecycleBinConfig = v
	return s
}

func (s *BaseDomainResponse) SetRoleConfig(v *RoleConfig) *BaseDomainResponse {
	s.RoleConfig = v
	return s
}

func (s *BaseDomainResponse) SetServiceCode(v string) *BaseDomainResponse {
	s.ServiceCode = &v
	return s
}

func (s *BaseDomainResponse) SetSharable(v bool) *BaseDomainResponse {
	s.Sharable = &v
	return s
}

func (s *BaseDomainResponse) SetShareDetail(v *ShareDetailResponse) *BaseDomainResponse {
	s.ShareDetail = v
	return s
}

func (s *BaseDomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *BaseDomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *BaseDomainResponse) SetShareLinkEnabled(v bool) *BaseDomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *BaseDomainResponse) SetSizeQuota(v int64) *BaseDomainResponse {
	s.SizeQuota = &v
	return s
}

func (s *BaseDomainResponse) SetSpiInstanceId(v string) *BaseDomainResponse {
	s.SpiInstanceId = &v
	return s
}

func (s *BaseDomainResponse) SetStatus(v int64) *BaseDomainResponse {
	s.Status = &v
	return s
}

func (s *BaseDomainResponse) SetStoreLevel(v string) *BaseDomainResponse {
	s.StoreLevel = &v
	return s
}

func (s *BaseDomainResponse) SetStoreRegionList(v []*string) *BaseDomainResponse {
	s.StoreRegionList = v
	return s
}

func (s *BaseDomainResponse) SetSubdomainConfig(v *SubdomainConfig) *BaseDomainResponse {
	s.SubdomainConfig = v
	return s
}

func (s *BaseDomainResponse) SetUpdatedAt(v string) *BaseDomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseDomainResponse) SetUsedSize(v int64) *BaseDomainResponse {
	s.UsedSize = &v
	return s
}

func (s *BaseDomainResponse) SetUsedSizeRefreshInterval(v int64) *BaseDomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *BaseDomainResponse) SetUserCountQuota(v int64) *BaseDomainResponse {
	s.UserCountQuota = &v
	return s
}

func (s *BaseDomainResponse) SetUserSingleDriveEnabled(v bool) *BaseDomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

func (s *BaseDomainResponse) SetVideoPreviewAppConfig(v *VideoPreviewAppConfig) *BaseDomainResponse {
	s.VideoPreviewAppConfig = v
	return s
}

func (s *BaseDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *BaseDomainResponse {
	s.VideoPreviewConfig = v
	return s
}

func (s *BaseDomainResponse) SetWatermarkConfig(v *BaseWatermarkConfigResponse) *BaseDomainResponse {
	s.WatermarkConfig = v
	return s
}

/**
 *
 */
type BaseGroupIDRequest struct {
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s BaseGroupIDRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseGroupIDRequest) GoString() string {
	return s.String()
}

func (s *BaseGroupIDRequest) SetGroupId(v string) *BaseGroupIDRequest {
	s.GroupId = &v
	return s
}

func (s *BaseGroupIDRequest) SetSubdomainId(v string) *BaseGroupIDRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type BaseGroupRequest struct {
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
	// group
	IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
}

func (s BaseGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseGroupRequest) GoString() string {
	return s.String()
}

func (s *BaseGroupRequest) SetDescription(v string) *BaseGroupRequest {
	s.Description = &v
	return s
}

func (s *BaseGroupRequest) SetGroupName(v string) *BaseGroupRequest {
	s.GroupName = &v
	return s
}

func (s *BaseGroupRequest) SetIsRoot(v bool) *BaseGroupRequest {
	s.IsRoot = &v
	return s
}

/**
 *
 */
type BaseIdentityBenefitPkgDeliveryInfoRequest struct {
	// 
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// 
	DeliveryId *string `json:"delivery_id,omitempty" xml:"delivery_id,omitempty"`
	// 
	ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
}

func (s BaseIdentityBenefitPkgDeliveryInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseIdentityBenefitPkgDeliveryInfoRequest) GoString() string {
	return s.String()
}

func (s *BaseIdentityBenefitPkgDeliveryInfoRequest) SetAmount(v int64) *BaseIdentityBenefitPkgDeliveryInfoRequest {
	s.Amount = &v
	return s
}

func (s *BaseIdentityBenefitPkgDeliveryInfoRequest) SetDeliveryId(v string) *BaseIdentityBenefitPkgDeliveryInfoRequest {
	s.DeliveryId = &v
	return s
}

func (s *BaseIdentityBenefitPkgDeliveryInfoRequest) SetExpireTime(v int64) *BaseIdentityBenefitPkgDeliveryInfoRequest {
	s.ExpireTime = &v
	return s
}

/**
 *
 */
type BaseIdentityToBenefitPkgMappingRequest struct {
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
}

func (s BaseIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *BaseIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *BaseIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *BaseIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *BaseIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

/**
 * Identity to benefit pkg mapping info
 */
type BaseIdentityToBenefitPkgMappingResponse struct {
	BenefitPkgComputationRule *string                           `json:"benefit_pkg_computation_rule,omitempty" xml:"benefit_pkg_computation_rule,omitempty"`
	BenefitPkgId              *string                           `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
	BenefitPkgName            *string                           `json:"benefit_pkg_name,omitempty" xml:"benefit_pkg_name,omitempty"`
	BenefitPkgOwnerId         *string                           `json:"benefit_pkg_owner_id,omitempty" xml:"benefit_pkg_owner_id,omitempty"`
	BenefitPkgPriority        *int64                            `json:"benefit_pkg_priority,omitempty" xml:"benefit_pkg_priority,omitempty"`
	BenefitPkgType            *string                           `json:"benefit_pkg_type,omitempty" xml:"benefit_pkg_type,omitempty"`
	CreatedAt                 *string                           `json:"created_at,omitempty" xml:"created_at,omitempty"`
	CustomBenefitMeta         map[string]interface{}            `json:"custom_benefit_meta,omitempty" xml:"custom_benefit_meta,omitempty"`
	DeliveryInfoList          []*BenefitPkgDeliveryInfoResponse `json:"delivery_info_list,omitempty" xml:"delivery_info_list,omitempty" type:"Repeated"`
	IdentityId                *string                           `json:"identity_id,omitempty" xml:"identity_id,omitempty"`
	IdentityType              *string                           `json:"identity_type,omitempty" xml:"identity_type,omitempty"`
	UpdatedAt                 *string                           `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseIdentityToBenefitPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseIdentityToBenefitPkgMappingResponse) GoString() string {
	return s.String()
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgComputationRule(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgComputationRule = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgId(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgId = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgName(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgName = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgOwnerId(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgOwnerId = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgPriority(v int64) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgPriority = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetBenefitPkgType(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.BenefitPkgType = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetCreatedAt(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetCustomBenefitMeta(v map[string]interface{}) *BaseIdentityToBenefitPkgMappingResponse {
	s.CustomBenefitMeta = v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetDeliveryInfoList(v []*BenefitPkgDeliveryInfoResponse) *BaseIdentityToBenefitPkgMappingResponse {
	s.DeliveryInfoList = v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetIdentityId(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.IdentityId = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetIdentityType(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.IdentityType = &v
	return s
}

func (s *BaseIdentityToBenefitPkgMappingResponse) SetUpdatedAt(v string) *BaseIdentityToBenefitPkgMappingResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type BaseSubdomainResponse struct {
	// 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// 
	Description           *string `json:"description,omitempty" xml:"description,omitempty" require:"true"`
	GroupSingeDriveEnable *bool   `json:"group_singe_drive_enable,omitempty" xml:"group_singe_drive_enable,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
	// quota-1
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty" require:"true"`
	// 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserQuota              *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty" require:"true"`
	UserSingleDriveEnabled *bool  `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
}

func (s BaseSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseSubdomainResponse) GoString() string {
	return s.String()
}

func (s *BaseSubdomainResponse) SetCreatedAt(v string) *BaseSubdomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseSubdomainResponse) SetDescription(v string) *BaseSubdomainResponse {
	s.Description = &v
	return s
}

func (s *BaseSubdomainResponse) SetGroupSingeDriveEnable(v bool) *BaseSubdomainResponse {
	s.GroupSingeDriveEnable = &v
	return s
}

func (s *BaseSubdomainResponse) SetName(v string) *BaseSubdomainResponse {
	s.Name = &v
	return s
}

func (s *BaseSubdomainResponse) SetSharable(v bool) *BaseSubdomainResponse {
	s.Sharable = &v
	return s
}

func (s *BaseSubdomainResponse) SetShareDetail(v *ShareDetailResponse) *BaseSubdomainResponse {
	s.ShareDetail = v
	return s
}

func (s *BaseSubdomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *BaseSubdomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *BaseSubdomainResponse) SetShareLinkEnabled(v bool) *BaseSubdomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *BaseSubdomainResponse) SetStatus(v int64) *BaseSubdomainResponse {
	s.Status = &v
	return s
}

func (s *BaseSubdomainResponse) SetSubdomainId(v string) *BaseSubdomainResponse {
	s.SubdomainId = &v
	return s
}

func (s *BaseSubdomainResponse) SetTotalSize(v int64) *BaseSubdomainResponse {
	s.TotalSize = &v
	return s
}

func (s *BaseSubdomainResponse) SetUpdatedAt(v string) *BaseSubdomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseSubdomainResponse) SetUsedSize(v int64) *BaseSubdomainResponse {
	s.UsedSize = &v
	return s
}

func (s *BaseSubdomainResponse) SetUsedSizeRefreshInterval(v int64) *BaseSubdomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *BaseSubdomainResponse) SetUserQuota(v int64) *BaseSubdomainResponse {
	s.UserQuota = &v
	return s
}

func (s *BaseSubdomainResponse) SetUserSingleDriveEnabled(v bool) *BaseSubdomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

/**
 * base watermark config response
 */
type BaseWatermarkConfigResponse struct {
	Bold                        *bool   `json:"bold,omitempty" xml:"bold,omitempty"`
	DisplayAccessUserName       *bool   `json:"display_access_user_name,omitempty" xml:"display_access_user_name,omitempty"`
	DisplayCustomText           *string `json:"display_custom_text,omitempty" xml:"display_custom_text,omitempty"`
	DisplayShareLinkCreatorName *bool   `json:"display_shareLink_creator_name,omitempty" xml:"display_shareLink_creator_name,omitempty"`
	EnableDocPreview            *bool   `json:"enable_doc_preview,omitempty" xml:"enable_doc_preview,omitempty"`
	EnableOnPreview             *bool   `json:"enable_on_preview,omitempty" xml:"enable_on_preview,omitempty"`
	FillStyle                   *string `json:"fill_style,omitempty" xml:"fill_style,omitempty"`
	Font                        *string `json:"font,omitempty" xml:"font,omitempty"`
	Horizontal                  *int64  `json:"horizontal,omitempty" xml:"horizontal,omitempty"`
	Rotate                      *int64  `json:"rotate,omitempty" xml:"rotate,omitempty"`
	Size                        *int64  `json:"size,omitempty" xml:"size,omitempty"`
	Vertical                    *int64  `json:"vertical,omitempty" xml:"vertical,omitempty"`
}

func (s BaseWatermarkConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseWatermarkConfigResponse) GoString() string {
	return s.String()
}

func (s *BaseWatermarkConfigResponse) SetBold(v bool) *BaseWatermarkConfigResponse {
	s.Bold = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetDisplayAccessUserName(v bool) *BaseWatermarkConfigResponse {
	s.DisplayAccessUserName = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetDisplayCustomText(v string) *BaseWatermarkConfigResponse {
	s.DisplayCustomText = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetDisplayShareLinkCreatorName(v bool) *BaseWatermarkConfigResponse {
	s.DisplayShareLinkCreatorName = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetEnableDocPreview(v bool) *BaseWatermarkConfigResponse {
	s.EnableDocPreview = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetEnableOnPreview(v bool) *BaseWatermarkConfigResponse {
	s.EnableOnPreview = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetFillStyle(v string) *BaseWatermarkConfigResponse {
	s.FillStyle = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetFont(v string) *BaseWatermarkConfigResponse {
	s.Font = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetHorizontal(v int64) *BaseWatermarkConfigResponse {
	s.Horizontal = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetRotate(v int64) *BaseWatermarkConfigResponse {
	s.Rotate = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetSize(v int64) *BaseWatermarkConfigResponse {
	s.Size = &v
	return s
}

func (s *BaseWatermarkConfigResponse) SetVertical(v int64) *BaseWatermarkConfigResponse {
	s.Vertical = &v
	return s
}

/**
 * Benefit base info of benefit package
 */
type BenefitBaseResponse struct {
	// 
	BenefitId   *string              `json:"benefit_id,omitempty" xml:"benefit_id,omitempty"`
	BenefitMeta *BenefitMetaResponse `json:"benefit_meta,omitempty" xml:"benefit_meta,omitempty"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s BenefitBaseResponse) String() string {
	return tea.Prettify(s)
}

func (s BenefitBaseResponse) GoString() string {
	return s.String()
}

func (s *BenefitBaseResponse) SetBenefitId(v string) *BenefitBaseResponse {
	s.BenefitId = &v
	return s
}

func (s *BenefitBaseResponse) SetBenefitMeta(v *BenefitMetaResponse) *BenefitBaseResponse {
	s.BenefitMeta = v
	return s
}

func (s *BenefitBaseResponse) SetBenefitPkgId(v string) *BenefitBaseResponse {
	s.BenefitPkgId = &v
	return s
}

func (s *BenefitBaseResponse) SetName(v string) *BenefitBaseResponse {
	s.Name = &v
	return s
}

/**
 * 
 */
type BenefitMeta struct {
	Config  *string `json:"config,omitempty" xml:"config,omitempty"`
	Enabled *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	Quota   *int64  `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s BenefitMeta) String() string {
	return tea.Prettify(s)
}

func (s BenefitMeta) GoString() string {
	return s.String()
}

func (s *BenefitMeta) SetConfig(v string) *BenefitMeta {
	s.Config = &v
	return s
}

func (s *BenefitMeta) SetEnabled(v bool) *BenefitMeta {
	s.Enabled = &v
	return s
}

func (s *BenefitMeta) SetQuota(v int64) *BenefitMeta {
	s.Quota = &v
	return s
}

/**
 * Benefit meta response
 */
type BenefitMetaResponse struct {
	// 
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// 
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// 
	Quota *int64 `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s BenefitMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s BenefitMetaResponse) GoString() string {
	return s.String()
}

func (s *BenefitMetaResponse) SetConfig(v string) *BenefitMetaResponse {
	s.Config = &v
	return s
}

func (s *BenefitMetaResponse) SetEnabled(v bool) *BenefitMetaResponse {
	s.Enabled = &v
	return s
}

func (s *BenefitMetaResponse) SetQuota(v int64) *BenefitMetaResponse {
	s.Quota = &v
	return s
}

/**
 * Benefit package delivery info
 */
type BenefitPkgDeliveryInfoResponse struct {
	// 
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// is_permanentfalse
	ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	// 
	IsPermanent *bool `json:"is_permanent,omitempty" xml:"is_permanent,omitempty"`
}

func (s BenefitPkgDeliveryInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s BenefitPkgDeliveryInfoResponse) GoString() string {
	return s.String()
}

func (s *BenefitPkgDeliveryInfoResponse) SetAmount(v int64) *BenefitPkgDeliveryInfoResponse {
	s.Amount = &v
	return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetCreatedAt(v string) *BenefitPkgDeliveryInfoResponse {
	s.CreatedAt = &v
	return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetExpireTime(v string) *BenefitPkgDeliveryInfoResponse {
	s.ExpireTime = &v
	return s
}

func (s *BenefitPkgDeliveryInfoResponse) SetIsPermanent(v bool) *BenefitPkgDeliveryInfoResponse {
	s.IsPermanent = &v
	return s
}

/**
 *
 */
type BindDeviceRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// device_info
	DeviceInfo *string `json:"device_info,omitempty" xml:"device_info,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// device_type
	DeviceType *string `json:"device_type,omitempty" xml:"device_type,omitempty"`
	// fs_type
	FsType *string `json:"fs_type,omitempty" xml:"fs_type,omitempty"`
	// manufacturer
	Manufacturer *string `json:"manufacturer,omitempty" xml:"manufacturer,omitempty"`
	// total_size
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// used_size
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s BindDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindDeviceRequest) GoString() string {
	return s.String()
}

func (s *BindDeviceRequest) SetHttpheaders(v map[string]*string) *BindDeviceRequest {
	s.Httpheaders = v
	return s
}

func (s *BindDeviceRequest) SetDeviceInfo(v string) *BindDeviceRequest {
	s.DeviceInfo = &v
	return s
}

func (s *BindDeviceRequest) SetDeviceName(v string) *BindDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *BindDeviceRequest) SetDeviceType(v string) *BindDeviceRequest {
	s.DeviceType = &v
	return s
}

func (s *BindDeviceRequest) SetFsType(v string) *BindDeviceRequest {
	s.FsType = &v
	return s
}

func (s *BindDeviceRequest) SetManufacturer(v string) *BindDeviceRequest {
	s.Manufacturer = &v
	return s
}

func (s *BindDeviceRequest) SetTotalSize(v int64) *BindDeviceRequest {
	s.TotalSize = &v
	return s
}

func (s *BindDeviceRequest) SetUsedSize(v int64) *BindDeviceRequest {
	s.UsedSize = &v
	return s
}

/**
 *
 */
type CNameStatus struct {
	// binding state
	BingdingState *string `json:"bingding_state,omitempty" xml:"bingding_state,omitempty" require:"true"`
	// legal state
	LegalState *string `json:"legal_state,omitempty" xml:"legal_state,omitempty" require:"true"`
	// remark
	Remark *string `json:"remark,omitempty" xml:"remark,omitempty" require:"true"`
}

func (s CNameStatus) String() string {
	return tea.Prettify(s)
}

func (s CNameStatus) GoString() string {
	return s.String()
}

func (s *CNameStatus) SetBingdingState(v string) *CNameStatus {
	s.BingdingState = &v
	return s
}

func (s *CNameStatus) SetLegalState(v string) *CNameStatus {
	s.LegalState = &v
	return s
}

func (s *CNameStatus) SetRemark(v string) *CNameStatus {
	s.Remark = &v
	return s
}

/**
 * 
 */
type ClearAllRecycleBinRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	FilePathType *string                `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
}

func (s ClearAllRecycleBinRequest) String() string {
	return tea.Prettify(s)
}

func (s ClearAllRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *ClearAllRecycleBinRequest) SetAdditionData(v map[string]interface{}) *ClearAllRecycleBinRequest {
	s.AdditionData = v
	return s
}

func (s *ClearAllRecycleBinRequest) SetFilePathType(v string) *ClearAllRecycleBinRequest {
	s.FilePathType = &v
	return s
}

/**
 * create domain response
 */
type CreateDomainResponse struct {
	// Domain APICName
	ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
	// Domain AppCName
	AppCname  *string    `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
	AppConfig *AppConfig `json:"app_config,omitempty" xml:"app_config,omitempty"`
	// 
	ArchiveFilesEnable *bool           `json:"archive_files_enable,omitempty" xml:"archive_files_enable,omitempty"`
	AuditLogConfig     *AuditLogConfig `json:"audit_log_config,omitempty" xml:"audit_log_config,omitempty"`
	// Domain AuthCName
	AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
	// 
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable *bool                  `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	Benefits      map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
	// Domain 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	//  Hash 
	DataHashName            *string                 `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// 
	EnterpriseCustomizedLogin *bool `json:"enterprise_customized_login,omitempty" xml:"enterprise_customized_login,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	// domain
	ExpireTime              *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	GroupSingleDriveEnabled *bool  `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	//  Drive  Store ID
	InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
	// Domain 
	Mode                  *string              `json:"mode,omitempty" xml:"mode,omitempty"`
	OfficeEditConfig      *OfficeEditConfig    `json:"office_edit_config,omitempty" xml:"office_edit_config,omitempty"`
	OfficePreviewConfig   *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
	ParallelUploadEnabled *bool                `json:"parallel_upload_enabled,omitempty" xml:"parallel_upload_enabled,omitempty"`
	// Parent Domain ID
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
	// Domain 
	PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
	// 
	PrepaidPackage             *string            `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	RecycleBinConfig           *RecycleBinConfig  `json:"recycle_bin_config,omitempty" xml:"recycle_bin_config,omitempty"`
	RoleConfig                 *RoleConfig        `json:"role_config,omitempty" xml:"role_config,omitempty"`
	// Domain ServiceCode
	ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// SPI  id
	SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
	// domain
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// 
	StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
	//  Region 
	StoreRegionList []*string        `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
	SubdomainConfig *SubdomainConfig `json:"subdomain_config,omitempty" xml:"subdomain_config,omitempty"`
	// Domain 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// 
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// usergroupdrive
	UserSingleDriveEnabled *bool                        `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
	VideoPreviewAppConfig  *VideoPreviewAppConfig       `json:"video_preview_app_config,omitempty" xml:"video_preview_app_config,omitempty"`
	VideoPreviewConfig     *VideoPreviewConfig          `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
	WatermarkConfig        *BaseWatermarkConfigResponse `json:"watermark_config,omitempty" xml:"watermark_config,omitempty"`
}

func (s CreateDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResponse) GoString() string {
	return s.String()
}

func (s *CreateDomainResponse) SetApiCname(v string) *CreateDomainResponse {
	s.ApiCname = &v
	return s
}

func (s *CreateDomainResponse) SetAppCname(v string) *CreateDomainResponse {
	s.AppCname = &v
	return s
}

func (s *CreateDomainResponse) SetAppConfig(v *AppConfig) *CreateDomainResponse {
	s.AppConfig = v
	return s
}

func (s *CreateDomainResponse) SetArchiveFilesEnable(v bool) *CreateDomainResponse {
	s.ArchiveFilesEnable = &v
	return s
}

func (s *CreateDomainResponse) SetAuditLogConfig(v *AuditLogConfig) *CreateDomainResponse {
	s.AuditLogConfig = v
	return s
}

func (s *CreateDomainResponse) SetAuthCname(v string) *CreateDomainResponse {
	s.AuthCname = &v
	return s
}

func (s *CreateDomainResponse) SetAuthConfig(v map[string]interface{}) *CreateDomainResponse {
	s.AuthConfig = v
	return s
}

func (s *CreateDomainResponse) SetAuthDingdingAppId(v string) *CreateDomainResponse {
	s.AuthDingdingAppId = &v
	return s
}

func (s *CreateDomainResponse) SetAuthDingdingAppSecret(v string) *CreateDomainResponse {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *CreateDomainResponse) SetAuthDingdingEnable(v bool) *CreateDomainResponse {
	s.AuthDingdingEnable = &v
	return s
}

func (s *CreateDomainResponse) SetAuthRamAppId(v string) *CreateDomainResponse {
	s.AuthRamAppId = &v
	return s
}

func (s *CreateDomainResponse) SetAuthRamAppSecret(v string) *CreateDomainResponse {
	s.AuthRamAppSecret = &v
	return s
}

func (s *CreateDomainResponse) SetAuthRamEnable(v bool) *CreateDomainResponse {
	s.AuthRamEnable = &v
	return s
}

func (s *CreateDomainResponse) SetBenefits(v map[string]interface{}) *CreateDomainResponse {
	s.Benefits = v
	return s
}

func (s *CreateDomainResponse) SetCreatedAt(v string) *CreateDomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *CreateDomainResponse) SetDataHashName(v string) *CreateDomainResponse {
	s.DataHashName = &v
	return s
}

func (s *CreateDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *CreateDomainResponse {
	s.DefaultSuperAdminConfig = v
	return s
}

func (s *CreateDomainResponse) SetDescription(v string) *CreateDomainResponse {
	s.Description = &v
	return s
}

func (s *CreateDomainResponse) SetDomainId(v string) *CreateDomainResponse {
	s.DomainId = &v
	return s
}

func (s *CreateDomainResponse) SetDomainName(v string) *CreateDomainResponse {
	s.DomainName = &v
	return s
}

func (s *CreateDomainResponse) SetEnterpriseCustomizedLogin(v bool) *CreateDomainResponse {
	s.EnterpriseCustomizedLogin = &v
	return s
}

func (s *CreateDomainResponse) SetEventFilenameMatches(v string) *CreateDomainResponse {
	s.EventFilenameMatches = &v
	return s
}

func (s *CreateDomainResponse) SetEventMnsEndpoint(v string) *CreateDomainResponse {
	s.EventMnsEndpoint = &v
	return s
}

func (s *CreateDomainResponse) SetEventMnsTopic(v string) *CreateDomainResponse {
	s.EventMnsTopic = &v
	return s
}

func (s *CreateDomainResponse) SetEventNames(v []*string) *CreateDomainResponse {
	s.EventNames = v
	return s
}

func (s *CreateDomainResponse) SetEventRoleArn(v string) *CreateDomainResponse {
	s.EventRoleArn = &v
	return s
}

func (s *CreateDomainResponse) SetExpireTime(v int64) *CreateDomainResponse {
	s.ExpireTime = &v
	return s
}

func (s *CreateDomainResponse) SetGroupSingleDriveEnabled(v bool) *CreateDomainResponse {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *CreateDomainResponse) SetInitDriveEnable(v bool) *CreateDomainResponse {
	s.InitDriveEnable = &v
	return s
}

func (s *CreateDomainResponse) SetInitDriveSize(v int64) *CreateDomainResponse {
	s.InitDriveSize = &v
	return s
}

func (s *CreateDomainResponse) SetInitDriveStoreId(v string) *CreateDomainResponse {
	s.InitDriveStoreId = &v
	return s
}

func (s *CreateDomainResponse) SetMode(v string) *CreateDomainResponse {
	s.Mode = &v
	return s
}

func (s *CreateDomainResponse) SetOfficeEditConfig(v *OfficeEditConfig) *CreateDomainResponse {
	s.OfficeEditConfig = v
	return s
}

func (s *CreateDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *CreateDomainResponse {
	s.OfficePreviewConfig = v
	return s
}

func (s *CreateDomainResponse) SetParallelUploadEnabled(v bool) *CreateDomainResponse {
	s.ParallelUploadEnabled = &v
	return s
}

func (s *CreateDomainResponse) SetParentDomainId(v string) *CreateDomainResponse {
	s.ParentDomainId = &v
	return s
}

func (s *CreateDomainResponse) SetPathType(v string) *CreateDomainResponse {
	s.PathType = &v
	return s
}

func (s *CreateDomainResponse) SetPrepaidPackage(v string) *CreateDomainResponse {
	s.PrepaidPackage = &v
	return s
}

func (s *CreateDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *CreateDomainResponse {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *CreateDomainResponse) SetRecycleBinConfig(v *RecycleBinConfig) *CreateDomainResponse {
	s.RecycleBinConfig = v
	return s
}

func (s *CreateDomainResponse) SetRoleConfig(v *RoleConfig) *CreateDomainResponse {
	s.RoleConfig = v
	return s
}

func (s *CreateDomainResponse) SetServiceCode(v string) *CreateDomainResponse {
	s.ServiceCode = &v
	return s
}

func (s *CreateDomainResponse) SetSharable(v bool) *CreateDomainResponse {
	s.Sharable = &v
	return s
}

func (s *CreateDomainResponse) SetShareDetail(v *ShareDetailResponse) *CreateDomainResponse {
	s.ShareDetail = v
	return s
}

func (s *CreateDomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *CreateDomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *CreateDomainResponse) SetShareLinkEnabled(v bool) *CreateDomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *CreateDomainResponse) SetSizeQuota(v int64) *CreateDomainResponse {
	s.SizeQuota = &v
	return s
}

func (s *CreateDomainResponse) SetSpiInstanceId(v string) *CreateDomainResponse {
	s.SpiInstanceId = &v
	return s
}

func (s *CreateDomainResponse) SetStatus(v int64) *CreateDomainResponse {
	s.Status = &v
	return s
}

func (s *CreateDomainResponse) SetStoreLevel(v string) *CreateDomainResponse {
	s.StoreLevel = &v
	return s
}

func (s *CreateDomainResponse) SetStoreRegionList(v []*string) *CreateDomainResponse {
	s.StoreRegionList = v
	return s
}

func (s *CreateDomainResponse) SetSubdomainConfig(v *SubdomainConfig) *CreateDomainResponse {
	s.SubdomainConfig = v
	return s
}

func (s *CreateDomainResponse) SetUpdatedAt(v string) *CreateDomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *CreateDomainResponse) SetUsedSize(v int64) *CreateDomainResponse {
	s.UsedSize = &v
	return s
}

func (s *CreateDomainResponse) SetUsedSizeRefreshInterval(v int64) *CreateDomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *CreateDomainResponse) SetUserCountQuota(v int64) *CreateDomainResponse {
	s.UserCountQuota = &v
	return s
}

func (s *CreateDomainResponse) SetUserSingleDriveEnabled(v bool) *CreateDomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

func (s *CreateDomainResponse) SetVideoPreviewAppConfig(v *VideoPreviewAppConfig) *CreateDomainResponse {
	s.VideoPreviewAppConfig = v
	return s
}

func (s *CreateDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *CreateDomainResponse {
	s.VideoPreviewConfig = v
	return s
}

func (s *CreateDomainResponse) SetWatermarkConfig(v *BaseWatermarkConfigResponse) *CreateDomainResponse {
	s.WatermarkConfig = v
	return s
}

/**
 *
 */
type CreateGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
	// group
	IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
	// parent group id
	ParentGroupId *string `json:"parent_group_id,omitempty" xml:"parent_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s CreateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateGroupRequest) SetHttpheaders(v map[string]*string) *CreateGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateGroupRequest) SetDescription(v string) *CreateGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateGroupRequest) SetGroupName(v string) *CreateGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateGroupRequest) SetIsRoot(v bool) *CreateGroupRequest {
	s.IsRoot = &v
	return s
}

func (s *CreateGroupRequest) SetParentGroupId(v string) *CreateGroupRequest {
	s.ParentGroupId = &v
	return s
}

func (s *CreateGroupRequest) SetSubdomainId(v string) *CreateGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * create identity to benefit pkg mapping request
 */
type CreateIdentityToBenefitPkgMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty" require:"true"`
	// Meta
	CustomBenefitMeta map[string]interface{} `json:"custom_benefit_meta,omitempty" xml:"custom_benefit_meta,omitempty"`
	// 
	DeliveryId *string `json:"delivery_id,omitempty" xml:"delivery_id,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
	// nonce ID
	NonceId *string `json:"nonce_id,omitempty" xml:"nonce_id,omitempty"`
}

func (s CreateIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetHttpheaders(v map[string]*string) *CreateIdentityToBenefitPkgMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetAmount(v int64) *CreateIdentityToBenefitPkgMappingRequest {
	s.Amount = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetBenefitPkgId(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.BenefitPkgId = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetCustomBenefitMeta(v map[string]interface{}) *CreateIdentityToBenefitPkgMappingRequest {
	s.CustomBenefitMeta = v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetDeliveryId(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.DeliveryId = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetExpireTime(v int64) *CreateIdentityToBenefitPkgMappingRequest {
	s.ExpireTime = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

func (s *CreateIdentityToBenefitPkgMappingRequest) SetNonceId(v string) *CreateIdentityToBenefitPkgMappingRequest {
	s.NonceId = &v
	return s
}

/**
 *
 */
type CreateIdentityToBenefitPkgMappingResponse struct {
}

func (s CreateIdentityToBenefitPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIdentityToBenefitPkgMappingResponse) GoString() string {
	return s.String()
}

/**
 *
 */
type CreateMembershipRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole  *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType  *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId  *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s CreateMembershipRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMembershipRequest) GoString() string {
	return s.String()
}

func (s *CreateMembershipRequest) SetHttpheaders(v map[string]*string) *CreateMembershipRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateMembershipRequest) SetDescription(v string) *CreateMembershipRequest {
	s.Description = &v
	return s
}

func (s *CreateMembershipRequest) SetGroupId(v string) *CreateMembershipRequest {
	s.GroupId = &v
	return s
}

func (s *CreateMembershipRequest) SetMemberRole(v string) *CreateMembershipRequest {
	s.MemberRole = &v
	return s
}

func (s *CreateMembershipRequest) SetMemberType(v string) *CreateMembershipRequest {
	s.MemberType = &v
	return s
}

func (s *CreateMembershipRequest) SetSubGroupId(v string) *CreateMembershipRequest {
	s.SubGroupId = &v
	return s
}

func (s *CreateMembershipRequest) SetSubdomainId(v string) *CreateMembershipRequest {
	s.SubdomainId = &v
	return s
}

func (s *CreateMembershipRequest) SetUserId(v string) *CreateMembershipRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type CreateSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// drive
	GroupSingleDriveEnabled *bool `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	// subdomain
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
	// quota-1
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty"`
	// drive
	UserSingleDriveEnabled *bool `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
}

func (s CreateSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSubdomainRequest) GoString() string {
	return s.String()
}

func (s *CreateSubdomainRequest) SetHttpheaders(v map[string]*string) *CreateSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateSubdomainRequest) SetDescription(v string) *CreateSubdomainRequest {
	s.Description = &v
	return s
}

func (s *CreateSubdomainRequest) SetGroupSingleDriveEnabled(v bool) *CreateSubdomainRequest {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *CreateSubdomainRequest) SetName(v string) *CreateSubdomainRequest {
	s.Name = &v
	return s
}

func (s *CreateSubdomainRequest) SetTotalSize(v int64) *CreateSubdomainRequest {
	s.TotalSize = &v
	return s
}

func (s *CreateSubdomainRequest) SetUsedSizeRefreshInterval(v int64) *CreateSubdomainRequest {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *CreateSubdomainRequest) SetUserQuota(v int64) *CreateSubdomainRequest {
	s.UserQuota = &v
	return s
}

func (s *CreateSubdomainRequest) SetUserSingleDriveEnabled(v bool) *CreateSubdomainRequest {
	s.UserSingleDriveEnabled = &v
	return s
}

/**
 *
 */
type CreateSubdomainResponse struct {
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s CreateSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSubdomainResponse) GoString() string {
	return s.String()
}

func (s *CreateSubdomainResponse) SetSubdomainId(v string) *CreateSubdomainResponse {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type CreateSyncMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// custom_meta
	CustomMeta *string `json:"custom_meta,omitempty" xml:"custom_meta,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// fs_id
	FsId *string `json:"fs_id,omitempty" xml:"fs_id,omitempty"`
	// local_path
	LocalPath *string `json:"local_path,omitempty" xml:"local_path,omitempty"`
	// sync_mode
	SyncMode *string `json:"sync_mode,omitempty" xml:"sync_mode,omitempty"`
}

func (s CreateSyncMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSyncMappingRequest) GoString() string {
	return s.String()
}

func (s *CreateSyncMappingRequest) SetHttpheaders(v map[string]*string) *CreateSyncMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateSyncMappingRequest) SetCustomMeta(v string) *CreateSyncMappingRequest {
	s.CustomMeta = &v
	return s
}

func (s *CreateSyncMappingRequest) SetDeviceName(v string) *CreateSyncMappingRequest {
	s.DeviceName = &v
	return s
}

func (s *CreateSyncMappingRequest) SetDriveId(v string) *CreateSyncMappingRequest {
	s.DriveId = &v
	return s
}

func (s *CreateSyncMappingRequest) SetFsId(v string) *CreateSyncMappingRequest {
	s.FsId = &v
	return s
}

func (s *CreateSyncMappingRequest) SetLocalPath(v string) *CreateSyncMappingRequest {
	s.LocalPath = &v
	return s
}

func (s *CreateSyncMappingRequest) SetSyncMode(v string) *CreateSyncMappingRequest {
	s.SyncMode = &v
	return s
}

/**
 * Create user request
 */
type CreateUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// 
	Email         *string      `json:"email,omitempty" xml:"email,omitempty"`
	GroupInfoList []*GroupInfo `json:"group_info_list,omitempty" xml:"group_info_list,omitempty" type:"Repeated"`
	// 
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s CreateUserRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUserRequest) GoString() string {
	return s.String()
}

func (s *CreateUserRequest) SetHttpheaders(v map[string]*string) *CreateUserRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateUserRequest) SetAvatar(v string) *CreateUserRequest {
	s.Avatar = &v
	return s
}

func (s *CreateUserRequest) SetDenyChangePasswordBySelf(v bool) *CreateUserRequest {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *CreateUserRequest) SetDescription(v string) *CreateUserRequest {
	s.Description = &v
	return s
}

func (s *CreateUserRequest) SetEmail(v string) *CreateUserRequest {
	s.Email = &v
	return s
}

func (s *CreateUserRequest) SetGroupInfoList(v []*GroupInfo) *CreateUserRequest {
	s.GroupInfoList = v
	return s
}

func (s *CreateUserRequest) SetLocation(v string) *CreateUserRequest {
	s.Location = &v
	return s
}

func (s *CreateUserRequest) SetNeedChangePasswordNextLogin(v bool) *CreateUserRequest {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *CreateUserRequest) SetNickName(v string) *CreateUserRequest {
	s.NickName = &v
	return s
}

func (s *CreateUserRequest) SetPhone(v string) *CreateUserRequest {
	s.Phone = &v
	return s
}

func (s *CreateUserRequest) SetPlainPassword(v string) *CreateUserRequest {
	s.PlainPassword = &v
	return s
}

func (s *CreateUserRequest) SetRole(v string) *CreateUserRequest {
	s.Role = &v
	return s
}

func (s *CreateUserRequest) SetStatus(v string) *CreateUserRequest {
	s.Status = &v
	return s
}

func (s *CreateUserRequest) SetSubdomainId(v string) *CreateUserRequest {
	s.SubdomainId = &v
	return s
}

func (s *CreateUserRequest) SetUserData(v map[string]interface{}) *CreateUserRequest {
	s.UserData = v
	return s
}

func (s *CreateUserRequest) SetUserId(v string) *CreateUserRequest {
	s.UserId = &v
	return s
}

func (s *CreateUserRequest) SetUserName(v string) *CreateUserRequest {
	s.UserName = &v
	return s
}

/**
 *
 */
type CustomBenefitMeta struct {
	Config          *string `json:"config,omitempty" xml:"config,omitempty"`
	CoverLowerLevel *bool   `json:"cover_lower_level,omitempty" xml:"cover_lower_level,omitempty"`
	Enabled         *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	Quota           *int64  `json:"quota,omitempty" xml:"quota,omitempty"`
}

func (s CustomBenefitMeta) String() string {
	return tea.Prettify(s)
}

func (s CustomBenefitMeta) GoString() string {
	return s.String()
}

func (s *CustomBenefitMeta) SetConfig(v string) *CustomBenefitMeta {
	s.Config = &v
	return s
}

func (s *CustomBenefitMeta) SetCoverLowerLevel(v bool) *CustomBenefitMeta {
	s.CoverLowerLevel = &v
	return s
}

func (s *CustomBenefitMeta) SetEnabled(v bool) *CustomBenefitMeta {
	s.Enabled = &v
	return s
}

func (s *CustomBenefitMeta) SetQuota(v int64) *CustomBenefitMeta {
	s.Quota = &v
	return s
}

/**
 *
 */
type CustomSideLinkConfig struct {
	Icon *string `json:"icon,omitempty" xml:"icon,omitempty"`
	Link *string `json:"link,omitempty" xml:"link,omitempty"`
	Text *string `json:"text,omitempty" xml:"text,omitempty"`
}

func (s CustomSideLinkConfig) String() string {
	return tea.Prettify(s)
}

func (s CustomSideLinkConfig) GoString() string {
	return s.String()
}

func (s *CustomSideLinkConfig) SetIcon(v string) *CustomSideLinkConfig {
	s.Icon = &v
	return s
}

func (s *CustomSideLinkConfig) SetLink(v string) *CustomSideLinkConfig {
	s.Link = &v
	return s
}

func (s *CustomSideLinkConfig) SetText(v string) *CustomSideLinkConfig {
	s.Text = &v
	return s
}

/**
 *
 */
type DataCName struct {
	// datacname
	DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
	// data location
	Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s DataCName) String() string {
	return tea.Prettify(s)
}

func (s DataCName) GoString() string {
	return s.String()
}

func (s *DataCName) SetDataCname(v string) *DataCName {
	s.DataCname = &v
	return s
}

func (s *DataCName) SetLocation(v string) *DataCName {
	s.Location = &v
	return s
}

/**
 *
 */
type DeleteGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s DeleteGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteGroupRequest) SetHttpheaders(v map[string]*string) *DeleteGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteGroupRequest) SetGroupId(v string) *DeleteGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteGroupRequest) SetSubdomainId(v string) *DeleteGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * delete identity to benefit pkg mapping request
 */
type DeleteIdentityToBenefitPkgMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
}

func (s DeleteIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *DeleteIdentityToBenefitPkgMappingRequest) SetHttpheaders(v map[string]*string) *DeleteIdentityToBenefitPkgMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteIdentityToBenefitPkgMappingRequest) SetBenefitPkgId(v string) *DeleteIdentityToBenefitPkgMappingRequest {
	s.BenefitPkgId = &v
	return s
}

func (s *DeleteIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *DeleteIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *DeleteIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *DeleteIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *DeleteIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *DeleteIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

/**
 *
 */
type DeleteIdentityToBenefitPkgMappingResponse struct {
}

func (s DeleteIdentityToBenefitPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIdentityToBenefitPkgMappingResponse) GoString() string {
	return s.String()
}

/**
 *
 */
type DeleteMembershipRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId    *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s DeleteMembershipRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMembershipRequest) GoString() string {
	return s.String()
}

func (s *DeleteMembershipRequest) SetHttpheaders(v map[string]*string) *DeleteMembershipRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteMembershipRequest) SetGroupId(v string) *DeleteMembershipRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteMembershipRequest) SetMemberType(v string) *DeleteMembershipRequest {
	s.MemberType = &v
	return s
}

func (s *DeleteMembershipRequest) SetSubGroupId(v string) *DeleteMembershipRequest {
	s.SubGroupId = &v
	return s
}

func (s *DeleteMembershipRequest) SetSubdomainId(v string) *DeleteMembershipRequest {
	s.SubdomainId = &v
	return s
}

func (s *DeleteMembershipRequest) SetUserId(v string) *DeleteMembershipRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type DeleteSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s DeleteSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubdomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteSubdomainRequest) SetHttpheaders(v map[string]*string) *DeleteSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteSubdomainRequest) SetSubdomainId(v string) *DeleteSubdomainRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type DeleteSubdomainResponse struct {
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s DeleteSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubdomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteSubdomainResponse) SetSubdomainId(v string) *DeleteSubdomainResponse {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type DeleteSyncMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// fs_id
	FsId *string `json:"fs_id,omitempty" xml:"fs_id,omitempty"`
	// local_path
	LocalPath *string `json:"local_path,omitempty" xml:"local_path,omitempty"`
}

func (s DeleteSyncMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyncMappingRequest) GoString() string {
	return s.String()
}

func (s *DeleteSyncMappingRequest) SetHttpheaders(v map[string]*string) *DeleteSyncMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteSyncMappingRequest) SetDeviceName(v string) *DeleteSyncMappingRequest {
	s.DeviceName = &v
	return s
}

func (s *DeleteSyncMappingRequest) SetDriveId(v string) *DeleteSyncMappingRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteSyncMappingRequest) SetFsId(v string) *DeleteSyncMappingRequest {
	s.FsId = &v
	return s
}

func (s *DeleteSyncMappingRequest) SetLocalPath(v string) *DeleteSyncMappingRequest {
	s.LocalPath = &v
	return s
}

/**
 * Delete user request
 */
type DeleteUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s DeleteUserRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserRequest) GoString() string {
	return s.String()
}

func (s *DeleteUserRequest) SetHttpheaders(v map[string]*string) *DeleteUserRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteUserRequest) SetUserId(v string) *DeleteUserRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type DomainBaseInfoLogDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s DomainBaseInfoLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DomainBaseInfoLogDetail) GoString() string {
	return s.String()
}

func (s *DomainBaseInfoLogDetail) SetName(v string) *DomainBaseInfoLogDetail {
	s.Name = &v
	return s
}

/**
 *
 */
type DomainBuildClient struct {
	Copyright *string `json:"copyright,omitempty" xml:"copyright,omitempty"`
	Name      *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s DomainBuildClient) String() string {
	return tea.Prettify(s)
}

func (s DomainBuildClient) GoString() string {
	return s.String()
}

func (s *DomainBuildClient) SetCopyright(v string) *DomainBuildClient {
	s.Copyright = &v
	return s
}

func (s *DomainBuildClient) SetName(v string) *DomainBuildClient {
	s.Name = &v
	return s
}

/**
 *
 */
type DomainCNameResponse struct {
	// data cname list
	DataCnameList []*DataCName `json:"data_cname_list,omitempty" xml:"data_cname_list,omitempty" require:"true" type:"Repeated"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
}

func (s DomainCNameResponse) String() string {
	return tea.Prettify(s)
}

func (s DomainCNameResponse) GoString() string {
	return s.String()
}

func (s *DomainCNameResponse) SetDataCnameList(v []*DataCName) *DomainCNameResponse {
	s.DataCnameList = v
	return s
}

func (s *DomainCNameResponse) SetDomainId(v string) *DomainCNameResponse {
	s.DomainId = &v
	return s
}

/**
 *
 */
type DomainCnameInfoLogDetail struct {
	// cert_name
	CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty"`
	// cname
	Cname *string `json:"cname,omitempty" xml:"cname,omitempty"`
}

func (s DomainCnameInfoLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DomainCnameInfoLogDetail) GoString() string {
	return s.String()
}

func (s *DomainCnameInfoLogDetail) SetCertName(v string) *DomainCnameInfoLogDetail {
	s.CertName = &v
	return s
}

func (s *DomainCnameInfoLogDetail) SetCname(v string) *DomainCnameInfoLogDetail {
	s.Cname = &v
	return s
}

/**
 *
 */
type DomainFileConfigDetail struct {
	RecycleBinAutoDeleteEnabled    *bool   `json:"recycle_bin_auto_delete_enabled,omitempty" xml:"recycle_bin_auto_delete_enabled,omitempty"`
	RecycleBinAutoDeleteKeepSecond *int64  `json:"recycle_bin_auto_delete_keep_second,omitempty" xml:"recycle_bin_auto_delete_keep_second,omitempty"`
	SameNameFileUploadMode         *string `json:"same_name_file_upload_mode,omitempty" xml:"same_name_file_upload_mode,omitempty"`
	WebClientDownloadMode          *string `json:"web_client_download_mode,omitempty" xml:"web_client_download_mode,omitempty"`
}

func (s DomainFileConfigDetail) String() string {
	return tea.Prettify(s)
}

func (s DomainFileConfigDetail) GoString() string {
	return s.String()
}

func (s *DomainFileConfigDetail) SetRecycleBinAutoDeleteEnabled(v bool) *DomainFileConfigDetail {
	s.RecycleBinAutoDeleteEnabled = &v
	return s
}

func (s *DomainFileConfigDetail) SetRecycleBinAutoDeleteKeepSecond(v int64) *DomainFileConfigDetail {
	s.RecycleBinAutoDeleteKeepSecond = &v
	return s
}

func (s *DomainFileConfigDetail) SetSameNameFileUploadMode(v string) *DomainFileConfigDetail {
	s.SameNameFileUploadMode = &v
	return s
}

func (s *DomainFileConfigDetail) SetWebClientDownloadMode(v string) *DomainFileConfigDetail {
	s.WebClientDownloadMode = &v
	return s
}

/**
 *
 */
type DomainSeniorConfig struct {
	// 
	ClientDownloadEnable *bool `json:"client_download_enable,omitempty" xml:"client_download_enable,omitempty"`
	// 
	CspFrameAncestors *string `json:"csp_frame_ancestors,omitempty" xml:"csp_frame_ancestors,omitempty"`
	// 
	CustomLoginAppid *string `json:"custom_login_appid,omitempty" xml:"custom_login_appid,omitempty"`
	CustomLoginUrl   *string `json:"custom_login_url,omitempty" xml:"custom_login_url,omitempty"`
	CustomLogoutUrl  *string `json:"custom_logout_url,omitempty" xml:"custom_logout_url,omitempty"`
	// 
	CustomSideLinkList []*CustomSideLinkConfig `json:"custom_side_link_list,omitempty" xml:"custom_side_link_list,omitempty" type:"Repeated"`
	// 
	HomePageBgImageUrl *string                  `json:"home_page_bg_image_url,omitempty" xml:"home_page_bg_image_url,omitempty"`
	HomePageFooter     *string                  `json:"home_page_footer,omitempty" xml:"home_page_footer,omitempty"`
	HomePageFooter2    *string                  `json:"home_page_footer2,omitempty" xml:"home_page_footer2,omitempty"`
	HomePageSlogan     *string                  `json:"home_page_slogan,omitempty" xml:"home_page_slogan,omitempty"`
	RefererEnable      *bool                    `json:"referer_enable,omitempty" xml:"referer_enable,omitempty"`
	WxTxtList          []*WxTrustedDomainConfig `json:"wx_txt_list,omitempty" xml:"wx_txt_list,omitempty" type:"Repeated"`
}

func (s DomainSeniorConfig) String() string {
	return tea.Prettify(s)
}

func (s DomainSeniorConfig) GoString() string {
	return s.String()
}

func (s *DomainSeniorConfig) SetClientDownloadEnable(v bool) *DomainSeniorConfig {
	s.ClientDownloadEnable = &v
	return s
}

func (s *DomainSeniorConfig) SetCspFrameAncestors(v string) *DomainSeniorConfig {
	s.CspFrameAncestors = &v
	return s
}

func (s *DomainSeniorConfig) SetCustomLoginAppid(v string) *DomainSeniorConfig {
	s.CustomLoginAppid = &v
	return s
}

func (s *DomainSeniorConfig) SetCustomLoginUrl(v string) *DomainSeniorConfig {
	s.CustomLoginUrl = &v
	return s
}

func (s *DomainSeniorConfig) SetCustomLogoutUrl(v string) *DomainSeniorConfig {
	s.CustomLogoutUrl = &v
	return s
}

func (s *DomainSeniorConfig) SetCustomSideLinkList(v []*CustomSideLinkConfig) *DomainSeniorConfig {
	s.CustomSideLinkList = v
	return s
}

func (s *DomainSeniorConfig) SetHomePageBgImageUrl(v string) *DomainSeniorConfig {
	s.HomePageBgImageUrl = &v
	return s
}

func (s *DomainSeniorConfig) SetHomePageFooter(v string) *DomainSeniorConfig {
	s.HomePageFooter = &v
	return s
}

func (s *DomainSeniorConfig) SetHomePageFooter2(v string) *DomainSeniorConfig {
	s.HomePageFooter2 = &v
	return s
}

func (s *DomainSeniorConfig) SetHomePageSlogan(v string) *DomainSeniorConfig {
	s.HomePageSlogan = &v
	return s
}

func (s *DomainSeniorConfig) SetRefererEnable(v bool) *DomainSeniorConfig {
	s.RefererEnable = &v
	return s
}

func (s *DomainSeniorConfig) SetWxTxtList(v []*WxTrustedDomainConfig) *DomainSeniorConfig {
	s.WxTxtList = v
	return s
}

/**
 *
 */
type DomainSuperAdminConfig struct {
	PhoneNumber *string `json:"phone_number,omitempty" xml:"phone_number,omitempty"`
	PhoneRegion *string `json:"phone_region,omitempty" xml:"phone_region,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s DomainSuperAdminConfig) String() string {
	return tea.Prettify(s)
}

func (s DomainSuperAdminConfig) GoString() string {
	return s.String()
}

func (s *DomainSuperAdminConfig) SetPhoneNumber(v string) *DomainSuperAdminConfig {
	s.PhoneNumber = &v
	return s
}

func (s *DomainSuperAdminConfig) SetPhoneRegion(v string) *DomainSuperAdminConfig {
	s.PhoneRegion = &v
	return s
}

func (s *DomainSuperAdminConfig) SetUserId(v string) *DomainSuperAdminConfig {
	s.UserId = &v
	return s
}

/**
 *
 */
type DriveLogDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// owner_id
	OwnerId *string `json:"owner_id,omitempty" xml:"owner_id,omitempty"`
	// owner_name
	OwnerName *string `json:"owner_name,omitempty" xml:"owner_name,omitempty"`
	// owner_type
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// total_size
	TotalSize *int64                 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	UpdateTo  *DriveLogSettingDetail `json:"update_to,omitempty" xml:"update_to,omitempty"`
}

func (s DriveLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DriveLogDetail) GoString() string {
	return s.String()
}

func (s *DriveLogDetail) SetName(v string) *DriveLogDetail {
	s.Name = &v
	return s
}

func (s *DriveLogDetail) SetOwnerId(v string) *DriveLogDetail {
	s.OwnerId = &v
	return s
}

func (s *DriveLogDetail) SetOwnerName(v string) *DriveLogDetail {
	s.OwnerName = &v
	return s
}

func (s *DriveLogDetail) SetOwnerType(v string) *DriveLogDetail {
	s.OwnerType = &v
	return s
}

func (s *DriveLogDetail) SetTotalSize(v int64) *DriveLogDetail {
	s.TotalSize = &v
	return s
}

func (s *DriveLogDetail) SetUpdateTo(v *DriveLogSettingDetail) *DriveLogDetail {
	s.UpdateTo = v
	return s
}

/**
 *
 */
type DriveLogSettingDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// owner_id
	OwnerId *string `json:"owner_id,omitempty" xml:"owner_id,omitempty"`
	// owner_name
	OwnerName *string `json:"owner_name,omitempty" xml:"owner_name,omitempty"`
	// owner_type
	OwnerType *string `json:"owner_type,omitempty" xml:"owner_type,omitempty"`
	// total_size
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
}

func (s DriveLogSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s DriveLogSettingDetail) GoString() string {
	return s.String()
}

func (s *DriveLogSettingDetail) SetName(v string) *DriveLogSettingDetail {
	s.Name = &v
	return s
}

func (s *DriveLogSettingDetail) SetOwnerId(v string) *DriveLogSettingDetail {
	s.OwnerId = &v
	return s
}

func (s *DriveLogSettingDetail) SetOwnerName(v string) *DriveLogSettingDetail {
	s.OwnerName = &v
	return s
}

func (s *DriveLogSettingDetail) SetOwnerType(v string) *DriveLogSettingDetail {
	s.OwnerType = &v
	return s
}

func (s *DriveLogSettingDetail) SetTotalSize(v int64) *DriveLogSettingDetail {
	s.TotalSize = &v
	return s
}

/**
 *
 */
type EntMgmtLogDetail struct {
	BuildClient                 *DomainBuildClient           `json:"build_client,omitempty" xml:"build_client,omitempty"`
	DomainBaseInfo              *DomainBaseInfoLogDetail     `json:"domain_base_info,omitempty" xml:"domain_base_info,omitempty"`
	DomainCnameInfo             *DomainCnameInfoLogDetail    `json:"domain_cname_info,omitempty" xml:"domain_cname_info,omitempty"`
	FileConfig                  *DomainFileConfigDetail      `json:"file_config,omitempty" xml:"file_config,omitempty"`
	FileCustomRoleInfo          *FileCustomRoleInfoLogDetail `json:"file_custom_role_info,omitempty" xml:"file_custom_role_info,omitempty"`
	FileCustomRoleInfoUpdatedTo *FileCustomRoleInfoLogDetail `json:"file_custom_role_info_updated_to,omitempty" xml:"file_custom_role_info_updated_to,omitempty"`
	SeniorConfig                *DomainSeniorConfig          `json:"senior_config,omitempty" xml:"senior_config,omitempty"`
}

func (s EntMgmtLogDetail) String() string {
	return tea.Prettify(s)
}

func (s EntMgmtLogDetail) GoString() string {
	return s.String()
}

func (s *EntMgmtLogDetail) SetBuildClient(v *DomainBuildClient) *EntMgmtLogDetail {
	s.BuildClient = v
	return s
}

func (s *EntMgmtLogDetail) SetDomainBaseInfo(v *DomainBaseInfoLogDetail) *EntMgmtLogDetail {
	s.DomainBaseInfo = v
	return s
}

func (s *EntMgmtLogDetail) SetDomainCnameInfo(v *DomainCnameInfoLogDetail) *EntMgmtLogDetail {
	s.DomainCnameInfo = v
	return s
}

func (s *EntMgmtLogDetail) SetFileConfig(v *DomainFileConfigDetail) *EntMgmtLogDetail {
	s.FileConfig = v
	return s
}

func (s *EntMgmtLogDetail) SetFileCustomRoleInfo(v *FileCustomRoleInfoLogDetail) *EntMgmtLogDetail {
	s.FileCustomRoleInfo = v
	return s
}

func (s *EntMgmtLogDetail) SetFileCustomRoleInfoUpdatedTo(v *FileCustomRoleInfoLogDetail) *EntMgmtLogDetail {
	s.FileCustomRoleInfoUpdatedTo = v
	return s
}

func (s *EntMgmtLogDetail) SetSeniorConfig(v *DomainSeniorConfig) *EntMgmtLogDetail {
	s.SeniorConfig = v
	return s
}

/**
 * request
 */
type ExportAuditLogRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// file_name
	FileName *string `json:"file_name,omitempty" xml:"file_name,omitempty"`
	// language
	Language *string `json:"language,omitempty" xml:"language,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
}

func (s ExportAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportAuditLogRequest) GoString() string {
	return s.String()
}

func (s *ExportAuditLogRequest) SetHttpheaders(v map[string]*string) *ExportAuditLogRequest {
	s.Httpheaders = v
	return s
}

func (s *ExportAuditLogRequest) SetFileName(v string) *ExportAuditLogRequest {
	s.FileName = &v
	return s
}

func (s *ExportAuditLogRequest) SetLanguage(v string) *ExportAuditLogRequest {
	s.Language = &v
	return s
}

func (s *ExportAuditLogRequest) SetOrderBy(v string) *ExportAuditLogRequest {
	s.OrderBy = &v
	return s
}

func (s *ExportAuditLogRequest) SetQuery(v string) *ExportAuditLogRequest {
	s.Query = &v
	return s
}

/**
 * response
 */
type ExportAuditLogResponse struct {
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s ExportAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportAuditLogResponse) GoString() string {
	return s.String()
}

func (s *ExportAuditLogResponse) SetAsyncTaskId(v string) *ExportAuditLogResponse {
	s.AsyncTaskId = &v
	return s
}

/**
 *
 */
type FileCustomRoleInfoLogDetail struct {
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	RoleName   *string   `json:"role_name,omitempty" xml:"role_name,omitempty"`
}

func (s FileCustomRoleInfoLogDetail) String() string {
	return tea.Prettify(s)
}

func (s FileCustomRoleInfoLogDetail) GoString() string {
	return s.String()
}

func (s *FileCustomRoleInfoLogDetail) SetActionList(v []*string) *FileCustomRoleInfoLogDetail {
	s.ActionList = v
	return s
}

func (s *FileCustomRoleInfoLogDetail) SetRoleName(v string) *FileCustomRoleInfoLogDetail {
	s.RoleName = &v
	return s
}

/**
 *
 */
type FileLogDetail struct {
	// new_name
	NewName *string `json:"new_name,omitempty" xml:"new_name,omitempty"`
	// parent_path
	ParentPath *string `json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// to_parent_path
	ToParentPath *string `json:"to_parent_path,omitempty" xml:"to_parent_path,omitempty"`
	// to_parent_path_type
	ToParentPathType *string `json:"to_parent_path_type,omitempty" xml:"to_parent_path_type,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s FileLogDetail) String() string {
	return tea.Prettify(s)
}

func (s FileLogDetail) GoString() string {
	return s.String()
}

func (s *FileLogDetail) SetNewName(v string) *FileLogDetail {
	s.NewName = &v
	return s
}

func (s *FileLogDetail) SetParentPath(v string) *FileLogDetail {
	s.ParentPath = &v
	return s
}

func (s *FileLogDetail) SetToParentPath(v string) *FileLogDetail {
	s.ToParentPath = &v
	return s
}

func (s *FileLogDetail) SetToParentPathType(v string) *FileLogDetail {
	s.ToParentPathType = &v
	return s
}

func (s *FileLogDetail) SetType(v string) *FileLogDetail {
	s.Type = &v
	return s
}

/**
 *
 */
type GetAppDebugCmdRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// app_id
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
}

func (s GetAppDebugCmdRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppDebugCmdRequest) GoString() string {
	return s.String()
}

func (s *GetAppDebugCmdRequest) SetHttpheaders(v map[string]*string) *GetAppDebugCmdRequest {
	s.Httpheaders = v
	return s
}

func (s *GetAppDebugCmdRequest) SetAppId(v string) *GetAppDebugCmdRequest {
	s.AppId = &v
	return s
}

/**
 *
 */
type GetAppPublicKeyResponse struct {
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// RSA, PEM
	PublicKey *string `json:"public_key,omitempty" xml:"public_key,omitempty" require:"true"`
}

func (s GetAppPublicKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppPublicKeyResponse) GoString() string {
	return s.String()
}

func (s *GetAppPublicKeyResponse) SetAppId(v string) *GetAppPublicKeyResponse {
	s.AppId = &v
	return s
}

func (s *GetAppPublicKeyResponse) SetPublicKey(v string) *GetAppPublicKeyResponse {
	s.PublicKey = &v
	return s
}

/**
 *
 */
type GetAppResponse struct {
	// App 
	AliOwnerId *string `json:"ali_owner_id,omitempty" xml:"ali_owner_id,omitempty" require:"true"`
	// App ID
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty" require:"true"`
	// App
	AppName *string `json:"app_name,omitempty" xml:"app_name,omitempty" require:"true" maxLength:"128" minLength:"1" pattern:"[0-9a-zA-Z]+"`
	// App 
	AppSecret *string `json:"app_secret,omitempty" xml:"app_secret,omitempty" require:"true"`
	// App 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// App
	Description *string `json:"description,omitempty" xml:"description,omitempty" require:"true" maxLength:"128" minLength:"0"`
	// App
	Logo *string `json:"logo,omitempty" xml:"logo,omitempty" require:"true"`
	// App 
	Provider *string `json:"provider,omitempty" xml:"provider,omitempty" require:"true"`
	// App
	RedirectUri *string `json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty" require:"true"`
	// App
	Scope []*string `json:"scope,omitempty" xml:"scope,omitempty" require:"true" type:"Repeated"`
	// App 
	Screenshots []*string `json:"screenshots,omitempty" xml:"screenshots,omitempty" require:"true" type:"Repeated"`
	// App 
	Stage *string `json:"stage,omitempty" xml:"stage,omitempty" require:"true"`
	// App
	Type *string `json:"type,omitempty" xml:"type,omitempty" require:"true"`
	// App 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
}

func (s GetAppResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppResponse) GoString() string {
	return s.String()
}

func (s *GetAppResponse) SetAliOwnerId(v string) *GetAppResponse {
	s.AliOwnerId = &v
	return s
}

func (s *GetAppResponse) SetAppId(v string) *GetAppResponse {
	s.AppId = &v
	return s
}

func (s *GetAppResponse) SetAppName(v string) *GetAppResponse {
	s.AppName = &v
	return s
}

func (s *GetAppResponse) SetAppSecret(v string) *GetAppResponse {
	s.AppSecret = &v
	return s
}

func (s *GetAppResponse) SetCreatedAt(v string) *GetAppResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetAppResponse) SetDescription(v string) *GetAppResponse {
	s.Description = &v
	return s
}

func (s *GetAppResponse) SetLogo(v string) *GetAppResponse {
	s.Logo = &v
	return s
}

func (s *GetAppResponse) SetProvider(v string) *GetAppResponse {
	s.Provider = &v
	return s
}

func (s *GetAppResponse) SetRedirectUri(v string) *GetAppResponse {
	s.RedirectUri = &v
	return s
}

func (s *GetAppResponse) SetScope(v []*string) *GetAppResponse {
	s.Scope = v
	return s
}

func (s *GetAppResponse) SetScreenshots(v []*string) *GetAppResponse {
	s.Screenshots = v
	return s
}

func (s *GetAppResponse) SetStage(v string) *GetAppResponse {
	s.Stage = &v
	return s
}

func (s *GetAppResponse) SetType(v string) *GetAppResponse {
	s.Type = &v
	return s
}

func (s *GetAppResponse) SetUpdatedAt(v string) *GetAppResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type GetBizCNameInfoResponse struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert name
	CertId *string `json:"cert_id,omitempty" xml:"cert_id,omitempty"`
	// cert name
	CertName    *string      `json:"cert_name,omitempty" xml:"cert_name,omitempty"`
	CnameStatus *CNameStatus `json:"cname_status,omitempty" xml:"cname_status,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s GetBizCNameInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBizCNameInfoResponse) GoString() string {
	return s.String()
}

func (s *GetBizCNameInfoResponse) SetBizCname(v string) *GetBizCNameInfoResponse {
	s.BizCname = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetCertId(v string) *GetBizCNameInfoResponse {
	s.CertId = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetCertName(v string) *GetBizCNameInfoResponse {
	s.CertName = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetCnameStatus(v *CNameStatus) *GetBizCNameInfoResponse {
	s.CnameStatus = v
	return s
}

func (s *GetBizCNameInfoResponse) SetCnameType(v string) *GetBizCNameInfoResponse {
	s.CnameType = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetDomainId(v string) *GetBizCNameInfoResponse {
	s.DomainId = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetIsVpc(v bool) *GetBizCNameInfoResponse {
	s.IsVpc = &v
	return s
}

func (s *GetBizCNameInfoResponse) SetSubdomainId(v string) *GetBizCNameInfoResponse {
	s.SubdomainId = &v
	return s
}

/**
 * get domain response
 */
type GetDomainResponse struct {
	// Domain APICName
	ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
	// Domain AppCName
	AppCname  *string    `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
	AppConfig *AppConfig `json:"app_config,omitempty" xml:"app_config,omitempty"`
	// 
	ArchiveFilesEnable *bool           `json:"archive_files_enable,omitempty" xml:"archive_files_enable,omitempty"`
	AuditLogConfig     *AuditLogConfig `json:"audit_log_config,omitempty" xml:"audit_log_config,omitempty"`
	// Domain AuthCName
	AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
	// 
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable *bool                  `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	Benefits      map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
	// Domain 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	//  Hash 
	DataHashName            *string                 `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// 
	EnterpriseCustomizedLogin *bool `json:"enterprise_customized_login,omitempty" xml:"enterprise_customized_login,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	// domain
	ExpireTime              *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	GroupSingleDriveEnabled *bool  `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	//  Drive  Store ID
	InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
	// Domain 
	Mode                  *string              `json:"mode,omitempty" xml:"mode,omitempty"`
	OfficeEditConfig      *OfficeEditConfig    `json:"office_edit_config,omitempty" xml:"office_edit_config,omitempty"`
	OfficePreviewConfig   *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
	ParallelUploadEnabled *bool                `json:"parallel_upload_enabled,omitempty" xml:"parallel_upload_enabled,omitempty"`
	// Parent Domain ID
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
	// Domain 
	PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
	// 
	PrepaidPackage             *string            `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	RecycleBinConfig           *RecycleBinConfig  `json:"recycle_bin_config,omitempty" xml:"recycle_bin_config,omitempty"`
	RoleConfig                 *RoleConfig        `json:"role_config,omitempty" xml:"role_config,omitempty"`
	// Domain ServiceCode
	ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// SPI  id
	SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
	// domain
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// 
	StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
	//  Region 
	StoreRegionList []*string        `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
	SubdomainConfig *SubdomainConfig `json:"subdomain_config,omitempty" xml:"subdomain_config,omitempty"`
	// Domain 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// 
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// usergroupdrive
	UserSingleDriveEnabled *bool                        `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
	VideoPreviewAppConfig  *VideoPreviewAppConfig       `json:"video_preview_app_config,omitempty" xml:"video_preview_app_config,omitempty"`
	VideoPreviewConfig     *VideoPreviewConfig          `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
	WatermarkConfig        *BaseWatermarkConfigResponse `json:"watermark_config,omitempty" xml:"watermark_config,omitempty"`
}

func (s GetDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDomainResponse) GoString() string {
	return s.String()
}

func (s *GetDomainResponse) SetApiCname(v string) *GetDomainResponse {
	s.ApiCname = &v
	return s
}

func (s *GetDomainResponse) SetAppCname(v string) *GetDomainResponse {
	s.AppCname = &v
	return s
}

func (s *GetDomainResponse) SetAppConfig(v *AppConfig) *GetDomainResponse {
	s.AppConfig = v
	return s
}

func (s *GetDomainResponse) SetArchiveFilesEnable(v bool) *GetDomainResponse {
	s.ArchiveFilesEnable = &v
	return s
}

func (s *GetDomainResponse) SetAuditLogConfig(v *AuditLogConfig) *GetDomainResponse {
	s.AuditLogConfig = v
	return s
}

func (s *GetDomainResponse) SetAuthCname(v string) *GetDomainResponse {
	s.AuthCname = &v
	return s
}

func (s *GetDomainResponse) SetAuthConfig(v map[string]interface{}) *GetDomainResponse {
	s.AuthConfig = v
	return s
}

func (s *GetDomainResponse) SetAuthDingdingAppId(v string) *GetDomainResponse {
	s.AuthDingdingAppId = &v
	return s
}

func (s *GetDomainResponse) SetAuthDingdingAppSecret(v string) *GetDomainResponse {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *GetDomainResponse) SetAuthDingdingEnable(v bool) *GetDomainResponse {
	s.AuthDingdingEnable = &v
	return s
}

func (s *GetDomainResponse) SetAuthRamAppId(v string) *GetDomainResponse {
	s.AuthRamAppId = &v
	return s
}

func (s *GetDomainResponse) SetAuthRamAppSecret(v string) *GetDomainResponse {
	s.AuthRamAppSecret = &v
	return s
}

func (s *GetDomainResponse) SetAuthRamEnable(v bool) *GetDomainResponse {
	s.AuthRamEnable = &v
	return s
}

func (s *GetDomainResponse) SetBenefits(v map[string]interface{}) *GetDomainResponse {
	s.Benefits = v
	return s
}

func (s *GetDomainResponse) SetCreatedAt(v string) *GetDomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetDomainResponse) SetDataHashName(v string) *GetDomainResponse {
	s.DataHashName = &v
	return s
}

func (s *GetDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *GetDomainResponse {
	s.DefaultSuperAdminConfig = v
	return s
}

func (s *GetDomainResponse) SetDescription(v string) *GetDomainResponse {
	s.Description = &v
	return s
}

func (s *GetDomainResponse) SetDomainId(v string) *GetDomainResponse {
	s.DomainId = &v
	return s
}

func (s *GetDomainResponse) SetDomainName(v string) *GetDomainResponse {
	s.DomainName = &v
	return s
}

func (s *GetDomainResponse) SetEnterpriseCustomizedLogin(v bool) *GetDomainResponse {
	s.EnterpriseCustomizedLogin = &v
	return s
}

func (s *GetDomainResponse) SetEventFilenameMatches(v string) *GetDomainResponse {
	s.EventFilenameMatches = &v
	return s
}

func (s *GetDomainResponse) SetEventMnsEndpoint(v string) *GetDomainResponse {
	s.EventMnsEndpoint = &v
	return s
}

func (s *GetDomainResponse) SetEventMnsTopic(v string) *GetDomainResponse {
	s.EventMnsTopic = &v
	return s
}

func (s *GetDomainResponse) SetEventNames(v []*string) *GetDomainResponse {
	s.EventNames = v
	return s
}

func (s *GetDomainResponse) SetEventRoleArn(v string) *GetDomainResponse {
	s.EventRoleArn = &v
	return s
}

func (s *GetDomainResponse) SetExpireTime(v int64) *GetDomainResponse {
	s.ExpireTime = &v
	return s
}

func (s *GetDomainResponse) SetGroupSingleDriveEnabled(v bool) *GetDomainResponse {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *GetDomainResponse) SetInitDriveEnable(v bool) *GetDomainResponse {
	s.InitDriveEnable = &v
	return s
}

func (s *GetDomainResponse) SetInitDriveSize(v int64) *GetDomainResponse {
	s.InitDriveSize = &v
	return s
}

func (s *GetDomainResponse) SetInitDriveStoreId(v string) *GetDomainResponse {
	s.InitDriveStoreId = &v
	return s
}

func (s *GetDomainResponse) SetMode(v string) *GetDomainResponse {
	s.Mode = &v
	return s
}

func (s *GetDomainResponse) SetOfficeEditConfig(v *OfficeEditConfig) *GetDomainResponse {
	s.OfficeEditConfig = v
	return s
}

func (s *GetDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *GetDomainResponse {
	s.OfficePreviewConfig = v
	return s
}

func (s *GetDomainResponse) SetParallelUploadEnabled(v bool) *GetDomainResponse {
	s.ParallelUploadEnabled = &v
	return s
}

func (s *GetDomainResponse) SetParentDomainId(v string) *GetDomainResponse {
	s.ParentDomainId = &v
	return s
}

func (s *GetDomainResponse) SetPathType(v string) *GetDomainResponse {
	s.PathType = &v
	return s
}

func (s *GetDomainResponse) SetPrepaidPackage(v string) *GetDomainResponse {
	s.PrepaidPackage = &v
	return s
}

func (s *GetDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *GetDomainResponse {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *GetDomainResponse) SetRecycleBinConfig(v *RecycleBinConfig) *GetDomainResponse {
	s.RecycleBinConfig = v
	return s
}

func (s *GetDomainResponse) SetRoleConfig(v *RoleConfig) *GetDomainResponse {
	s.RoleConfig = v
	return s
}

func (s *GetDomainResponse) SetServiceCode(v string) *GetDomainResponse {
	s.ServiceCode = &v
	return s
}

func (s *GetDomainResponse) SetSharable(v bool) *GetDomainResponse {
	s.Sharable = &v
	return s
}

func (s *GetDomainResponse) SetShareDetail(v *ShareDetailResponse) *GetDomainResponse {
	s.ShareDetail = v
	return s
}

func (s *GetDomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *GetDomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *GetDomainResponse) SetShareLinkEnabled(v bool) *GetDomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *GetDomainResponse) SetSizeQuota(v int64) *GetDomainResponse {
	s.SizeQuota = &v
	return s
}

func (s *GetDomainResponse) SetSpiInstanceId(v string) *GetDomainResponse {
	s.SpiInstanceId = &v
	return s
}

func (s *GetDomainResponse) SetStatus(v int64) *GetDomainResponse {
	s.Status = &v
	return s
}

func (s *GetDomainResponse) SetStoreLevel(v string) *GetDomainResponse {
	s.StoreLevel = &v
	return s
}

func (s *GetDomainResponse) SetStoreRegionList(v []*string) *GetDomainResponse {
	s.StoreRegionList = v
	return s
}

func (s *GetDomainResponse) SetSubdomainConfig(v *SubdomainConfig) *GetDomainResponse {
	s.SubdomainConfig = v
	return s
}

func (s *GetDomainResponse) SetUpdatedAt(v string) *GetDomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetDomainResponse) SetUsedSize(v int64) *GetDomainResponse {
	s.UsedSize = &v
	return s
}

func (s *GetDomainResponse) SetUsedSizeRefreshInterval(v int64) *GetDomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *GetDomainResponse) SetUserCountQuota(v int64) *GetDomainResponse {
	s.UserCountQuota = &v
	return s
}

func (s *GetDomainResponse) SetUserSingleDriveEnabled(v bool) *GetDomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

func (s *GetDomainResponse) SetVideoPreviewAppConfig(v *VideoPreviewAppConfig) *GetDomainResponse {
	s.VideoPreviewAppConfig = v
	return s
}

func (s *GetDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *GetDomainResponse {
	s.VideoPreviewConfig = v
	return s
}

func (s *GetDomainResponse) SetWatermarkConfig(v *BaseWatermarkConfigResponse) *GetDomainResponse {
	s.WatermarkConfig = v
	return s
}

/**
 *
 */
type GetGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGroupRequest) GoString() string {
	return s.String()
}

func (s *GetGroupRequest) SetHttpheaders(v map[string]*string) *GetGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *GetGroupRequest) SetGroupId(v string) *GetGroupRequest {
	s.GroupId = &v
	return s
}

func (s *GetGroupRequest) SetSubdomainId(v string) *GetGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * get identity to benefit pkg mapping request
 */
type GetIdentityToBenefitPkgMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
}

func (s GetIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *GetIdentityToBenefitPkgMappingRequest) SetHttpheaders(v map[string]*string) *GetIdentityToBenefitPkgMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *GetIdentityToBenefitPkgMappingRequest) SetBenefitPkgId(v string) *GetIdentityToBenefitPkgMappingRequest {
	s.BenefitPkgId = &v
	return s
}

func (s *GetIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *GetIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *GetIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *GetIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *GetIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *GetIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

/**
 *
 */
type GetMembershipRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId    *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetMembershipRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMembershipRequest) GoString() string {
	return s.String()
}

func (s *GetMembershipRequest) SetHttpheaders(v map[string]*string) *GetMembershipRequest {
	s.Httpheaders = v
	return s
}

func (s *GetMembershipRequest) SetGroupId(v string) *GetMembershipRequest {
	s.GroupId = &v
	return s
}

func (s *GetMembershipRequest) SetMemberType(v string) *GetMembershipRequest {
	s.MemberType = &v
	return s
}

func (s *GetMembershipRequest) SetSubGroupId(v string) *GetMembershipRequest {
	s.SubGroupId = &v
	return s
}

func (s *GetMembershipRequest) SetSubdomainId(v string) *GetMembershipRequest {
	s.SubdomainId = &v
	return s
}

func (s *GetMembershipRequest) SetUserId(v string) *GetMembershipRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type GetSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s GetSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainRequest) GoString() string {
	return s.String()
}

func (s *GetSubdomainRequest) SetHttpheaders(v map[string]*string) *GetSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *GetSubdomainRequest) SetSubdomainId(v string) *GetSubdomainRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type GetSubdomainResponse struct {
	// 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// 
	Description           *string `json:"description,omitempty" xml:"description,omitempty" require:"true"`
	GroupSingeDriveEnable *bool   `json:"group_singe_drive_enable,omitempty" xml:"group_singe_drive_enable,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
	// quota-1
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty" require:"true"`
	// 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserQuota              *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty" require:"true"`
	UserSingleDriveEnabled *bool  `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
}

func (s GetSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainResponse) GoString() string {
	return s.String()
}

func (s *GetSubdomainResponse) SetCreatedAt(v string) *GetSubdomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetSubdomainResponse) SetDescription(v string) *GetSubdomainResponse {
	s.Description = &v
	return s
}

func (s *GetSubdomainResponse) SetGroupSingeDriveEnable(v bool) *GetSubdomainResponse {
	s.GroupSingeDriveEnable = &v
	return s
}

func (s *GetSubdomainResponse) SetName(v string) *GetSubdomainResponse {
	s.Name = &v
	return s
}

func (s *GetSubdomainResponse) SetSharable(v bool) *GetSubdomainResponse {
	s.Sharable = &v
	return s
}

func (s *GetSubdomainResponse) SetShareDetail(v *ShareDetailResponse) *GetSubdomainResponse {
	s.ShareDetail = v
	return s
}

func (s *GetSubdomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *GetSubdomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *GetSubdomainResponse) SetShareLinkEnabled(v bool) *GetSubdomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *GetSubdomainResponse) SetStatus(v int64) *GetSubdomainResponse {
	s.Status = &v
	return s
}

func (s *GetSubdomainResponse) SetSubdomainId(v string) *GetSubdomainResponse {
	s.SubdomainId = &v
	return s
}

func (s *GetSubdomainResponse) SetTotalSize(v int64) *GetSubdomainResponse {
	s.TotalSize = &v
	return s
}

func (s *GetSubdomainResponse) SetUpdatedAt(v string) *GetSubdomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetSubdomainResponse) SetUsedSize(v int64) *GetSubdomainResponse {
	s.UsedSize = &v
	return s
}

func (s *GetSubdomainResponse) SetUsedSizeRefreshInterval(v int64) *GetSubdomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *GetSubdomainResponse) SetUserQuota(v int64) *GetSubdomainResponse {
	s.UserQuota = &v
	return s
}

func (s *GetSubdomainResponse) SetUserSingleDriveEnabled(v bool) *GetSubdomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

/**
 *
 */
type GetUserAccessTokenRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetUserAccessTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUserAccessTokenRequest) GoString() string {
	return s.String()
}

func (s *GetUserAccessTokenRequest) SetHttpheaders(v map[string]*string) *GetUserAccessTokenRequest {
	s.Httpheaders = v
	return s
}

func (s *GetUserAccessTokenRequest) SetSubdomainId(v string) *GetUserAccessTokenRequest {
	s.SubdomainId = &v
	return s
}

func (s *GetUserAccessTokenRequest) SetUserId(v string) *GetUserAccessTokenRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type GetUserAccessTokenResponse struct {
	// accessToken
	AccessToken *string `json:"access_token,omitempty" xml:"access_token,omitempty" require:"true"`
	// Default Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty" require:"true"`
	// accessTokenISO
	ExpireTime *string `json:"expire_time,omitempty" xml:"expire_time,omitempty" require:"true"`
	// accessToken
	ExpiresIn *int64 `json:"expires_in,omitempty" xml:"expires_in,omitempty" require:"true"`
	// accessToken
	RefreshToken *string `json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty" require:"true"`
	// accessTokenBearer
	TokenType *string `json:"token_type,omitempty" xml:"token_type,omitempty" require:"true"`
	// ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s GetUserAccessTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUserAccessTokenResponse) GoString() string {
	return s.String()
}

func (s *GetUserAccessTokenResponse) SetAccessToken(v string) *GetUserAccessTokenResponse {
	s.AccessToken = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetDefaultDriveId(v string) *GetUserAccessTokenResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetExpireTime(v string) *GetUserAccessTokenResponse {
	s.ExpireTime = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetExpiresIn(v int64) *GetUserAccessTokenResponse {
	s.ExpiresIn = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetRefreshToken(v string) *GetUserAccessTokenResponse {
	s.RefreshToken = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetRole(v string) *GetUserAccessTokenResponse {
	s.Role = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetTokenType(v string) *GetUserAccessTokenResponse {
	s.TokenType = &v
	return s
}

func (s *GetUserAccessTokenResponse) SetUserId(v string) *GetUserAccessTokenResponse {
	s.UserId = &v
	return s
}

/**
 * Get user request
 */
type GetUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	//  ID, ak, access_tokenuser
	// example
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetUserRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUserRequest) GoString() string {
	return s.String()
}

func (s *GetUserRequest) SetHttpheaders(v map[string]*string) *GetUserRequest {
	s.Httpheaders = v
	return s
}

func (s *GetUserRequest) SetUserId(v string) *GetUserRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type GroupInfo struct {
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// MemberRole 
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
}

func (s GroupInfo) String() string {
	return tea.Prettify(s)
}

func (s GroupInfo) GoString() string {
	return s.String()
}

func (s *GroupInfo) SetGroupId(v string) *GroupInfo {
	s.GroupId = &v
	return s
}

func (s *GroupInfo) SetMemberRole(v string) *GroupInfo {
	s.MemberRole = &v
	return s
}

/**
 *
 */
type GroupLogDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// parent_group_id
	ParentGroupId *string `json:"parent_group_id,omitempty" xml:"parent_group_id,omitempty"`
	// parent_group_name
	ParentGroupName *string                `json:"parent_group_name,omitempty" xml:"parent_group_name,omitempty"`
	UpdateTo        *GroupLogSettingDetail `json:"update_to,omitempty" xml:"update_to,omitempty"`
}

func (s GroupLogDetail) String() string {
	return tea.Prettify(s)
}

func (s GroupLogDetail) GoString() string {
	return s.String()
}

func (s *GroupLogDetail) SetName(v string) *GroupLogDetail {
	s.Name = &v
	return s
}

func (s *GroupLogDetail) SetParentGroupId(v string) *GroupLogDetail {
	s.ParentGroupId = &v
	return s
}

func (s *GroupLogDetail) SetParentGroupName(v string) *GroupLogDetail {
	s.ParentGroupName = &v
	return s
}

func (s *GroupLogDetail) SetUpdateTo(v *GroupLogSettingDetail) *GroupLogDetail {
	s.UpdateTo = v
	return s
}

/**
 *
 */
type GroupLogSettingDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// parent_group_id
	ParentGroupId *string `json:"parent_group_id,omitempty" xml:"parent_group_id,omitempty"`
	// parent_group_name
	ParentGroupName *string `json:"parent_group_name,omitempty" xml:"parent_group_name,omitempty"`
}

func (s GroupLogSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s GroupLogSettingDetail) GoString() string {
	return s.String()
}

func (s *GroupLogSettingDetail) SetName(v string) *GroupLogSettingDetail {
	s.Name = &v
	return s
}

func (s *GroupLogSettingDetail) SetParentGroupId(v string) *GroupLogSettingDetail {
	s.ParentGroupId = &v
	return s
}

func (s *GroupLogSettingDetail) SetParentGroupName(v string) *GroupLogSettingDetail {
	s.ParentGroupName = &v
	return s
}

/**
 *
 */
type HasMemberRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId    *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s HasMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s HasMemberRequest) GoString() string {
	return s.String()
}

func (s *HasMemberRequest) SetHttpheaders(v map[string]*string) *HasMemberRequest {
	s.Httpheaders = v
	return s
}

func (s *HasMemberRequest) SetGroupId(v string) *HasMemberRequest {
	s.GroupId = &v
	return s
}

func (s *HasMemberRequest) SetMemberType(v string) *HasMemberRequest {
	s.MemberType = &v
	return s
}

func (s *HasMemberRequest) SetSubGroupId(v string) *HasMemberRequest {
	s.SubGroupId = &v
	return s
}

func (s *HasMemberRequest) SetSubdomainId(v string) *HasMemberRequest {
	s.SubdomainId = &v
	return s
}

func (s *HasMemberRequest) SetUserId(v string) *HasMemberRequest {
	s.UserId = &v
	return s
}

/**
 * Identity benefit package response
 */
type IdentityBenefitPkgResponse struct {
	// 
	BenefitList []*BenefitBaseResponse `json:"benefit_list,omitempty" xml:"benefit_list,omitempty" type:"Repeated"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
	// 
	DeliveryInfoList []*BenefitPkgDeliveryInfoResponse `json:"delivery_info_list,omitempty" xml:"delivery_info_list,omitempty" type:"Repeated"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s IdentityBenefitPkgResponse) String() string {
	return tea.Prettify(s)
}

func (s IdentityBenefitPkgResponse) GoString() string {
	return s.String()
}

func (s *IdentityBenefitPkgResponse) SetBenefitList(v []*BenefitBaseResponse) *IdentityBenefitPkgResponse {
	s.BenefitList = v
	return s
}

func (s *IdentityBenefitPkgResponse) SetBenefitPkgId(v string) *IdentityBenefitPkgResponse {
	s.BenefitPkgId = &v
	return s
}

func (s *IdentityBenefitPkgResponse) SetDeliveryInfoList(v []*BenefitPkgDeliveryInfoResponse) *IdentityBenefitPkgResponse {
	s.DeliveryInfoList = v
	return s
}

func (s *IdentityBenefitPkgResponse) SetName(v string) *IdentityBenefitPkgResponse {
	s.Name = &v
	return s
}

/**
 * Import user request
 */
type ImportUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	AuthenticationType *string `json:"authentication_type,omitempty" xml:"authentication_type,omitempty" require:"true"`
	// 
	AutoCreateDrive *bool   `json:"auto_create_drive,omitempty" xml:"auto_create_drive,omitempty"`
	CustomIdentity  *string `json:"custom_identity,omitempty" xml:"custom_identity,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	DriveTotalSize *int64 `json:"drive_total_size,omitempty" xml:"drive_total_size,omitempty"`
	// typemobile86
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// 
	Identity *string `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty" require:"true"`
	// group
	ParentGroupId *string `json:"parent_group_id,omitempty" xml:"parent_group_id,omitempty"`
	// 
	PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
}

func (s ImportUserRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportUserRequest) GoString() string {
	return s.String()
}

func (s *ImportUserRequest) SetHttpheaders(v map[string]*string) *ImportUserRequest {
	s.Httpheaders = v
	return s
}

func (s *ImportUserRequest) SetAuthenticationType(v string) *ImportUserRequest {
	s.AuthenticationType = &v
	return s
}

func (s *ImportUserRequest) SetAutoCreateDrive(v bool) *ImportUserRequest {
	s.AutoCreateDrive = &v
	return s
}

func (s *ImportUserRequest) SetCustomIdentity(v string) *ImportUserRequest {
	s.CustomIdentity = &v
	return s
}

func (s *ImportUserRequest) SetDenyChangePasswordBySelf(v bool) *ImportUserRequest {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *ImportUserRequest) SetDriveTotalSize(v int64) *ImportUserRequest {
	s.DriveTotalSize = &v
	return s
}

func (s *ImportUserRequest) SetExtra(v string) *ImportUserRequest {
	s.Extra = &v
	return s
}

func (s *ImportUserRequest) SetIdentity(v string) *ImportUserRequest {
	s.Identity = &v
	return s
}

func (s *ImportUserRequest) SetNeedChangePasswordNextLogin(v bool) *ImportUserRequest {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *ImportUserRequest) SetNickName(v string) *ImportUserRequest {
	s.NickName = &v
	return s
}

func (s *ImportUserRequest) SetParentGroupId(v string) *ImportUserRequest {
	s.ParentGroupId = &v
	return s
}

func (s *ImportUserRequest) SetPlainPassword(v string) *ImportUserRequest {
	s.PlainPassword = &v
	return s
}

/**
 *
 */
type ListAppsResponse struct {
	// App 
	Items []*GetAppResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
	// App 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListAppsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppsResponse) GoString() string {
	return s.String()
}

func (s *ListAppsResponse) SetItems(v []*GetAppResponse) *ListAppsResponse {
	s.Items = v
	return s
}

func (s *ListAppsResponse) SetNextMarker(v string) *ListAppsResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type ListDeviceRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceRequest) GoString() string {
	return s.String()
}

func (s *ListDeviceRequest) SetHttpheaders(v map[string]*string) *ListDeviceRequest {
	s.Httpheaders = v
	return s
}

func (s *ListDeviceRequest) SetLimit(v int32) *ListDeviceRequest {
	s.Limit = &v
	return s
}

func (s *ListDeviceRequest) SetMarker(v string) *ListDeviceRequest {
	s.Marker = &v
	return s
}

/**
 *
 */
type ListDirectChildMembershipsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// 100
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// ["", "user", "group"], ""
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListDirectChildMembershipsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDirectChildMembershipsRequest) GoString() string {
	return s.String()
}

func (s *ListDirectChildMembershipsRequest) SetHttpheaders(v map[string]*string) *ListDirectChildMembershipsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListDirectChildMembershipsRequest) SetGroupId(v string) *ListDirectChildMembershipsRequest {
	s.GroupId = &v
	return s
}

func (s *ListDirectChildMembershipsRequest) SetLimit(v int32) *ListDirectChildMembershipsRequest {
	s.Limit = &v
	return s
}

func (s *ListDirectChildMembershipsRequest) SetMarker(v string) *ListDirectChildMembershipsRequest {
	s.Marker = &v
	return s
}

func (s *ListDirectChildMembershipsRequest) SetMemberType(v string) *ListDirectChildMembershipsRequest {
	s.MemberType = &v
	return s
}

func (s *ListDirectChildMembershipsRequest) SetSubdomainId(v string) *ListDirectChildMembershipsRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type ListDirectParentMembershipsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 100
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// 
	Marker     *string `json:"marker,omitempty" xml:"marker,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s ListDirectParentMembershipsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDirectParentMembershipsRequest) GoString() string {
	return s.String()
}

func (s *ListDirectParentMembershipsRequest) SetHttpheaders(v map[string]*string) *ListDirectParentMembershipsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetLimit(v int32) *ListDirectParentMembershipsRequest {
	s.Limit = &v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetMarker(v string) *ListDirectParentMembershipsRequest {
	s.Marker = &v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetMemberType(v string) *ListDirectParentMembershipsRequest {
	s.MemberType = &v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetSubGroupId(v string) *ListDirectParentMembershipsRequest {
	s.SubGroupId = &v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetSubdomainId(v string) *ListDirectParentMembershipsRequest {
	s.SubdomainId = &v
	return s
}

func (s *ListDirectParentMembershipsRequest) SetUserId(v string) *ListDirectParentMembershipsRequest {
	s.UserId = &v
	return s
}

/**
 * list domain cors response
 */
type ListDomainCORSRuleResponse struct {
	// cors rule 
	CorsRuleList []*CorsRule `json:"cors_rule_list,omitempty" xml:"cors_rule_list,omitempty" type:"Repeated"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
}

func (s ListDomainCORSRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDomainCORSRuleResponse) GoString() string {
	return s.String()
}

func (s *ListDomainCORSRuleResponse) SetCorsRuleList(v []*CorsRule) *ListDomainCORSRuleResponse {
	s.CorsRuleList = v
	return s
}

func (s *ListDomainCORSRuleResponse) SetDomainId(v string) *ListDomainCORSRuleResponse {
	s.DomainId = &v
	return s
}

/**
 * list domain response
 */
type ListDomainsResponse struct {
	// domain 
	Items []*BaseDomainResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponse) GoString() string {
	return s.String()
}

func (s *ListDomainsResponse) SetItems(v []*BaseDomainResponse) *ListDomainsResponse {
	s.Items = v
	return s
}

func (s *ListDomainsResponse) SetNextMarker(v string) *ListDomainsResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type ListGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 100
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	//  subdomain group
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGroupRequest) GoString() string {
	return s.String()
}

func (s *ListGroupRequest) SetHttpheaders(v map[string]*string) *ListGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *ListGroupRequest) SetLimit(v int32) *ListGroupRequest {
	s.Limit = &v
	return s
}

func (s *ListGroupRequest) SetMarker(v string) *ListGroupRequest {
	s.Marker = &v
	return s
}

func (s *ListGroupRequest) SetSubdomainId(v string) *ListGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * List identity benefit package request
 */
type ListIdentityBenefitPkgRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// benefit IDinclude_benefittrue benefit ID
	BenefitIdList []*string `json:"benefit_id_list,omitempty" xml:"benefit_id_list,omitempty" type:"Repeated"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
	// false
	IncludeBenefit *bool `json:"include_benefit,omitempty" xml:"include_benefit,omitempty"`
	// false
	IncludeExpired *bool `json:"include_expired,omitempty" xml:"include_expired,omitempty"`
}

func (s ListIdentityBenefitPkgRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityBenefitPkgRequest) GoString() string {
	return s.String()
}

func (s *ListIdentityBenefitPkgRequest) SetHttpheaders(v map[string]*string) *ListIdentityBenefitPkgRequest {
	s.Httpheaders = v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetBenefitIdList(v []*string) *ListIdentityBenefitPkgRequest {
	s.BenefitIdList = v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetDomainId(v string) *ListIdentityBenefitPkgRequest {
	s.DomainId = &v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetIdentityId(v string) *ListIdentityBenefitPkgRequest {
	s.IdentityId = &v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetIdentityType(v string) *ListIdentityBenefitPkgRequest {
	s.IdentityType = &v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetIncludeBenefit(v bool) *ListIdentityBenefitPkgRequest {
	s.IncludeBenefit = &v
	return s
}

func (s *ListIdentityBenefitPkgRequest) SetIncludeExpired(v bool) *ListIdentityBenefitPkgRequest {
	s.IncludeExpired = &v
	return s
}

/**
 * List identity benefit package response
 */
type ListIdentityBenefitPkgResponse struct {
	Items []*IdentityBenefitPkgResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListIdentityBenefitPkgResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityBenefitPkgResponse) GoString() string {
	return s.String()
}

func (s *ListIdentityBenefitPkgResponse) SetItems(v []*IdentityBenefitPkgResponse) *ListIdentityBenefitPkgResponse {
	s.Items = v
	return s
}

/**
 * list identity to benefit pkg mapping request
 */
type ListIdentityToBenefitPkgMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
	// false
	IncludeExpired *bool `json:"include_expired,omitempty" xml:"include_expired,omitempty"`
}

func (s ListIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *ListIdentityToBenefitPkgMappingRequest) SetHttpheaders(v map[string]*string) *ListIdentityToBenefitPkgMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *ListIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *ListIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *ListIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *ListIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *ListIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *ListIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

func (s *ListIdentityToBenefitPkgMappingRequest) SetIncludeExpired(v bool) *ListIdentityToBenefitPkgMappingRequest {
	s.IncludeExpired = &v
	return s
}

/**
 * List identity to benefit pkg mapping info
 */
type ListIdentityToBenefitPkgMappingResponse struct {
	Items []*BaseIdentityToBenefitPkgMappingResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListIdentityToBenefitPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityToBenefitPkgMappingResponse) GoString() string {
	return s.String()
}

func (s *ListIdentityToBenefitPkgMappingResponse) SetItems(v []*BaseIdentityToBenefitPkgMappingResponse) *ListIdentityToBenefitPkgMappingResponse {
	s.Items = v
	return s
}

/**
 *
 */
type ListStoresResponse struct {
	// Store 
	Items []*Store `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
}

func (s ListStoresResponse) String() string {
	return tea.Prettify(s)
}

func (s ListStoresResponse) GoString() string {
	return s.String()
}

func (s *ListStoresResponse) SetItems(v []*Store) *ListStoresResponse {
	s.Items = v
	return s
}

/**
 *
 */
type ListSubdomainsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 50
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	//  response 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListSubdomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSubdomainsRequest) GoString() string {
	return s.String()
}

func (s *ListSubdomainsRequest) SetHttpheaders(v map[string]*string) *ListSubdomainsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListSubdomainsRequest) SetLimit(v int32) *ListSubdomainsRequest {
	s.Limit = &v
	return s
}

func (s *ListSubdomainsRequest) SetMarker(v string) *ListSubdomainsRequest {
	s.Marker = &v
	return s
}

/**
 *
 */
type ListSubdomainsResponse struct {
	//  subdomain 
	Items []*BaseSubdomainResponse `json:"items,omitempty" xml:"items,omitempty" require:"true" type:"Repeated"`
	// list
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty" require:"true"`
}

func (s ListSubdomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSubdomainsResponse) GoString() string {
	return s.String()
}

func (s *ListSubdomainsResponse) SetItems(v []*BaseSubdomainResponse) *ListSubdomainsResponse {
	s.Items = v
	return s
}

func (s *ListSubdomainsResponse) SetNextMarker(v string) *ListSubdomainsResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type ListSyncMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListSyncMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSyncMappingRequest) GoString() string {
	return s.String()
}

func (s *ListSyncMappingRequest) SetHttpheaders(v map[string]*string) *ListSyncMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *ListSyncMappingRequest) SetDeviceName(v string) *ListSyncMappingRequest {
	s.DeviceName = &v
	return s
}

func (s *ListSyncMappingRequest) SetLimit(v int32) *ListSyncMappingRequest {
	s.Limit = &v
	return s
}

func (s *ListSyncMappingRequest) SetMarker(v string) *ListSyncMappingRequest {
	s.Marker = &v
	return s
}

/**
 * List user request
 */
type ListUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListUserRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserRequest) GoString() string {
	return s.String()
}

func (s *ListUserRequest) SetHttpheaders(v map[string]*string) *ListUserRequest {
	s.Httpheaders = v
	return s
}

func (s *ListUserRequest) SetLimit(v int32) *ListUserRequest {
	s.Limit = &v
	return s
}

func (s *ListUserRequest) SetMarker(v string) *ListUserRequest {
	s.Marker = &v
	return s
}

func (s *ListUserRequest) SetSubdomainId(v string) *ListUserRequest {
	s.SubdomainId = &v
	return s
}

/**
 *
 */
type LogDetail struct {
	AccountLogDetail    *AccountLogDetail    `json:"account_log_detail,omitempty" xml:"account_log_detail,omitempty"`
	AuditMgmtLogDetail  *AuditMgmtLogDetail  `json:"audit_mgmt_log_detail,omitempty" xml:"audit_mgmt_log_detail,omitempty"`
	DriveLogDetail      *DriveLogDetail      `json:"drive_log_detail,omitempty" xml:"drive_log_detail,omitempty"`
	EntMgmtLogDetail    *EntMgmtLogDetail    `json:"ent_mgmt_log_detail,omitempty" xml:"ent_mgmt_log_detail,omitempty"`
	FileLogDetail       *FileLogDetail       `json:"file_log_detail,omitempty" xml:"file_log_detail,omitempty"`
	GroupLogDetail      *GroupLogDetail      `json:"group_log_detail,omitempty" xml:"group_log_detail,omitempty"`
	LoginMgmtLogDetail  *LoginMgmtLogDetail  `json:"login_mgmt_log_detail,omitempty" xml:"login_mgmt_log_detail,omitempty"`
	MembershipLogDetail *MembershipLogDetail `json:"membership_log_detail,omitempty" xml:"membership_log_detail,omitempty"`
	RoleLogDetail       *RoleLogDetail       `json:"role_log_detail,omitempty" xml:"role_log_detail,omitempty"`
	SecurityLogDetail   *SecurityLogDetail   `json:"security_log_detail,omitempty" xml:"security_log_detail,omitempty"`
	ShareLinkLogDetail  *ShareLinkLogDetail  `json:"share_link_log_detail,omitempty" xml:"share_link_log_detail,omitempty"`
	ShareLogDetail      *ShareLogDetail      `json:"share_log_detail,omitempty" xml:"share_log_detail,omitempty"`
	UserLogDetail       *UserLogDetail       `json:"user_log_detail,omitempty" xml:"user_log_detail,omitempty"`
}

func (s LogDetail) String() string {
	return tea.Prettify(s)
}

func (s LogDetail) GoString() string {
	return s.String()
}

func (s *LogDetail) SetAccountLogDetail(v *AccountLogDetail) *LogDetail {
	s.AccountLogDetail = v
	return s
}

func (s *LogDetail) SetAuditMgmtLogDetail(v *AuditMgmtLogDetail) *LogDetail {
	s.AuditMgmtLogDetail = v
	return s
}

func (s *LogDetail) SetDriveLogDetail(v *DriveLogDetail) *LogDetail {
	s.DriveLogDetail = v
	return s
}

func (s *LogDetail) SetEntMgmtLogDetail(v *EntMgmtLogDetail) *LogDetail {
	s.EntMgmtLogDetail = v
	return s
}

func (s *LogDetail) SetFileLogDetail(v *FileLogDetail) *LogDetail {
	s.FileLogDetail = v
	return s
}

func (s *LogDetail) SetGroupLogDetail(v *GroupLogDetail) *LogDetail {
	s.GroupLogDetail = v
	return s
}

func (s *LogDetail) SetLoginMgmtLogDetail(v *LoginMgmtLogDetail) *LogDetail {
	s.LoginMgmtLogDetail = v
	return s
}

func (s *LogDetail) SetMembershipLogDetail(v *MembershipLogDetail) *LogDetail {
	s.MembershipLogDetail = v
	return s
}

func (s *LogDetail) SetRoleLogDetail(v *RoleLogDetail) *LogDetail {
	s.RoleLogDetail = v
	return s
}

func (s *LogDetail) SetSecurityLogDetail(v *SecurityLogDetail) *LogDetail {
	s.SecurityLogDetail = v
	return s
}

func (s *LogDetail) SetShareLinkLogDetail(v *ShareLinkLogDetail) *LogDetail {
	s.ShareLinkLogDetail = v
	return s
}

func (s *LogDetail) SetShareLogDetail(v *ShareLogDetail) *LogDetail {
	s.ShareLogDetail = v
	return s
}

func (s *LogDetail) SetUserLogDetail(v *UserLogDetail) *LogDetail {
	s.UserLogDetail = v
	return s
}

/**
 *
 */
type LoginMgmtLogDetail struct {
	// app_id
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
	// enable
	Enable           *bool             `json:"enable,omitempty" xml:"enable,omitempty"`
	LdapConfig       *LdapConfig       `json:"ldap_config,omitempty" xml:"ldap_config,omitempty"`
	WechatSyncConfig *WeChatSyncConfig `json:"wechat_sync_config,omitempty" xml:"wechat_sync_config,omitempty"`
}

func (s LoginMgmtLogDetail) String() string {
	return tea.Prettify(s)
}

func (s LoginMgmtLogDetail) GoString() string {
	return s.String()
}

func (s *LoginMgmtLogDetail) SetAppId(v string) *LoginMgmtLogDetail {
	s.AppId = &v
	return s
}

func (s *LoginMgmtLogDetail) SetEnable(v bool) *LoginMgmtLogDetail {
	s.Enable = &v
	return s
}

func (s *LoginMgmtLogDetail) SetLdapConfig(v *LdapConfig) *LoginMgmtLogDetail {
	s.LdapConfig = v
	return s
}

func (s *LoginMgmtLogDetail) SetWechatSyncConfig(v *WeChatSyncConfig) *LoginMgmtLogDetail {
	s.WechatSyncConfig = v
	return s
}

/**
 *
 */
type MemberIDInfo struct {
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	UserId     *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s MemberIDInfo) String() string {
	return tea.Prettify(s)
}

func (s MemberIDInfo) GoString() string {
	return s.String()
}

func (s *MemberIDInfo) SetMemberType(v string) *MemberIDInfo {
	s.MemberType = &v
	return s
}

func (s *MemberIDInfo) SetSubGroupId(v string) *MemberIDInfo {
	s.SubGroupId = &v
	return s
}

func (s *MemberIDInfo) SetUserId(v string) *MemberIDInfo {
	s.UserId = &v
	return s
}

/**
 *
 */
type MembershipLogDetail struct {
	// group_id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// group_name
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
	// member_name
	MemberName *string `json:"member_name,omitempty" xml:"member_name,omitempty"`
	// member_type
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
}

func (s MembershipLogDetail) String() string {
	return tea.Prettify(s)
}

func (s MembershipLogDetail) GoString() string {
	return s.String()
}

func (s *MembershipLogDetail) SetGroupId(v string) *MembershipLogDetail {
	s.GroupId = &v
	return s
}

func (s *MembershipLogDetail) SetGroupName(v string) *MembershipLogDetail {
	s.GroupName = &v
	return s
}

func (s *MembershipLogDetail) SetMemberName(v string) *MembershipLogDetail {
	s.MemberName = &v
	return s
}

func (s *MembershipLogDetail) SetMemberType(v string) *MembershipLogDetail {
	s.MemberType = &v
	return s
}

/**
 * MigrateUserToSubdomainRequest uc migrate user
 */
type MigrateUserToSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s MigrateUserToSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateUserToSubdomainRequest) GoString() string {
	return s.String()
}

func (s *MigrateUserToSubdomainRequest) SetHttpheaders(v map[string]*string) *MigrateUserToSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *MigrateUserToSubdomainRequest) SetSubdomainId(v string) *MigrateUserToSubdomainRequest {
	s.SubdomainId = &v
	return s
}

func (s *MigrateUserToSubdomainRequest) SetUserId(v string) *MigrateUserToSubdomainRequest {
	s.UserId = &v
	return s
}

/**
 * OfficeEditConfig 
 */
type OfficeEditConfig struct {
	Enabled *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	Role    *string `json:"role,omitempty" xml:"role,omitempty"`
}

func (s OfficeEditConfig) String() string {
	return tea.Prettify(s)
}

func (s OfficeEditConfig) GoString() string {
	return s.String()
}

func (s *OfficeEditConfig) SetEnabled(v bool) *OfficeEditConfig {
	s.Enabled = &v
	return s
}

func (s *OfficeEditConfig) SetRole(v string) *OfficeEditConfig {
	s.Role = &v
	return s
}

/**
 * OfficePreviewConfig 
 */
type OfficePreviewConfig struct {
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s OfficePreviewConfig) String() string {
	return tea.Prettify(s)
}

func (s OfficePreviewConfig) GoString() string {
	return s.String()
}

func (s *OfficePreviewConfig) SetEnabled(v bool) *OfficePreviewConfig {
	s.Enabled = &v
	return s
}

/**
 *
 */
type RecycleBinConfig struct {
	AutoDeleteEnabled             *bool  `json:"auto_delete_enabled,omitempty" xml:"auto_delete_enabled,omitempty"`
	AutoDeleteKeepSecond          *int64 `json:"auto_delete_keep_second,omitempty" xml:"auto_delete_keep_second,omitempty"`
	DeleteTrashNormalFileDisabled *bool  `json:"delete_trash_normal_file_disabled,omitempty" xml:"delete_trash_normal_file_disabled,omitempty"`
}

func (s RecycleBinConfig) String() string {
	return tea.Prettify(s)
}

func (s RecycleBinConfig) GoString() string {
	return s.String()
}

func (s *RecycleBinConfig) SetAutoDeleteEnabled(v bool) *RecycleBinConfig {
	s.AutoDeleteEnabled = &v
	return s
}

func (s *RecycleBinConfig) SetAutoDeleteKeepSecond(v int64) *RecycleBinConfig {
	s.AutoDeleteKeepSecond = &v
	return s
}

func (s *RecycleBinConfig) SetDeleteTrashNormalFileDisabled(v bool) *RecycleBinConfig {
	s.DeleteTrashNormalFileDisabled = &v
	return s
}

/**
 * Remove user to subdomain request
 */
type RemoveUserFromSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s RemoveUserFromSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromSubdomainRequest) GoString() string {
	return s.String()
}

func (s *RemoveUserFromSubdomainRequest) SetHttpheaders(v map[string]*string) *RemoveUserFromSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *RemoveUserFromSubdomainRequest) SetSubdomainId(v string) *RemoveUserFromSubdomainRequest {
	s.SubdomainId = &v
	return s
}

func (s *RemoveUserFromSubdomainRequest) SetUserId(v string) *RemoveUserFromSubdomainRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type RoleConfig struct {
	DefaultGroupDriveRole                    *string `json:"default_group_drive_role,omitempty" xml:"default_group_drive_role,omitempty"`
	DisabledAdminFilePermission              *bool   `json:"disabled_admin_file_permission,omitempty" xml:"disabled_admin_file_permission,omitempty"`
	Enabled                                  *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	EnabledAdminDeletePersonalFilePermission *bool   `json:"enabled_admin_delete_personal_file_permission,omitempty" xml:"enabled_admin_delete_personal_file_permission,omitempty"`
	EnabledAdminPersonalFilePermission       *bool   `json:"enabled_admin_personal_file_permission,omitempty" xml:"enabled_admin_personal_file_permission,omitempty"`
}

func (s RoleConfig) String() string {
	return tea.Prettify(s)
}

func (s RoleConfig) GoString() string {
	return s.String()
}

func (s *RoleConfig) SetDefaultGroupDriveRole(v string) *RoleConfig {
	s.DefaultGroupDriveRole = &v
	return s
}

func (s *RoleConfig) SetDisabledAdminFilePermission(v bool) *RoleConfig {
	s.DisabledAdminFilePermission = &v
	return s
}

func (s *RoleConfig) SetEnabled(v bool) *RoleConfig {
	s.Enabled = &v
	return s
}

func (s *RoleConfig) SetEnabledAdminDeletePersonalFilePermission(v bool) *RoleConfig {
	s.EnabledAdminDeletePersonalFilePermission = &v
	return s
}

func (s *RoleConfig) SetEnabledAdminPersonalFilePermission(v bool) *RoleConfig {
	s.EnabledAdminPersonalFilePermission = &v
	return s
}

/**
 *
 */
type RoleLogDetail struct {
	// manage_resource_id
	ManageResourceId *string `json:"manage_resource_id,omitempty" xml:"manage_resource_id,omitempty"`
	// manage_resource_name
	ManageResourceName *string `json:"manage_resource_name,omitempty" xml:"manage_resource_name,omitempty"`
	// manage_resource_type
	ManageResourceType *string `json:"manage_resource_type,omitempty" xml:"manage_resource_type,omitempty"`
	// member_type
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	// role_id
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty"`
	// role_tag_description
	RoleTagDescription *string `json:"role_tag_description,omitempty" xml:"role_tag_description,omitempty"`
	// role_tag_name
	RoleTagName *string               `json:"role_tag_name,omitempty" xml:"role_tag_name,omitempty"`
	UpdateTo    *RoleLogSettingDetail `json:"update_to,omitempty" xml:"update_to,omitempty"`
}

func (s RoleLogDetail) String() string {
	return tea.Prettify(s)
}

func (s RoleLogDetail) GoString() string {
	return s.String()
}

func (s *RoleLogDetail) SetManageResourceId(v string) *RoleLogDetail {
	s.ManageResourceId = &v
	return s
}

func (s *RoleLogDetail) SetManageResourceName(v string) *RoleLogDetail {
	s.ManageResourceName = &v
	return s
}

func (s *RoleLogDetail) SetManageResourceType(v string) *RoleLogDetail {
	s.ManageResourceType = &v
	return s
}

func (s *RoleLogDetail) SetMemberType(v string) *RoleLogDetail {
	s.MemberType = &v
	return s
}

func (s *RoleLogDetail) SetRoleId(v string) *RoleLogDetail {
	s.RoleId = &v
	return s
}

func (s *RoleLogDetail) SetRoleTagDescription(v string) *RoleLogDetail {
	s.RoleTagDescription = &v
	return s
}

func (s *RoleLogDetail) SetRoleTagName(v string) *RoleLogDetail {
	s.RoleTagName = &v
	return s
}

func (s *RoleLogDetail) SetUpdateTo(v *RoleLogSettingDetail) *RoleLogDetail {
	s.UpdateTo = v
	return s
}

/**
 *
 */
type RoleLogSettingDetail struct {
	// role_tag_description
	RoleTagDescription *string `json:"role_tag_description,omitempty" xml:"role_tag_description,omitempty"`
	// role_tag_name
	RoleTagName *string `json:"role_tag_name,omitempty" xml:"role_tag_name,omitempty"`
}

func (s RoleLogSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s RoleLogSettingDetail) GoString() string {
	return s.String()
}

func (s *RoleLogSettingDetail) SetRoleTagDescription(v string) *RoleLogSettingDetail {
	s.RoleTagDescription = &v
	return s
}

func (s *RoleLogSettingDetail) SetRoleTagName(v string) *RoleLogSettingDetail {
	s.RoleTagName = &v
	return s
}

/**
 * RollbackUserFromSubdomainRequest uc migrate user
 */
type RollbackUserFromSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain_id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s RollbackUserFromSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackUserFromSubdomainRequest) GoString() string {
	return s.String()
}

func (s *RollbackUserFromSubdomainRequest) SetHttpheaders(v map[string]*string) *RollbackUserFromSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *RollbackUserFromSubdomainRequest) SetSubdomainId(v string) *RollbackUserFromSubdomainRequest {
	s.SubdomainId = &v
	return s
}

func (s *RollbackUserFromSubdomainRequest) SetUserId(v string) *RollbackUserFromSubdomainRequest {
	s.UserId = &v
	return s
}

/**
 * 
 */
type SearchAllRecycleBinRequest struct {
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// fields
	Fields                    *string   `json:"fields,omitempty" xml:"fields,omitempty"`
	FilePathType              *string   `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	ImageCroppingAspectRatios []*string `json:"image_cropping_aspect_ratios,omitempty" xml:"image_cropping_aspect_ratios,omitempty" type:"Repeated"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"1"`
	// location
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// Marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
	// referer
	Referer *string `json:"referer,omitempty" xml:"referer,omitempty"`
	// sign_token
	SignToken *string `json:"sign_token,omitempty" xml:"sign_token,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty" maximum:"14400" minimum:"10"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s SearchAllRecycleBinRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAllRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *SearchAllRecycleBinRequest) SetAdditionData(v map[string]interface{}) *SearchAllRecycleBinRequest {
	s.AdditionData = v
	return s
}

func (s *SearchAllRecycleBinRequest) SetFields(v string) *SearchAllRecycleBinRequest {
	s.Fields = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetFilePathType(v string) *SearchAllRecycleBinRequest {
	s.FilePathType = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetImageCroppingAspectRatios(v []*string) *SearchAllRecycleBinRequest {
	s.ImageCroppingAspectRatios = v
	return s
}

func (s *SearchAllRecycleBinRequest) SetImageThumbnailProcess(v string) *SearchAllRecycleBinRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetImageUrlProcess(v string) *SearchAllRecycleBinRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetLimit(v int32) *SearchAllRecycleBinRequest {
	s.Limit = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetLocation(v string) *SearchAllRecycleBinRequest {
	s.Location = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetMarker(v string) *SearchAllRecycleBinRequest {
	s.Marker = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetOfficeThumbnailProcess(v string) *SearchAllRecycleBinRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetOrderBy(v string) *SearchAllRecycleBinRequest {
	s.OrderBy = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetQuery(v string) *SearchAllRecycleBinRequest {
	s.Query = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetReferer(v string) *SearchAllRecycleBinRequest {
	s.Referer = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetSignToken(v string) *SearchAllRecycleBinRequest {
	s.SignToken = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetUrlExpireSec(v int64) *SearchAllRecycleBinRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *SearchAllRecycleBinRequest) SetVideoThumbnailProcess(v string) *SearchAllRecycleBinRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * request
 */
type SearchAuditLogRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// limit
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"200" minimum:"1"`
	// Marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// query
	Query *string `json:"query,omitempty" xml:"query,omitempty" maxLength:"4096"`
}

func (s SearchAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAuditLogRequest) GoString() string {
	return s.String()
}

func (s *SearchAuditLogRequest) SetHttpheaders(v map[string]*string) *SearchAuditLogRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchAuditLogRequest) SetLimit(v int32) *SearchAuditLogRequest {
	s.Limit = &v
	return s
}

func (s *SearchAuditLogRequest) SetMarker(v string) *SearchAuditLogRequest {
	s.Marker = &v
	return s
}

func (s *SearchAuditLogRequest) SetOrderBy(v string) *SearchAuditLogRequest {
	s.OrderBy = &v
	return s
}

func (s *SearchAuditLogRequest) SetQuery(v string) *SearchAuditLogRequest {
	s.Query = &v
	return s
}

/**
 * response
 */
type SearchAuditLogResponse struct {
	// items
	Items []*BaseAuditLogResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s SearchAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchAuditLogResponse) GoString() string {
	return s.String()
}

func (s *SearchAuditLogResponse) SetItems(v []*BaseAuditLogResponse) *SearchAuditLogResponse {
	s.Items = v
	return s
}

func (s *SearchAuditLogResponse) SetNextMarker(v string) *SearchAuditLogResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type SearchGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// group_name
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
	// group_name_for_fuzzy
	GroupNameForFuzzy *string `json:"group_name_for_fuzzy,omitempty" xml:"group_name_for_fuzzy,omitempty"`
	// 100
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	//  subdomain group
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s SearchGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchGroupRequest) GoString() string {
	return s.String()
}

func (s *SearchGroupRequest) SetHttpheaders(v map[string]*string) *SearchGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchGroupRequest) SetGroupName(v string) *SearchGroupRequest {
	s.GroupName = &v
	return s
}

func (s *SearchGroupRequest) SetGroupNameForFuzzy(v string) *SearchGroupRequest {
	s.GroupNameForFuzzy = &v
	return s
}

func (s *SearchGroupRequest) SetLimit(v int32) *SearchGroupRequest {
	s.Limit = &v
	return s
}

func (s *SearchGroupRequest) SetMarker(v string) *SearchGroupRequest {
	s.Marker = &v
	return s
}

func (s *SearchGroupRequest) SetSubdomainId(v string) *SearchGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * Search user and group request
 */
type SearchUserAndGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	IdentityTypeList []*string `json:"identity_type_list,omitempty" xml:"identity_type_list,omitempty" type:"Repeated"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// Group
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// Group
	NameForFuzzy *string `json:"name_for_fuzzy,omitempty" xml:"name_for_fuzzy,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s SearchUserAndGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchUserAndGroupRequest) GoString() string {
	return s.String()
}

func (s *SearchUserAndGroupRequest) SetHttpheaders(v map[string]*string) *SearchUserAndGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchUserAndGroupRequest) SetIdentityTypeList(v []*string) *SearchUserAndGroupRequest {
	s.IdentityTypeList = v
	return s
}

func (s *SearchUserAndGroupRequest) SetLimit(v int32) *SearchUserAndGroupRequest {
	s.Limit = &v
	return s
}

func (s *SearchUserAndGroupRequest) SetMarker(v string) *SearchUserAndGroupRequest {
	s.Marker = &v
	return s
}

func (s *SearchUserAndGroupRequest) SetName(v string) *SearchUserAndGroupRequest {
	s.Name = &v
	return s
}

func (s *SearchUserAndGroupRequest) SetNameForFuzzy(v string) *SearchUserAndGroupRequest {
	s.NameForFuzzy = &v
	return s
}

func (s *SearchUserAndGroupRequest) SetSubdomainId(v string) *SearchUserAndGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * Search user request
 */
type SearchUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// 
	NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	// -
	NickNameForFuzzy *string `json:"nick_name_for_fuzzy,omitempty" xml:"nick_name_for_fuzzy,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s SearchUserRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchUserRequest) GoString() string {
	return s.String()
}

func (s *SearchUserRequest) SetHttpheaders(v map[string]*string) *SearchUserRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchUserRequest) SetEmail(v string) *SearchUserRequest {
	s.Email = &v
	return s
}

func (s *SearchUserRequest) SetLimit(v int32) *SearchUserRequest {
	s.Limit = &v
	return s
}

func (s *SearchUserRequest) SetMarker(v string) *SearchUserRequest {
	s.Marker = &v
	return s
}

func (s *SearchUserRequest) SetNickName(v string) *SearchUserRequest {
	s.NickName = &v
	return s
}

func (s *SearchUserRequest) SetNickNameForFuzzy(v string) *SearchUserRequest {
	s.NickNameForFuzzy = &v
	return s
}

func (s *SearchUserRequest) SetPhone(v string) *SearchUserRequest {
	s.Phone = &v
	return s
}

func (s *SearchUserRequest) SetRole(v string) *SearchUserRequest {
	s.Role = &v
	return s
}

func (s *SearchUserRequest) SetStatus(v string) *SearchUserRequest {
	s.Status = &v
	return s
}

func (s *SearchUserRequest) SetSubdomainId(v string) *SearchUserRequest {
	s.SubdomainId = &v
	return s
}

func (s *SearchUserRequest) SetUserName(v string) *SearchUserRequest {
	s.UserName = &v
	return s
}

/**
 *
 */
type SecurityLogDetail struct {
	ShareConfig     *ShareConfigLogDetail     `json:"share_config,omitempty" xml:"share_config,omitempty"`
	ShareLinkConfig *ShareLinkConfigLogDetail `json:"share_link_config,omitempty" xml:"share_link_config,omitempty"`
	WatermarkConfig *WatermarkEnableConfig    `json:"watermark_config,omitempty" xml:"watermark_config,omitempty"`
}

func (s SecurityLogDetail) String() string {
	return tea.Prettify(s)
}

func (s SecurityLogDetail) GoString() string {
	return s.String()
}

func (s *SecurityLogDetail) SetShareConfig(v *ShareConfigLogDetail) *SecurityLogDetail {
	s.ShareConfig = v
	return s
}

func (s *SecurityLogDetail) SetShareLinkConfig(v *ShareLinkConfigLogDetail) *SecurityLogDetail {
	s.ShareLinkConfig = v
	return s
}

func (s *SecurityLogDetail) SetWatermarkConfig(v *WatermarkEnableConfig) *SecurityLogDetail {
	s.WatermarkConfig = v
	return s
}

/**
 *
 */
type SetBizCNameCertResponse struct {
	// biz cname
	BizCname *string `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	// cert name
	CertName *string `json:"cert_name,omitempty" xml:"cert_name,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameCertResponse) String() string {
	return tea.Prettify(s)
}

func (s SetBizCNameCertResponse) GoString() string {
	return s.String()
}

func (s *SetBizCNameCertResponse) SetBizCname(v string) *SetBizCNameCertResponse {
	s.BizCname = &v
	return s
}

func (s *SetBizCNameCertResponse) SetCertName(v string) *SetBizCNameCertResponse {
	s.CertName = &v
	return s
}

func (s *SetBizCNameCertResponse) SetCnameType(v string) *SetBizCNameCertResponse {
	s.CnameType = &v
	return s
}

func (s *SetBizCNameCertResponse) SetDomainId(v string) *SetBizCNameCertResponse {
	s.DomainId = &v
	return s
}

func (s *SetBizCNameCertResponse) SetIsVpc(v bool) *SetBizCNameCertResponse {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type SetBizCNameResponse struct {
	// biz cname
	BizCname    *string      `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	CnameStatus *CNameStatus `json:"cname_status,omitempty" xml:"cname_status,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
}

func (s SetBizCNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SetBizCNameResponse) GoString() string {
	return s.String()
}

func (s *SetBizCNameResponse) SetBizCname(v string) *SetBizCNameResponse {
	s.BizCname = &v
	return s
}

func (s *SetBizCNameResponse) SetCnameStatus(v *CNameStatus) *SetBizCNameResponse {
	s.CnameStatus = v
	return s
}

func (s *SetBizCNameResponse) SetCnameType(v string) *SetBizCNameResponse {
	s.CnameType = &v
	return s
}

func (s *SetBizCNameResponse) SetDomainId(v string) *SetBizCNameResponse {
	s.DomainId = &v
	return s
}

func (s *SetBizCNameResponse) SetIsVpc(v bool) *SetBizCNameResponse {
	s.IsVpc = &v
	return s
}

/**
 *
 */
type SetDataCNameResponse struct {
	// datacname
	DataCname *string `json:"data_cname,omitempty" xml:"data_cname,omitempty" require:"true"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// data location
	Location *string `json:"location,omitempty" xml:"location,omitempty" require:"true"`
}

func (s SetDataCNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDataCNameResponse) GoString() string {
	return s.String()
}

func (s *SetDataCNameResponse) SetDataCname(v string) *SetDataCNameResponse {
	s.DataCname = &v
	return s
}

func (s *SetDataCNameResponse) SetDomainId(v string) *SetDataCNameResponse {
	s.DomainId = &v
	return s
}

func (s *SetDataCNameResponse) SetLocation(v string) *SetDataCNameResponse {
	s.Location = &v
	return s
}

/**
 *
 */
type ShareConfigLogDetail struct {
	// enable
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
}

func (s ShareConfigLogDetail) String() string {
	return tea.Prettify(s)
}

func (s ShareConfigLogDetail) GoString() string {
	return s.String()
}

func (s *ShareConfigLogDetail) SetEnable(v bool) *ShareConfigLogDetail {
	s.Enable = &v
	return s
}

/**
 * share detail response
 */
type ShareDetailResponse struct {
	// 
	AccessQuota *int64 `json:"access_quota,omitempty" xml:"access_quota,omitempty"`
	// 
	ExceedAccessQuota *bool `json:"exceed_access_quota,omitempty" xml:"exceed_access_quota,omitempty"`
}

func (s ShareDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s ShareDetailResponse) GoString() string {
	return s.String()
}

func (s *ShareDetailResponse) SetAccessQuota(v int64) *ShareDetailResponse {
	s.AccessQuota = &v
	return s
}

func (s *ShareDetailResponse) SetExceedAccessQuota(v bool) *ShareDetailResponse {
	s.ExceedAccessQuota = &v
	return s
}

/**
 *
 */
type ShareLinkConfigLogDetail struct {
	// enable
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
}

func (s ShareLinkConfigLogDetail) String() string {
	return tea.Prettify(s)
}

func (s ShareLinkConfigLogDetail) GoString() string {
	return s.String()
}

func (s *ShareLinkConfigLogDetail) SetEnable(v bool) *ShareLinkConfigLogDetail {
	s.Enable = &v
	return s
}

/**
 *
 */
type ShareLinkLogDetail struct {
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// has_multi_object
	HasMultiObject *bool `json:"has_multi_object,omitempty" xml:"has_multi_object,omitempty"`
	// has_pwd
	HasPwd *bool `json:"has_pwd,omitempty" xml:"has_pwd,omitempty"`
	// share_created_at
	ShareCreatedAt *string `json:"share_created_at,omitempty" xml:"share_created_at,omitempty"`
	// share_creator_id
	ShareCreatorId *string `json:"share_creator_id,omitempty" xml:"share_creator_id,omitempty"`
	// share_creator_name
	ShareCreatorName *string `json:"share_creator_name,omitempty" xml:"share_creator_name,omitempty"`
	// share_id ()
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// to_parent_path
	ToParentPath *string `json:"to_parent_path,omitempty" xml:"to_parent_path,omitempty"`
	// to_parent_path_type
	ToParentPathType *string `json:"to_parent_path_type,omitempty" xml:"to_parent_path_type,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ShareLinkLogDetail) String() string {
	return tea.Prettify(s)
}

func (s ShareLinkLogDetail) GoString() string {
	return s.String()
}

func (s *ShareLinkLogDetail) SetExpiration(v string) *ShareLinkLogDetail {
	s.Expiration = &v
	return s
}

func (s *ShareLinkLogDetail) SetHasMultiObject(v bool) *ShareLinkLogDetail {
	s.HasMultiObject = &v
	return s
}

func (s *ShareLinkLogDetail) SetHasPwd(v bool) *ShareLinkLogDetail {
	s.HasPwd = &v
	return s
}

func (s *ShareLinkLogDetail) SetShareCreatedAt(v string) *ShareLinkLogDetail {
	s.ShareCreatedAt = &v
	return s
}

func (s *ShareLinkLogDetail) SetShareCreatorId(v string) *ShareLinkLogDetail {
	s.ShareCreatorId = &v
	return s
}

func (s *ShareLinkLogDetail) SetShareCreatorName(v string) *ShareLinkLogDetail {
	s.ShareCreatorName = &v
	return s
}

func (s *ShareLinkLogDetail) SetShareId(v string) *ShareLinkLogDetail {
	s.ShareId = &v
	return s
}

func (s *ShareLinkLogDetail) SetToParentPath(v string) *ShareLinkLogDetail {
	s.ToParentPath = &v
	return s
}

func (s *ShareLinkLogDetail) SetToParentPathType(v string) *ShareLinkLogDetail {
	s.ToParentPathType = &v
	return s
}

func (s *ShareLinkLogDetail) SetType(v string) *ShareLinkLogDetail {
	s.Type = &v
	return s
}

/**
 * list received share request
 */
type ShareListReceivedRequest struct {
	Limit          *int32  `json:"limit,omitempty" xml:"limit,omitempty"`
	Marker         *string `json:"marker,omitempty" xml:"marker,omitempty"`
	OrderBy        *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
}

func (s ShareListReceivedRequest) String() string {
	return tea.Prettify(s)
}

func (s ShareListReceivedRequest) GoString() string {
	return s.String()
}

func (s *ShareListReceivedRequest) SetLimit(v int32) *ShareListReceivedRequest {
	s.Limit = &v
	return s
}

func (s *ShareListReceivedRequest) SetMarker(v string) *ShareListReceivedRequest {
	s.Marker = &v
	return s
}

func (s *ShareListReceivedRequest) SetOrderBy(v string) *ShareListReceivedRequest {
	s.OrderBy = &v
	return s
}

func (s *ShareListReceivedRequest) SetOrderDirection(v string) *ShareListReceivedRequest {
	s.OrderDirection = &v
	return s
}

/**
 *
 */
type ShareLogDetail struct {
	// disinherit_sub_group
	DisinheritSubGroup *bool `json:"disinherit_sub_group,omitempty" xml:"disinherit_sub_group,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// parent_path
	ParentPath *string `json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// role_id
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty"`
	// role_name
	RoleName *string `json:"role_name,omitempty" xml:"role_name,omitempty"`
	// share_to_id
	ShareToId *string `json:"share_to_id,omitempty" xml:"share_to_id,omitempty"`
	// share_to_name
	ShareToName *string `json:"share_to_name,omitempty" xml:"share_to_name,omitempty"`
	// share_to_type
	ShareToType *string `json:"share_to_type,omitempty" xml:"share_to_type,omitempty"`
	// type
	Type     *string                `json:"type,omitempty" xml:"type,omitempty"`
	UpdateTo *ShareLogSettingDetail `json:"update_to,omitempty" xml:"update_to,omitempty"`
}

func (s ShareLogDetail) String() string {
	return tea.Prettify(s)
}

func (s ShareLogDetail) GoString() string {
	return s.String()
}

func (s *ShareLogDetail) SetDisinheritSubGroup(v bool) *ShareLogDetail {
	s.DisinheritSubGroup = &v
	return s
}

func (s *ShareLogDetail) SetExpiration(v string) *ShareLogDetail {
	s.Expiration = &v
	return s
}

func (s *ShareLogDetail) SetParentPath(v string) *ShareLogDetail {
	s.ParentPath = &v
	return s
}

func (s *ShareLogDetail) SetPermissions(v []*string) *ShareLogDetail {
	s.Permissions = v
	return s
}

func (s *ShareLogDetail) SetRoleId(v string) *ShareLogDetail {
	s.RoleId = &v
	return s
}

func (s *ShareLogDetail) SetRoleName(v string) *ShareLogDetail {
	s.RoleName = &v
	return s
}

func (s *ShareLogDetail) SetShareToId(v string) *ShareLogDetail {
	s.ShareToId = &v
	return s
}

func (s *ShareLogDetail) SetShareToName(v string) *ShareLogDetail {
	s.ShareToName = &v
	return s
}

func (s *ShareLogDetail) SetShareToType(v string) *ShareLogDetail {
	s.ShareToType = &v
	return s
}

func (s *ShareLogDetail) SetType(v string) *ShareLogDetail {
	s.Type = &v
	return s
}

func (s *ShareLogDetail) SetUpdateTo(v *ShareLogSettingDetail) *ShareLogDetail {
	s.UpdateTo = v
	return s
}

/**
 *
 */
type ShareLogSettingDetail struct {
	// disinherit_sub_group
	DisinheritSubGroup *bool `json:"disinherit_sub_group,omitempty" xml:"disinherit_sub_group,omitempty"`
	// expiration
	Expiration *string `json:"expiration,omitempty" xml:"expiration,omitempty"`
	// permissions
	Permissions []*string `json:"permissions,omitempty" xml:"permissions,omitempty" type:"Repeated"`
	// role_id
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty"`
	// role_name
	RoleName *string `json:"role_name,omitempty" xml:"role_name,omitempty"`
}

func (s ShareLogSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s ShareLogSettingDetail) GoString() string {
	return s.String()
}

func (s *ShareLogSettingDetail) SetDisinheritSubGroup(v bool) *ShareLogSettingDetail {
	s.DisinheritSubGroup = &v
	return s
}

func (s *ShareLogSettingDetail) SetExpiration(v string) *ShareLogSettingDetail {
	s.Expiration = &v
	return s
}

func (s *ShareLogSettingDetail) SetPermissions(v []*string) *ShareLogSettingDetail {
	s.Permissions = v
	return s
}

func (s *ShareLogSettingDetail) SetRoleId(v string) *ShareLogSettingDetail {
	s.RoleId = &v
	return s
}

func (s *ShareLogSettingDetail) SetRoleName(v string) *ShareLogSettingDetail {
	s.RoleName = &v
	return s
}

/**
 *
 */
type SubdomainConfig struct {
	EnableRootDomainCreateResource *bool   `json:"enable_root_domain_create_resource,omitempty" xml:"enable_root_domain_create_resource,omitempty"`
	Enabled                        *bool   `json:"enabled,omitempty" xml:"enabled,omitempty"`
	IndependentStoreCountQuota     *int64  `json:"independent_store_count_quota,omitempty" xml:"independent_store_count_quota,omitempty"`
	SubdomainCountQuota            *int64  `json:"subdomain_count_quota,omitempty" xml:"subdomain_count_quota,omitempty"`
	Version                        *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s SubdomainConfig) String() string {
	return tea.Prettify(s)
}

func (s SubdomainConfig) GoString() string {
	return s.String()
}

func (s *SubdomainConfig) SetEnableRootDomainCreateResource(v bool) *SubdomainConfig {
	s.EnableRootDomainCreateResource = &v
	return s
}

func (s *SubdomainConfig) SetEnabled(v bool) *SubdomainConfig {
	s.Enabled = &v
	return s
}

func (s *SubdomainConfig) SetIndependentStoreCountQuota(v int64) *SubdomainConfig {
	s.IndependentStoreCountQuota = &v
	return s
}

func (s *SubdomainConfig) SetSubdomainCountQuota(v int64) *SubdomainConfig {
	s.SubdomainCountQuota = &v
	return s
}

func (s *SubdomainConfig) SetVersion(v string) *SubdomainConfig {
	s.Version = &v
	return s
}

/**
 *
 */
type SubdomainSetBizCNameResponse struct {
	// biz cname
	BizCname    *string      `json:"biz_cname,omitempty" xml:"biz_cname,omitempty"`
	CnameStatus *CNameStatus `json:"cname_status,omitempty" xml:"cname_status,omitempty"`
	// cname type
	CnameType *string `json:"cname_type,omitempty" xml:"cname_type,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	// is vpc
	IsVpc *bool `json:"is_vpc,omitempty" xml:"is_vpc,omitempty"`
	// subdomain ID
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
}

func (s SubdomainSetBizCNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SubdomainSetBizCNameResponse) GoString() string {
	return s.String()
}

func (s *SubdomainSetBizCNameResponse) SetBizCname(v string) *SubdomainSetBizCNameResponse {
	s.BizCname = &v
	return s
}

func (s *SubdomainSetBizCNameResponse) SetCnameStatus(v *CNameStatus) *SubdomainSetBizCNameResponse {
	s.CnameStatus = v
	return s
}

func (s *SubdomainSetBizCNameResponse) SetCnameType(v string) *SubdomainSetBizCNameResponse {
	s.CnameType = &v
	return s
}

func (s *SubdomainSetBizCNameResponse) SetDomainId(v string) *SubdomainSetBizCNameResponse {
	s.DomainId = &v
	return s
}

func (s *SubdomainSetBizCNameResponse) SetIsVpc(v bool) *SubdomainSetBizCNameResponse {
	s.IsVpc = &v
	return s
}

func (s *SubdomainSetBizCNameResponse) SetSubdomainId(v string) *SubdomainSetBizCNameResponse {
	s.SubdomainId = &v
	return s
}

/**
 * update benefit to benefit package mapping request
 */
type UpdateBenefitToPkgMappingRequest struct {
	AllowConfigByTenant *bool        `json:"allow_config_by_tenant,omitempty" xml:"allow_config_by_tenant,omitempty"`
	AllowConfigByUser   *bool        `json:"allow_config_by_user,omitempty" xml:"allow_config_by_user,omitempty"`
	AllowShowToTenant   *bool        `json:"allow_show_to_tenant,omitempty" xml:"allow_show_to_tenant,omitempty"`
	AllowShowToUser     *bool        `json:"allow_show_to_user,omitempty" xml:"allow_show_to_user,omitempty"`
	BenefitId           *string      `json:"benefit_id,omitempty" xml:"benefit_id,omitempty"`
	BenefitMeta         *BenefitMeta `json:"benefit_meta,omitempty" xml:"benefit_meta,omitempty"`
	BenefitPkgId        *string      `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty"`
	Name                *string      `json:"name,omitempty" xml:"name,omitempty"`
	UserMeta            *string      `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
}

func (s UpdateBenefitToPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBenefitToPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *UpdateBenefitToPkgMappingRequest) SetAllowConfigByTenant(v bool) *UpdateBenefitToPkgMappingRequest {
	s.AllowConfigByTenant = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetAllowConfigByUser(v bool) *UpdateBenefitToPkgMappingRequest {
	s.AllowConfigByUser = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetAllowShowToTenant(v bool) *UpdateBenefitToPkgMappingRequest {
	s.AllowShowToTenant = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetAllowShowToUser(v bool) *UpdateBenefitToPkgMappingRequest {
	s.AllowShowToUser = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetBenefitId(v string) *UpdateBenefitToPkgMappingRequest {
	s.BenefitId = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetBenefitMeta(v *BenefitMeta) *UpdateBenefitToPkgMappingRequest {
	s.BenefitMeta = v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetBenefitPkgId(v string) *UpdateBenefitToPkgMappingRequest {
	s.BenefitPkgId = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetName(v string) *UpdateBenefitToPkgMappingRequest {
	s.Name = &v
	return s
}

func (s *UpdateBenefitToPkgMappingRequest) SetUserMeta(v string) *UpdateBenefitToPkgMappingRequest {
	s.UserMeta = &v
	return s
}

/**
 *
 */
type UpdateBenefitToPkgMappingResponse struct {
}

func (s UpdateBenefitToPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBenefitToPkgMappingResponse) GoString() string {
	return s.String()
}

/**
 * create domain response
 */
type UpdateDomainResponse struct {
	// Domain APICName
	ApiCname *string `json:"api_cname,omitempty" xml:"api_cname,omitempty"`
	// Domain AppCName
	AppCname  *string    `json:"app_cname,omitempty" xml:"app_cname,omitempty"`
	AppConfig *AppConfig `json:"app_config,omitempty" xml:"app_config,omitempty"`
	// 
	ArchiveFilesEnable *bool           `json:"archive_files_enable,omitempty" xml:"archive_files_enable,omitempty"`
	AuditLogConfig     *AuditLogConfig `json:"audit_log_config,omitempty" xml:"audit_log_config,omitempty"`
	// Domain AuthCName
	AuthCname *string `json:"auth_cname,omitempty" xml:"auth_cname,omitempty"`
	// 
	AuthConfig map[string]interface{} `json:"auth_config,omitempty" xml:"auth_config,omitempty"`
	//  App Id
	AuthDingdingAppId *string `json:"auth_dingding_app_id,omitempty" xml:"auth_dingding_app_id,omitempty"`
	//  App Secret
	AuthDingdingAppSecret *string `json:"auth_dingding_app_secret,omitempty" xml:"auth_dingding_app_secret,omitempty"`
	// 
	AuthDingdingEnable *bool `json:"auth_dingding_enable,omitempty" xml:"auth_dingding_enable,omitempty"`
	// RAM App Id
	AuthRamAppId *string `json:"auth_ram_app_id,omitempty" xml:"auth_ram_app_id,omitempty"`
	// RAM App Secret
	AuthRamAppSecret *string `json:"auth_ram_app_secret,omitempty" xml:"auth_ram_app_secret,omitempty"`
	//  RAM 
	AuthRamEnable *bool                  `json:"auth_ram_enable,omitempty" xml:"auth_ram_enable,omitempty"`
	Benefits      map[string]interface{} `json:"benefits,omitempty" xml:"benefits,omitempty"`
	// Domain 
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	//  Hash 
	DataHashName            *string                 `json:"data_hash_name,omitempty" xml:"data_hash_name,omitempty"`
	DefaultSuperAdminConfig *DomainSuperAdminConfig `json:"default_super_admin_config,omitempty" xml:"default_super_admin_config,omitempty"`
	// Domain 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// Domain 
	DomainName *string `json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// 
	EnterpriseCustomizedLogin *bool `json:"enterprise_customized_login,omitempty" xml:"enterprise_customized_login,omitempty"`
	//  MNS 
	EventFilenameMatches *string `json:"event_filename_matches,omitempty" xml:"event_filename_matches,omitempty"`
	//  MNS Endpoint
	EventMnsEndpoint *string `json:"event_mns_endpoint,omitempty" xml:"event_mns_endpoint,omitempty"`
	//  MNS Topic
	EventMnsTopic *string `json:"event_mns_topic,omitempty" xml:"event_mns_topic,omitempty"`
	// 
	EventNames []*string `json:"event_names,omitempty" xml:"event_names,omitempty" type:"Repeated"`
	//  Role Arn
	EventRoleArn *string `json:"event_role_arn,omitempty" xml:"event_role_arn,omitempty"`
	// domain
	ExpireTime              *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	GroupSingleDriveEnabled *bool  `json:"group_single_drive_enabled,omitempty" xml:"group_single_drive_enabled,omitempty"`
	//  Drive
	InitDriveEnable *bool `json:"init_drive_enable,omitempty" xml:"init_drive_enable,omitempty"`
	//  Drive 
	InitDriveSize *int64 `json:"init_drive_size,omitempty" xml:"init_drive_size,omitempty"`
	//  Drive  Store ID
	InitDriveStoreId *string `json:"init_drive_store_id,omitempty" xml:"init_drive_store_id,omitempty"`
	// Domain 
	Mode                  *string              `json:"mode,omitempty" xml:"mode,omitempty"`
	OfficeEditConfig      *OfficeEditConfig    `json:"office_edit_config,omitempty" xml:"office_edit_config,omitempty"`
	OfficePreviewConfig   *OfficePreviewConfig `json:"office_preview_config,omitempty" xml:"office_preview_config,omitempty"`
	ParallelUploadEnabled *bool                `json:"parallel_upload_enabled,omitempty" xml:"parallel_upload_enabled,omitempty"`
	// Parent Domain ID
	ParentDomainId *string `json:"parent_domain_id,omitempty" xml:"parent_domain_id,omitempty"`
	// Domain 
	PathType *string `json:"path_type,omitempty" xml:"path_type,omitempty"`
	// 
	PrepaidPackage             *string            `json:"prepaid_package,omitempty" xml:"prepaid_package,omitempty"`
	PublishedAppAccessStrategy *AppAccessStrategy `json:"published_app_access_strategy,omitempty" xml:"published_app_access_strategy,omitempty"`
	RecycleBinConfig           *RecycleBinConfig  `json:"recycle_bin_config,omitempty" xml:"recycle_bin_config,omitempty"`
	RoleConfig                 *RoleConfig        `json:"role_config,omitempty" xml:"role_config,omitempty"`
	// Domain ServiceCode
	ServiceCode *string `json:"service_code,omitempty" xml:"service_code,omitempty"`
	// 
	Sharable        *bool                `json:"sharable,omitempty" xml:"sharable,omitempty"`
	ShareDetail     *ShareDetailResponse `json:"share_detail,omitempty" xml:"share_detail,omitempty"`
	ShareLinkDetail *ShareDetailResponse `json:"share_link_detail,omitempty" xml:"share_link_detail,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	SizeQuota *int64 `json:"size_quota,omitempty" xml:"size_quota,omitempty"`
	// SPI  id
	SpiInstanceId *string `json:"spi_instance_id,omitempty" xml:"spi_instance_id,omitempty"`
	// domain
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// 
	StoreLevel *string `json:"store_level,omitempty" xml:"store_level,omitempty"`
	//  Region 
	StoreRegionList []*string        `json:"store_region_list,omitempty" xml:"store_region_list,omitempty" type:"Repeated"`
	SubdomainConfig *SubdomainConfig `json:"subdomain_config,omitempty" xml:"subdomain_config,omitempty"`
	// Domain 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// 
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// 
	UserCountQuota *int64 `json:"user_count_quota,omitempty" xml:"user_count_quota,omitempty"`
	// usergroupdrive
	UserSingleDriveEnabled *bool                        `json:"user_single_drive_enabled,omitempty" xml:"user_single_drive_enabled,omitempty"`
	VideoPreviewAppConfig  *VideoPreviewAppConfig       `json:"video_preview_app_config,omitempty" xml:"video_preview_app_config,omitempty"`
	VideoPreviewConfig     *VideoPreviewConfig          `json:"video_preview_config,omitempty" xml:"video_preview_config,omitempty"`
	WatermarkConfig        *BaseWatermarkConfigResponse `json:"watermark_config,omitempty" xml:"watermark_config,omitempty"`
}

func (s UpdateDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainResponse) SetApiCname(v string) *UpdateDomainResponse {
	s.ApiCname = &v
	return s
}

func (s *UpdateDomainResponse) SetAppCname(v string) *UpdateDomainResponse {
	s.AppCname = &v
	return s
}

func (s *UpdateDomainResponse) SetAppConfig(v *AppConfig) *UpdateDomainResponse {
	s.AppConfig = v
	return s
}

func (s *UpdateDomainResponse) SetArchiveFilesEnable(v bool) *UpdateDomainResponse {
	s.ArchiveFilesEnable = &v
	return s
}

func (s *UpdateDomainResponse) SetAuditLogConfig(v *AuditLogConfig) *UpdateDomainResponse {
	s.AuditLogConfig = v
	return s
}

func (s *UpdateDomainResponse) SetAuthCname(v string) *UpdateDomainResponse {
	s.AuthCname = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthConfig(v map[string]interface{}) *UpdateDomainResponse {
	s.AuthConfig = v
	return s
}

func (s *UpdateDomainResponse) SetAuthDingdingAppId(v string) *UpdateDomainResponse {
	s.AuthDingdingAppId = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthDingdingAppSecret(v string) *UpdateDomainResponse {
	s.AuthDingdingAppSecret = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthDingdingEnable(v bool) *UpdateDomainResponse {
	s.AuthDingdingEnable = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthRamAppId(v string) *UpdateDomainResponse {
	s.AuthRamAppId = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthRamAppSecret(v string) *UpdateDomainResponse {
	s.AuthRamAppSecret = &v
	return s
}

func (s *UpdateDomainResponse) SetAuthRamEnable(v bool) *UpdateDomainResponse {
	s.AuthRamEnable = &v
	return s
}

func (s *UpdateDomainResponse) SetBenefits(v map[string]interface{}) *UpdateDomainResponse {
	s.Benefits = v
	return s
}

func (s *UpdateDomainResponse) SetCreatedAt(v string) *UpdateDomainResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateDomainResponse) SetDataHashName(v string) *UpdateDomainResponse {
	s.DataHashName = &v
	return s
}

func (s *UpdateDomainResponse) SetDefaultSuperAdminConfig(v *DomainSuperAdminConfig) *UpdateDomainResponse {
	s.DefaultSuperAdminConfig = v
	return s
}

func (s *UpdateDomainResponse) SetDescription(v string) *UpdateDomainResponse {
	s.Description = &v
	return s
}

func (s *UpdateDomainResponse) SetDomainId(v string) *UpdateDomainResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateDomainResponse) SetDomainName(v string) *UpdateDomainResponse {
	s.DomainName = &v
	return s
}

func (s *UpdateDomainResponse) SetEnterpriseCustomizedLogin(v bool) *UpdateDomainResponse {
	s.EnterpriseCustomizedLogin = &v
	return s
}

func (s *UpdateDomainResponse) SetEventFilenameMatches(v string) *UpdateDomainResponse {
	s.EventFilenameMatches = &v
	return s
}

func (s *UpdateDomainResponse) SetEventMnsEndpoint(v string) *UpdateDomainResponse {
	s.EventMnsEndpoint = &v
	return s
}

func (s *UpdateDomainResponse) SetEventMnsTopic(v string) *UpdateDomainResponse {
	s.EventMnsTopic = &v
	return s
}

func (s *UpdateDomainResponse) SetEventNames(v []*string) *UpdateDomainResponse {
	s.EventNames = v
	return s
}

func (s *UpdateDomainResponse) SetEventRoleArn(v string) *UpdateDomainResponse {
	s.EventRoleArn = &v
	return s
}

func (s *UpdateDomainResponse) SetExpireTime(v int64) *UpdateDomainResponse {
	s.ExpireTime = &v
	return s
}

func (s *UpdateDomainResponse) SetGroupSingleDriveEnabled(v bool) *UpdateDomainResponse {
	s.GroupSingleDriveEnabled = &v
	return s
}

func (s *UpdateDomainResponse) SetInitDriveEnable(v bool) *UpdateDomainResponse {
	s.InitDriveEnable = &v
	return s
}

func (s *UpdateDomainResponse) SetInitDriveSize(v int64) *UpdateDomainResponse {
	s.InitDriveSize = &v
	return s
}

func (s *UpdateDomainResponse) SetInitDriveStoreId(v string) *UpdateDomainResponse {
	s.InitDriveStoreId = &v
	return s
}

func (s *UpdateDomainResponse) SetMode(v string) *UpdateDomainResponse {
	s.Mode = &v
	return s
}

func (s *UpdateDomainResponse) SetOfficeEditConfig(v *OfficeEditConfig) *UpdateDomainResponse {
	s.OfficeEditConfig = v
	return s
}

func (s *UpdateDomainResponse) SetOfficePreviewConfig(v *OfficePreviewConfig) *UpdateDomainResponse {
	s.OfficePreviewConfig = v
	return s
}

func (s *UpdateDomainResponse) SetParallelUploadEnabled(v bool) *UpdateDomainResponse {
	s.ParallelUploadEnabled = &v
	return s
}

func (s *UpdateDomainResponse) SetParentDomainId(v string) *UpdateDomainResponse {
	s.ParentDomainId = &v
	return s
}

func (s *UpdateDomainResponse) SetPathType(v string) *UpdateDomainResponse {
	s.PathType = &v
	return s
}

func (s *UpdateDomainResponse) SetPrepaidPackage(v string) *UpdateDomainResponse {
	s.PrepaidPackage = &v
	return s
}

func (s *UpdateDomainResponse) SetPublishedAppAccessStrategy(v *AppAccessStrategy) *UpdateDomainResponse {
	s.PublishedAppAccessStrategy = v
	return s
}

func (s *UpdateDomainResponse) SetRecycleBinConfig(v *RecycleBinConfig) *UpdateDomainResponse {
	s.RecycleBinConfig = v
	return s
}

func (s *UpdateDomainResponse) SetRoleConfig(v *RoleConfig) *UpdateDomainResponse {
	s.RoleConfig = v
	return s
}

func (s *UpdateDomainResponse) SetServiceCode(v string) *UpdateDomainResponse {
	s.ServiceCode = &v
	return s
}

func (s *UpdateDomainResponse) SetSharable(v bool) *UpdateDomainResponse {
	s.Sharable = &v
	return s
}

func (s *UpdateDomainResponse) SetShareDetail(v *ShareDetailResponse) *UpdateDomainResponse {
	s.ShareDetail = v
	return s
}

func (s *UpdateDomainResponse) SetShareLinkDetail(v *ShareDetailResponse) *UpdateDomainResponse {
	s.ShareLinkDetail = v
	return s
}

func (s *UpdateDomainResponse) SetShareLinkEnabled(v bool) *UpdateDomainResponse {
	s.ShareLinkEnabled = &v
	return s
}

func (s *UpdateDomainResponse) SetSizeQuota(v int64) *UpdateDomainResponse {
	s.SizeQuota = &v
	return s
}

func (s *UpdateDomainResponse) SetSpiInstanceId(v string) *UpdateDomainResponse {
	s.SpiInstanceId = &v
	return s
}

func (s *UpdateDomainResponse) SetStatus(v int64) *UpdateDomainResponse {
	s.Status = &v
	return s
}

func (s *UpdateDomainResponse) SetStoreLevel(v string) *UpdateDomainResponse {
	s.StoreLevel = &v
	return s
}

func (s *UpdateDomainResponse) SetStoreRegionList(v []*string) *UpdateDomainResponse {
	s.StoreRegionList = v
	return s
}

func (s *UpdateDomainResponse) SetSubdomainConfig(v *SubdomainConfig) *UpdateDomainResponse {
	s.SubdomainConfig = v
	return s
}

func (s *UpdateDomainResponse) SetUpdatedAt(v string) *UpdateDomainResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UpdateDomainResponse) SetUsedSize(v int64) *UpdateDomainResponse {
	s.UsedSize = &v
	return s
}

func (s *UpdateDomainResponse) SetUsedSizeRefreshInterval(v int64) *UpdateDomainResponse {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *UpdateDomainResponse) SetUserCountQuota(v int64) *UpdateDomainResponse {
	s.UserCountQuota = &v
	return s
}

func (s *UpdateDomainResponse) SetUserSingleDriveEnabled(v bool) *UpdateDomainResponse {
	s.UserSingleDriveEnabled = &v
	return s
}

func (s *UpdateDomainResponse) SetVideoPreviewAppConfig(v *VideoPreviewAppConfig) *UpdateDomainResponse {
	s.VideoPreviewAppConfig = v
	return s
}

func (s *UpdateDomainResponse) SetVideoPreviewConfig(v *VideoPreviewConfig) *UpdateDomainResponse {
	s.VideoPreviewConfig = v
	return s
}

func (s *UpdateDomainResponse) SetWatermarkConfig(v *BaseWatermarkConfigResponse) *UpdateDomainResponse {
	s.WatermarkConfig = v
	return s
}

/**
 *
 */
type UpdateGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// 
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty" require:"true"`
	// group
	IsRoot *bool `json:"is_root,omitempty" xml:"is_root,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s UpdateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateGroupRequest) SetHttpheaders(v map[string]*string) *UpdateGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateGroupRequest) SetDescription(v string) *UpdateGroupRequest {
	s.Description = &v
	return s
}

func (s *UpdateGroupRequest) SetGroupId(v string) *UpdateGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateGroupRequest) SetGroupName(v string) *UpdateGroupRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateGroupRequest) SetIsRoot(v bool) *UpdateGroupRequest {
	s.IsRoot = &v
	return s
}

func (s *UpdateGroupRequest) SetSubdomainId(v string) *UpdateGroupRequest {
	s.SubdomainId = &v
	return s
}

/**
 * update identity to benefit pkg mapping request
 */
type UpdateIdentityToBenefitPkgMappingRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// 
	BenefitPkgId *string `json:"benefit_pkg_id,omitempty" xml:"benefit_pkg_id,omitempty" require:"true"`
	// Meta
	CustomBenefitMeta map[string]interface{} `json:"custom_benefit_meta,omitempty" xml:"custom_benefit_meta,omitempty"`
	// 
	DeliveryId *string `json:"delivery_id,omitempty" xml:"delivery_id,omitempty"`
	// domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	ExpireTime *int64 `json:"expire_time,omitempty" xml:"expire_time,omitempty"`
	//  userID
	IdentityId *string `json:"identity_id,omitempty" xml:"identity_id,omitempty" require:"true"`
	// user
	IdentityType *string `json:"identity_type,omitempty" xml:"identity_type,omitempty" require:"true"`
	// nonce ID
	NonceId *string `json:"nonce_id,omitempty" xml:"nonce_id,omitempty"`
}

func (s UpdateIdentityToBenefitPkgMappingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIdentityToBenefitPkgMappingRequest) GoString() string {
	return s.String()
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetHttpheaders(v map[string]*string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetAmount(v int64) *UpdateIdentityToBenefitPkgMappingRequest {
	s.Amount = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetBenefitPkgId(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.BenefitPkgId = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetCustomBenefitMeta(v map[string]interface{}) *UpdateIdentityToBenefitPkgMappingRequest {
	s.CustomBenefitMeta = v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetDeliveryId(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.DeliveryId = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetDomainId(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.DomainId = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetExpireTime(v int64) *UpdateIdentityToBenefitPkgMappingRequest {
	s.ExpireTime = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetIdentityId(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.IdentityId = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetIdentityType(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.IdentityType = &v
	return s
}

func (s *UpdateIdentityToBenefitPkgMappingRequest) SetNonceId(v string) *UpdateIdentityToBenefitPkgMappingRequest {
	s.NonceId = &v
	return s
}

/**
 *
 */
type UpdateIdentityToBenefitPkgMappingResponse struct {
}

func (s UpdateIdentityToBenefitPkgMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIdentityToBenefitPkgMappingResponse) GoString() string {
	return s.String()
}

/**
 *
 */
type UpdateMembershipRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// subdomain id
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
	UserId      *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s UpdateMembershipRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMembershipRequest) GoString() string {
	return s.String()
}

func (s *UpdateMembershipRequest) SetHttpheaders(v map[string]*string) *UpdateMembershipRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateMembershipRequest) SetDescription(v string) *UpdateMembershipRequest {
	s.Description = &v
	return s
}

func (s *UpdateMembershipRequest) SetGroupId(v string) *UpdateMembershipRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateMembershipRequest) SetMemberRole(v string) *UpdateMembershipRequest {
	s.MemberRole = &v
	return s
}

func (s *UpdateMembershipRequest) SetMemberType(v string) *UpdateMembershipRequest {
	s.MemberType = &v
	return s
}

func (s *UpdateMembershipRequest) SetSubGroupId(v string) *UpdateMembershipRequest {
	s.SubGroupId = &v
	return s
}

func (s *UpdateMembershipRequest) SetSubdomainId(v string) *UpdateMembershipRequest {
	s.SubdomainId = &v
	return s
}

func (s *UpdateMembershipRequest) SetUserId(v string) *UpdateMembershipRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type UpdateSubdomainRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// 
	Sharable *bool `json:"sharable,omitempty" xml:"sharable,omitempty"`
	// 
	ShareLinkEnabled *bool `json:"share_link_enabled,omitempty" xml:"share_link_enabled,omitempty"`
	// 
	Status *int64 `json:"status,omitempty" xml:"status,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty" require:"true"`
	// quota-1
	TotalSize *int64 `json:"total_size,omitempty" xml:"total_size,omitempty"`
	// 
	UsedSizeRefreshInterval *int64 `json:"used_size_refresh_interval,omitempty" xml:"used_size_refresh_interval,omitempty"`
	// quota-1
	UserQuota *int64 `json:"user_quota,omitempty" xml:"user_quota,omitempty"`
}

func (s UpdateSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubdomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateSubdomainRequest) SetHttpheaders(v map[string]*string) *UpdateSubdomainRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateSubdomainRequest) SetDescription(v string) *UpdateSubdomainRequest {
	s.Description = &v
	return s
}

func (s *UpdateSubdomainRequest) SetName(v string) *UpdateSubdomainRequest {
	s.Name = &v
	return s
}

func (s *UpdateSubdomainRequest) SetSharable(v bool) *UpdateSubdomainRequest {
	s.Sharable = &v
	return s
}

func (s *UpdateSubdomainRequest) SetShareLinkEnabled(v bool) *UpdateSubdomainRequest {
	s.ShareLinkEnabled = &v
	return s
}

func (s *UpdateSubdomainRequest) SetStatus(v int64) *UpdateSubdomainRequest {
	s.Status = &v
	return s
}

func (s *UpdateSubdomainRequest) SetSubdomainId(v string) *UpdateSubdomainRequest {
	s.SubdomainId = &v
	return s
}

func (s *UpdateSubdomainRequest) SetTotalSize(v int64) *UpdateSubdomainRequest {
	s.TotalSize = &v
	return s
}

func (s *UpdateSubdomainRequest) SetUsedSizeRefreshInterval(v int64) *UpdateSubdomainRequest {
	s.UsedSizeRefreshInterval = &v
	return s
}

func (s *UpdateSubdomainRequest) SetUserQuota(v int64) *UpdateSubdomainRequest {
	s.UserQuota = &v
	return s
}

/**
 *
 */
type UpdateSubdomainResponse struct {
}

func (s UpdateSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubdomainResponse) GoString() string {
	return s.String()
}

/**
 * Update user request
 */
type UpdateUserRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty" maxLength:"1024"`
	// 
	Email         *string      `json:"email,omitempty" xml:"email,omitempty"`
	GroupInfoList []*GroupInfo `json:"group_info_list,omitempty" xml:"group_info_list,omitempty" type:"Repeated"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName *string `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PlainPassword *string `json:"plain_password,omitempty" xml:"plain_password,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty" require:"true"`
}

func (s UpdateUserRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserRequest) GoString() string {
	return s.String()
}

func (s *UpdateUserRequest) SetHttpheaders(v map[string]*string) *UpdateUserRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateUserRequest) SetAvatar(v string) *UpdateUserRequest {
	s.Avatar = &v
	return s
}

func (s *UpdateUserRequest) SetDenyChangePasswordBySelf(v bool) *UpdateUserRequest {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *UpdateUserRequest) SetDescription(v string) *UpdateUserRequest {
	s.Description = &v
	return s
}

func (s *UpdateUserRequest) SetEmail(v string) *UpdateUserRequest {
	s.Email = &v
	return s
}

func (s *UpdateUserRequest) SetGroupInfoList(v []*GroupInfo) *UpdateUserRequest {
	s.GroupInfoList = v
	return s
}

func (s *UpdateUserRequest) SetNeedChangePasswordNextLogin(v bool) *UpdateUserRequest {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *UpdateUserRequest) SetNickName(v string) *UpdateUserRequest {
	s.NickName = &v
	return s
}

func (s *UpdateUserRequest) SetPhone(v string) *UpdateUserRequest {
	s.Phone = &v
	return s
}

func (s *UpdateUserRequest) SetPlainPassword(v string) *UpdateUserRequest {
	s.PlainPassword = &v
	return s
}

func (s *UpdateUserRequest) SetRole(v string) *UpdateUserRequest {
	s.Role = &v
	return s
}

func (s *UpdateUserRequest) SetStatus(v string) *UpdateUserRequest {
	s.Status = &v
	return s
}

func (s *UpdateUserRequest) SetUserData(v map[string]interface{}) *UpdateUserRequest {
	s.UserData = v
	return s
}

func (s *UpdateUserRequest) SetUserId(v string) *UpdateUserRequest {
	s.UserId = &v
	return s
}

/**
 *
 */
type UpgradeCheckAppRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// app_id
	AppId *string `json:"app_id,omitempty" xml:"app_id,omitempty"`
	// arch
	Arch *string `json:"arch,omitempty" xml:"arch,omitempty"`
	// version
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s UpgradeCheckAppRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeCheckAppRequest) GoString() string {
	return s.String()
}

func (s *UpgradeCheckAppRequest) SetHttpheaders(v map[string]*string) *UpgradeCheckAppRequest {
	s.Httpheaders = v
	return s
}

func (s *UpgradeCheckAppRequest) SetAppId(v string) *UpgradeCheckAppRequest {
	s.AppId = &v
	return s
}

func (s *UpgradeCheckAppRequest) SetArch(v string) *UpgradeCheckAppRequest {
	s.Arch = &v
	return s
}

func (s *UpgradeCheckAppRequest) SetVersion(v string) *UpgradeCheckAppRequest {
	s.Version = &v
	return s
}

/**
 *
 */
type UserLogDetail struct {
	// email
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// phone
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// role_id
	RoleId   *string               `json:"role_id,omitempty" xml:"role_id,omitempty"`
	UpdateTo *UserLogSettingDetail `json:"update_to,omitempty" xml:"update_to,omitempty"`
}

func (s UserLogDetail) String() string {
	return tea.Prettify(s)
}

func (s UserLogDetail) GoString() string {
	return s.String()
}

func (s *UserLogDetail) SetEmail(v string) *UserLogDetail {
	s.Email = &v
	return s
}

func (s *UserLogDetail) SetName(v string) *UserLogDetail {
	s.Name = &v
	return s
}

func (s *UserLogDetail) SetPhone(v string) *UserLogDetail {
	s.Phone = &v
	return s
}

func (s *UserLogDetail) SetRoleId(v string) *UserLogDetail {
	s.RoleId = &v
	return s
}

func (s *UserLogDetail) SetUpdateTo(v *UserLogSettingDetail) *UserLogDetail {
	s.UpdateTo = v
	return s
}

/**
 *
 */
type UserLogSettingDetail struct {
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// role_id
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty"`
}

func (s UserLogSettingDetail) String() string {
	return tea.Prettify(s)
}

func (s UserLogSettingDetail) GoString() string {
	return s.String()
}

func (s *UserLogSettingDetail) SetName(v string) *UserLogSettingDetail {
	s.Name = &v
	return s
}

func (s *UserLogSettingDetail) SetRoleId(v string) *UserLogSettingDetail {
	s.RoleId = &v
	return s
}

/**
 * 
if OnlineVideoTranscodeEnable then do video_preview play  // , OfflineVideoTranscodeEnable, 
else if appConfig.VideoPlayEnable then do source file play // AudioPlayEnable
else notify user the function not support
*/
type VideoPreviewAppConfig struct {
	OfflineAudioTranscodeEnable *bool `json:"offline_audio_transcode_enable,omitempty" xml:"offline_audio_transcode_enable,omitempty"`
	OfflineVideoTranscodeEnable *bool `json:"offline_video_transcode_enable,omitempty" xml:"offline_video_transcode_enable,omitempty"`
	OnlineAudioTranscodeEnable  *bool `json:"online_audio_transcode_enable,omitempty" xml:"online_audio_transcode_enable,omitempty"`
	OnlineVideoTranscodeEnable  *bool `json:"online_video_transcode_enable,omitempty" xml:"online_video_transcode_enable,omitempty"`
}

func (s VideoPreviewAppConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAppConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewAppConfig) SetOfflineAudioTranscodeEnable(v bool) *VideoPreviewAppConfig {
	s.OfflineAudioTranscodeEnable = &v
	return s
}

func (s *VideoPreviewAppConfig) SetOfflineVideoTranscodeEnable(v bool) *VideoPreviewAppConfig {
	s.OfflineVideoTranscodeEnable = &v
	return s
}

func (s *VideoPreviewAppConfig) SetOnlineAudioTranscodeEnable(v bool) *VideoPreviewAppConfig {
	s.OnlineAudioTranscodeEnable = &v
	return s
}

func (s *VideoPreviewAppConfig) SetOnlineVideoTranscodeEnable(v bool) *VideoPreviewAppConfig {
	s.OnlineVideoTranscodeEnable = &v
	return s
}

/**
 * 
 */
type VideoPreviewAudio struct {
	AudioBitrate    *int64  `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
	AudioChannel    *int64  `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
	AudioCodec      *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
	AudioSampleRate *int64  `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
}

func (s VideoPreviewAudio) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAudio) GoString() string {
	return s.String()
}

func (s *VideoPreviewAudio) SetAudioBitrate(v int64) *VideoPreviewAudio {
	s.AudioBitrate = &v
	return s
}

func (s *VideoPreviewAudio) SetAudioChannel(v int64) *VideoPreviewAudio {
	s.AudioChannel = &v
	return s
}

func (s *VideoPreviewAudio) SetAudioCodec(v string) *VideoPreviewAudio {
	s.AudioCodec = &v
	return s
}

func (s *VideoPreviewAudio) SetAudioSampleRate(v int64) *VideoPreviewAudio {
	s.AudioSampleRate = &v
	return s
}

/**
 * 
 */
type VideoPreviewAudioConfig struct {
	SupportExt []*string                    `json:"support_ext,omitempty" xml:"support_ext,omitempty" type:"Repeated"`
	Template   []*VideoPreviewAudioTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Repeated"`
}

func (s VideoPreviewAudioConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAudioConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewAudioConfig) SetSupportExt(v []*string) *VideoPreviewAudioConfig {
	s.SupportExt = v
	return s
}

func (s *VideoPreviewAudioConfig) SetTemplate(v []*VideoPreviewAudioTemplate) *VideoPreviewAudioConfig {
	s.Template = v
	return s
}

/**
 * 
 */
type VideoPreviewAudioTemplate struct {
	AudioBitrate    *int64  `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
	AudioChannel    *int64  `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
	AudioCodec      *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
	AudioOutputExt  *string `json:"audio_output_ext,omitempty" xml:"audio_output_ext,omitempty"`
	AudioSampleRate *int64  `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
	AudioTemplateId *string `json:"audio_template_id,omitempty" xml:"audio_template_id,omitempty"`
}

func (s VideoPreviewAudioTemplate) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAudioTemplate) GoString() string {
	return s.String()
}

func (s *VideoPreviewAudioTemplate) SetAudioBitrate(v int64) *VideoPreviewAudioTemplate {
	s.AudioBitrate = &v
	return s
}

func (s *VideoPreviewAudioTemplate) SetAudioChannel(v int64) *VideoPreviewAudioTemplate {
	s.AudioChannel = &v
	return s
}

func (s *VideoPreviewAudioTemplate) SetAudioCodec(v string) *VideoPreviewAudioTemplate {
	s.AudioCodec = &v
	return s
}

func (s *VideoPreviewAudioTemplate) SetAudioOutputExt(v string) *VideoPreviewAudioTemplate {
	s.AudioOutputExt = &v
	return s
}

func (s *VideoPreviewAudioTemplate) SetAudioSampleRate(v int64) *VideoPreviewAudioTemplate {
	s.AudioSampleRate = &v
	return s
}

func (s *VideoPreviewAudioTemplate) SetAudioTemplateId(v string) *VideoPreviewAudioTemplate {
	s.AudioTemplateId = &v
	return s
}

/**
 *
 */
type VideoPreviewAutoScaleConfig struct {
	Enabled   *bool  `json:"enabled,omitempty" xml:"enabled,omitempty"`
	MaxLength *int64 `json:"max_length,omitempty" xml:"max_length,omitempty"`
}

func (s VideoPreviewAutoScaleConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewAutoScaleConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewAutoScaleConfig) SetEnabled(v bool) *VideoPreviewAutoScaleConfig {
	s.Enabled = &v
	return s
}

func (s *VideoPreviewAutoScaleConfig) SetMaxLength(v int64) *VideoPreviewAutoScaleConfig {
	s.MaxLength = &v
	return s
}

/**
 * 
 */
type VideoPreviewBackupConfig struct {
	CountOnce  *int64                 `json:"count_once,omitempty" xml:"count_once,omitempty"`
	Store      *Store                 `json:"store,omitempty" xml:"store,omitempty"`
	StoreIdMap map[string]interface{} `json:"store_id_map,omitempty" xml:"store_id_map,omitempty"`
}

func (s VideoPreviewBackupConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewBackupConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewBackupConfig) SetCountOnce(v int64) *VideoPreviewBackupConfig {
	s.CountOnce = &v
	return s
}

func (s *VideoPreviewBackupConfig) SetStore(v *Store) *VideoPreviewBackupConfig {
	s.Store = v
	return s
}

func (s *VideoPreviewBackupConfig) SetStoreIdMap(v map[string]interface{}) *VideoPreviewBackupConfig {
	s.StoreIdMap = v
	return s
}

/**
 * 
 */
type VideoPreviewConfig struct {
	AudioConfig           *VideoPreviewAudioConfig           `json:"audio_config,omitempty" xml:"audio_config,omitempty"`
	AudioTemplateList     []*string                          `json:"audio_template_list,omitempty" xml:"audio_template_list,omitempty" type:"Repeated"`
	AudioThumbnail        *VideoPreviewThumbnailConfig       `json:"audio_thumbnail,omitempty" xml:"audio_thumbnail,omitempty"`
	BackupConfig          *VideoPreviewBackupConfig          `json:"backup_config,omitempty" xml:"backup_config,omitempty"`
	EnableConfig          *VideoPreviewEnableConfig          `json:"enable_config,omitempty" xml:"enable_config,omitempty"`
	Enabled               *bool                              `json:"enabled,omitempty" xml:"enabled,omitempty"`
	LiveTranscodingConfig *VideoPreviewLiveTranscodingConfig `json:"live_transcoding_config,omitempty" xml:"live_transcoding_config,omitempty"`
	RateLimitConfig       *VideoPreviewRateLimitConfig       `json:"rate_limit_config,omitempty" xml:"rate_limit_config,omitempty"`
	Sprite                *VideoPreviewSpriteConfig          `json:"sprite,omitempty" xml:"sprite,omitempty"`
	Store                 *Store                             `json:"store,omitempty" xml:"store,omitempty"`
	StoreIdMap            map[string]interface{}             `json:"store_id_map,omitempty" xml:"store_id_map,omitempty"`
	TemplateList          []*string                          `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
	TemplatePolicyConfig  *VideoPreviewTemplatePolicyConfig  `json:"template_policy_config,omitempty" xml:"template_policy_config,omitempty"`
	Thumbnail             *VideoPreviewThumbnailConfig       `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	VideoConfig           *VideoPreviewVideoConfig           `json:"video_config,omitempty" xml:"video_config,omitempty"`
	VideoFilterConfig     *VideoPreviewVideoFilterConfig     `json:"video_filter_config,omitempty" xml:"video_filter_config,omitempty"`
}

func (s VideoPreviewConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewConfig) SetAudioConfig(v *VideoPreviewAudioConfig) *VideoPreviewConfig {
	s.AudioConfig = v
	return s
}

func (s *VideoPreviewConfig) SetAudioTemplateList(v []*string) *VideoPreviewConfig {
	s.AudioTemplateList = v
	return s
}

func (s *VideoPreviewConfig) SetAudioThumbnail(v *VideoPreviewThumbnailConfig) *VideoPreviewConfig {
	s.AudioThumbnail = v
	return s
}

func (s *VideoPreviewConfig) SetBackupConfig(v *VideoPreviewBackupConfig) *VideoPreviewConfig {
	s.BackupConfig = v
	return s
}

func (s *VideoPreviewConfig) SetEnableConfig(v *VideoPreviewEnableConfig) *VideoPreviewConfig {
	s.EnableConfig = v
	return s
}

func (s *VideoPreviewConfig) SetEnabled(v bool) *VideoPreviewConfig {
	s.Enabled = &v
	return s
}

func (s *VideoPreviewConfig) SetLiveTranscodingConfig(v *VideoPreviewLiveTranscodingConfig) *VideoPreviewConfig {
	s.LiveTranscodingConfig = v
	return s
}

func (s *VideoPreviewConfig) SetRateLimitConfig(v *VideoPreviewRateLimitConfig) *VideoPreviewConfig {
	s.RateLimitConfig = v
	return s
}

func (s *VideoPreviewConfig) SetSprite(v *VideoPreviewSpriteConfig) *VideoPreviewConfig {
	s.Sprite = v
	return s
}

func (s *VideoPreviewConfig) SetStore(v *Store) *VideoPreviewConfig {
	s.Store = v
	return s
}

func (s *VideoPreviewConfig) SetStoreIdMap(v map[string]interface{}) *VideoPreviewConfig {
	s.StoreIdMap = v
	return s
}

func (s *VideoPreviewConfig) SetTemplateList(v []*string) *VideoPreviewConfig {
	s.TemplateList = v
	return s
}

func (s *VideoPreviewConfig) SetTemplatePolicyConfig(v *VideoPreviewTemplatePolicyConfig) *VideoPreviewConfig {
	s.TemplatePolicyConfig = v
	return s
}

func (s *VideoPreviewConfig) SetThumbnail(v *VideoPreviewThumbnailConfig) *VideoPreviewConfig {
	s.Thumbnail = v
	return s
}

func (s *VideoPreviewConfig) SetVideoConfig(v *VideoPreviewVideoConfig) *VideoPreviewConfig {
	s.VideoConfig = v
	return s
}

func (s *VideoPreviewConfig) SetVideoFilterConfig(v *VideoPreviewVideoFilterConfig) *VideoPreviewConfig {
	s.VideoFilterConfig = v
	return s
}

/**
 * 
 */
type VideoPreviewEnableConfig struct {
	DisableOfflineAudioTranscode *bool `json:"disable_offline_audio_transcode,omitempty" xml:"disable_offline_audio_transcode,omitempty"`
	DisableOfflineVideoTranscode *bool `json:"disable_offline_video_transcode,omitempty" xml:"disable_offline_video_transcode,omitempty"`
	EnableTranscodeWhenPlay      *bool `json:"enable_transcode_when_play,omitempty" xml:"enable_transcode_when_play,omitempty"`
	EnableTranscodeWhenUploaded  *bool `json:"enable_transcode_when_uploaded,omitempty" xml:"enable_transcode_when_uploaded,omitempty"`
}

func (s VideoPreviewEnableConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewEnableConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewEnableConfig) SetDisableOfflineAudioTranscode(v bool) *VideoPreviewEnableConfig {
	s.DisableOfflineAudioTranscode = &v
	return s
}

func (s *VideoPreviewEnableConfig) SetDisableOfflineVideoTranscode(v bool) *VideoPreviewEnableConfig {
	s.DisableOfflineVideoTranscode = &v
	return s
}

func (s *VideoPreviewEnableConfig) SetEnableTranscodeWhenPlay(v bool) *VideoPreviewEnableConfig {
	s.EnableTranscodeWhenPlay = &v
	return s
}

func (s *VideoPreviewEnableConfig) SetEnableTranscodeWhenUploaded(v bool) *VideoPreviewEnableConfig {
	s.EnableTranscodeWhenUploaded = &v
	return s
}

/**
 * 
 */
type VideoPreviewLiveTranscodingConfig struct {
	CurrentVersion     *int64                                     `json:"current_version,omitempty" xml:"current_version,omitempty"`
	DeprecatedVersion  *int64                                     `json:"deprecated_version,omitempty" xml:"deprecated_version,omitempty"`
	DetailCountLimit   *int64                                     `json:"detail_count_limit,omitempty" xml:"detail_count_limit,omitempty"`
	EnableConfig       *VideoPreviewLiveTranscodingEnableConfig   `json:"enable_config,omitempty" xml:"enable_config,omitempty"`
	Enabled            *bool                                      `json:"enabled,omitempty" xml:"enabled,omitempty"`
	IgnoreTemplateList []*string                                  `json:"ignore_template_list,omitempty" xml:"ignore_template_list,omitempty" type:"Repeated"`
	LeadingPrefix      *string                                    `json:"leading_prefix,omitempty" xml:"leading_prefix,omitempty"`
	M3u8FilePrefix     *string                                    `json:"m3u8_file_prefix,omitempty" xml:"m3u8_file_prefix,omitempty"`
	MediaDurationLimit *float64                                   `json:"media_duration_limit,omitempty" xml:"media_duration_limit,omitempty"`
	RefTaskConfig      *VideoPreviewLiveTranscodingRefTaskConfig  `json:"ref_task_config,omitempty" xml:"ref_task_config,omitempty"`
	Segment            *int64                                     `json:"segment,omitempty" xml:"segment,omitempty"`
	SubtitleConfig     *VideoPreviewLiveTranscodingSubtitleConfig `json:"subtitle_config,omitempty" xml:"subtitle_config,omitempty"`
	TemplateList       []*string                                  `json:"template_list,omitempty" xml:"template_list,omitempty" type:"Repeated"`
	TemplateListSorted []*string                                  `json:"template_list_sorted,omitempty" xml:"template_list_sorted,omitempty" type:"Repeated"`
	TemplateNameMap    map[string]interface{}                     `json:"template_name_map,omitempty" xml:"template_name_map,omitempty"`
	// Mode              string   `json:"mode"`               // media
	// counttaskstatusstage, 
	TsCountWhenInitM3u8 *int64  `json:"ts_count_when_init_m3u8,omitempty" xml:"ts_count_when_init_m3u8,omitempty"`
	TsCountWhenTs404    *int64  `json:"ts_count_when_ts_404,omitempty" xml:"ts_count_when_ts_404,omitempty"`
	TsFilePrefix        *string `json:"ts_file_prefix,omitempty" xml:"ts_file_prefix,omitempty"`
}

func (s VideoPreviewLiveTranscodingConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewLiveTranscodingConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewLiveTranscodingConfig) SetCurrentVersion(v int64) *VideoPreviewLiveTranscodingConfig {
	s.CurrentVersion = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetDeprecatedVersion(v int64) *VideoPreviewLiveTranscodingConfig {
	s.DeprecatedVersion = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetDetailCountLimit(v int64) *VideoPreviewLiveTranscodingConfig {
	s.DetailCountLimit = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetEnableConfig(v *VideoPreviewLiveTranscodingEnableConfig) *VideoPreviewLiveTranscodingConfig {
	s.EnableConfig = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetEnabled(v bool) *VideoPreviewLiveTranscodingConfig {
	s.Enabled = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetIgnoreTemplateList(v []*string) *VideoPreviewLiveTranscodingConfig {
	s.IgnoreTemplateList = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetLeadingPrefix(v string) *VideoPreviewLiveTranscodingConfig {
	s.LeadingPrefix = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetM3u8FilePrefix(v string) *VideoPreviewLiveTranscodingConfig {
	s.M3u8FilePrefix = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetMediaDurationLimit(v float64) *VideoPreviewLiveTranscodingConfig {
	s.MediaDurationLimit = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetRefTaskConfig(v *VideoPreviewLiveTranscodingRefTaskConfig) *VideoPreviewLiveTranscodingConfig {
	s.RefTaskConfig = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetSegment(v int64) *VideoPreviewLiveTranscodingConfig {
	s.Segment = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetSubtitleConfig(v *VideoPreviewLiveTranscodingSubtitleConfig) *VideoPreviewLiveTranscodingConfig {
	s.SubtitleConfig = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTemplateList(v []*string) *VideoPreviewLiveTranscodingConfig {
	s.TemplateList = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTemplateListSorted(v []*string) *VideoPreviewLiveTranscodingConfig {
	s.TemplateListSorted = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTemplateNameMap(v map[string]interface{}) *VideoPreviewLiveTranscodingConfig {
	s.TemplateNameMap = v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsCountWhenInitM3u8(v int64) *VideoPreviewLiveTranscodingConfig {
	s.TsCountWhenInitM3u8 = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsCountWhenTs404(v int64) *VideoPreviewLiveTranscodingConfig {
	s.TsCountWhenTs404 = &v
	return s
}

func (s *VideoPreviewLiveTranscodingConfig) SetTsFilePrefix(v string) *VideoPreviewLiveTranscodingConfig {
	s.TsFilePrefix = &v
	return s
}

/**
 * 
 */
type VideoPreviewLiveTranscodingEnableConfig struct {
	DropFileCreatedEvent      *bool `json:"drop_file_created_event,omitempty" xml:"drop_file_created_event,omitempty"`
	EnableDumpOldM3u8TaskInfo *bool `json:"enable_dump_old_m3u8_task_info,omitempty" xml:"enable_dump_old_m3u8_task_info,omitempty"`
	EnableIgnoreCopiedFile    *bool `json:"enable_ignore_copied_file,omitempty" xml:"enable_ignore_copied_file,omitempty"`
}

func (s VideoPreviewLiveTranscodingEnableConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewLiveTranscodingEnableConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewLiveTranscodingEnableConfig) SetDropFileCreatedEvent(v bool) *VideoPreviewLiveTranscodingEnableConfig {
	s.DropFileCreatedEvent = &v
	return s
}

func (s *VideoPreviewLiveTranscodingEnableConfig) SetEnableDumpOldM3u8TaskInfo(v bool) *VideoPreviewLiveTranscodingEnableConfig {
	s.EnableDumpOldM3u8TaskInfo = &v
	return s
}

func (s *VideoPreviewLiveTranscodingEnableConfig) SetEnableIgnoreCopiedFile(v bool) *VideoPreviewLiveTranscodingEnableConfig {
	s.EnableIgnoreCopiedFile = &v
	return s
}

/**
 * refTask
 */
type VideoPreviewLiveTranscodingRefTaskConfig struct {
	Duration *float64 `json:"duration,omitempty" xml:"duration,omitempty"`
	Enabled  *bool    `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s VideoPreviewLiveTranscodingRefTaskConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewLiveTranscodingRefTaskConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewLiveTranscodingRefTaskConfig) SetDuration(v float64) *VideoPreviewLiveTranscodingRefTaskConfig {
	s.Duration = &v
	return s
}

func (s *VideoPreviewLiveTranscodingRefTaskConfig) SetEnabled(v bool) *VideoPreviewLiveTranscodingRefTaskConfig {
	s.Enabled = &v
	return s
}

/**
 * 
 */
type VideoPreviewLiveTranscodingSubtitleConfig struct {
	Enabled          *bool     `json:"enabled,omitempty" xml:"enabled,omitempty"`
	ExtractFormat    *string   `json:"extract_format,omitempty" xml:"extract_format,omitempty"`
	SubtitleLangList []*string `json:"subtitle_lang_list,omitempty" xml:"subtitle_lang_list,omitempty" type:"Repeated"`
}

func (s VideoPreviewLiveTranscodingSubtitleConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewLiveTranscodingSubtitleConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewLiveTranscodingSubtitleConfig) SetEnabled(v bool) *VideoPreviewLiveTranscodingSubtitleConfig {
	s.Enabled = &v
	return s
}

func (s *VideoPreviewLiveTranscodingSubtitleConfig) SetExtractFormat(v string) *VideoPreviewLiveTranscodingSubtitleConfig {
	s.ExtractFormat = &v
	return s
}

func (s *VideoPreviewLiveTranscodingSubtitleConfig) SetSubtitleLangList(v []*string) *VideoPreviewLiveTranscodingSubtitleConfig {
	s.SubtitleLangList = v
	return s
}

/**
 *
 */
type VideoPreviewM3U8Config struct {
	HlsTime *int64 `json:"hls_time,omitempty" xml:"hls_time,omitempty"`
}

func (s VideoPreviewM3U8Config) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewM3U8Config) GoString() string {
	return s.String()
}

func (s *VideoPreviewM3U8Config) SetHlsTime(v int64) *VideoPreviewM3U8Config {
	s.HlsTime = &v
	return s
}

/**
 * 
 */
type VideoPreviewRateLimitConfig struct {
	RateLimit *int64 `json:"rate_limit,omitempty" xml:"rate_limit,omitempty"`
}

func (s VideoPreviewRateLimitConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewRateLimitConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewRateLimitConfig) SetRateLimit(v int64) *VideoPreviewRateLimitConfig {
	s.RateLimit = &v
	return s
}

/**
 * 
 */
type VideoPreviewSpriteConfig struct {
	AutoScale   *VideoPreviewAutoScaleConfig      `json:"auto_scale,omitempty" xml:"auto_scale,omitempty"`
	Col         *int64                            `json:"col,omitempty" xml:"col,omitempty"`
	FrameHeight *int64                            `json:"frame_height,omitempty" xml:"frame_height,omitempty"`
	FrameWidth  *int64                            `json:"frame_width,omitempty" xml:"frame_width,omitempty"`
	Interval    *VideoPreviewSpriteIntervalConfig `json:"interval,omitempty" xml:"interval,omitempty"`
	Row         *int64                            `json:"row,omitempty" xml:"row,omitempty"`
}

func (s VideoPreviewSpriteConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewSpriteConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewSpriteConfig) SetAutoScale(v *VideoPreviewAutoScaleConfig) *VideoPreviewSpriteConfig {
	s.AutoScale = v
	return s
}

func (s *VideoPreviewSpriteConfig) SetCol(v int64) *VideoPreviewSpriteConfig {
	s.Col = &v
	return s
}

func (s *VideoPreviewSpriteConfig) SetFrameHeight(v int64) *VideoPreviewSpriteConfig {
	s.FrameHeight = &v
	return s
}

func (s *VideoPreviewSpriteConfig) SetFrameWidth(v int64) *VideoPreviewSpriteConfig {
	s.FrameWidth = &v
	return s
}

func (s *VideoPreviewSpriteConfig) SetInterval(v *VideoPreviewSpriteIntervalConfig) *VideoPreviewSpriteConfig {
	s.Interval = v
	return s
}

func (s *VideoPreviewSpriteConfig) SetRow(v int64) *VideoPreviewSpriteConfig {
	s.Row = &v
	return s
}

/**
 * 1%
 */
type VideoPreviewSpriteIntervalConfig struct {
	DefaultInterval  *string   `json:"default_interval,omitempty" xml:"default_interval,omitempty"`
	GrabIntervalList []*string `json:"grab_interval_list,omitempty" xml:"grab_interval_list,omitempty" type:"Repeated"`
	UpperLimitList   []*int    `json:"upper_limit_list,omitempty" xml:"upper_limit_list,omitempty" type:"Repeated"`
}

func (s VideoPreviewSpriteIntervalConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewSpriteIntervalConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewSpriteIntervalConfig) SetDefaultInterval(v string) *VideoPreviewSpriteIntervalConfig {
	s.DefaultInterval = &v
	return s
}

func (s *VideoPreviewSpriteIntervalConfig) SetGrabIntervalList(v []*string) *VideoPreviewSpriteIntervalConfig {
	s.GrabIntervalList = v
	return s
}

func (s *VideoPreviewSpriteIntervalConfig) SetUpperLimitList(v []*int) *VideoPreviewSpriteIntervalConfig {
	s.UpperLimitList = v
	return s
}

/**
 * , ,  bug
 hotfix 
*/
type VideoPreviewTemplatePolicyAliyundriveConfig struct {
	PreTranscodeBeginDuration *int64 `json:"pre_transcode_begin_duration,omitempty" xml:"pre_transcode_begin_duration,omitempty"`
}

func (s VideoPreviewTemplatePolicyAliyundriveConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewTemplatePolicyAliyundriveConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewTemplatePolicyAliyundriveConfig) SetPreTranscodeBeginDuration(v int64) *VideoPreviewTemplatePolicyAliyundriveConfig {
	s.PreTranscodeBeginDuration = &v
	return s
}

/**
 * 
 */
type VideoPreviewTemplatePolicyConfig struct {
	AliyundriveConfig *VideoPreviewTemplatePolicyAliyundriveConfig `json:"aliyundrive_config,omitempty" xml:"aliyundrive_config,omitempty"`
	Policy            *string                                      `json:"policy,omitempty" xml:"policy,omitempty"`
}

func (s VideoPreviewTemplatePolicyConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewTemplatePolicyConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewTemplatePolicyConfig) SetAliyundriveConfig(v *VideoPreviewTemplatePolicyAliyundriveConfig) *VideoPreviewTemplatePolicyConfig {
	s.AliyundriveConfig = v
	return s
}

func (s *VideoPreviewTemplatePolicyConfig) SetPolicy(v string) *VideoPreviewTemplatePolicyConfig {
	s.Policy = &v
	return s
}

/**
 * 
 */
type VideoPreviewThumbnailConfig struct {
	SkipBeginPercent *string  `json:"skip_begin_percent,omitempty" xml:"skip_begin_percent,omitempty"`
	SkipBeginSec     *float64 `json:"skip_begin_sec,omitempty" xml:"skip_begin_sec,omitempty"`
}

func (s VideoPreviewThumbnailConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewThumbnailConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewThumbnailConfig) SetSkipBeginPercent(v string) *VideoPreviewThumbnailConfig {
	s.SkipBeginPercent = &v
	return s
}

func (s *VideoPreviewThumbnailConfig) SetSkipBeginSec(v float64) *VideoPreviewThumbnailConfig {
	s.SkipBeginSec = &v
	return s
}

/**
 * 
 */
type VideoPreviewVideo struct {
	Height         *int64  `json:"height,omitempty" xml:"height,omitempty"`
	KeepOriginal   *bool   `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
	VideoBitrate   *int64  `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
	VideoCodec     *string `json:"video_codec,omitempty" xml:"video_codec,omitempty"`
	VideoFrameRate *int64  `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
	Width          *int64  `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideo) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewVideo) GoString() string {
	return s.String()
}

func (s *VideoPreviewVideo) SetHeight(v int64) *VideoPreviewVideo {
	s.Height = &v
	return s
}

func (s *VideoPreviewVideo) SetKeepOriginal(v bool) *VideoPreviewVideo {
	s.KeepOriginal = &v
	return s
}

func (s *VideoPreviewVideo) SetVideoBitrate(v int64) *VideoPreviewVideo {
	s.VideoBitrate = &v
	return s
}

func (s *VideoPreviewVideo) SetVideoCodec(v string) *VideoPreviewVideo {
	s.VideoCodec = &v
	return s
}

func (s *VideoPreviewVideo) SetVideoFrameRate(v int64) *VideoPreviewVideo {
	s.VideoFrameRate = &v
	return s
}

func (s *VideoPreviewVideo) SetWidth(v int64) *VideoPreviewVideo {
	s.Width = &v
	return s
}

/**
 * 
 */
type VideoPreviewVideoConfig struct {
	DefaultOutputExt *string                      `json:"default_output_ext,omitempty" xml:"default_output_ext,omitempty"`
	KeepOriginal     *bool                        `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
	M3u8Config       *VideoPreviewM3U8Config      `json:"m3u8_config,omitempty" xml:"m3u8_config,omitempty"`
	SupportExt       []*string                    `json:"support_ext,omitempty" xml:"support_ext,omitempty" type:"Repeated"`
	Template         []*VideoPreviewVideoTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Repeated"`
}

func (s VideoPreviewVideoConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewVideoConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewVideoConfig) SetDefaultOutputExt(v string) *VideoPreviewVideoConfig {
	s.DefaultOutputExt = &v
	return s
}

func (s *VideoPreviewVideoConfig) SetKeepOriginal(v bool) *VideoPreviewVideoConfig {
	s.KeepOriginal = &v
	return s
}

func (s *VideoPreviewVideoConfig) SetM3u8Config(v *VideoPreviewM3U8Config) *VideoPreviewVideoConfig {
	s.M3u8Config = v
	return s
}

func (s *VideoPreviewVideoConfig) SetSupportExt(v []*string) *VideoPreviewVideoConfig {
	s.SupportExt = v
	return s
}

func (s *VideoPreviewVideoConfig) SetTemplate(v []*VideoPreviewVideoTemplate) *VideoPreviewVideoConfig {
	s.Template = v
	return s
}

/**
 * TODO: 
null
*/
type VideoPreviewVideoFilterConfig struct {
	AudioBitrate *int64 `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
	AudioChannel *int64 `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
	// 
	AudioCodecList  []*string `json:"audio_codec_list,omitempty" xml:"audio_codec_list,omitempty" type:"Repeated"`
	AudioSampleRate *int64    `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
	Bitrate         *int64    `json:"bitrate,omitempty" xml:"bitrate,omitempty"`
	// 
	Duration     *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
	Height       *int64 `json:"height,omitempty" xml:"height,omitempty"`
	Pixel        *int64 `json:"pixel,omitempty" xml:"pixel,omitempty"`
	Size         *int64 `json:"size,omitempty" xml:"size,omitempty"`
	VideoBitrate *int64 `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
	// 
	VideoCodecList []*string `json:"video_codec_list,omitempty" xml:"video_codec_list,omitempty" type:"Repeated"`
	VideoFrameRate *int64    `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
	Width          *int64    `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideoFilterConfig) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewVideoFilterConfig) GoString() string {
	return s.String()
}

func (s *VideoPreviewVideoFilterConfig) SetAudioBitrate(v int64) *VideoPreviewVideoFilterConfig {
	s.AudioBitrate = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioChannel(v int64) *VideoPreviewVideoFilterConfig {
	s.AudioChannel = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioCodecList(v []*string) *VideoPreviewVideoFilterConfig {
	s.AudioCodecList = v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetAudioSampleRate(v int64) *VideoPreviewVideoFilterConfig {
	s.AudioSampleRate = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetBitrate(v int64) *VideoPreviewVideoFilterConfig {
	s.Bitrate = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetDuration(v int64) *VideoPreviewVideoFilterConfig {
	s.Duration = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetHeight(v int64) *VideoPreviewVideoFilterConfig {
	s.Height = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetPixel(v int64) *VideoPreviewVideoFilterConfig {
	s.Pixel = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetSize(v int64) *VideoPreviewVideoFilterConfig {
	s.Size = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoBitrate(v int64) *VideoPreviewVideoFilterConfig {
	s.VideoBitrate = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoCodecList(v []*string) *VideoPreviewVideoFilterConfig {
	s.VideoCodecList = v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetVideoFrameRate(v int64) *VideoPreviewVideoFilterConfig {
	s.VideoFrameRate = &v
	return s
}

func (s *VideoPreviewVideoFilterConfig) SetWidth(v int64) *VideoPreviewVideoFilterConfig {
	s.Width = &v
	return s
}

/**
 * 
 */
type VideoPreviewVideoTemplate struct {
	AudioBitrate    *int64  `json:"audio_bitrate,omitempty" xml:"audio_bitrate,omitempty"`
	AudioChannel    *int64  `json:"audio_channel,omitempty" xml:"audio_channel,omitempty"`
	AudioCodec      *string `json:"audio_codec,omitempty" xml:"audio_codec,omitempty"`
	AudioSampleRate *int64  `json:"audio_sample_rate,omitempty" xml:"audio_sample_rate,omitempty"`
	Height          *int64  `json:"height,omitempty" xml:"height,omitempty"`
	KeepOriginal    *bool   `json:"keep_original,omitempty" xml:"keep_original,omitempty"`
	VideoBitrate    *int64  `json:"video_bitrate,omitempty" xml:"video_bitrate,omitempty"`
	VideoCodec      *string `json:"video_codec,omitempty" xml:"video_codec,omitempty"`
	VideoFrameRate  *int64  `json:"video_frame_rate,omitempty" xml:"video_frame_rate,omitempty"`
	VideoOutputExt  *string `json:"video_output_ext,omitempty" xml:"video_output_ext,omitempty"`
	VideoTemplateId *string `json:"video_template_id,omitempty" xml:"video_template_id,omitempty"`
	Width           *int64  `json:"width,omitempty" xml:"width,omitempty"`
}

func (s VideoPreviewVideoTemplate) String() string {
	return tea.Prettify(s)
}

func (s VideoPreviewVideoTemplate) GoString() string {
	return s.String()
}

func (s *VideoPreviewVideoTemplate) SetAudioBitrate(v int64) *VideoPreviewVideoTemplate {
	s.AudioBitrate = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetAudioChannel(v int64) *VideoPreviewVideoTemplate {
	s.AudioChannel = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetAudioCodec(v string) *VideoPreviewVideoTemplate {
	s.AudioCodec = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetAudioSampleRate(v int64) *VideoPreviewVideoTemplate {
	s.AudioSampleRate = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetHeight(v int64) *VideoPreviewVideoTemplate {
	s.Height = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetKeepOriginal(v bool) *VideoPreviewVideoTemplate {
	s.KeepOriginal = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetVideoBitrate(v int64) *VideoPreviewVideoTemplate {
	s.VideoBitrate = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetVideoCodec(v string) *VideoPreviewVideoTemplate {
	s.VideoCodec = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetVideoFrameRate(v int64) *VideoPreviewVideoTemplate {
	s.VideoFrameRate = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetVideoOutputExt(v string) *VideoPreviewVideoTemplate {
	s.VideoOutputExt = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetVideoTemplateId(v string) *VideoPreviewVideoTemplate {
	s.VideoTemplateId = &v
	return s
}

func (s *VideoPreviewVideoTemplate) SetWidth(v int64) *VideoPreviewVideoTemplate {
	s.Width = &v
	return s
}

/**
 * WatermarkEnableConfig 
 */
type WatermarkEnableConfig struct {
	DisplayAccessUserName       *bool   `json:"display_access_user_name,omitempty" xml:"display_access_user_name,omitempty"`
	DisplayCustomText           *string `json:"display_custom_text,omitempty" xml:"display_custom_text,omitempty"`
	DisplayShareLinkCreatorName *bool   `json:"display_shareLink_creator_name,omitempty" xml:"display_shareLink_creator_name,omitempty"`
	EnableDocPreview            *bool   `json:"enable_doc_preview,omitempty" xml:"enable_doc_preview,omitempty"`
	EnableOnPreview             *bool   `json:"enable_on_preview,omitempty" xml:"enable_on_preview,omitempty"`
}

func (s WatermarkEnableConfig) String() string {
	return tea.Prettify(s)
}

func (s WatermarkEnableConfig) GoString() string {
	return s.String()
}

func (s *WatermarkEnableConfig) SetDisplayAccessUserName(v bool) *WatermarkEnableConfig {
	s.DisplayAccessUserName = &v
	return s
}

func (s *WatermarkEnableConfig) SetDisplayCustomText(v string) *WatermarkEnableConfig {
	s.DisplayCustomText = &v
	return s
}

func (s *WatermarkEnableConfig) SetDisplayShareLinkCreatorName(v bool) *WatermarkEnableConfig {
	s.DisplayShareLinkCreatorName = &v
	return s
}

func (s *WatermarkEnableConfig) SetEnableDocPreview(v bool) *WatermarkEnableConfig {
	s.EnableDocPreview = &v
	return s
}

func (s *WatermarkEnableConfig) SetEnableOnPreview(v bool) *WatermarkEnableConfig {
	s.EnableOnPreview = &v
	return s
}

/**
 * WatermarkTextConfig 
 */
type WatermarkTextConfig struct {
	Bold       *bool   `json:"bold,omitempty" xml:"bold,omitempty"`
	FillStyle  *string `json:"fill_style,omitempty" xml:"fill_style,omitempty"`
	Font       *string `json:"font,omitempty" xml:"font,omitempty"`
	Horizontal *int64  `json:"horizontal,omitempty" xml:"horizontal,omitempty"`
	Rotate     *int64  `json:"rotate,omitempty" xml:"rotate,omitempty"`
	Size       *int64  `json:"size,omitempty" xml:"size,omitempty"`
	Vertical   *int64  `json:"vertical,omitempty" xml:"vertical,omitempty"`
}

func (s WatermarkTextConfig) String() string {
	return tea.Prettify(s)
}

func (s WatermarkTextConfig) GoString() string {
	return s.String()
}

func (s *WatermarkTextConfig) SetBold(v bool) *WatermarkTextConfig {
	s.Bold = &v
	return s
}

func (s *WatermarkTextConfig) SetFillStyle(v string) *WatermarkTextConfig {
	s.FillStyle = &v
	return s
}

func (s *WatermarkTextConfig) SetFont(v string) *WatermarkTextConfig {
	s.Font = &v
	return s
}

func (s *WatermarkTextConfig) SetHorizontal(v int64) *WatermarkTextConfig {
	s.Horizontal = &v
	return s
}

func (s *WatermarkTextConfig) SetRotate(v int64) *WatermarkTextConfig {
	s.Rotate = &v
	return s
}

func (s *WatermarkTextConfig) SetSize(v int64) *WatermarkTextConfig {
	s.Size = &v
	return s
}

func (s *WatermarkTextConfig) SetVertical(v int64) *WatermarkTextConfig {
	s.Vertical = &v
	return s
}

/**
 *
 */
type WxTrustedDomainConfig struct {
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	Name    *string `json:"name,omitempty" xml:"name,omitempty"`
	Show    *bool   `json:"show,omitempty" xml:"show,omitempty"`
}

func (s WxTrustedDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s WxTrustedDomainConfig) GoString() string {
	return s.String()
}

func (s *WxTrustedDomainConfig) SetContent(v string) *WxTrustedDomainConfig {
	s.Content = &v
	return s
}

func (s *WxTrustedDomainConfig) SetName(v string) *WxTrustedDomainConfig {
	s.Name = &v
	return s
}

func (s *WxTrustedDomainConfig) SetShow(v bool) *WxTrustedDomainConfig {
	s.Show = &v
	return s
}

/**
 * 
 */
type PunishFileRequest struct {
	Httpheaders  map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	ActionCode   *string            `json:"action_code,omitempty" xml:"action_code,omitempty"`
	DriveId      *string            `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId       *string            `json:"file_id,omitempty" xml:"file_id,omitempty"`
	PunishReason *string            `json:"punish_reason,omitempty" xml:"punish_reason,omitempty"`
}

func (s PunishFileRequest) String() string {
	return tea.Prettify(s)
}

func (s PunishFileRequest) GoString() string {
	return s.String()
}

func (s *PunishFileRequest) SetHttpheaders(v map[string]*string) *PunishFileRequest {
	s.Httpheaders = v
	return s
}

func (s *PunishFileRequest) SetActionCode(v string) *PunishFileRequest {
	s.ActionCode = &v
	return s
}

func (s *PunishFileRequest) SetDriveId(v string) *PunishFileRequest {
	s.DriveId = &v
	return s
}

func (s *PunishFileRequest) SetFileId(v string) *PunishFileRequest {
	s.FileId = &v
	return s
}

func (s *PunishFileRequest) SetPunishReason(v string) *PunishFileRequest {
	s.PunishReason = &v
	return s
}

/**
 * add file to view
 */
type AddViewFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string                `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	DriveId  *string                `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	Fields   map[string]interface{} `json:"fields,omitempty" xml:"fields,omitempty"`
	FileId   *string                `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s AddViewFileRequest) String() string {
	return tea.Prettify(s)
}

func (s AddViewFileRequest) GoString() string {
	return s.String()
}

func (s *AddViewFileRequest) SetHttpheaders(v map[string]*string) *AddViewFileRequest {
	s.Httpheaders = v
	return s
}

func (s *AddViewFileRequest) SetCategory(v string) *AddViewFileRequest {
	s.Category = &v
	return s
}

func (s *AddViewFileRequest) SetDriveId(v string) *AddViewFileRequest {
	s.DriveId = &v
	return s
}

func (s *AddViewFileRequest) SetFields(v map[string]interface{}) *AddViewFileRequest {
	s.Fields = v
	return s
}

func (s *AddViewFileRequest) SetFileId(v string) *AddViewFileRequest {
	s.FileId = &v
	return s
}

func (s *AddViewFileRequest) SetUserId(v string) *AddViewFileRequest {
	s.UserId = &v
	return s
}

func (s *AddViewFileRequest) SetViewId(v string) *AddViewFileRequest {
	s.ViewId = &v
	return s
}

/**
 * add file to view response
 */
type AddViewFileResponse struct {
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId  *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	ViewId  *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s AddViewFileResponse) String() string {
	return tea.Prettify(s)
}

func (s AddViewFileResponse) GoString() string {
	return s.String()
}

func (s *AddViewFileResponse) SetDriveId(v string) *AddViewFileResponse {
	s.DriveId = &v
	return s
}

func (s *AddViewFileResponse) SetFileId(v string) *AddViewFileResponse {
	s.FileId = &v
	return s
}

func (s *AddViewFileResponse) SetViewId(v string) *AddViewFileResponse {
	s.ViewId = &v
	return s
}

/**
 *
 */
type Address struct {
	City     *string `json:"city,omitempty" xml:"city,omitempty"`
	Country  *string `json:"country,omitempty" xml:"country,omitempty"`
	District *string `json:"district,omitempty" xml:"district,omitempty"`
	Province *string `json:"province,omitempty" xml:"province,omitempty"`
	Township *string `json:"township,omitempty" xml:"township,omitempty"`
}

func (s Address) String() string {
	return tea.Prettify(s)
}

func (s Address) GoString() string {
	return s.String()
}

func (s *Address) SetCity(v string) *Address {
	s.City = &v
	return s
}

func (s *Address) SetCountry(v string) *Address {
	s.Country = &v
	return s
}

func (s *Address) SetDistrict(v string) *Address {
	s.District = &v
	return s
}

func (s *Address) SetProvince(v string) *Address {
	s.Province = &v
	return s
}

func (s *Address) SetTownship(v string) *Address {
	s.Township = &v
	return s
}

/**
 *
 */
type AlbumsBaseRequest struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
}

func (s AlbumsBaseRequest) String() string {
	return tea.Prettify(s)
}

func (s AlbumsBaseRequest) GoString() string {
	return s.String()
}

func (s *AlbumsBaseRequest) SetDriveId(v string) *AlbumsBaseRequest {
	s.DriveId = &v
	return s
}

/**
 * 
 */
type AssignRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	DisinheritSubGroup *bool     `json:"disinherit_sub_group,omitempty" xml:"disinherit_sub_group,omitempty" require:"true"`
	Identity           *Identity `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// ID
	ManageResourceId *string `json:"manage_resource_id,omitempty" xml:"manage_resource_id,omitempty" require:"true"`
	// : IT_Group
	ManageResourceType *string `json:"manage_resource_type,omitempty" xml:"manage_resource_type,omitempty" require:"true"`
	// SystemGroupAdmin()
	RoleId      *string `json:"role_id,omitempty" xml:"role_id,omitempty" require:"true"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s AssignRequest) String() string {
	return tea.Prettify(s)
}

func (s AssignRequest) GoString() string {
	return s.String()
}

func (s *AssignRequest) SetHttpheaders(v map[string]*string) *AssignRequest {
	s.Httpheaders = v
	return s
}

func (s *AssignRequest) SetDisinheritSubGroup(v bool) *AssignRequest {
	s.DisinheritSubGroup = &v
	return s
}

func (s *AssignRequest) SetIdentity(v *Identity) *AssignRequest {
	s.Identity = v
	return s
}

func (s *AssignRequest) SetManageResourceId(v string) *AssignRequest {
	s.ManageResourceId = &v
	return s
}

func (s *AssignRequest) SetManageResourceType(v string) *AssignRequest {
	s.ManageResourceType = &v
	return s
}

func (s *AssignRequest) SetRoleId(v string) *AssignRequest {
	s.RoleId = &v
	return s
}

func (s *AssignRequest) SetSubdomainId(v string) *AssignRequest {
	s.SubdomainId = &v
	return s
}

/**
 * List identity role response item
 */
type BaseAssignmentResponse struct {
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty" require:"true"`
	// UserID
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty" require:"true"`
	// domain_id
	DomainId *string   `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	Identity *Identity `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// ID
	ManageResourceId *string `json:"manage_resource_id,omitempty" xml:"manage_resource_id,omitempty" require:"true"`
	// 
	ManageResourceType *string `json:"manage_resource_type,omitempty" xml:"manage_resource_type,omitempty" require:"true"`
	// 
	RoleId *string `json:"role_id,omitempty" xml:"role_id,omitempty" require:"true"`
	// 
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty" require:"true"`
}

func (s BaseAssignmentResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseAssignmentResponse) GoString() string {
	return s.String()
}

func (s *BaseAssignmentResponse) SetCreatedAt(v int64) *BaseAssignmentResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseAssignmentResponse) SetCreator(v string) *BaseAssignmentResponse {
	s.Creator = &v
	return s
}

func (s *BaseAssignmentResponse) SetDomainId(v string) *BaseAssignmentResponse {
	s.DomainId = &v
	return s
}

func (s *BaseAssignmentResponse) SetIdentity(v *Identity) *BaseAssignmentResponse {
	s.Identity = v
	return s
}

func (s *BaseAssignmentResponse) SetManageResourceId(v string) *BaseAssignmentResponse {
	s.ManageResourceId = &v
	return s
}

func (s *BaseAssignmentResponse) SetManageResourceType(v string) *BaseAssignmentResponse {
	s.ManageResourceType = &v
	return s
}

func (s *BaseAssignmentResponse) SetRoleId(v string) *BaseAssignmentResponse {
	s.RoleId = &v
	return s
}

func (s *BaseAssignmentResponse) SetUpdatedAt(v int64) *BaseAssignmentResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type BaseGroupResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// group name
	GroupName  *string                `json:"group_name,omitempty" xml:"group_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// updated_at
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BaseGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseGroupResponse) GoString() string {
	return s.String()
}

func (s *BaseGroupResponse) SetCreatedAt(v int64) *BaseGroupResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseGroupResponse) SetCreator(v string) *BaseGroupResponse {
	s.Creator = &v
	return s
}

func (s *BaseGroupResponse) SetDescription(v string) *BaseGroupResponse {
	s.Description = &v
	return s
}

func (s *BaseGroupResponse) SetDomainId(v string) *BaseGroupResponse {
	s.DomainId = &v
	return s
}

func (s *BaseGroupResponse) SetGroupId(v string) *BaseGroupResponse {
	s.GroupId = &v
	return s
}

func (s *BaseGroupResponse) SetGroupName(v string) *BaseGroupResponse {
	s.GroupName = &v
	return s
}

func (s *BaseGroupResponse) SetPermission(v map[string]interface{}) *BaseGroupResponse {
	s.Permission = v
	return s
}

func (s *BaseGroupResponse) SetUpdatedAt(v int64) *BaseGroupResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type BaseMembershipResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// updated_at
	UpdatedAt *int64  `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	UserId    *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s BaseMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseMembershipResponse) GoString() string {
	return s.String()
}

func (s *BaseMembershipResponse) SetCreatedAt(v int64) *BaseMembershipResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseMembershipResponse) SetCreator(v string) *BaseMembershipResponse {
	s.Creator = &v
	return s
}

func (s *BaseMembershipResponse) SetDescription(v string) *BaseMembershipResponse {
	s.Description = &v
	return s
}

func (s *BaseMembershipResponse) SetDomainId(v string) *BaseMembershipResponse {
	s.DomainId = &v
	return s
}

func (s *BaseMembershipResponse) SetGroupId(v string) *BaseMembershipResponse {
	s.GroupId = &v
	return s
}

func (s *BaseMembershipResponse) SetMemberRole(v string) *BaseMembershipResponse {
	s.MemberRole = &v
	return s
}

func (s *BaseMembershipResponse) SetMemberType(v string) *BaseMembershipResponse {
	s.MemberType = &v
	return s
}

func (s *BaseMembershipResponse) SetSubGroupId(v string) *BaseMembershipResponse {
	s.SubGroupId = &v
	return s
}

func (s *BaseMembershipResponse) SetUpdatedAt(v int64) *BaseMembershipResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseMembershipResponse) SetUserId(v string) *BaseMembershipResponse {
	s.UserId = &v
	return s
}

/**
 *
 */
type BaseRequest struct {
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s BaseRequest) String() string {
	return tea.Prettify(s)
}

func (s BaseRequest) GoString() string {
	return s.String()
}

func (s *BaseRequest) SetCategory(v string) *BaseRequest {
	s.Category = &v
	return s
}

func (s *BaseRequest) SetUserId(v string) *BaseRequest {
	s.UserId = &v
	return s
}

func (s *BaseRequest) SetViewId(v string) *BaseRequest {
	s.ViewId = &v
	return s
}

/**
 * List identity role response
 */
type BaseRoleMemberResponse struct {
	// 
	AssignmentList []*BaseAssignmentResponse `json:"assignment_list,omitempty" xml:"assignment_list,omitempty" require:"true" type:"Repeated"`
	// domain_id
	DomainId *string   `json:"domain_id,omitempty" xml:"domain_id,omitempty" require:"true"`
	Identity *Identity `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	IdentityName *string `json:"identity_name,omitempty" xml:"identity_name,omitempty" require:"true"`
	// 
	IsAdmin     *bool   `json:"is_admin,omitempty" xml:"is_admin,omitempty" require:"true"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s BaseRoleMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseRoleMemberResponse) GoString() string {
	return s.String()
}

func (s *BaseRoleMemberResponse) SetAssignmentList(v []*BaseAssignmentResponse) *BaseRoleMemberResponse {
	s.AssignmentList = v
	return s
}

func (s *BaseRoleMemberResponse) SetDomainId(v string) *BaseRoleMemberResponse {
	s.DomainId = &v
	return s
}

func (s *BaseRoleMemberResponse) SetIdentity(v *Identity) *BaseRoleMemberResponse {
	s.Identity = v
	return s
}

func (s *BaseRoleMemberResponse) SetIdentityName(v string) *BaseRoleMemberResponse {
	s.IdentityName = &v
	return s
}

func (s *BaseRoleMemberResponse) SetIsAdmin(v bool) *BaseRoleMemberResponse {
	s.IsAdmin = &v
	return s
}

func (s *BaseRoleMemberResponse) SetSubdomainId(v string) *BaseRoleMemberResponse {
	s.SubdomainId = &v
	return s
}

/**
 * Base user response
 */
type BaseUserResponse struct {
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	//  Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName   *string                `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// 
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s BaseUserResponse) String() string {
	return tea.Prettify(s)
}

func (s BaseUserResponse) GoString() string {
	return s.String()
}

func (s *BaseUserResponse) SetAvatar(v string) *BaseUserResponse {
	s.Avatar = &v
	return s
}

func (s *BaseUserResponse) SetCreatedAt(v int64) *BaseUserResponse {
	s.CreatedAt = &v
	return s
}

func (s *BaseUserResponse) SetCreator(v string) *BaseUserResponse {
	s.Creator = &v
	return s
}

func (s *BaseUserResponse) SetDefaultDriveId(v string) *BaseUserResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *BaseUserResponse) SetDenyChangePasswordBySelf(v bool) *BaseUserResponse {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *BaseUserResponse) SetDescription(v string) *BaseUserResponse {
	s.Description = &v
	return s
}

func (s *BaseUserResponse) SetDomainId(v string) *BaseUserResponse {
	s.DomainId = &v
	return s
}

func (s *BaseUserResponse) SetEmail(v string) *BaseUserResponse {
	s.Email = &v
	return s
}

func (s *BaseUserResponse) SetNeedChangePasswordNextLogin(v bool) *BaseUserResponse {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *BaseUserResponse) SetNickName(v string) *BaseUserResponse {
	s.NickName = &v
	return s
}

func (s *BaseUserResponse) SetPermission(v map[string]interface{}) *BaseUserResponse {
	s.Permission = v
	return s
}

func (s *BaseUserResponse) SetPhone(v string) *BaseUserResponse {
	s.Phone = &v
	return s
}

func (s *BaseUserResponse) SetPunishFlag(v int64) *BaseUserResponse {
	s.PunishFlag = &v
	return s
}

func (s *BaseUserResponse) SetRole(v string) *BaseUserResponse {
	s.Role = &v
	return s
}

func (s *BaseUserResponse) SetStatus(v string) *BaseUserResponse {
	s.Status = &v
	return s
}

func (s *BaseUserResponse) SetUpdatedAt(v int64) *BaseUserResponse {
	s.UpdatedAt = &v
	return s
}

func (s *BaseUserResponse) SetUserData(v map[string]interface{}) *BaseUserResponse {
	s.UserData = v
	return s
}

func (s *BaseUserResponse) SetUserId(v string) *BaseUserResponse {
	s.UserId = &v
	return s
}

func (s *BaseUserResponse) SetUserName(v string) *BaseUserResponse {
	s.UserName = &v
	return s
}

/**
 *
 */
type BindDeviceResponse struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// device_id
	DeviceId *string `json:"device_id,omitempty" xml:"device_id,omitempty"`
	// device_info
	DeviceInfo *string `json:"device_info,omitempty" xml:"device_info,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// device_type
	DeviceType *string `json:"device_type,omitempty" xml:"device_type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s BindDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindDeviceResponse) GoString() string {
	return s.String()
}

func (s *BindDeviceResponse) SetCreatedAt(v string) *BindDeviceResponse {
	s.CreatedAt = &v
	return s
}

func (s *BindDeviceResponse) SetDeviceId(v string) *BindDeviceResponse {
	s.DeviceId = &v
	return s
}

func (s *BindDeviceResponse) SetDeviceInfo(v string) *BindDeviceResponse {
	s.DeviceInfo = &v
	return s
}

func (s *BindDeviceResponse) SetDeviceName(v string) *BindDeviceResponse {
	s.DeviceName = &v
	return s
}

func (s *BindDeviceResponse) SetDeviceType(v string) *BindDeviceResponse {
	s.DeviceType = &v
	return s
}

func (s *BindDeviceResponse) SetUpdatedAt(v string) *BindDeviceResponse {
	s.UpdatedAt = &v
	return s
}

/**
 * 
 */
type CancelAssignRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	Identity    *Identity          `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// ID
	ManageResourceId *string `json:"manage_resource_id,omitempty" xml:"manage_resource_id,omitempty" require:"true"`
	// : IT_Group
	ManageResourceType *string `json:"manage_resource_type,omitempty" xml:"manage_resource_type,omitempty" require:"true"`
	// SystemGroupAdmin()
	RoleId      *string `json:"role_id,omitempty" xml:"role_id,omitempty" require:"true"`
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s CancelAssignRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelAssignRequest) GoString() string {
	return s.String()
}

func (s *CancelAssignRequest) SetHttpheaders(v map[string]*string) *CancelAssignRequest {
	s.Httpheaders = v
	return s
}

func (s *CancelAssignRequest) SetIdentity(v *Identity) *CancelAssignRequest {
	s.Identity = v
	return s
}

func (s *CancelAssignRequest) SetManageResourceId(v string) *CancelAssignRequest {
	s.ManageResourceId = &v
	return s
}

func (s *CancelAssignRequest) SetManageResourceType(v string) *CancelAssignRequest {
	s.ManageResourceType = &v
	return s
}

func (s *CancelAssignRequest) SetRoleId(v string) *CancelAssignRequest {
	s.RoleId = &v
	return s
}

func (s *CancelAssignRequest) SetSubdomainId(v string) *CancelAssignRequest {
	s.SubdomainId = &v
	return s
}

/**
 * Copy view files
 */
type CopyViewFilesRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// addition_data
	AdditionData map[string]interface{} `json:"addition_data,omitempty" xml:"addition_data,omitempty"`
	// auto_rename
	// type: boolean
	AutoRename *bool `json:"auto_rename,omitempty" xml:"auto_rename,omitempty"`
	// category
	Category      *string      `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	DriveFileList []*ShareFile `json:"drive_file_list,omitempty" xml:"drive_file_list,omitempty" type:"Repeated"`
	Referer       *string      `json:"referer,omitempty" xml:"referer,omitempty"`
	// share_id
	ShareId *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// to_drive_id
	ToDriveId *string `json:"to_drive_id,omitempty" xml:"to_drive_id,omitempty" pattern:"[0-9]+"`
	// to_parent_file_id
	ToParentFileId *string `json:"to_parent_file_id,omitempty" xml:"to_parent_file_id,omitempty" require:"true" maxLength:"50" minLength:"4" pattern:"[a-z0-9.-_]{1,50}"`
	// to_view_id
	ToViewId *string `json:"to_view_id,omitempty" xml:"to_view_id,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s CopyViewFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyViewFilesRequest) GoString() string {
	return s.String()
}

func (s *CopyViewFilesRequest) SetHttpheaders(v map[string]*string) *CopyViewFilesRequest {
	s.Httpheaders = v
	return s
}

func (s *CopyViewFilesRequest) SetAdditionData(v map[string]interface{}) *CopyViewFilesRequest {
	s.AdditionData = v
	return s
}

func (s *CopyViewFilesRequest) SetAutoRename(v bool) *CopyViewFilesRequest {
	s.AutoRename = &v
	return s
}

func (s *CopyViewFilesRequest) SetCategory(v string) *CopyViewFilesRequest {
	s.Category = &v
	return s
}

func (s *CopyViewFilesRequest) SetDriveFileList(v []*ShareFile) *CopyViewFilesRequest {
	s.DriveFileList = v
	return s
}

func (s *CopyViewFilesRequest) SetReferer(v string) *CopyViewFilesRequest {
	s.Referer = &v
	return s
}

func (s *CopyViewFilesRequest) SetShareId(v string) *CopyViewFilesRequest {
	s.ShareId = &v
	return s
}

func (s *CopyViewFilesRequest) SetToDriveId(v string) *CopyViewFilesRequest {
	s.ToDriveId = &v
	return s
}

func (s *CopyViewFilesRequest) SetToParentFileId(v string) *CopyViewFilesRequest {
	s.ToParentFileId = &v
	return s
}

func (s *CopyViewFilesRequest) SetToViewId(v string) *CopyViewFilesRequest {
	s.ToViewId = &v
	return s
}

func (s *CopyViewFilesRequest) SetUserId(v string) *CopyViewFilesRequest {
	s.UserId = &v
	return s
}

func (s *CopyViewFilesRequest) SetViewId(v string) *CopyViewFilesRequest {
	s.ViewId = &v
	return s
}

/**
 * copy view files
 */
type CopyViewFilesResponse struct {
	// async_task_id
	AsyncTaskId *string `json:"async_task_id,omitempty" xml:"async_task_id,omitempty"`
}

func (s CopyViewFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyViewFilesResponse) GoString() string {
	return s.String()
}

func (s *CopyViewFilesResponse) SetAsyncTaskId(v string) *CopyViewFilesResponse {
	s.AsyncTaskId = &v
	return s
}

/**
 *
 */
type CreateGroupResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// group name
	GroupName  *string                `json:"group_name,omitempty" xml:"group_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// updated_at
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s CreateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateGroupResponse) SetCreatedAt(v int64) *CreateGroupResponse {
	s.CreatedAt = &v
	return s
}

func (s *CreateGroupResponse) SetCreator(v string) *CreateGroupResponse {
	s.Creator = &v
	return s
}

func (s *CreateGroupResponse) SetDescription(v string) *CreateGroupResponse {
	s.Description = &v
	return s
}

func (s *CreateGroupResponse) SetDomainId(v string) *CreateGroupResponse {
	s.DomainId = &v
	return s
}

func (s *CreateGroupResponse) SetGroupId(v string) *CreateGroupResponse {
	s.GroupId = &v
	return s
}

func (s *CreateGroupResponse) SetGroupName(v string) *CreateGroupResponse {
	s.GroupName = &v
	return s
}

func (s *CreateGroupResponse) SetPermission(v map[string]interface{}) *CreateGroupResponse {
	s.Permission = v
	return s
}

func (s *CreateGroupResponse) SetUpdatedAt(v int64) *CreateGroupResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type CreateMembershipResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// updated_at
	UpdatedAt *int64  `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	UserId    *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s CreateMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMembershipResponse) GoString() string {
	return s.String()
}

func (s *CreateMembershipResponse) SetCreatedAt(v int64) *CreateMembershipResponse {
	s.CreatedAt = &v
	return s
}

func (s *CreateMembershipResponse) SetCreator(v string) *CreateMembershipResponse {
	s.Creator = &v
	return s
}

func (s *CreateMembershipResponse) SetDescription(v string) *CreateMembershipResponse {
	s.Description = &v
	return s
}

func (s *CreateMembershipResponse) SetDomainId(v string) *CreateMembershipResponse {
	s.DomainId = &v
	return s
}

func (s *CreateMembershipResponse) SetGroupId(v string) *CreateMembershipResponse {
	s.GroupId = &v
	return s
}

func (s *CreateMembershipResponse) SetMemberRole(v string) *CreateMembershipResponse {
	s.MemberRole = &v
	return s
}

func (s *CreateMembershipResponse) SetMemberType(v string) *CreateMembershipResponse {
	s.MemberType = &v
	return s
}

func (s *CreateMembershipResponse) SetSubGroupId(v string) *CreateMembershipResponse {
	s.SubGroupId = &v
	return s
}

func (s *CreateMembershipResponse) SetUpdatedAt(v int64) *CreateMembershipResponse {
	s.UpdatedAt = &v
	return s
}

func (s *CreateMembershipResponse) SetUserId(v string) *CreateMembershipResponse {
	s.UserId = &v
	return s
}

/**
 * Create story request
 */
type CreateStoryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// custom_id
	CustomId *string `json:"custom_id,omitempty" xml:"custom_id,omitempty"`
	// custom_labels
	CustomLabels map[string]interface{} `json:"custom_labels,omitempty" xml:"custom_labels,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// max_image_count
	MaxImageCount *int64 `json:"max_image_count,omitempty" xml:"max_image_count,omitempty"`
	// min_image_count
	MinImageCount *int64 `json:"min_image_count,omitempty" xml:"min_image_count,omitempty"`
	// story_end_time
	StoryEndTime *string `json:"story_end_time,omitempty" xml:"story_end_time,omitempty"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
	// story_name
	StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
	// story_start_time
	StoryStartTime *string `json:"story_start_time,omitempty" xml:"story_start_time,omitempty"`
	// story_sub_type
	StorySubType *string `json:"story_sub_type,omitempty" xml:"story_sub_type,omitempty"`
	// story_type
	StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty" require:"true"`
}

func (s CreateStoryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStoryRequest) GoString() string {
	return s.String()
}

func (s *CreateStoryRequest) SetHttpheaders(v map[string]*string) *CreateStoryRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateStoryRequest) SetCustomId(v string) *CreateStoryRequest {
	s.CustomId = &v
	return s
}

func (s *CreateStoryRequest) SetCustomLabels(v map[string]interface{}) *CreateStoryRequest {
	s.CustomLabels = v
	return s
}

func (s *CreateStoryRequest) SetDriveId(v string) *CreateStoryRequest {
	s.DriveId = &v
	return s
}

func (s *CreateStoryRequest) SetMaxImageCount(v int64) *CreateStoryRequest {
	s.MaxImageCount = &v
	return s
}

func (s *CreateStoryRequest) SetMinImageCount(v int64) *CreateStoryRequest {
	s.MinImageCount = &v
	return s
}

func (s *CreateStoryRequest) SetStoryEndTime(v string) *CreateStoryRequest {
	s.StoryEndTime = &v
	return s
}

func (s *CreateStoryRequest) SetStoryId(v string) *CreateStoryRequest {
	s.StoryId = &v
	return s
}

func (s *CreateStoryRequest) SetStoryName(v string) *CreateStoryRequest {
	s.StoryName = &v
	return s
}

func (s *CreateStoryRequest) SetStoryStartTime(v string) *CreateStoryRequest {
	s.StoryStartTime = &v
	return s
}

func (s *CreateStoryRequest) SetStorySubType(v string) *CreateStoryRequest {
	s.StorySubType = &v
	return s
}

func (s *CreateStoryRequest) SetStoryType(v string) *CreateStoryRequest {
	s.StoryType = &v
	return s
}

/**
 * 
 */
type CreateStoryResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
}

func (s CreateStoryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateStoryResponse) GoString() string {
	return s.String()
}

func (s *CreateStoryResponse) SetDriveId(v string) *CreateStoryResponse {
	s.DriveId = &v
	return s
}

/**
 *
 */
type CreateSyncMappingResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
}

func (s CreateSyncMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSyncMappingResponse) GoString() string {
	return s.String()
}

func (s *CreateSyncMappingResponse) SetDriveId(v string) *CreateSyncMappingResponse {
	s.DriveId = &v
	return s
}

func (s *CreateSyncMappingResponse) SetFileId(v string) *CreateSyncMappingResponse {
	s.FileId = &v
	return s
}

/**
 * Create user response
 */
type CreateUserResponse struct {
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	//  Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName   *string                `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// 
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s CreateUserResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUserResponse) GoString() string {
	return s.String()
}

func (s *CreateUserResponse) SetAvatar(v string) *CreateUserResponse {
	s.Avatar = &v
	return s
}

func (s *CreateUserResponse) SetCreatedAt(v int64) *CreateUserResponse {
	s.CreatedAt = &v
	return s
}

func (s *CreateUserResponse) SetCreator(v string) *CreateUserResponse {
	s.Creator = &v
	return s
}

func (s *CreateUserResponse) SetDefaultDriveId(v string) *CreateUserResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *CreateUserResponse) SetDenyChangePasswordBySelf(v bool) *CreateUserResponse {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *CreateUserResponse) SetDescription(v string) *CreateUserResponse {
	s.Description = &v
	return s
}

func (s *CreateUserResponse) SetDomainId(v string) *CreateUserResponse {
	s.DomainId = &v
	return s
}

func (s *CreateUserResponse) SetEmail(v string) *CreateUserResponse {
	s.Email = &v
	return s
}

func (s *CreateUserResponse) SetNeedChangePasswordNextLogin(v bool) *CreateUserResponse {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *CreateUserResponse) SetNickName(v string) *CreateUserResponse {
	s.NickName = &v
	return s
}

func (s *CreateUserResponse) SetPermission(v map[string]interface{}) *CreateUserResponse {
	s.Permission = v
	return s
}

func (s *CreateUserResponse) SetPhone(v string) *CreateUserResponse {
	s.Phone = &v
	return s
}

func (s *CreateUserResponse) SetPunishFlag(v int64) *CreateUserResponse {
	s.PunishFlag = &v
	return s
}

func (s *CreateUserResponse) SetRole(v string) *CreateUserResponse {
	s.Role = &v
	return s
}

func (s *CreateUserResponse) SetStatus(v string) *CreateUserResponse {
	s.Status = &v
	return s
}

func (s *CreateUserResponse) SetUpdatedAt(v int64) *CreateUserResponse {
	s.UpdatedAt = &v
	return s
}

func (s *CreateUserResponse) SetUserData(v map[string]interface{}) *CreateUserResponse {
	s.UserData = v
	return s
}

func (s *CreateUserResponse) SetUserId(v string) *CreateUserResponse {
	s.UserId = &v
	return s
}

func (s *CreateUserResponse) SetUserName(v string) *CreateUserResponse {
	s.UserName = &v
	return s
}

/**
 * Create view request
 */
type CreateViewRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s CreateViewRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateViewRequest) GoString() string {
	return s.String()
}

func (s *CreateViewRequest) SetHttpheaders(v map[string]*string) *CreateViewRequest {
	s.Httpheaders = v
	return s
}

func (s *CreateViewRequest) SetCategory(v string) *CreateViewRequest {
	s.Category = &v
	return s
}

func (s *CreateViewRequest) SetDescription(v string) *CreateViewRequest {
	s.Description = &v
	return s
}

func (s *CreateViewRequest) SetName(v string) *CreateViewRequest {
	s.Name = &v
	return s
}

func (s *CreateViewRequest) SetOwner(v string) *CreateViewRequest {
	s.Owner = &v
	return s
}

func (s *CreateViewRequest) SetUserId(v string) *CreateViewRequest {
	s.UserId = &v
	return s
}

/**
 * 
 */
type CreateViewResponse struct {
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	Owner    *string `json:"owner,omitempty" xml:"owner,omitempty"`
	ViewId   *string `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s CreateViewResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateViewResponse) GoString() string {
	return s.String()
}

func (s *CreateViewResponse) SetCategory(v string) *CreateViewResponse {
	s.Category = &v
	return s
}

func (s *CreateViewResponse) SetOwner(v string) *CreateViewResponse {
	s.Owner = &v
	return s
}

func (s *CreateViewResponse) SetViewId(v string) *CreateViewResponse {
	s.ViewId = &v
	return s
}

/**
 *
 */
type DeleteGroupResponse struct {
}

func (s DeleteGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGroupResponse) GoString() string {
	return s.String()
}

/**
 *
 */
type DeleteMembershipResponse struct {
}

func (s DeleteMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMembershipResponse) GoString() string {
	return s.String()
}

/**
 * delete story request
 */
type DeleteStoryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty" require:"true"`
}

func (s DeleteStoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteStoryRequest) GoString() string {
	return s.String()
}

func (s *DeleteStoryRequest) SetHttpheaders(v map[string]*string) *DeleteStoryRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteStoryRequest) SetDriveId(v string) *DeleteStoryRequest {
	s.DriveId = &v
	return s
}

func (s *DeleteStoryRequest) SetStoryId(v string) *DeleteStoryRequest {
	s.StoryId = &v
	return s
}

/**
 * 
 */
type DeleteStoryResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
}

func (s DeleteStoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStoryResponse) GoString() string {
	return s.String()
}

func (s *DeleteStoryResponse) SetDriveId(v string) *DeleteStoryResponse {
	s.DriveId = &v
	return s
}

/**
 *
 */
type DeleteSyncMappingResponse struct {
}

func (s DeleteSyncMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyncMappingResponse) GoString() string {
	return s.String()
}

/**
 * Delete user response
 */
type DeleteUserResponse struct {
}

func (s DeleteUserResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserResponse) GoString() string {
	return s.String()
}

/**
 * Delete view request
 */
type DeleteViewRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s DeleteViewRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteViewRequest) GoString() string {
	return s.String()
}

func (s *DeleteViewRequest) SetHttpheaders(v map[string]*string) *DeleteViewRequest {
	s.Httpheaders = v
	return s
}

func (s *DeleteViewRequest) SetCategory(v string) *DeleteViewRequest {
	s.Category = &v
	return s
}

func (s *DeleteViewRequest) SetUserId(v string) *DeleteViewRequest {
	s.UserId = &v
	return s
}

func (s *DeleteViewRequest) SetViewId(v string) *DeleteViewRequest {
	s.ViewId = &v
	return s
}

/**
 *
 */
type DeviceItem struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// device_id
	DeviceId *string `json:"device_id,omitempty" xml:"device_id,omitempty"`
	// device_info
	DeviceInfo *string `json:"device_info,omitempty" xml:"device_info,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// device_type
	DeviceType *string `json:"device_type,omitempty" xml:"device_type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s DeviceItem) String() string {
	return tea.Prettify(s)
}

func (s DeviceItem) GoString() string {
	return s.String()
}

func (s *DeviceItem) SetCreatedAt(v string) *DeviceItem {
	s.CreatedAt = &v
	return s
}

func (s *DeviceItem) SetDeviceId(v string) *DeviceItem {
	s.DeviceId = &v
	return s
}

func (s *DeviceItem) SetDeviceInfo(v string) *DeviceItem {
	s.DeviceInfo = &v
	return s
}

func (s *DeviceItem) SetDeviceName(v string) *DeviceItem {
	s.DeviceName = &v
	return s
}

func (s *DeviceItem) SetDeviceType(v string) *DeviceItem {
	s.DeviceType = &v
	return s
}

func (s *DeviceItem) SetUpdatedAt(v string) *DeviceItem {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type FaceBoundary struct {
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	Left   *int64 `json:"Left,omitempty" xml:"Left,omitempty"`
	Top    *int64 `json:"Top,omitempty" xml:"Top,omitempty"`
	Width  *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s FaceBoundary) String() string {
	return tea.Prettify(s)
}

func (s FaceBoundary) GoString() string {
	return s.String()
}

func (s *FaceBoundary) SetHeight(v int64) *FaceBoundary {
	s.Height = &v
	return s
}

func (s *FaceBoundary) SetLeft(v int64) *FaceBoundary {
	s.Left = &v
	return s
}

func (s *FaceBoundary) SetTop(v int64) *FaceBoundary {
	s.Top = &v
	return s
}

func (s *FaceBoundary) SetWidth(v int64) *FaceBoundary {
	s.Width = &v
	return s
}

/**
 * find story request
 */
type FindStoriesRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// cover_image_thumbnail_process
	CoverImageThumbnailProcess *string `json:"cover_image_thumbnail_process,omitempty" xml:"cover_image_thumbnail_process,omitempty"`
	// cover_video_thumbnail_process
	CoverVideoThumbnailProcess *string                    `json:"cover_video_thumbnail_process,omitempty" xml:"cover_video_thumbnail_process,omitempty"`
	CreateTimeRange            *FindStoryRequestTimeRange `json:"create_time_range,omitempty" xml:"create_time_range,omitempty"`
	// custom_labels
	CustomLabels *string `json:"custom_labels,omitempty" xml:"custom_labels,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// face_group_ids
	FaceGroupIds []*string `json:"face_group_ids,omitempty" xml:"face_group_ids,omitempty" type:"Repeated"`
	// limit
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty"`
	// marker
	Marker            *string                    `json:"marker,omitempty" xml:"marker,omitempty"`
	StoryEndTimeRange *FindStoryRequestTimeRange `json:"story_end_time_range,omitempty" xml:"story_end_time_range,omitempty"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
	// story_name
	StoryName           *string                    `json:"story_name,omitempty" xml:"story_name,omitempty"`
	StoryStartTimeRange *FindStoryRequestTimeRange `json:"story_start_time_range,omitempty" xml:"story_start_time_range,omitempty"`
	// story_type
	StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty"`
	// with_empty_stories
	WithEmptyStories *bool `json:"with_empty_stories,omitempty" xml:"with_empty_stories,omitempty"`
}

func (s FindStoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s FindStoriesRequest) GoString() string {
	return s.String()
}

func (s *FindStoriesRequest) SetHttpheaders(v map[string]*string) *FindStoriesRequest {
	s.Httpheaders = v
	return s
}

func (s *FindStoriesRequest) SetCoverImageThumbnailProcess(v string) *FindStoriesRequest {
	s.CoverImageThumbnailProcess = &v
	return s
}

func (s *FindStoriesRequest) SetCoverVideoThumbnailProcess(v string) *FindStoriesRequest {
	s.CoverVideoThumbnailProcess = &v
	return s
}

func (s *FindStoriesRequest) SetCreateTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
	s.CreateTimeRange = v
	return s
}

func (s *FindStoriesRequest) SetCustomLabels(v string) *FindStoriesRequest {
	s.CustomLabels = &v
	return s
}

func (s *FindStoriesRequest) SetDriveId(v string) *FindStoriesRequest {
	s.DriveId = &v
	return s
}

func (s *FindStoriesRequest) SetFaceGroupIds(v []*string) *FindStoriesRequest {
	s.FaceGroupIds = v
	return s
}

func (s *FindStoriesRequest) SetLimit(v int64) *FindStoriesRequest {
	s.Limit = &v
	return s
}

func (s *FindStoriesRequest) SetMarker(v string) *FindStoriesRequest {
	s.Marker = &v
	return s
}

func (s *FindStoriesRequest) SetStoryEndTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
	s.StoryEndTimeRange = v
	return s
}

func (s *FindStoriesRequest) SetStoryId(v string) *FindStoriesRequest {
	s.StoryId = &v
	return s
}

func (s *FindStoriesRequest) SetStoryName(v string) *FindStoriesRequest {
	s.StoryName = &v
	return s
}

func (s *FindStoriesRequest) SetStoryStartTimeRange(v *FindStoryRequestTimeRange) *FindStoriesRequest {
	s.StoryStartTimeRange = v
	return s
}

func (s *FindStoriesRequest) SetStoryType(v string) *FindStoriesRequest {
	s.StoryType = &v
	return s
}

func (s *FindStoriesRequest) SetUrlExpireSec(v int64) *FindStoriesRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *FindStoriesRequest) SetWithEmptyStories(v bool) *FindStoriesRequest {
	s.WithEmptyStories = &v
	return s
}

/**
 * 
 */
type FindStoriesResponse struct {
	// items
	Items []*GetStoryResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s FindStoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s FindStoriesResponse) GoString() string {
	return s.String()
}

func (s *FindStoriesResponse) SetItems(v []*GetStoryResponse) *FindStoriesResponse {
	s.Items = v
	return s
}

func (s *FindStoriesResponse) SetNextMarker(v string) *FindStoriesResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type FindStoryRequestTimeRange struct {
	// end
	End *string `json:"end,omitempty" xml:"end,omitempty"`
	// start
	Start *string `json:"start,omitempty" xml:"start,omitempty"`
}

func (s FindStoryRequestTimeRange) String() string {
	return tea.Prettify(s)
}

func (s FindStoryRequestTimeRange) GoString() string {
	return s.String()
}

func (s *FindStoryRequestTimeRange) SetEnd(v string) *FindStoryRequestTimeRange {
	s.End = &v
	return s
}

func (s *FindStoryRequestTimeRange) SetStart(v string) *FindStoryRequestTimeRange {
	s.Start = &v
	return s
}

/**
 *
 */
type GetAppDebugCmdResponse struct {
	// cmd
	Cmd *string `json:"cmd,omitempty" xml:"cmd,omitempty"`
}

func (s GetAppDebugCmdResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppDebugCmdResponse) GoString() string {
	return s.String()
}

func (s *GetAppDebugCmdResponse) SetCmd(v string) *GetAppDebugCmdResponse {
	s.Cmd = &v
	return s
}

/**
 *
 */
type GetGroupResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// group name
	GroupName  *string                `json:"group_name,omitempty" xml:"group_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// updated_at
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGroupResponse) GoString() string {
	return s.String()
}

func (s *GetGroupResponse) SetCreatedAt(v int64) *GetGroupResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetGroupResponse) SetCreator(v string) *GetGroupResponse {
	s.Creator = &v
	return s
}

func (s *GetGroupResponse) SetDescription(v string) *GetGroupResponse {
	s.Description = &v
	return s
}

func (s *GetGroupResponse) SetDomainId(v string) *GetGroupResponse {
	s.DomainId = &v
	return s
}

func (s *GetGroupResponse) SetGroupId(v string) *GetGroupResponse {
	s.GroupId = &v
	return s
}

func (s *GetGroupResponse) SetGroupName(v string) *GetGroupResponse {
	s.GroupName = &v
	return s
}

func (s *GetGroupResponse) SetPermission(v map[string]interface{}) *GetGroupResponse {
	s.Permission = v
	return s
}

func (s *GetGroupResponse) SetUpdatedAt(v int64) *GetGroupResponse {
	s.UpdatedAt = &v
	return s
}

/**
 * Get photo count request
 */
type GetImageCountRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
}

func (s GetImageCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageCountRequest) GoString() string {
	return s.String()
}

func (s *GetImageCountRequest) SetHttpheaders(v map[string]*string) *GetImageCountRequest {
	s.Httpheaders = v
	return s
}

func (s *GetImageCountRequest) SetDriveId(v string) *GetImageCountRequest {
	s.DriveId = &v
	return s
}

/**
 * 
 */
type GetImageCountResponse struct {
	// image_count
	ImageCount *int64 `json:"image_count,omitempty" xml:"image_count,omitempty"`
}

func (s GetImageCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageCountResponse) GoString() string {
	return s.String()
}

func (s *GetImageCountResponse) SetImageCount(v int64) *GetImageCountResponse {
	s.ImageCount = &v
	return s
}

/**
 *
 */
type GetMembershipResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// updated_at
	UpdatedAt *int64  `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	UserId    *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s GetMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMembershipResponse) GoString() string {
	return s.String()
}

func (s *GetMembershipResponse) SetCreatedAt(v int64) *GetMembershipResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetMembershipResponse) SetCreator(v string) *GetMembershipResponse {
	s.Creator = &v
	return s
}

func (s *GetMembershipResponse) SetDescription(v string) *GetMembershipResponse {
	s.Description = &v
	return s
}

func (s *GetMembershipResponse) SetDomainId(v string) *GetMembershipResponse {
	s.DomainId = &v
	return s
}

func (s *GetMembershipResponse) SetGroupId(v string) *GetMembershipResponse {
	s.GroupId = &v
	return s
}

func (s *GetMembershipResponse) SetMemberRole(v string) *GetMembershipResponse {
	s.MemberRole = &v
	return s
}

func (s *GetMembershipResponse) SetMemberType(v string) *GetMembershipResponse {
	s.MemberType = &v
	return s
}

func (s *GetMembershipResponse) SetSubGroupId(v string) *GetMembershipResponse {
	s.SubGroupId = &v
	return s
}

func (s *GetMembershipResponse) SetUpdatedAt(v int64) *GetMembershipResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetMembershipResponse) SetUserId(v string) *GetMembershipResponse {
	s.UserId = &v
	return s
}

/**
 * Get story request
 */
type GetStoryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// cover_image_thumbnail_process
	CoverImageThumbnailProcess *string `json:"cover_image_thumbnail_process,omitempty" xml:"cover_image_thumbnail_process,omitempty"`
	// cover_video_thumbnail_process
	CoverVideoThumbnailProcess *string `json:"cover_video_thumbnail_process,omitempty" xml:"cover_video_thumbnail_process,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty" require:"true"`
	// url_expire_sec
	UrlExpireSec *int64 `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s GetStoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStoryRequest) GoString() string {
	return s.String()
}

func (s *GetStoryRequest) SetHttpheaders(v map[string]*string) *GetStoryRequest {
	s.Httpheaders = v
	return s
}

func (s *GetStoryRequest) SetCoverImageThumbnailProcess(v string) *GetStoryRequest {
	s.CoverImageThumbnailProcess = &v
	return s
}

func (s *GetStoryRequest) SetCoverVideoThumbnailProcess(v string) *GetStoryRequest {
	s.CoverVideoThumbnailProcess = &v
	return s
}

func (s *GetStoryRequest) SetDriveId(v string) *GetStoryRequest {
	s.DriveId = &v
	return s
}

func (s *GetStoryRequest) SetImageThumbnailProcess(v string) *GetStoryRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *GetStoryRequest) SetImageUrlProcess(v string) *GetStoryRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *GetStoryRequest) SetOfficeThumbnailProcess(v string) *GetStoryRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *GetStoryRequest) SetStoryId(v string) *GetStoryRequest {
	s.StoryId = &v
	return s
}

func (s *GetStoryRequest) SetUrlExpireSec(v int64) *GetStoryRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *GetStoryRequest) SetVideoThumbnailProcess(v string) *GetStoryRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * 
 */
type GetStoryResponse struct {
	// cover_file_id
	CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
	// cover_file_url
	CoverFileThumbnailUrl *string `json:"cover_file_thumbnail_url,omitempty" xml:"cover_file_thumbnail_url,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// custom_id
	CustomId *string `json:"custom_id,omitempty" xml:"custom_id,omitempty"`
	// custom_labels
	CustomLabels map[string]interface{} `json:"custom_labels,omitempty" xml:"custom_labels,omitempty"`
	// face_group_ids
	FaceGroupIds []*string `json:"face_group_ids,omitempty" xml:"face_group_ids,omitempty" type:"Repeated"`
	// story_end_time
	StoryEndTime  *string                `json:"story_end_time,omitempty" xml:"story_end_time,omitempty"`
	StoryFileList []*BaseCCPFileResponse `json:"story_file_list,omitempty" xml:"story_file_list,omitempty" type:"Repeated"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
	// story_name
	StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
	// story_start_time
	StoryStartTime *string `json:"story_start_time,omitempty" xml:"story_start_time,omitempty"`
	// story_sub_type
	StorySubType *string `json:"story_sub_type,omitempty" xml:"story_sub_type,omitempty"`
	// story_type
	StoryType *string `json:"story_type,omitempty" xml:"story_type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s GetStoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStoryResponse) GoString() string {
	return s.String()
}

func (s *GetStoryResponse) SetCoverFileId(v string) *GetStoryResponse {
	s.CoverFileId = &v
	return s
}

func (s *GetStoryResponse) SetCoverFileThumbnailUrl(v string) *GetStoryResponse {
	s.CoverFileThumbnailUrl = &v
	return s
}

func (s *GetStoryResponse) SetCreatedAt(v string) *GetStoryResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetStoryResponse) SetCustomId(v string) *GetStoryResponse {
	s.CustomId = &v
	return s
}

func (s *GetStoryResponse) SetCustomLabels(v map[string]interface{}) *GetStoryResponse {
	s.CustomLabels = v
	return s
}

func (s *GetStoryResponse) SetFaceGroupIds(v []*string) *GetStoryResponse {
	s.FaceGroupIds = v
	return s
}

func (s *GetStoryResponse) SetStoryEndTime(v string) *GetStoryResponse {
	s.StoryEndTime = &v
	return s
}

func (s *GetStoryResponse) SetStoryFileList(v []*BaseCCPFileResponse) *GetStoryResponse {
	s.StoryFileList = v
	return s
}

func (s *GetStoryResponse) SetStoryId(v string) *GetStoryResponse {
	s.StoryId = &v
	return s
}

func (s *GetStoryResponse) SetStoryName(v string) *GetStoryResponse {
	s.StoryName = &v
	return s
}

func (s *GetStoryResponse) SetStoryStartTime(v string) *GetStoryResponse {
	s.StoryStartTime = &v
	return s
}

func (s *GetStoryResponse) SetStorySubType(v string) *GetStoryResponse {
	s.StorySubType = &v
	return s
}

func (s *GetStoryResponse) SetStoryType(v string) *GetStoryResponse {
	s.StoryType = &v
	return s
}

func (s *GetStoryResponse) SetUpdatedAt(v string) *GetStoryResponse {
	s.UpdatedAt = &v
	return s
}

/**
 * Get user response
 */
type GetUserResponse struct {
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	//  Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName   *string                `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// 
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s GetUserResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponse) GoString() string {
	return s.String()
}

func (s *GetUserResponse) SetAvatar(v string) *GetUserResponse {
	s.Avatar = &v
	return s
}

func (s *GetUserResponse) SetCreatedAt(v int64) *GetUserResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetUserResponse) SetCreator(v string) *GetUserResponse {
	s.Creator = &v
	return s
}

func (s *GetUserResponse) SetDefaultDriveId(v string) *GetUserResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *GetUserResponse) SetDenyChangePasswordBySelf(v bool) *GetUserResponse {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *GetUserResponse) SetDescription(v string) *GetUserResponse {
	s.Description = &v
	return s
}

func (s *GetUserResponse) SetDomainId(v string) *GetUserResponse {
	s.DomainId = &v
	return s
}

func (s *GetUserResponse) SetEmail(v string) *GetUserResponse {
	s.Email = &v
	return s
}

func (s *GetUserResponse) SetNeedChangePasswordNextLogin(v bool) *GetUserResponse {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *GetUserResponse) SetNickName(v string) *GetUserResponse {
	s.NickName = &v
	return s
}

func (s *GetUserResponse) SetPermission(v map[string]interface{}) *GetUserResponse {
	s.Permission = v
	return s
}

func (s *GetUserResponse) SetPhone(v string) *GetUserResponse {
	s.Phone = &v
	return s
}

func (s *GetUserResponse) SetPunishFlag(v int64) *GetUserResponse {
	s.PunishFlag = &v
	return s
}

func (s *GetUserResponse) SetRole(v string) *GetUserResponse {
	s.Role = &v
	return s
}

func (s *GetUserResponse) SetStatus(v string) *GetUserResponse {
	s.Status = &v
	return s
}

func (s *GetUserResponse) SetUpdatedAt(v int64) *GetUserResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetUserResponse) SetUserData(v map[string]interface{}) *GetUserResponse {
	s.UserData = v
	return s
}

func (s *GetUserResponse) SetUserId(v string) *GetUserResponse {
	s.UserId = &v
	return s
}

func (s *GetUserResponse) SetUserName(v string) *GetUserResponse {
	s.UserName = &v
	return s
}

/**
 * Get view request
 */
type GetViewRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s GetViewRequest) String() string {
	return tea.Prettify(s)
}

func (s GetViewRequest) GoString() string {
	return s.String()
}

func (s *GetViewRequest) SetHttpheaders(v map[string]*string) *GetViewRequest {
	s.Httpheaders = v
	return s
}

func (s *GetViewRequest) SetCategory(v string) *GetViewRequest {
	s.Category = &v
	return s
}

func (s *GetViewRequest) SetUserId(v string) *GetViewRequest {
	s.UserId = &v
	return s
}

func (s *GetViewRequest) SetViewId(v string) *GetViewRequest {
	s.ViewId = &v
	return s
}

/**
 * 
 */
type GetViewResponse struct {
	Category     *string                `json:"category,omitempty" xml:"category,omitempty"`
	CreatedAt    *string                `json:"created_at,omitempty" xml:"created_at,omitempty"`
	Description  *string                `json:"description,omitempty" xml:"description,omitempty"`
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	FileCount    *int64                 `json:"file_count,omitempty" xml:"file_count,omitempty"`
	Name         *string                `json:"name,omitempty" xml:"name,omitempty"`
	Owner        *string                `json:"owner,omitempty" xml:"owner,omitempty"`
	UpdatedAt    *string                `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	ViewId       *string                `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s GetViewResponse) String() string {
	return tea.Prettify(s)
}

func (s GetViewResponse) GoString() string {
	return s.String()
}

func (s *GetViewResponse) SetCategory(v string) *GetViewResponse {
	s.Category = &v
	return s
}

func (s *GetViewResponse) SetCreatedAt(v string) *GetViewResponse {
	s.CreatedAt = &v
	return s
}

func (s *GetViewResponse) SetDescription(v string) *GetViewResponse {
	s.Description = &v
	return s
}

func (s *GetViewResponse) SetExFieldsInfo(v map[string]interface{}) *GetViewResponse {
	s.ExFieldsInfo = v
	return s
}

func (s *GetViewResponse) SetFileCount(v int64) *GetViewResponse {
	s.FileCount = &v
	return s
}

func (s *GetViewResponse) SetName(v string) *GetViewResponse {
	s.Name = &v
	return s
}

func (s *GetViewResponse) SetOwner(v string) *GetViewResponse {
	s.Owner = &v
	return s
}

func (s *GetViewResponse) SetUpdatedAt(v string) *GetViewResponse {
	s.UpdatedAt = &v
	return s
}

func (s *GetViewResponse) SetViewId(v string) *GetViewResponse {
	s.ViewId = &v
	return s
}

/**
 *
 */
type HasMembershipResponse struct {
	Result *bool `json:"result,omitempty" xml:"result,omitempty"`
}

func (s HasMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s HasMembershipResponse) GoString() string {
	return s.String()
}

func (s *HasMembershipResponse) SetResult(v bool) *HasMembershipResponse {
	s.Result = &v
	return s
}

/**
 *
 */
type ImageAddressResponse struct {
	AddressDetail *Address `json:"address_detail,omitempty" xml:"address_detail,omitempty"`
	// 
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// cover_file_id
	CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
	// 
	CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
	// 
	Location *string `json:"location,omitempty" xml:"location,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ImageAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s ImageAddressResponse) GoString() string {
	return s.String()
}

func (s *ImageAddressResponse) SetAddressDetail(v *Address) *ImageAddressResponse {
	s.AddressDetail = v
	return s
}

func (s *ImageAddressResponse) SetCount(v int64) *ImageAddressResponse {
	s.Count = &v
	return s
}

func (s *ImageAddressResponse) SetCoverFileId(v string) *ImageAddressResponse {
	s.CoverFileId = &v
	return s
}

func (s *ImageAddressResponse) SetCoverUrl(v string) *ImageAddressResponse {
	s.CoverUrl = &v
	return s
}

func (s *ImageAddressResponse) SetLocation(v string) *ImageAddressResponse {
	s.Location = &v
	return s
}

func (s *ImageAddressResponse) SetName(v string) *ImageAddressResponse {
	s.Name = &v
	return s
}

/**
 *
 */
type ImageFaceGroupResponse struct {
	// 
	CreatedAt              *string       `json:"created_at,omitempty" xml:"created_at,omitempty"`
	GroupCoverFaceBoundary *FaceBoundary `json:"group_cover_face_boundary,omitempty" xml:"group_cover_face_boundary,omitempty"`
	// group_cover_file_id
	GroupCoverFileId *string `json:"group_cover_file_id,omitempty" xml:"group_cover_file_id,omitempty"`
	// group_cover_height
	GroupCoverHeight *int64 `json:"group_cover_height,omitempty" xml:"group_cover_height,omitempty"`
	// 
	GroupCoverUrl *string `json:"group_cover_url,omitempty" xml:"group_cover_url,omitempty"`
	// group_cover_width
	GroupCoverWidth *int64 `json:"group_cover_width,omitempty" xml:"group_cover_width,omitempty"`
	//  ID
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// 
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
	// 
	ImageCount *int64 `json:"image_count,omitempty" xml:"image_count,omitempty"`
	// remarks
	Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
	// remarks_array
	RemarksArray []*string `json:"remarks_array,omitempty" xml:"remarks_array,omitempty" type:"Repeated"`
	// 
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s ImageFaceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ImageFaceGroupResponse) GoString() string {
	return s.String()
}

func (s *ImageFaceGroupResponse) SetCreatedAt(v string) *ImageFaceGroupResponse {
	s.CreatedAt = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverFaceBoundary(v *FaceBoundary) *ImageFaceGroupResponse {
	s.GroupCoverFaceBoundary = v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverFileId(v string) *ImageFaceGroupResponse {
	s.GroupCoverFileId = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverHeight(v int64) *ImageFaceGroupResponse {
	s.GroupCoverHeight = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverUrl(v string) *ImageFaceGroupResponse {
	s.GroupCoverUrl = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupCoverWidth(v int64) *ImageFaceGroupResponse {
	s.GroupCoverWidth = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupId(v string) *ImageFaceGroupResponse {
	s.GroupId = &v
	return s
}

func (s *ImageFaceGroupResponse) SetGroupName(v string) *ImageFaceGroupResponse {
	s.GroupName = &v
	return s
}

func (s *ImageFaceGroupResponse) SetImageCount(v int64) *ImageFaceGroupResponse {
	s.ImageCount = &v
	return s
}

func (s *ImageFaceGroupResponse) SetRemarks(v string) *ImageFaceGroupResponse {
	s.Remarks = &v
	return s
}

func (s *ImageFaceGroupResponse) SetRemarksArray(v []*string) *ImageFaceGroupResponse {
	s.RemarksArray = v
	return s
}

func (s *ImageFaceGroupResponse) SetUpdatedAt(v string) *ImageFaceGroupResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type ImageTagResponse struct {
	// 
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// cover_file_category
	CoverFileCategory *string `json:"cover_file_category,omitempty" xml:"cover_file_category,omitempty"`
	// cover_file_id
	CoverFileId *string `json:"cover_file_id,omitempty" xml:"cover_file_id,omitempty"`
	// cover_score
	CoverOverallScore *float64 `json:"cover_overall_score,omitempty" xml:"cover_overall_score,omitempty"`
	// cover_tag_confidence
	CoverTagConfidence *float64 `json:"cover_tag_confidence,omitempty" xml:"cover_tag_confidence,omitempty"`
	// 
	CoverUrl *string `json:"cover_url,omitempty" xml:"cover_url,omitempty"`
	// 
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ImageTagResponse) String() string {
	return tea.Prettify(s)
}

func (s ImageTagResponse) GoString() string {
	return s.String()
}

func (s *ImageTagResponse) SetCount(v int64) *ImageTagResponse {
	s.Count = &v
	return s
}

func (s *ImageTagResponse) SetCoverFileCategory(v string) *ImageTagResponse {
	s.CoverFileCategory = &v
	return s
}

func (s *ImageTagResponse) SetCoverFileId(v string) *ImageTagResponse {
	s.CoverFileId = &v
	return s
}

func (s *ImageTagResponse) SetCoverOverallScore(v float64) *ImageTagResponse {
	s.CoverOverallScore = &v
	return s
}

func (s *ImageTagResponse) SetCoverTagConfidence(v float64) *ImageTagResponse {
	s.CoverTagConfidence = &v
	return s
}

func (s *ImageTagResponse) SetCoverUrl(v string) *ImageTagResponse {
	s.CoverUrl = &v
	return s
}

func (s *ImageTagResponse) SetName(v string) *ImageTagResponse {
	s.Name = &v
	return s
}

/**
 *
 */
type ListDeviceResponse struct {
	// items
	Items []*DeviceItem `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceResponse) GoString() string {
	return s.String()
}

func (s *ListDeviceResponse) SetItems(v []*DeviceItem) *ListDeviceResponse {
	s.Items = v
	return s
}

func (s *ListDeviceResponse) SetMarker(v string) *ListDeviceResponse {
	s.Marker = &v
	return s
}

/**
 *
 */
type ListDirectChildMembershipsResponse struct {
	// items
	Items []*BaseMembershipResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDirectChildMembershipsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDirectChildMembershipsResponse) GoString() string {
	return s.String()
}

func (s *ListDirectChildMembershipsResponse) SetItems(v []*BaseMembershipResponse) *ListDirectChildMembershipsResponse {
	s.Items = v
	return s
}

func (s *ListDirectChildMembershipsResponse) SetNextMarker(v string) *ListDirectChildMembershipsResponse {
	s.NextMarker = &v
	return s
}

/**
 *
 */
type ListDirectParentMembershipsResponse struct {
	// items
	Items []*BaseMembershipResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListDirectParentMembershipsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDirectParentMembershipsResponse) GoString() string {
	return s.String()
}

func (s *ListDirectParentMembershipsResponse) SetItems(v []*BaseMembershipResponse) *ListDirectParentMembershipsResponse {
	s.Items = v
	return s
}

func (s *ListDirectParentMembershipsResponse) SetNextMarker(v string) *ListDirectParentMembershipsResponse {
	s.NextMarker = &v
	return s
}

/**
 * list file view ids
 */
type ListFileViewsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	Category    *string            `json:"category,omitempty" xml:"category,omitempty"`
	DriveId     *string            `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId      *string            `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s ListFileViewsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileViewsRequest) GoString() string {
	return s.String()
}

func (s *ListFileViewsRequest) SetHttpheaders(v map[string]*string) *ListFileViewsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListFileViewsRequest) SetCategory(v string) *ListFileViewsRequest {
	s.Category = &v
	return s
}

func (s *ListFileViewsRequest) SetDriveId(v string) *ListFileViewsRequest {
	s.DriveId = &v
	return s
}

func (s *ListFileViewsRequest) SetFileId(v string) *ListFileViewsRequest {
	s.FileId = &v
	return s
}

func (s *ListFileViewsRequest) SetUserId(v string) *ListFileViewsRequest {
	s.UserId = &v
	return s
}

/**
 * list file view ids
 */
type ListFileViewsResponse struct {
	Items []*GetViewResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListFileViewsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileViewsResponse) GoString() string {
	return s.String()
}

func (s *ListFileViewsResponse) SetItems(v []*GetViewResponse) *ListFileViewsResponse {
	s.Items = v
	return s
}

/**
 *
 */
type ListGroupResponse struct {
	// items
	Items []*BaseGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGroupResponse) GoString() string {
	return s.String()
}

func (s *ListGroupResponse) SetItems(v []*BaseGroupResponse) *ListGroupResponse {
	s.Items = v
	return s
}

func (s *ListGroupResponse) SetNextMarker(v string) *ListGroupResponse {
	s.NextMarker = &v
	return s
}

/**
 * 
 */
type ListIdentityRoleRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	Identity    *Identity          `json:"identity,omitempty" xml:"identity,omitempty" require:"true"`
	// 
	IncludeGroupRole *bool   `json:"include_group_role,omitempty" xml:"include_group_role,omitempty" require:"true"`
	SubdomainId      *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s ListIdentityRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIdentityRoleRequest) GoString() string {
	return s.String()
}

func (s *ListIdentityRoleRequest) SetHttpheaders(v map[string]*string) *ListIdentityRoleRequest {
	s.Httpheaders = v
	return s
}

func (s *ListIdentityRoleRequest) SetIdentity(v *Identity) *ListIdentityRoleRequest {
	s.Identity = v
	return s
}

func (s *ListIdentityRoleRequest) SetIncludeGroupRole(v bool) *ListIdentityRoleRequest {
	s.IncludeGroupRole = &v
	return s
}

func (s *ListIdentityRoleRequest) SetSubdomainId(v string) *ListIdentityRoleRequest {
	s.SubdomainId = &v
	return s
}

/**
 * List image address groups request
 */
type ListImageAddressGroupsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// video_thumbnail_process
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListImageAddressGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListImageAddressGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListImageAddressGroupsRequest) SetHttpheaders(v map[string]*string) *ListImageAddressGroupsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListImageAddressGroupsRequest) SetDriveId(v string) *ListImageAddressGroupsRequest {
	s.DriveId = &v
	return s
}

func (s *ListImageAddressGroupsRequest) SetImageThumbnailProcess(v string) *ListImageAddressGroupsRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListImageAddressGroupsRequest) SetLimit(v int32) *ListImageAddressGroupsRequest {
	s.Limit = &v
	return s
}

func (s *ListImageAddressGroupsRequest) SetMarker(v string) *ListImageAddressGroupsRequest {
	s.Marker = &v
	return s
}

func (s *ListImageAddressGroupsRequest) SetVideoThumbnailProcess(v string) *ListImageAddressGroupsRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * 
 */
type ListImageAddressGroupsResponse struct {
	Items      []*ImageAddressResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string                 `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListImageAddressGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListImageAddressGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListImageAddressGroupsResponse) SetItems(v []*ImageAddressResponse) *ListImageAddressGroupsResponse {
	s.Items = v
	return s
}

func (s *ListImageAddressGroupsResponse) SetNextMarker(v string) *ListImageAddressGroupsResponse {
	s.NextMarker = &v
	return s
}

/**
 * List image face groups request
 */
type ListImageFaceGroupsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// 
	Limit *int64 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// 
	Marker  *string `json:"marker,omitempty" xml:"marker,omitempty"`
	Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
}

func (s ListImageFaceGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListImageFaceGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListImageFaceGroupsRequest) SetHttpheaders(v map[string]*string) *ListImageFaceGroupsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListImageFaceGroupsRequest) SetDriveId(v string) *ListImageFaceGroupsRequest {
	s.DriveId = &v
	return s
}

func (s *ListImageFaceGroupsRequest) SetLimit(v int64) *ListImageFaceGroupsRequest {
	s.Limit = &v
	return s
}

func (s *ListImageFaceGroupsRequest) SetMarker(v string) *ListImageFaceGroupsRequest {
	s.Marker = &v
	return s
}

func (s *ListImageFaceGroupsRequest) SetRemarks(v string) *ListImageFaceGroupsRequest {
	s.Remarks = &v
	return s
}

/**
 * 
 */
type ListImageFaceGroupsResponse struct {
	Items      []*ImageFaceGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string                   `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListImageFaceGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListImageFaceGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListImageFaceGroupsResponse) SetItems(v []*ImageFaceGroupResponse) *ListImageFaceGroupsResponse {
	s.Items = v
	return s
}

func (s *ListImageFaceGroupsResponse) SetNextMarker(v string) *ListImageFaceGroupsResponse {
	s.NextMarker = &v
	return s
}

/**
 * List image tags request
 */
type ListImageTagsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s ListImageTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListImageTagsRequest) GoString() string {
	return s.String()
}

func (s *ListImageTagsRequest) SetHttpheaders(v map[string]*string) *ListImageTagsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListImageTagsRequest) SetDriveId(v string) *ListImageTagsRequest {
	s.DriveId = &v
	return s
}

func (s *ListImageTagsRequest) SetImageThumbnailProcess(v string) *ListImageTagsRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListImageTagsRequest) SetVideoThumbnailProcess(v string) *ListImageTagsRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * 
 */
type ListImageTagsResponse struct {
	Tags []*ImageTagResponse `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s ListImageTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListImageTagsResponse) GoString() string {
	return s.String()
}

func (s *ListImageTagsResponse) SetTags(v []*ImageTagResponse) *ListImageTagsResponse {
	s.Tags = v
	return s
}

/**
 *
 */
type ListSyncMappingResponse struct {
	// items
	Items []*SyncMappingItem `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
}

func (s ListSyncMappingResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSyncMappingResponse) GoString() string {
	return s.String()
}

func (s *ListSyncMappingResponse) SetItems(v []*SyncMappingItem) *ListSyncMappingResponse {
	s.Items = v
	return s
}

func (s *ListSyncMappingResponse) SetMarker(v string) *ListSyncMappingResponse {
	s.Marker = &v
	return s
}

/**
 * List user response
 */
type ListUserResponse struct {
	Items []*BaseUserResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// 
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListUserResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserResponse) GoString() string {
	return s.String()
}

func (s *ListUserResponse) SetItems(v []*BaseUserResponse) *ListUserResponse {
	s.Items = v
	return s
}

func (s *ListUserResponse) SetNextMarker(v string) *ListUserResponse {
	s.NextMarker = &v
	return s
}

/**
 * list view file
 */
type ListViewFilesRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	Fields   *string `json:"fields,omitempty" xml:"fields,omitempty"`
	Filter   *string `json:"filter,omitempty" xml:"filter,omitempty"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// image_url_process
	ImageUrlProcess *string `json:"image_url_process,omitempty" xml:"image_url_process,omitempty"`
	Limit           *int32  `json:"limit,omitempty" xml:"limit,omitempty"`
	Marker          *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// office_thumbnail_process
	OfficeThumbnailProcess *string `json:"office_thumbnail_process,omitempty" xml:"office_thumbnail_process,omitempty"`
	OrderBy                *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	OrderDirection         *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	UrlExpireSec           *int32  `json:"url_expire_sec,omitempty" xml:"url_expire_sec,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// video_thumbnail_process
	// type:string
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s ListViewFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListViewFilesRequest) GoString() string {
	return s.String()
}

func (s *ListViewFilesRequest) SetHttpheaders(v map[string]*string) *ListViewFilesRequest {
	s.Httpheaders = v
	return s
}

func (s *ListViewFilesRequest) SetCategory(v string) *ListViewFilesRequest {
	s.Category = &v
	return s
}

func (s *ListViewFilesRequest) SetFields(v string) *ListViewFilesRequest {
	s.Fields = &v
	return s
}

func (s *ListViewFilesRequest) SetFilter(v string) *ListViewFilesRequest {
	s.Filter = &v
	return s
}

func (s *ListViewFilesRequest) SetImageThumbnailProcess(v string) *ListViewFilesRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *ListViewFilesRequest) SetImageUrlProcess(v string) *ListViewFilesRequest {
	s.ImageUrlProcess = &v
	return s
}

func (s *ListViewFilesRequest) SetLimit(v int32) *ListViewFilesRequest {
	s.Limit = &v
	return s
}

func (s *ListViewFilesRequest) SetMarker(v string) *ListViewFilesRequest {
	s.Marker = &v
	return s
}

func (s *ListViewFilesRequest) SetOfficeThumbnailProcess(v string) *ListViewFilesRequest {
	s.OfficeThumbnailProcess = &v
	return s
}

func (s *ListViewFilesRequest) SetOrderBy(v string) *ListViewFilesRequest {
	s.OrderBy = &v
	return s
}

func (s *ListViewFilesRequest) SetOrderDirection(v string) *ListViewFilesRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListViewFilesRequest) SetUrlExpireSec(v int32) *ListViewFilesRequest {
	s.UrlExpireSec = &v
	return s
}

func (s *ListViewFilesRequest) SetUserId(v string) *ListViewFilesRequest {
	s.UserId = &v
	return s
}

func (s *ListViewFilesRequest) SetVideoThumbnailProcess(v string) *ListViewFilesRequest {
	s.VideoThumbnailProcess = &v
	return s
}

func (s *ListViewFilesRequest) SetViewId(v string) *ListViewFilesRequest {
	s.ViewId = &v
	return s
}

/**
 * list view files response
 */
type ListViewFilesResponse struct {
	Items      []*ViewFileItem `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string         `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListViewFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListViewFilesResponse) GoString() string {
	return s.String()
}

func (s *ListViewFilesResponse) SetItems(v []*ViewFileItem) *ListViewFilesResponse {
	s.Items = v
	return s
}

func (s *ListViewFilesResponse) SetNextMarker(v string) *ListViewFilesResponse {
	s.NextMarker = &v
	return s
}

/**
 * List views request
 */
type ListViewsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty" require:"true"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s ListViewsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListViewsRequest) GoString() string {
	return s.String()
}

func (s *ListViewsRequest) SetHttpheaders(v map[string]*string) *ListViewsRequest {
	s.Httpheaders = v
	return s
}

func (s *ListViewsRequest) SetCategory(v string) *ListViewsRequest {
	s.Category = &v
	return s
}

func (s *ListViewsRequest) SetLimit(v int32) *ListViewsRequest {
	s.Limit = &v
	return s
}

func (s *ListViewsRequest) SetMarker(v string) *ListViewsRequest {
	s.Marker = &v
	return s
}

func (s *ListViewsRequest) SetOrderBy(v string) *ListViewsRequest {
	s.OrderBy = &v
	return s
}

func (s *ListViewsRequest) SetOrderDirection(v string) *ListViewsRequest {
	s.OrderDirection = &v
	return s
}

func (s *ListViewsRequest) SetOwner(v string) *ListViewsRequest {
	s.Owner = &v
	return s
}

func (s *ListViewsRequest) SetUserId(v string) *ListViewsRequest {
	s.UserId = &v
	return s
}

/**
 * 
 */
type ListViewsResponse struct {
	Items      []*GetViewResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string            `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s ListViewsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListViewsResponse) GoString() string {
	return s.String()
}

func (s *ListViewsResponse) SetItems(v []*GetViewResponse) *ListViewsResponse {
	s.Items = v
	return s
}

func (s *ListViewsResponse) SetNextMarker(v string) *ListViewsResponse {
	s.NextMarker = &v
	return s
}

/**
 * Merge face group request
 */
type MergeFaceGroupRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// from_group_id
	FromGroupId *string `json:"from_group_id,omitempty" xml:"from_group_id,omitempty" require:"true"`
	// to_group_id
	ToGroupId *string `json:"to_group_id,omitempty" xml:"to_group_id,omitempty" require:"true"`
}

func (s MergeFaceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MergeFaceGroupRequest) GoString() string {
	return s.String()
}

func (s *MergeFaceGroupRequest) SetHttpheaders(v map[string]*string) *MergeFaceGroupRequest {
	s.Httpheaders = v
	return s
}

func (s *MergeFaceGroupRequest) SetDriveId(v string) *MergeFaceGroupRequest {
	s.DriveId = &v
	return s
}

func (s *MergeFaceGroupRequest) SetFromGroupId(v string) *MergeFaceGroupRequest {
	s.FromGroupId = &v
	return s
}

func (s *MergeFaceGroupRequest) SetToGroupId(v string) *MergeFaceGroupRequest {
	s.ToGroupId = &v
	return s
}

/**
 * Merge face group response
 */
type MergeFaceGroupResponse struct {
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	TaskId *string `json:"task_id,omitempty" xml:"task_id,omitempty"`
}

func (s MergeFaceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MergeFaceGroupResponse) GoString() string {
	return s.String()
}

func (s *MergeFaceGroupResponse) SetStatus(v string) *MergeFaceGroupResponse {
	s.Status = &v
	return s
}

func (s *MergeFaceGroupResponse) SetTaskId(v string) *MergeFaceGroupResponse {
	s.TaskId = &v
	return s
}

/**
 * MigrateUserToSubdomainResponse
 */
type MigrateUserToSubdomainResponse struct {
}

func (s MigrateUserToSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateUserToSubdomainResponse) GoString() string {
	return s.String()
}

/**
 * Parse keywords request
 */
type ParseKeywordsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	Keywords    *string            `json:"keywords,omitempty" xml:"keywords,omitempty"`
}

func (s ParseKeywordsRequest) String() string {
	return tea.Prettify(s)
}

func (s ParseKeywordsRequest) GoString() string {
	return s.String()
}

func (s *ParseKeywordsRequest) SetHttpheaders(v map[string]*string) *ParseKeywordsRequest {
	s.Httpheaders = v
	return s
}

func (s *ParseKeywordsRequest) SetKeywords(v string) *ParseKeywordsRequest {
	s.Keywords = &v
	return s
}

/**
 * Parse keywords response
 */
type ParseKeywordsResponse struct {
	// AddressLine
	AddressLine *string         `json:"address_line,omitempty" xml:"address_line,omitempty"`
	Tags        []*SystemTag    `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	TimeRange   *ParseTimeRange `json:"time_range,omitempty" xml:"time_range,omitempty"`
}

func (s ParseKeywordsResponse) String() string {
	return tea.Prettify(s)
}

func (s ParseKeywordsResponse) GoString() string {
	return s.String()
}

func (s *ParseKeywordsResponse) SetAddressLine(v string) *ParseKeywordsResponse {
	s.AddressLine = &v
	return s
}

func (s *ParseKeywordsResponse) SetTags(v []*SystemTag) *ParseKeywordsResponse {
	s.Tags = v
	return s
}

func (s *ParseKeywordsResponse) SetTimeRange(v *ParseTimeRange) *ParseKeywordsResponse {
	s.TimeRange = v
	return s
}

/**
 *
 */
type ParseTimeRange struct {
	End   *string `json:"end,omitempty" xml:"end,omitempty"`
	Start *string `json:"start,omitempty" xml:"start,omitempty"`
}

func (s ParseTimeRange) String() string {
	return tea.Prettify(s)
}

func (s ParseTimeRange) GoString() string {
	return s.String()
}

func (s *ParseTimeRange) SetEnd(v string) *ParseTimeRange {
	s.End = &v
	return s
}

func (s *ParseTimeRange) SetStart(v string) *ParseTimeRange {
	s.Start = &v
	return s
}

/**
 * Remove story images response
 */
type RemoveStoryImagesResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_ids
	FileIds []*string                      `json:"file_ids,omitempty" xml:"file_ids,omitempty" type:"Repeated"`
	Results []*RemoveStoryImagesResultItem `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
	// success_file_ids
	SuccessFileIds []*string `json:"success_file_ids,omitempty" xml:"success_file_ids,omitempty" type:"Repeated"`
}

func (s RemoveStoryImagesResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveStoryImagesResponse) GoString() string {
	return s.String()
}

func (s *RemoveStoryImagesResponse) SetDriveId(v string) *RemoveStoryImagesResponse {
	s.DriveId = &v
	return s
}

func (s *RemoveStoryImagesResponse) SetFileIds(v []*string) *RemoveStoryImagesResponse {
	s.FileIds = v
	return s
}

func (s *RemoveStoryImagesResponse) SetResults(v []*RemoveStoryImagesResultItem) *RemoveStoryImagesResponse {
	s.Results = v
	return s
}

func (s *RemoveStoryImagesResponse) SetStoryId(v string) *RemoveStoryImagesResponse {
	s.StoryId = &v
	return s
}

func (s *RemoveStoryImagesResponse) SetSuccessFileIds(v []*string) *RemoveStoryImagesResponse {
	s.SuccessFileIds = v
	return s
}

/**
 *
 */
type RemoveStoryImagesResultItem struct {
	// code
	Code *string `json:"code,omitempty" xml:"code,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// is_succeed
	IsSucceed *bool `json:"is_succeed,omitempty" xml:"is_succeed,omitempty"`
	// message
	Message *string `json:"message,omitempty" xml:"message,omitempty"`
}

func (s RemoveStoryImagesResultItem) String() string {
	return tea.Prettify(s)
}

func (s RemoveStoryImagesResultItem) GoString() string {
	return s.String()
}

func (s *RemoveStoryImagesResultItem) SetCode(v string) *RemoveStoryImagesResultItem {
	s.Code = &v
	return s
}

func (s *RemoveStoryImagesResultItem) SetFileId(v string) *RemoveStoryImagesResultItem {
	s.FileId = &v
	return s
}

func (s *RemoveStoryImagesResultItem) SetIsSucceed(v bool) *RemoveStoryImagesResultItem {
	s.IsSucceed = &v
	return s
}

func (s *RemoveStoryImagesResultItem) SetMessage(v string) *RemoveStoryImagesResultItem {
	s.Message = &v
	return s
}

/**
 * remove file from view
 */
type RemoveViewFileRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	FileId   *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s RemoveViewFileRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveViewFileRequest) GoString() string {
	return s.String()
}

func (s *RemoveViewFileRequest) SetHttpheaders(v map[string]*string) *RemoveViewFileRequest {
	s.Httpheaders = v
	return s
}

func (s *RemoveViewFileRequest) SetCategory(v string) *RemoveViewFileRequest {
	s.Category = &v
	return s
}

func (s *RemoveViewFileRequest) SetDriveId(v string) *RemoveViewFileRequest {
	s.DriveId = &v
	return s
}

func (s *RemoveViewFileRequest) SetFileId(v string) *RemoveViewFileRequest {
	s.FileId = &v
	return s
}

func (s *RemoveViewFileRequest) SetUserId(v string) *RemoveViewFileRequest {
	s.UserId = &v
	return s
}

func (s *RemoveViewFileRequest) SetViewId(v string) *RemoveViewFileRequest {
	s.ViewId = &v
	return s
}

/**
 * RollbackUserFromSubdomainResponse
 */
type RollbackUserFromSubdomainResponse struct {
}

func (s RollbackUserFromSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackUserFromSubdomainResponse) GoString() string {
	return s.String()
}

/**
 *
 */
type SearchGroupResponse struct {
	// items
	Items []*BaseGroupResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	// next_marker
	NextMarker *string `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
}

func (s SearchGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchGroupResponse) GoString() string {
	return s.String()
}

func (s *SearchGroupResponse) SetItems(v []*BaseGroupResponse) *SearchGroupResponse {
	s.Items = v
	return s
}

func (s *SearchGroupResponse) SetNextMarker(v string) *SearchGroupResponse {
	s.NextMarker = &v
	return s
}

/**
 * Search image address groups request
 */
type SearchImageAddressGroupsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// 
	AddressLevel *string `json:"address_level,omitempty" xml:"address_level,omitempty"`
	// 
	AddressNames []*string `json:"address_names,omitempty" xml:"address_names,omitempty" type:"Repeated"`
	// br_geo_point
	BrGeoPoint *string `json:"br_geo_point,omitempty" xml:"br_geo_point,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// image_thumbnail_process
	ImageThumbnailProcess *string `json:"image_thumbnail_process,omitempty" xml:"image_thumbnail_process,omitempty"`
	// tl_geo_point
	TlGeoPoint *string `json:"tl_geo_point,omitempty" xml:"tl_geo_point,omitempty"`
	// video_thumbnail_process
	VideoThumbnailProcess *string `json:"video_thumbnail_process,omitempty" xml:"video_thumbnail_process,omitempty"`
}

func (s SearchImageAddressGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchImageAddressGroupsRequest) GoString() string {
	return s.String()
}

func (s *SearchImageAddressGroupsRequest) SetHttpheaders(v map[string]*string) *SearchImageAddressGroupsRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetAddressLevel(v string) *SearchImageAddressGroupsRequest {
	s.AddressLevel = &v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetAddressNames(v []*string) *SearchImageAddressGroupsRequest {
	s.AddressNames = v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetBrGeoPoint(v string) *SearchImageAddressGroupsRequest {
	s.BrGeoPoint = &v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetDriveId(v string) *SearchImageAddressGroupsRequest {
	s.DriveId = &v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetImageThumbnailProcess(v string) *SearchImageAddressGroupsRequest {
	s.ImageThumbnailProcess = &v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetTlGeoPoint(v string) *SearchImageAddressGroupsRequest {
	s.TlGeoPoint = &v
	return s
}

func (s *SearchImageAddressGroupsRequest) SetVideoThumbnailProcess(v string) *SearchImageAddressGroupsRequest {
	s.VideoThumbnailProcess = &v
	return s
}

/**
 * 
 */
type SearchImageAddressGroupsResponse struct {
	Items []*ImageAddressResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s SearchImageAddressGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchImageAddressGroupsResponse) GoString() string {
	return s.String()
}

func (s *SearchImageAddressGroupsResponse) SetItems(v []*ImageAddressResponse) *SearchImageAddressGroupsResponse {
	s.Items = v
	return s
}

/**
 * Search user and group response
 */
type SearchUserAndGroupResponse struct {
	Groups []*BaseGroupResponse `json:"groups,omitempty" xml:"groups,omitempty" type:"Repeated"`
	// 
	NextMarker *string             `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	Users      []*BaseUserResponse `json:"users,omitempty" xml:"users,omitempty" type:"Repeated"`
}

func (s SearchUserAndGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchUserAndGroupResponse) GoString() string {
	return s.String()
}

func (s *SearchUserAndGroupResponse) SetGroups(v []*BaseGroupResponse) *SearchUserAndGroupResponse {
	s.Groups = v
	return s
}

func (s *SearchUserAndGroupResponse) SetNextMarker(v string) *SearchUserAndGroupResponse {
	s.NextMarker = &v
	return s
}

func (s *SearchUserAndGroupResponse) SetUsers(v []*BaseUserResponse) *SearchUserAndGroupResponse {
	s.Users = v
	return s
}

/**
 * Search view request
 */
type SearchViewsRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// 
	Limit *int32 `json:"limit,omitempty" xml:"limit,omitempty" maximum:"100" minimum:"1"`
	// marker
	Marker *string `json:"marker,omitempty" xml:"marker,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// order_by
	OrderBy *string `json:"order_by,omitempty" xml:"order_by,omitempty"`
	// order_direction
	OrderDirection *string `json:"order_direction,omitempty" xml:"order_direction,omitempty"`
	// owner
	Owner *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// return_total_count 
	ReturnTotalCount *bool `json:"return_total_count,omitempty" xml:"return_total_count,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s SearchViewsRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchViewsRequest) GoString() string {
	return s.String()
}

func (s *SearchViewsRequest) SetHttpheaders(v map[string]*string) *SearchViewsRequest {
	s.Httpheaders = v
	return s
}

func (s *SearchViewsRequest) SetCategory(v string) *SearchViewsRequest {
	s.Category = &v
	return s
}

func (s *SearchViewsRequest) SetLimit(v int32) *SearchViewsRequest {
	s.Limit = &v
	return s
}

func (s *SearchViewsRequest) SetMarker(v string) *SearchViewsRequest {
	s.Marker = &v
	return s
}

func (s *SearchViewsRequest) SetName(v string) *SearchViewsRequest {
	s.Name = &v
	return s
}

func (s *SearchViewsRequest) SetOrderBy(v string) *SearchViewsRequest {
	s.OrderBy = &v
	return s
}

func (s *SearchViewsRequest) SetOrderDirection(v string) *SearchViewsRequest {
	s.OrderDirection = &v
	return s
}

func (s *SearchViewsRequest) SetOwner(v string) *SearchViewsRequest {
	s.Owner = &v
	return s
}

func (s *SearchViewsRequest) SetReturnTotalCount(v bool) *SearchViewsRequest {
	s.ReturnTotalCount = &v
	return s
}

func (s *SearchViewsRequest) SetUserId(v string) *SearchViewsRequest {
	s.UserId = &v
	return s
}

/**
 * 
 */
type SearchViewsResponse struct {
	Items      []*GetViewResponse `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
	NextMarker *string            `json:"next_marker,omitempty" xml:"next_marker,omitempty"`
	TotalCount *int64             `json:"total_count,omitempty" xml:"total_count,omitempty"`
}

func (s SearchViewsResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchViewsResponse) GoString() string {
	return s.String()
}

func (s *SearchViewsResponse) SetItems(v []*GetViewResponse) *SearchViewsResponse {
	s.Items = v
	return s
}

func (s *SearchViewsResponse) SetNextMarker(v string) *SearchViewsResponse {
	s.NextMarker = &v
	return s
}

func (s *SearchViewsResponse) SetTotalCount(v int64) *SearchViewsResponse {
	s.TotalCount = &v
	return s
}

/**
 *
 */
type SyncMappingItem struct {
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// custom_meta
	CustomMeta *string `json:"custom_meta,omitempty" xml:"custom_meta,omitempty"`
	// device_name
	DeviceName *string `json:"device_name,omitempty" xml:"device_name,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty"`
	// fs_id
	FsId *string `json:"fs_id,omitempty" xml:"fs_id,omitempty"`
	// local_path
	LocalPath *string `json:"local_path,omitempty" xml:"local_path,omitempty"`
	// sync_mode
	SyncMode *string `json:"sync_mode,omitempty" xml:"sync_mode,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s SyncMappingItem) String() string {
	return tea.Prettify(s)
}

func (s SyncMappingItem) GoString() string {
	return s.String()
}

func (s *SyncMappingItem) SetCreatedAt(v string) *SyncMappingItem {
	s.CreatedAt = &v
	return s
}

func (s *SyncMappingItem) SetCustomMeta(v string) *SyncMappingItem {
	s.CustomMeta = &v
	return s
}

func (s *SyncMappingItem) SetDeviceName(v string) *SyncMappingItem {
	s.DeviceName = &v
	return s
}

func (s *SyncMappingItem) SetDriveId(v string) *SyncMappingItem {
	s.DriveId = &v
	return s
}

func (s *SyncMappingItem) SetFileId(v string) *SyncMappingItem {
	s.FileId = &v
	return s
}

func (s *SyncMappingItem) SetFsId(v string) *SyncMappingItem {
	s.FsId = &v
	return s
}

func (s *SyncMappingItem) SetLocalPath(v string) *SyncMappingItem {
	s.LocalPath = &v
	return s
}

func (s *SyncMappingItem) SetSyncMode(v string) *SyncMappingItem {
	s.SyncMode = &v
	return s
}

func (s *SyncMappingItem) SetUpdatedAt(v string) *SyncMappingItem {
	s.UpdatedAt = &v
	return s
}

/**
 * Unassign facegroup item request
 */
type UnAssignFaceGroupItemRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// face_group_id
	FaceGroupId *string `json:"face_group_id,omitempty" xml:"face_group_id,omitempty" require:"true"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" require:"true"`
}

func (s UnAssignFaceGroupItemRequest) String() string {
	return tea.Prettify(s)
}

func (s UnAssignFaceGroupItemRequest) GoString() string {
	return s.String()
}

func (s *UnAssignFaceGroupItemRequest) SetHttpheaders(v map[string]*string) *UnAssignFaceGroupItemRequest {
	s.Httpheaders = v
	return s
}

func (s *UnAssignFaceGroupItemRequest) SetDriveId(v string) *UnAssignFaceGroupItemRequest {
	s.DriveId = &v
	return s
}

func (s *UnAssignFaceGroupItemRequest) SetFaceGroupId(v string) *UnAssignFaceGroupItemRequest {
	s.FaceGroupId = &v
	return s
}

func (s *UnAssignFaceGroupItemRequest) SetFileId(v string) *UnAssignFaceGroupItemRequest {
	s.FileId = &v
	return s
}

/**
 * Update face group info request
 */
type UpdateFaceGroupInfoRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// group_cover_face_id
	GroupCoverFaceId *string `json:"group_cover_face_id,omitempty" xml:"group_cover_face_id,omitempty"`
	// group_id 
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty" require:"true"`
	// group_name
	GroupName *string `json:"group_name,omitempty" xml:"group_name,omitempty"`
	// remarks
	Remarks *string `json:"remarks,omitempty" xml:"remarks,omitempty"`
}

func (s UpdateFaceGroupInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFaceGroupInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateFaceGroupInfoRequest) SetHttpheaders(v map[string]*string) *UpdateFaceGroupInfoRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateFaceGroupInfoRequest) SetDriveId(v string) *UpdateFaceGroupInfoRequest {
	s.DriveId = &v
	return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupCoverFaceId(v string) *UpdateFaceGroupInfoRequest {
	s.GroupCoverFaceId = &v
	return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupId(v string) *UpdateFaceGroupInfoRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateFaceGroupInfoRequest) SetGroupName(v string) *UpdateFaceGroupInfoRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateFaceGroupInfoRequest) SetRemarks(v string) *UpdateFaceGroupInfoRequest {
	s.Remarks = &v
	return s
}

/**
 * 
 */
type UpdateFaceGroupInfoResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// group_id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
}

func (s UpdateFaceGroupInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFaceGroupInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateFaceGroupInfoResponse) SetDriveId(v string) *UpdateFaceGroupInfoResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateFaceGroupInfoResponse) SetGroupId(v string) *UpdateFaceGroupInfoResponse {
	s.GroupId = &v
	return s
}

/**
 *
 */
type UpdateGroupResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	// group name
	GroupName  *string                `json:"group_name,omitempty" xml:"group_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// updated_at
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

func (s UpdateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateGroupResponse) SetCreatedAt(v int64) *UpdateGroupResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateGroupResponse) SetCreator(v string) *UpdateGroupResponse {
	s.Creator = &v
	return s
}

func (s *UpdateGroupResponse) SetDescription(v string) *UpdateGroupResponse {
	s.Description = &v
	return s
}

func (s *UpdateGroupResponse) SetDomainId(v string) *UpdateGroupResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateGroupResponse) SetGroupId(v string) *UpdateGroupResponse {
	s.GroupId = &v
	return s
}

func (s *UpdateGroupResponse) SetGroupName(v string) *UpdateGroupResponse {
	s.GroupName = &v
	return s
}

func (s *UpdateGroupResponse) SetPermission(v map[string]interface{}) *UpdateGroupResponse {
	s.Permission = v
	return s
}

func (s *UpdateGroupResponse) SetUpdatedAt(v int64) *UpdateGroupResponse {
	s.UpdatedAt = &v
	return s
}

/**
 *
 */
type UpdateMembershipResponse struct {
	// created_at
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// domain id
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// group id
	GroupId *string `json:"group_id,omitempty" xml:"group_id,omitempty"`
	//  member or admin
	MemberRole *string `json:"member_role,omitempty" xml:"member_role,omitempty"`
	MemberType *string `json:"member_type,omitempty" xml:"member_type,omitempty"`
	SubGroupId *string `json:"sub_group_id,omitempty" xml:"sub_group_id,omitempty"`
	// updated_at
	UpdatedAt *int64  `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	UserId    *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
}

func (s UpdateMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMembershipResponse) GoString() string {
	return s.String()
}

func (s *UpdateMembershipResponse) SetCreatedAt(v int64) *UpdateMembershipResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateMembershipResponse) SetCreator(v string) *UpdateMembershipResponse {
	s.Creator = &v
	return s
}

func (s *UpdateMembershipResponse) SetDescription(v string) *UpdateMembershipResponse {
	s.Description = &v
	return s
}

func (s *UpdateMembershipResponse) SetDomainId(v string) *UpdateMembershipResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateMembershipResponse) SetGroupId(v string) *UpdateMembershipResponse {
	s.GroupId = &v
	return s
}

func (s *UpdateMembershipResponse) SetMemberRole(v string) *UpdateMembershipResponse {
	s.MemberRole = &v
	return s
}

func (s *UpdateMembershipResponse) SetMemberType(v string) *UpdateMembershipResponse {
	s.MemberType = &v
	return s
}

func (s *UpdateMembershipResponse) SetSubGroupId(v string) *UpdateMembershipResponse {
	s.SubGroupId = &v
	return s
}

func (s *UpdateMembershipResponse) SetUpdatedAt(v int64) *UpdateMembershipResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UpdateMembershipResponse) SetUserId(v string) *UpdateMembershipResponse {
	s.UserId = &v
	return s
}

/**
 * Update story request
 */
type UpdateStoryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// custom_id
	CustomId *string `json:"custom_id,omitempty" xml:"custom_id,omitempty"`
	// custom_labels
	CustomLabels map[string]interface{} `json:"custom_labels,omitempty" xml:"custom_labels,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty" require:"true"`
	// story_name
	StoryName *string `json:"story_name,omitempty" xml:"story_name,omitempty"`
}

func (s UpdateStoryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateStoryRequest) GoString() string {
	return s.String()
}

func (s *UpdateStoryRequest) SetHttpheaders(v map[string]*string) *UpdateStoryRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateStoryRequest) SetCustomId(v string) *UpdateStoryRequest {
	s.CustomId = &v
	return s
}

func (s *UpdateStoryRequest) SetCustomLabels(v map[string]interface{}) *UpdateStoryRequest {
	s.CustomLabels = v
	return s
}

func (s *UpdateStoryRequest) SetDriveId(v string) *UpdateStoryRequest {
	s.DriveId = &v
	return s
}

func (s *UpdateStoryRequest) SetStoryId(v string) *UpdateStoryRequest {
	s.StoryId = &v
	return s
}

func (s *UpdateStoryRequest) SetStoryName(v string) *UpdateStoryRequest {
	s.StoryName = &v
	return s
}

/**
 * update story response
 */
type UpdateStoryResponse struct {
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// story_id
	StoryId *string `json:"story_id,omitempty" xml:"story_id,omitempty"`
}

func (s UpdateStoryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateStoryResponse) GoString() string {
	return s.String()
}

func (s *UpdateStoryResponse) SetDriveId(v string) *UpdateStoryResponse {
	s.DriveId = &v
	return s
}

func (s *UpdateStoryResponse) SetStoryId(v string) *UpdateStoryResponse {
	s.StoryId = &v
	return s
}

/**
 * Update user response
 */
type UpdateUserResponse struct {
	// 
	Avatar *string `json:"avatar,omitempty" xml:"avatar,omitempty"`
	// 
	CreatedAt *int64 `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator
	Creator *string `json:"creator,omitempty" xml:"creator,omitempty"`
	//  Drive ID
	DefaultDriveId *string `json:"default_drive_id,omitempty" xml:"default_drive_id,omitempty"`
	// 
	DenyChangePasswordBySelf *bool `json:"deny_change_password_by_self,omitempty" xml:"deny_change_password_by_self,omitempty"`
	// 
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// Domain ID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty"`
	// 
	Email *string `json:"email,omitempty" xml:"email,omitempty"`
	// 
	NeedChangePasswordNextLogin *bool `json:"need_change_password_next_login,omitempty" xml:"need_change_password_next_login,omitempty"`
	// 
	NickName   *string                `json:"nick_name,omitempty" xml:"nick_name,omitempty"`
	Permission map[string]interface{} `json:"permission,omitempty" xml:"permission,omitempty"`
	// 
	Phone *string `json:"phone,omitempty" xml:"phone,omitempty"`
	// 
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// 
	Role *string `json:"role,omitempty" xml:"role,omitempty"`
	// 
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// 
	UpdatedAt *int64 `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// json1K
	UserData map[string]interface{} `json:"user_data,omitempty" xml:"user_data,omitempty"`
	//  ID
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// 
	UserName *string `json:"user_name,omitempty" xml:"user_name,omitempty"`
}

func (s UpdateUserResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserResponse) GoString() string {
	return s.String()
}

func (s *UpdateUserResponse) SetAvatar(v string) *UpdateUserResponse {
	s.Avatar = &v
	return s
}

func (s *UpdateUserResponse) SetCreatedAt(v int64) *UpdateUserResponse {
	s.CreatedAt = &v
	return s
}

func (s *UpdateUserResponse) SetCreator(v string) *UpdateUserResponse {
	s.Creator = &v
	return s
}

func (s *UpdateUserResponse) SetDefaultDriveId(v string) *UpdateUserResponse {
	s.DefaultDriveId = &v
	return s
}

func (s *UpdateUserResponse) SetDenyChangePasswordBySelf(v bool) *UpdateUserResponse {
	s.DenyChangePasswordBySelf = &v
	return s
}

func (s *UpdateUserResponse) SetDescription(v string) *UpdateUserResponse {
	s.Description = &v
	return s
}

func (s *UpdateUserResponse) SetDomainId(v string) *UpdateUserResponse {
	s.DomainId = &v
	return s
}

func (s *UpdateUserResponse) SetEmail(v string) *UpdateUserResponse {
	s.Email = &v
	return s
}

func (s *UpdateUserResponse) SetNeedChangePasswordNextLogin(v bool) *UpdateUserResponse {
	s.NeedChangePasswordNextLogin = &v
	return s
}

func (s *UpdateUserResponse) SetNickName(v string) *UpdateUserResponse {
	s.NickName = &v
	return s
}

func (s *UpdateUserResponse) SetPermission(v map[string]interface{}) *UpdateUserResponse {
	s.Permission = v
	return s
}

func (s *UpdateUserResponse) SetPhone(v string) *UpdateUserResponse {
	s.Phone = &v
	return s
}

func (s *UpdateUserResponse) SetPunishFlag(v int64) *UpdateUserResponse {
	s.PunishFlag = &v
	return s
}

func (s *UpdateUserResponse) SetRole(v string) *UpdateUserResponse {
	s.Role = &v
	return s
}

func (s *UpdateUserResponse) SetStatus(v string) *UpdateUserResponse {
	s.Status = &v
	return s
}

func (s *UpdateUserResponse) SetUpdatedAt(v int64) *UpdateUserResponse {
	s.UpdatedAt = &v
	return s
}

func (s *UpdateUserResponse) SetUserData(v map[string]interface{}) *UpdateUserResponse {
	s.UserData = v
	return s
}

func (s *UpdateUserResponse) SetUserId(v string) *UpdateUserResponse {
	s.UserId = &v
	return s
}

func (s *UpdateUserResponse) SetUserName(v string) *UpdateUserResponse {
	s.UserName = &v
	return s
}

/**
 * Update view request
 */
type UpdateViewRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	// description
	FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s UpdateViewRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateViewRequest) GoString() string {
	return s.String()
}

func (s *UpdateViewRequest) SetHttpheaders(v map[string]*string) *UpdateViewRequest {
	s.Httpheaders = v
	return s
}

func (s *UpdateViewRequest) SetCategory(v string) *UpdateViewRequest {
	s.Category = &v
	return s
}

func (s *UpdateViewRequest) SetDescription(v string) *UpdateViewRequest {
	s.Description = &v
	return s
}

func (s *UpdateViewRequest) SetExFieldsInfo(v map[string]interface{}) *UpdateViewRequest {
	s.ExFieldsInfo = v
	return s
}

func (s *UpdateViewRequest) SetFileCount(v int64) *UpdateViewRequest {
	s.FileCount = &v
	return s
}

func (s *UpdateViewRequest) SetName(v string) *UpdateViewRequest {
	s.Name = &v
	return s
}

func (s *UpdateViewRequest) SetUserId(v string) *UpdateViewRequest {
	s.UserId = &v
	return s
}

func (s *UpdateViewRequest) SetViewId(v string) *UpdateViewRequest {
	s.ViewId = &v
	return s
}

/**
 *
 */
type UpgradeCheckAppResponse struct {
	// option
	Option *string `json:"option,omitempty" xml:"option,omitempty"`
	// release_date
	ReleaseDate *string `json:"release_date,omitempty" xml:"release_date,omitempty"`
	// release_notes_url
	ReleaseNotesUrl *string `json:"release_notes_url,omitempty" xml:"release_notes_url,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// version
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s UpgradeCheckAppResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeCheckAppResponse) GoString() string {
	return s.String()
}

func (s *UpgradeCheckAppResponse) SetOption(v string) *UpgradeCheckAppResponse {
	s.Option = &v
	return s
}

func (s *UpgradeCheckAppResponse) SetReleaseDate(v string) *UpgradeCheckAppResponse {
	s.ReleaseDate = &v
	return s
}

func (s *UpgradeCheckAppResponse) SetReleaseNotesUrl(v string) *UpgradeCheckAppResponse {
	s.ReleaseNotesUrl = &v
	return s
}

func (s *UpgradeCheckAppResponse) SetUrl(v string) *UpgradeCheckAppResponse {
	s.Url = &v
	return s
}

func (s *UpgradeCheckAppResponse) SetVersion(v string) *UpgradeCheckAppResponse {
	s.Version = &v
	return s
}

/**
 *
 */
type ViewFileBaseRequest struct {
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty" require:"true"`
	DriveId  *string `json:"drive_id,omitempty" xml:"drive_id,omitempty"`
	// user_id
	UserId *string `json:"user_id,omitempty" xml:"user_id,omitempty"`
	// view_id
	ViewId *string `json:"view_id,omitempty" xml:"view_id,omitempty" require:"true"`
}

func (s ViewFileBaseRequest) String() string {
	return tea.Prettify(s)
}

func (s ViewFileBaseRequest) GoString() string {
	return s.String()
}

func (s *ViewFileBaseRequest) SetCategory(v string) *ViewFileBaseRequest {
	s.Category = &v
	return s
}

func (s *ViewFileBaseRequest) SetDriveId(v string) *ViewFileBaseRequest {
	s.DriveId = &v
	return s
}

func (s *ViewFileBaseRequest) SetUserId(v string) *ViewFileBaseRequest {
	s.UserId = &v
	return s
}

func (s *ViewFileBaseRequest) SetViewId(v string) *ViewFileBaseRequest {
	s.ViewId = &v
	return s
}

/**
 *
 */
type ViewFileItem struct {
	// action_list
	ActionList []*string `json:"action_list,omitempty" xml:"action_list,omitempty" type:"Repeated"`
	// auto_delete_left_sec
	AutoDeleteLeftSec *int64 `json:"auto_delete_left_sec,omitempty" xml:"auto_delete_left_sec,omitempty"`
	// category
	Category *string `json:"category,omitempty" xml:"category,omitempty"`
	// CharacteristicHash
	CharacteristicHash *string `json:"characteristic_hash,omitempty" xml:"characteristic_hash,omitempty"`
	// Content Hash
	ContentHash *string `json:"content_hash,omitempty" xml:"content_hash,omitempty"`
	// content_hash_name
	ContentHashName *string `json:"content_hash_name,omitempty" xml:"content_hash_name,omitempty"`
	// content_type
	ContentType *string `json:"content_type,omitempty" xml:"content_type,omitempty"`
	// crc64_hash
	Crc64Hash *string `json:"crc64_hash,omitempty" xml:"crc64_hash,omitempty"`
	// created_at
	CreatedAt *string `json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator_id
	CreatorId *string `json:"creator_id,omitempty" xml:"creator_id,omitempty"`
	// creator_name
	CreatorName *string `json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// creator_type
	CreatorType *string `json:"creator_type,omitempty" xml:"creator_type,omitempty"`
	// custom_field_1
	CustomField1 *string `json:"custom_field_1,omitempty" xml:"custom_field_1,omitempty"`
	// custom_field_2
	CustomField2 *string `json:"custom_field_2,omitempty" xml:"custom_field_2,omitempty"`
	// custom_type
	CustomType *string `json:"custom_type,omitempty" xml:"custom_type,omitempty"`
	// description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// DomainID
	DomainId *string `json:"domain_id,omitempty" xml:"domain_id,omitempty" pattern:"[a-z0-9A-Z]+"`
	// download_url
	DownloadUrl *string `json:"download_url,omitempty" xml:"download_url,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// encrypt_mode
	EncryptMode *string `json:"encrypt_mode,omitempty" xml:"encrypt_mode,omitempty"`
	// ex_fields_info
	ExFieldsInfo map[string]interface{} `json:"ex_fields_info,omitempty" xml:"ex_fields_info,omitempty"`
	Fields       map[string]interface{} `json:"fields,omitempty" xml:"fields,omitempty"`
	// file_extension
	FileExtension *string `json:"file_extension,omitempty" xml:"file_extension,omitempty"`
	// file_id
	FileId *string `json:"file_id,omitempty" xml:"file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// TODO APIfile_path_typeedmpath typePDS
	FilePathType   *string `json:"file_path_type,omitempty" xml:"file_path_type,omitempty"`
	FileRevisionId *string `json:"file_revision_id,omitempty" xml:"file_revision_id,omitempty"`
	// Hidden
	// type: boolean
	Hidden             *bool               `json:"hidden,omitempty" xml:"hidden,omitempty"`
	ImageMediaMetadata *ImageMediaResponse `json:"image_media_metadata,omitempty" xml:"image_media_metadata,omitempty"`
	JoinedAt           *int64              `json:"joined_at,omitempty" xml:"joined_at,omitempty"`
	// labels
	Labels []*string `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// last_modifier_id
	LastModifierId *string `json:"last_modifier_id,omitempty" xml:"last_modifier_id,omitempty"`
	// last_modifier_name
	LastModifierName *string `json:"last_modifier_name,omitempty" xml:"last_modifier_name,omitempty"`
	// last_modifier_type
	LastModifierType *string `json:"last_modifier_type,omitempty" xml:"last_modifier_type,omitempty"`
	// local_created_at
	LocalCreatedAt  *string `json:"local_created_at,omitempty" xml:"local_created_at,omitempty"`
	LocalModifiedAt *string `json:"local_modified_at,omitempty" xml:"local_modified_at,omitempty"`
	Meta            *string `json:"meta,omitempty" xml:"meta,omitempty"`
	// mime_extension
	MimeExtension *string `json:"mime_extension,omitempty" xml:"mime_extension,omitempty"`
	// mime_type
	MimeType *string `json:"mime_type,omitempty" xml:"mime_type,omitempty"`
	// name
	Name *string `json:"name,omitempty" xml:"name,omitempty" require:"true" pattern:"[a-zA-Z0-9.-]{1,1000}"`
	// parent_file_id
	ParentFileId *string `json:"parent_file_id,omitempty" xml:"parent_file_id,omitempty" maxLength:"50" minLength:"40" pattern:"[a-z0-9]{1,50}"`
	// PunishFlag
	PunishFlag *int64 `json:"punish_flag,omitempty" xml:"punish_flag,omitempty"`
	// revision_id
	RevisionId *string `json:"revision_id,omitempty" xml:"revision_id,omitempty"`
	ShareId    *string `json:"share_id,omitempty" xml:"share_id,omitempty"`
	// Size
	Size *int64 `json:"size,omitempty" xml:"size,omitempty" minimum:"0"`
	// starred
	// type: boolean
	Starred *bool `json:"starred,omitempty" xml:"starred,omitempty"`
	// status
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// @Deprecated streams url info
	StreamsInfo map[string]interface{} `json:"streams_info,omitempty" xml:"streams_info,omitempty"`
	// sync_device_flag
	SyncDeviceFlag *bool `json:"sync_device_flag,omitempty" xml:"sync_device_flag,omitempty"`
	// sync_flag
	SyncFlag *bool `json:"sync_flag,omitempty" xml:"sync_flag,omitempty"`
	// sync_meta
	SyncMeta *string `json:"sync_meta,omitempty" xml:"sync_meta,omitempty"`
	// thumbnail
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
	// trashed_at
	TrashedAt *string `json:"trashed_at,omitempty" xml:"trashed_at,omitempty"`
	// type
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// updated_at
	UpdatedAt *string `json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// upload_id
	UploadId *string `json:"upload_id,omitempty" xml:"upload_id,omitempty"`
	// url
	Url *string `json:"url,omitempty" xml:"url,omitempty"`
	// user_meta
	UserMeta *string `json:"user_meta,omitempty" xml:"user_meta,omitempty"`
	// user_tags
	UserTags             map[string]interface{} `json:"user_tags,omitempty" xml:"user_tags,omitempty"`
	VideoMediaMetadata   *VideoMediaResponse    `json:"video_media_metadata,omitempty" xml:"video_media_metadata,omitempty"`
	VideoPreviewMetadata *VideoPreviewResponse  `json:"video_preview_metadata,omitempty" xml:"video_preview_metadata,omitempty"`
	ViewId               *string                `json:"view_id,omitempty" xml:"view_id,omitempty"`
}

func (s ViewFileItem) String() string {
	return tea.Prettify(s)
}

func (s ViewFileItem) GoString() string {
	return s.String()
}

func (s *ViewFileItem) SetActionList(v []*string) *ViewFileItem {
	s.ActionList = v
	return s
}

func (s *ViewFileItem) SetAutoDeleteLeftSec(v int64) *ViewFileItem {
	s.AutoDeleteLeftSec = &v
	return s
}

func (s *ViewFileItem) SetCategory(v string) *ViewFileItem {
	s.Category = &v
	return s
}

func (s *ViewFileItem) SetCharacteristicHash(v string) *ViewFileItem {
	s.CharacteristicHash = &v
	return s
}

func (s *ViewFileItem) SetContentHash(v string) *ViewFileItem {
	s.ContentHash = &v
	return s
}

func (s *ViewFileItem) SetContentHashName(v string) *ViewFileItem {
	s.ContentHashName = &v
	return s
}

func (s *ViewFileItem) SetContentType(v string) *ViewFileItem {
	s.ContentType = &v
	return s
}

func (s *ViewFileItem) SetCrc64Hash(v string) *ViewFileItem {
	s.Crc64Hash = &v
	return s
}

func (s *ViewFileItem) SetCreatedAt(v string) *ViewFileItem {
	s.CreatedAt = &v
	return s
}

func (s *ViewFileItem) SetCreatorId(v string) *ViewFileItem {
	s.CreatorId = &v
	return s
}

func (s *ViewFileItem) SetCreatorName(v string) *ViewFileItem {
	s.CreatorName = &v
	return s
}

func (s *ViewFileItem) SetCreatorType(v string) *ViewFileItem {
	s.CreatorType = &v
	return s
}

func (s *ViewFileItem) SetCustomField1(v string) *ViewFileItem {
	s.CustomField1 = &v
	return s
}

func (s *ViewFileItem) SetCustomField2(v string) *ViewFileItem {
	s.CustomField2 = &v
	return s
}

func (s *ViewFileItem) SetCustomType(v string) *ViewFileItem {
	s.CustomType = &v
	return s
}

func (s *ViewFileItem) SetDescription(v string) *ViewFileItem {
	s.Description = &v
	return s
}

func (s *ViewFileItem) SetDomainId(v string) *ViewFileItem {
	s.DomainId = &v
	return s
}

func (s *ViewFileItem) SetDownloadUrl(v string) *ViewFileItem {
	s.DownloadUrl = &v
	return s
}

func (s *ViewFileItem) SetDriveId(v string) *ViewFileItem {
	s.DriveId = &v
	return s
}

func (s *ViewFileItem) SetEncryptMode(v string) *ViewFileItem {
	s.EncryptMode = &v
	return s
}

func (s *ViewFileItem) SetExFieldsInfo(v map[string]interface{}) *ViewFileItem {
	s.ExFieldsInfo = v
	return s
}

func (s *ViewFileItem) SetFields(v map[string]interface{}) *ViewFileItem {
	s.Fields = v
	return s
}

func (s *ViewFileItem) SetFileExtension(v string) *ViewFileItem {
	s.FileExtension = &v
	return s
}

func (s *ViewFileItem) SetFileId(v string) *ViewFileItem {
	s.FileId = &v
	return s
}

func (s *ViewFileItem) SetFilePathType(v string) *ViewFileItem {
	s.FilePathType = &v
	return s
}

func (s *ViewFileItem) SetFileRevisionId(v string) *ViewFileItem {
	s.FileRevisionId = &v
	return s
}

func (s *ViewFileItem) SetHidden(v bool) *ViewFileItem {
	s.Hidden = &v
	return s
}

func (s *ViewFileItem) SetImageMediaMetadata(v *ImageMediaResponse) *ViewFileItem {
	s.ImageMediaMetadata = v
	return s
}

func (s *ViewFileItem) SetJoinedAt(v int64) *ViewFileItem {
	s.JoinedAt = &v
	return s
}

func (s *ViewFileItem) SetLabels(v []*string) *ViewFileItem {
	s.Labels = v
	return s
}

func (s *ViewFileItem) SetLastModifierId(v string) *ViewFileItem {
	s.LastModifierId = &v
	return s
}

func (s *ViewFileItem) SetLastModifierName(v string) *ViewFileItem {
	s.LastModifierName = &v
	return s
}

func (s *ViewFileItem) SetLastModifierType(v string) *ViewFileItem {
	s.LastModifierType = &v
	return s
}

func (s *ViewFileItem) SetLocalCreatedAt(v string) *ViewFileItem {
	s.LocalCreatedAt = &v
	return s
}

func (s *ViewFileItem) SetLocalModifiedAt(v string) *ViewFileItem {
	s.LocalModifiedAt = &v
	return s
}

func (s *ViewFileItem) SetMeta(v string) *ViewFileItem {
	s.Meta = &v
	return s
}

func (s *ViewFileItem) SetMimeExtension(v string) *ViewFileItem {
	s.MimeExtension = &v
	return s
}

func (s *ViewFileItem) SetMimeType(v string) *ViewFileItem {
	s.MimeType = &v
	return s
}

func (s *ViewFileItem) SetName(v string) *ViewFileItem {
	s.Name = &v
	return s
}

func (s *ViewFileItem) SetParentFileId(v string) *ViewFileItem {
	s.ParentFileId = &v
	return s
}

func (s *ViewFileItem) SetPunishFlag(v int64) *ViewFileItem {
	s.PunishFlag = &v
	return s
}

func (s *ViewFileItem) SetRevisionId(v string) *ViewFileItem {
	s.RevisionId = &v
	return s
}

func (s *ViewFileItem) SetShareId(v string) *ViewFileItem {
	s.ShareId = &v
	return s
}

func (s *ViewFileItem) SetSize(v int64) *ViewFileItem {
	s.Size = &v
	return s
}

func (s *ViewFileItem) SetStarred(v bool) *ViewFileItem {
	s.Starred = &v
	return s
}

func (s *ViewFileItem) SetStatus(v string) *ViewFileItem {
	s.Status = &v
	return s
}

func (s *ViewFileItem) SetStreamsInfo(v map[string]interface{}) *ViewFileItem {
	s.StreamsInfo = v
	return s
}

func (s *ViewFileItem) SetSyncDeviceFlag(v bool) *ViewFileItem {
	s.SyncDeviceFlag = &v
	return s
}

func (s *ViewFileItem) SetSyncFlag(v bool) *ViewFileItem {
	s.SyncFlag = &v
	return s
}

func (s *ViewFileItem) SetSyncMeta(v string) *ViewFileItem {
	s.SyncMeta = &v
	return s
}

func (s *ViewFileItem) SetThumbnail(v string) *ViewFileItem {
	s.Thumbnail = &v
	return s
}

func (s *ViewFileItem) SetTrashedAt(v string) *ViewFileItem {
	s.TrashedAt = &v
	return s
}

func (s *ViewFileItem) SetType(v string) *ViewFileItem {
	s.Type = &v
	return s
}

func (s *ViewFileItem) SetUpdatedAt(v string) *ViewFileItem {
	s.UpdatedAt = &v
	return s
}

func (s *ViewFileItem) SetUploadId(v string) *ViewFileItem {
	s.UploadId = &v
	return s
}

func (s *ViewFileItem) SetUrl(v string) *ViewFileItem {
	s.Url = &v
	return s
}

func (s *ViewFileItem) SetUserMeta(v string) *ViewFileItem {
	s.UserMeta = &v
	return s
}

func (s *ViewFileItem) SetUserTags(v map[string]interface{}) *ViewFileItem {
	s.UserTags = v
	return s
}

func (s *ViewFileItem) SetVideoMediaMetadata(v *VideoMediaResponse) *ViewFileItem {
	s.VideoMediaMetadata = v
	return s
}

func (s *ViewFileItem) SetVideoPreviewMetadata(v *VideoPreviewResponse) *ViewFileItem {
	s.VideoPreviewMetadata = v
	return s
}

func (s *ViewFileItem) SetViewId(v string) *ViewFileItem {
	s.ViewId = &v
	return s
}

/**
 * DomainSummaryResponse
 */
type DomainSummaryResponse struct {
	// drive_count
	DriveCount *int64 `json:"drive_count,omitempty" xml:"drive_count,omitempty"`
	// file_count
	FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
	// state
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// statistics_time
	StatisticsTime *int64 `json:"statistics_time,omitempty" xml:"statistics_time,omitempty"`
	// used_size
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// user_count
	UserCount *int64 `json:"user_count,omitempty" xml:"user_count,omitempty"`
}

func (s DomainSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DomainSummaryResponse) GoString() string {
	return s.String()
}

func (s *DomainSummaryResponse) SetDriveCount(v int64) *DomainSummaryResponse {
	s.DriveCount = &v
	return s
}

func (s *DomainSummaryResponse) SetFileCount(v int64) *DomainSummaryResponse {
	s.FileCount = &v
	return s
}

func (s *DomainSummaryResponse) SetState(v string) *DomainSummaryResponse {
	s.State = &v
	return s
}

func (s *DomainSummaryResponse) SetStatisticsTime(v int64) *DomainSummaryResponse {
	s.StatisticsTime = &v
	return s
}

func (s *DomainSummaryResponse) SetUsedSize(v int64) *DomainSummaryResponse {
	s.UsedSize = &v
	return s
}

func (s *DomainSummaryResponse) SetUserCount(v int64) *DomainSummaryResponse {
	s.UserCount = &v
	return s
}

/**
 *  domain 
 */
type GetDomainSummaryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
}

func (s GetDomainSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDomainSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetDomainSummaryRequest) SetHttpheaders(v map[string]*string) *GetDomainSummaryRequest {
	s.Httpheaders = v
	return s
}

/**
 *  Drive 
 */
type GetDriveUsedSizeRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" require:"true" pattern:"[0-9]+"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetDriveUsedSizeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDriveUsedSizeRequest) GoString() string {
	return s.String()
}

func (s *GetDriveUsedSizeRequest) SetHttpheaders(v map[string]*string) *GetDriveUsedSizeRequest {
	s.Httpheaders = v
	return s
}

func (s *GetDriveUsedSizeRequest) SetDriveId(v string) *GetDriveUsedSizeRequest {
	s.DriveId = &v
	return s
}

func (s *GetDriveUsedSizeRequest) SetSubdomainId(v string) *GetDriveUsedSizeRequest {
	s.SubdomainId = &v
	return s
}

/**
 * GetDriveUsedSizeResponse
 */
type GetDriveUsedSizeResponse struct {
	// used_size
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
}

func (s GetDriveUsedSizeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDriveUsedSizeResponse) GoString() string {
	return s.String()
}

func (s *GetDriveUsedSizeResponse) SetUsedSize(v int64) *GetDriveUsedSizeResponse {
	s.UsedSize = &v
	return s
}

/**
 *  Domain  Drive 
 */
type GetFileCountRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// drive_id
	DriveId *string `json:"drive_id,omitempty" xml:"drive_id,omitempty" pattern:"[0-9]+"`
	// file_ext
	FileExt *string `json:"file_ext,omitempty" xml:"file_ext,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetFileCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileCountRequest) GoString() string {
	return s.String()
}

func (s *GetFileCountRequest) SetHttpheaders(v map[string]*string) *GetFileCountRequest {
	s.Httpheaders = v
	return s
}

func (s *GetFileCountRequest) SetDriveId(v string) *GetFileCountRequest {
	s.DriveId = &v
	return s
}

func (s *GetFileCountRequest) SetFileExt(v string) *GetFileCountRequest {
	s.FileExt = &v
	return s
}

func (s *GetFileCountRequest) SetSubdomainId(v string) *GetFileCountRequest {
	s.SubdomainId = &v
	return s
}

/**
 * GetFileCountResponse
 */
type GetFileCountResponse struct {
	// file_count
	FileCount *int64 `json:"file_count,omitempty" xml:"file_count,omitempty"`
}

func (s GetFileCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileCountResponse) GoString() string {
	return s.String()
}

func (s *GetFileCountResponse) SetFileCount(v int64) *GetFileCountResponse {
	s.FileCount = &v
	return s
}

/**
 *  subdomain 
 */
type GetSubdomainSummaryRequest struct {
	Httpheaders map[string]*string `json:"httpheaders,omitempty" xml:"httpheaders,omitempty"`
	// subdomain
	SubdomainId *string `json:"subdomain_id,omitempty" xml:"subdomain_id,omitempty"`
}

func (s GetSubdomainSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSubdomainSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetSubdomainSummaryRequest) SetHttpheaders(v map[string]*string) *GetSubdomainSummaryRequest {
	s.Httpheaders = v
	return s
}

func (s *GetSubdomainSummaryRequest) SetSubdomainId(v string) *GetSubdomainSummaryRequest {
	s.SubdomainId = &v
	return s
}

/**
 * SubdomainSummaryResponse
 */
type SubdomainSummaryResponse struct {
	// drive_count
	DriveCount *int64 `json:"drive_count,omitempty" xml:"drive_count,omitempty"`
	// state
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// statistics_time
	StatisticsTime *int64 `json:"statistics_time,omitempty" xml:"statistics_time,omitempty"`
	// used_size
	UsedSize *int64 `json:"used_size,omitempty" xml:"used_size,omitempty"`
	// user_count
	UserCount *int64 `json:"user_count,omitempty" xml:"user_count,omitempty"`
}

func (s SubdomainSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s SubdomainSummaryResponse) GoString() string {
	return s.String()
}

func (s *SubdomainSummaryResponse) SetDriveCount(v int64) *SubdomainSummaryResponse {
	s.DriveCount = &v
	return s
}

func (s *SubdomainSummaryResponse) SetState(v string) *SubdomainSummaryResponse {
	s.State = &v
	return s
}

func (s *SubdomainSummaryResponse) SetStatisticsTime(v int64) *SubdomainSummaryResponse {
	s.StatisticsTime = &v
	return s
}

func (s *SubdomainSummaryResponse) SetUsedSize(v int64) *SubdomainSummaryResponse {
	s.UsedSize = &v
	return s
}

func (s *SubdomainSummaryResponse) SetUserCount(v int64) *SubdomainSummaryResponse {
	s.UserCount = &v
	return s
}

type Client struct {
	DomainId              *string
	AccessTokenCredential *accesstokencredential.AccessTokenCredential
	Endpoint              *string
	Protocol              *string
	Nickname              *string
	UserAgent             *string
	Credential            credential.Credential
}

func NewClient(config *Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *Config) (_err error) {
	if tea.BoolValue(util.IsUnset(tea.ToMap(config))) {
		_err = tea.NewSDKError(map[string]interface{}{
			"name":    "ParameterMissing",
			"message": "'config' can not be unset",
		})
		return _err
	}

	_err = util.ValidateModel(config)
	if _err != nil {
		return _err
	}
	if !tea.BoolValue(util.Empty(config.AccessToken)) || !tea.BoolValue(util.Empty(config.RefreshToken)) {
		accessConfig := &accesstokencredential.Config{
			AccessToken:  config.AccessToken,
			Endpoint:     config.Endpoint,
			DomainId:     config.DomainId,
			ClientId:     config.ClientId,
			RefreshToken: config.RefreshToken,
			ClientSecret: config.ClientSecret,
			ExpireTime:   config.ExpireTime,
		}
		client.AccessTokenCredential, _err = accesstokencredential.NewAccessTokenCredential(accessConfig)
		if _err != nil {
			return _err
		}

	}

	if !tea.BoolValue(util.Empty(config.AccessKeyId)) {
		if tea.BoolValue(util.Empty(config.Type)) {
			config.Type = tea.String("access_key")
		}

		credentialConfig := &credential.Config{
			AccessKeyId:     config.AccessKeyId,
			Type:            config.Type,
			AccessKeySecret: config.AccessKeySecret,
			SecurityToken:   config.SecurityToken,
		}
		client.Credential, _err = credential.NewCredential(credentialConfig)
		if _err != nil {
			return _err
		}

	}

	client.Endpoint = config.Endpoint
	client.Protocol = config.Protocol
	client.UserAgent = config.UserAgent
	client.Nickname = config.Nickname
	client.DomainId = config.DomainId
	return nil
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CancelLinkEx(request *CancelLinkRequest, runtime *RuntimeOptions) (_result *CancelLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CancelLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CancelLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/cancel_link"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CancelLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CheckExistEx(request *CheckExistRequest, runtime *RuntimeOptions) (_result *CheckExistModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CheckExistModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CheckExistModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/check_exist"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CheckExistModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * , 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ConfirmLinkEx(request *ConfirmLinkRequest, runtime *RuntimeOptions) (_result *ConfirmLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ConfirmLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ConfirmLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/confirm_link"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ConfirmLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * statestate
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) VerifyCodeEx(request *VerifyCodeRequest, runtime *RuntimeOptions) (_result *VerifyCodeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &VerifyCodeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*VerifyCodeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/default/verify_code"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &VerifyCodeModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetAccessTokenByLinkInfoEx(request *GetAccessTokenByLinkInfoRequest, runtime *RuntimeOptions) (_result *GetAccessTokenByLinkInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetAccessTokenByLinkInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetAccessTokenByLinkInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_access_token_by_link_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetAccessTokenByLinkInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoEx(request *GetByLinkInfoRequest, runtime *RuntimeOptions) (_result *GetLinkInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetLinkInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetLinkInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_link_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetLinkInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoByUserIdEx(request *GetLinkInfoByUserIDRequest, runtime *RuntimeOptions) (_result *GetLinkInfoByUserIdModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetLinkInfoByUserIdModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetLinkInfoByUserIdModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_link_info_by_user_id"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetLinkInfoByUserIdModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetPublicKeyEx(request *GetPublicKeyRequest, runtime *RuntimeOptions) (_result *GetPublicKeyModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetPublicKeyModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetPublicKeyModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/get_public_key"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetPublicKeyModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) LinkEx(request *AccountLinkRequest, runtime *RuntimeOptions) (_result *LinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &LinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*LinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/link"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &LinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) LoginEx(request *LoginRequest, runtime *RuntimeOptions) (_result *LoginModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &LoginModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*LoginModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/login"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &LoginModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) RegisterEx(request *RegisterRequest, runtime *RuntimeOptions) (_result *RegisterModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RegisterModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RegisterModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/register"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &RegisterModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountRevokeEx(request *RevokeRequest, runtime *RuntimeOptions) (_result *AccountRevokeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AccountRevokeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AccountRevokeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/revoke"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &AccountRevokeModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SendSmsCodeEx(request *SendSmsCodeRequest, runtime *RuntimeOptions) (_result *SendSmsCodeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SendSmsCodeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SendSmsCodeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/send_sms_code"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SendSmsCodeModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * refresh_tokenaccess_token
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountTokenEx(request *AccountTokenRequest, runtime *RuntimeOptions) (_result *AccountTokenModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AccountTokenModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AccountTokenModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/account/token"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".auth.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &AccountTokenModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * export audit log
 * @tags audit_log
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ExportAuditLogEx(request *ExportAuditLogRequest, runtime *RuntimeOptions) (_result *ExportAuditLogModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ExportAuditLogModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ExportAuditLogModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/audit_log/export"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ExportAuditLogModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * search audit log
 * @tags audit_log
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SearchAuditLogEx(request *SearchAuditLogRequest, runtime *RuntimeOptions) (_result *SearchAuditLogModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchAuditLogModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchAuditLogModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/audit_log/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchAuditLogModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateIdentityToBenefitPkgMappingEx(request *CreateIdentityToBenefitPkgMappingRequest, runtime *RuntimeOptions) (_result *CreateIdentityToBenefitPkgMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateIdentityToBenefitPkgMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateIdentityToBenefitPkgMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/identity_to_benefit_pkg_mapping/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateIdentityToBenefitPkgMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteIdentityToBenefitPkgMappingEx(request *DeleteIdentityToBenefitPkgMappingRequest, runtime *RuntimeOptions) (_result *DeleteIdentityToBenefitPkgMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteIdentityToBenefitPkgMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteIdentityToBenefitPkgMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/identity_to_benefit_pkg_mapping/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &DeleteIdentityToBenefitPkgMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetIdentityToBenefitPkgMappingEx(request *GetIdentityToBenefitPkgMappingRequest, runtime *RuntimeOptions) (_result *GetIdentityToBenefitPkgMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetIdentityToBenefitPkgMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetIdentityToBenefitPkgMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/identity_to_benefit_pkg_mapping/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetIdentityToBenefitPkgMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityToBenefitPkgMappingEx(request *ListIdentityToBenefitPkgMappingRequest, runtime *RuntimeOptions) (_result *ListIdentityToBenefitPkgMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListIdentityToBenefitPkgMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListIdentityToBenefitPkgMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/identity_to_benefit_pkg_mapping/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListIdentityToBenefitPkgMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateIdentityToBenefitPkgMappingEx(request *UpdateIdentityToBenefitPkgMappingRequest, runtime *RuntimeOptions) (_result *UpdateIdentityToBenefitPkgMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateIdentityToBenefitPkgMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateIdentityToBenefitPkgMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/identity_to_benefit_pkg_mapping/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateIdentityToBenefitPkgMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityBenefitPkgEx(request *ListIdentityBenefitPkgRequest, runtime *RuntimeOptions) (_result *ListIdentityBenefitPkgModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListIdentityBenefitPkgModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListIdentityBenefitPkgModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/benefit/list_identity_benefit_pkg"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListIdentityBenefitPkgModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Store
 * @tags admin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AdminListStoresEx(request *AdminListStoresRequest, runtime *RuntimeOptions) (_result *AdminListStoresModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AdminListStoresModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AdminListStoresModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/domain/list_stores"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &AdminListStoresModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * create subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CreateSubdomainEx(request *CreateSubdomainRequest, runtime *RuntimeOptions) (_result *CreateSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * delete subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) DeleteSubdomainEx(request *DeleteSubdomainRequest, runtime *RuntimeOptions) (_result *DeleteSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &DeleteSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * get subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetSubdomainEx(request *GetSubdomainRequest, runtime *RuntimeOptions) (_result *GetSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * list subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListSubdomainsEx(request *ListSubdomainsRequest, runtime *RuntimeOptions) (_result *ListSubdomainsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListSubdomainsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListSubdomainsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListSubdomainsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * update subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) UpdateSubdomainEx(request *UpdateSubdomainRequest, runtime *RuntimeOptions) (_result *UpdateSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/subdomain/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * accessToken
 * @tags admin
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 */
func (client *Client) GetUserAccessTokenEx(request *GetUserAccessTokenRequest, runtime *RuntimeOptions) (_result *GetUserAccessTokenModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetUserAccessTokenModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetUserAccessTokenModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/get_access_token"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetUserAccessTokenModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  ID
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) PunishFileEx(request *PunishFileRequest, runtime *RuntimeOptions) (_result *PunishFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &PunishFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*PunishFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/csi/business/punish_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &PunishFileModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * id
 * 
 * @tags async_task
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAsyncTaskInfoEx(request *GetAsyncTaskRequest, runtime *RuntimeOptions) (_result *GetAsyncTaskInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetAsyncTaskInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetAsyncTaskInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/async_task/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetAsyncTaskInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * 100
 * @tags batch
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BatchOperationEx(request *BatchRequest, runtime *RuntimeOptions) (_result *BatchOperationModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &BatchOperationModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*BatchOperationModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/batch"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &BatchOperationModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * normallargedrive
 * largedrivelist
 * drive1large
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateDriveEx(request *CreateDriveRequest, runtime *RuntimeOptions) (_result *CreateDriveModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateDriveModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateDriveModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateDriveModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteDriveEx(request *DeleteDriveRequest, runtime *RuntimeOptions) (_result *DeleteDriveModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteDriveModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteDriveModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteDriveModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDriveEx(request *GetDriveRequest, runtime *RuntimeOptions) (_result *GetDriveModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetDriveModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetDriveModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDriveModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drivedrivedrive
 * drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDefaultDriveEx(request *GetDefaultDriveRequest, runtime *RuntimeOptions) (_result *GetDefaultDriveModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetDefaultDriveModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetDefaultDriveModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/get_default_drive"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDefaultDriveModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDrivesEx(request *ListDriveRequest, runtime *RuntimeOptions) (_result *ListDrivesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListDrivesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListDrivesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListDrivesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListMyDrivesEx(request *ListMyDriveRequest, runtime *RuntimeOptions) (_result *ListMyDrivesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListMyDrivesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListMyDrivesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/list_my_drives"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListMyDrivesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchDrivesEx(request *SearchDriveRequest, runtime *RuntimeOptions) (_result *SearchDrivesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchDrivesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchDrivesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchDrivesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateDriveEx(request *UpdateDriveRequest, runtime *RuntimeOptions) (_result *UpdateDriveModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateDriveModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateDriveModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/drive/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateDriveModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddPermissionEx(request *FileAddPermissionRequest, runtime *RuntimeOptions) (_result *AddPermissionModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AddPermissionModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AddPermissionModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/add_permission"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &AddPermissionModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * archive_files
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ArchiveFilesEx(request *CCPArchiveFilesRequest, runtime *RuntimeOptions) (_result *ArchiveFilesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ArchiveFilesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ArchiveFilesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/archive_files"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ArchiveFilesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFileEx(request *CompleteFileRequest, runtime *RuntimeOptions) (_result *CompleteFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CompleteFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CompleteFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/complete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CompleteFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * UCCompleteFileRequest
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFileWithStoreInfoEx(request *UCCompleteFileRequest, runtime *RuntimeOptions) (_result *CompleteFileWithStoreInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CompleteFileWithStoreInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CompleteFileWithStoreInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/complete_with_store_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CompleteFileWithStoreInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFileEx(request *CopyFileRequest, runtime *RuntimeOptions) (_result *CopyFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CopyFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CopyFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/copy"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CopyFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CopyFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileEx(request *CreateFileRequest, runtime *RuntimeOptions) (_result *CreateFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithProofEx(request *CreateFileRequest, runtime *RuntimeOptions) (_result *CreateFileWithProofModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateFileWithProofModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateFileWithProofModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/create_with_proof"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateFileWithProofModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * CreateFileWithSignature
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithSignatureEx(request *UCCreateFileRequest, runtime *RuntimeOptions) (_result *CreateFileWithSignatureModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateFileWithSignatureModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateFileWithSignatureModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/create_with_signature"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateFileWithSignatureModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteFileEx(request *DeleteFileRequest, runtime *RuntimeOptions) (_result *DeleteFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &DeleteFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteFileModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  user tags
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUsertagsEx(request *DeleteFileUserTagsRequest, runtime *RuntimeOptions) (_result *DeleteUsertagsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteUsertagsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteUsertagsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/delete_usertags"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteUsertagsModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileEx(request *GetFileRequest, runtime *RuntimeOptions) (_result *GetFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileByPathEx(request *GetFileByPathRequest, runtime *RuntimeOptions) (_result *GetFileByPathModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetFileByPathModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetFileByPathModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_by_path"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetFileByPathModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDownloadUrlEx(request *GetDownloadUrlRequest, runtime *RuntimeOptions) (_result *GetDownloadUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetDownloadUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetDownloadUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_download_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDownloadUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetLastCursorEx(request *GetLastCursorRequest, runtime *RuntimeOptions) (_result *GetLastCursorModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetLastCursorModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetLastCursorModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_last_cursor"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetLastCursorModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * mediaURLm3u8
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMediaPlayUrlEx(request *GetMediaPlayURLRequest, runtime *RuntimeOptions) (_result *GetMediaPlayUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetMediaPlayUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetMediaPlayUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_media_play_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetMediaPlayUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficeEditUrlEx(request *GetOfficeEditUrlRequest, runtime *RuntimeOptions) (_result *GetOfficeEditUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetOfficeEditUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetOfficeEditUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_office_edit_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetOfficeEditUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * office
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficePreviewUrlEx(request *GetOfficePreviewUrlRequest, runtime *RuntimeOptions) (_result *GetOfficePreviewUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetOfficePreviewUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetOfficePreviewUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_office_preview_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetOfficePreviewUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkDownloadUrlEx(request *GetShareLinkDownloadURLRequest, runtime *RuntimeOptions) (_result *GetShareLinkDownloadUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareLinkDownloadUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareLinkDownloadUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_share_link_download_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareLinkDownloadUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkVideoPreviewPlayInfoEx(request *CCPGetShareLinkVideoPreviewPlayInfoRequest, runtime *RuntimeOptions) (_result *GetShareLinkVideoPreviewPlayInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareLinkVideoPreviewPlayInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareLinkVideoPreviewPlayInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_share_link_video_preview_play_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareLinkVideoPreviewPlayInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * GetFileSignature
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileSignatureEx(request *UCFileGetSignatureRequest, runtime *RuntimeOptions) (_result *GetFileSignatureModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetFileSignatureModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetFileSignatureModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_signature"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetFileSignatureModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUploadUrlEx(request *GetUploadUrlRequest, runtime *RuntimeOptions) (_result *GetUploadUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetUploadUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetUploadUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_upload_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetUploadUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewPlayInfoEx(request *CCPGetVideoPreviewPlayInfoRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewPlayInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetVideoPreviewPlayInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetVideoPreviewPlayInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_play_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetVideoPreviewPlayInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewSpriteUrlEx(request *GetVideoPreviewSpriteURLRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewSpriteUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetVideoPreviewSpriteUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetVideoPreviewSpriteUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_sprite_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetVideoPreviewSpriteUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewUrlEx(request *GetVideoPreviewURLRequest, runtime *RuntimeOptions) (_result *GetVideoPreviewUrlModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetVideoPreviewUrlModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetVideoPreviewUrlModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/get_video_preview_url"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetVideoPreviewUrlModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileEx(request *ListFileRequest, runtime *RuntimeOptions) (_result *ListFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * list file activity
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileActivityEx(request *ListFileActivityRequest, runtime *RuntimeOptions) (_result *ListFileActivityModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileActivityModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileActivityModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_activity"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileActivityModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ShareLinkTokenInvalid ShareToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByAnonymousEx(request *ListByAnonymousRequest, runtime *RuntimeOptions) (_result *ListFileByAnonymousModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileByAnonymousModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileByAnonymousModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_by_anonymous"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileByAnonymousModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByCustomIndexKeyEx(request *ListFileByCustomIndexKeyRequest, runtime *RuntimeOptions) (_result *ListFileByCustomIndexKeyModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileByCustomIndexKeyModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileByCustomIndexKeyModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_by_custom_index_key"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileByCustomIndexKeyModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileDeltaEx(request *ListFileDeltaRequest, runtime *RuntimeOptions) (_result *ListFileDeltaModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileDeltaModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileDeltaModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_delta"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileDeltaModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListInheritPermissionEx(request *FileListInheritPermissionRequest, runtime *RuntimeOptions) (_result *ListInheritPermissionModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListInheritPermissionModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListInheritPermissionModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_inherit_permission"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListInheritPermissionModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListManageSharingFileEx(request *ListMangeSharingFileRequest, runtime *RuntimeOptions) (_result *ListManageSharingFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListManageSharingFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListManageSharingFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_manage_sharing_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListManageSharingFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListPermissionEx(request *FileListPermissionRequest, runtime *RuntimeOptions) (_result *ListPermissionModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListPermissionModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListPermissionModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_permission"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListPermissionModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListReceivedFileEx(request *ListReceivedFileRequest, runtime *RuntimeOptions) (_result *ListReceivedFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListReceivedFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListReceivedFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_received_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListReceivedFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListSharingFileEx(request *ListSharingFileRequest, runtime *RuntimeOptions) (_result *ListSharingFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListSharingFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListSharingFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_sharing_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListSharingFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * upload_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUploadedPartsEx(request *ListUploadedPartRequest, runtime *RuntimeOptions) (_result *ListUploadedPartsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListUploadedPartsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListUploadedPartsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_uploaded_parts"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListUploadedPartsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUserPermissionEx(request *FileListUserPermissionRequest, runtime *RuntimeOptions) (_result *ListUserPermissionModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListUserPermissionModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListUserPermissionModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/list_user_permission"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListUserPermissionModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * live_transcode
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) LiveTranscodeEx(request *CCPLiveTranscodeRequest, runtime *RuntimeOptions) (_result *LiveTranscodeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &LiveTranscodeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*LiveTranscodeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/live_transcode"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &LiveTranscodeModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MoveFileEx(request *MoveFileRequest, runtime *RuntimeOptions) (_result *MoveFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &MoveFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*MoveFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/move"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &MoveFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  user tags
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) PutUsertagsEx(request *PutFileUserTagsRequest, runtime *RuntimeOptions) (_result *PutUsertagsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &PutUsertagsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*PutUsertagsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/put_usertags"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &PutUsertagsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Token
 * @tags file, refresh, office, edit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TokenEx(request *RefreshOfficeEditTokenRequest, runtime *RuntimeOptions) (_result *TokenModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &TokenModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*TokenModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/refresh_office_edit_token"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &TokenModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemovePermissionEx(request *FileRemovePermissionRequest, runtime *RuntimeOptions) (_result *RemovePermissionModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RemovePermissionModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RemovePermissionModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/remove_permission"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &RemovePermissionModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ScanFileMetaEx(request *ScanFileMetaRequest, runtime *RuntimeOptions) (_result *ScanFileMetaModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ScanFileMetaModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ScanFileMetaModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/scan"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ScanFileMetaModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFileEx(request *SearchFileRequest, runtime *RuntimeOptions) (_result *SearchFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFileFpRefsEx(request *SearchFileFpRefsRequest, runtime *RuntimeOptions) (_result *SearchFileFpRefsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchFileFpRefsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchFileFpRefsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/search_file_fp_refs"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchFileFpRefsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFileEx(request *UpdateFileMetaRequest, runtime *RuntimeOptions) (_result *UpdateFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * UpdateFileUploadContentHash
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFileUploadContentHashEx(request *UCUpdateUploadContentHashRequest, runtime *RuntimeOptions) (_result *UpdateFileUploadContentHashModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateFileUploadContentHashModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateFileUploadContentHashModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/update_upload_content_hash"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateFileUploadContentHashModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * walk file
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) WalkFileEx(request *CCPWalkFileRequest, runtime *RuntimeOptions) (_result *WalkFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &WalkFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*WalkFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/file/walk"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &WalkFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * clear_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ClearRecyclebinEx(request *ClearRecycleBinRequest, runtime *RuntimeOptions) (_result *ClearRecyclebinModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ClearRecyclebinModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ClearRecyclebinModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/clear"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ClearRecyclebinModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * list_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListRecyclebinEx(request *ListFileInRecycleBinRequest, runtime *RuntimeOptions) (_result *ListRecyclebinModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListRecyclebinModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListRecyclebinModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListRecyclebinModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * restore_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RestoreFileEx(request *RestoreFileRequest, runtime *RuntimeOptions) (_result *RestoreFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RestoreFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RestoreFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/restore"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &RestoreFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &RestoreFileModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * trash_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TrashFileEx(request *TrashFileRequest, runtime *RuntimeOptions) (_result *TrashFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &TrashFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*TrashFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/recyclebin/trash"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &TrashFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &TrashFileModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ReportEventEx(request *ReportEventRequest, runtime *RuntimeOptions) (_result *ReportEventModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ReportEventModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ReportEventModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/report_event"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ReportEventModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareEx(request *CreateShareRequest, runtime *RuntimeOptions) (_result *CreateShareModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateShareModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateShareModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateShareModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteShareEx(request *DeleteShareRequest, runtime *RuntimeOptions) (_result *DeleteShareModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteShareModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteShareModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteShareModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareEx(request *GetShareRequest, runtime *RuntimeOptions) (_result *GetShareModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareEx(request *ListShareRequest, runtime *RuntimeOptions) (_result *ListShareModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListShareModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListShareModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListShareModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareEx(request *UpdateShareRequest, runtime *RuntimeOptions) (_result *UpdateShareModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateShareModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateShareModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateShareModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelShareLinkEx(request *CancelShareLinkRequest, runtime *RuntimeOptions) (_result *CancelShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CancelShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CancelShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/cancel"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &CancelShareLinkModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareLinkEx(request *CreateShareLinkRequest, runtime *RuntimeOptions) (_result *CreateShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateShareLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkEx(request *GetShareLinkRequest, runtime *RuntimeOptions) (_result *GetShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareByAnonymousEx(request *GetShareLinkByAnonymousRequest, runtime *RuntimeOptions) (_result *GetShareByAnonymousModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareByAnonymousModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareByAnonymousModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_by_anonymous"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareByAnonymousModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * id
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareIdEx(request *GetShareLinkIDRequest, runtime *RuntimeOptions) (_result *GetShareIdModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareIdModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareIdModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_share_id"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareIdModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * +token
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareTokenEx(request *GetShareLinkTokenRequest, runtime *RuntimeOptions) (_result *GetShareTokenModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetShareTokenModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetShareTokenModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/get_share_token"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetShareTokenModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareLinkEx(request *ListShareLinkRequest, runtime *RuntimeOptions) (_result *ListShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListShareLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchShareLinkEx(request *SearchShareLinkRequest, runtime *RuntimeOptions) (_result *SearchShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchShareLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareLinkEx(request *UpdateShareLinkRequest, runtime *RuntimeOptions) (_result *UpdateShareLinkModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateShareLinkModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateShareLinkModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/share_link/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateShareLinkModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AssignEx(request *AssignRequest, runtime *RuntimeOptions) (_result *AssignModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AssignModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AssignModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/role/assign"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &AssignModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelAssignEx(request *CancelAssignRequest, runtime *RuntimeOptions) (_result *CancelAssignModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CancelAssignModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CancelAssignModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/role/cancel_assign"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &CancelAssignModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityRoleEx(request *ListIdentityRoleRequest, runtime *RuntimeOptions) (_result *ListIdentityRoleModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListIdentityRoleModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListIdentityRoleModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/role/list_identity_role"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListIdentityRoleModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  Drive 
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDriveUsedSizeEx(request *GetDriveUsedSizeRequest, runtime *RuntimeOptions) (_result *GetDriveUsedSizeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetDriveUsedSizeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetDriveUsedSizeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/statistics/drive_used_size"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String("localhost")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDriveUsedSizeModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  Domain  Drive 
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileCountEx(request *GetFileCountRequest, runtime *RuntimeOptions) (_result *GetFileCountModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetFileCountModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetFileCountModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/statistics/file_count"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String("localhost")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetFileCountModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  Subdomain summary
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetSubdomainSummaryEx(request *GetSubdomainSummaryRequest, runtime *RuntimeOptions) (_result *GetSubdomainSummaryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetSubdomainSummaryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetSubdomainSummaryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/statistics/subdomain_summary"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String("localhost")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetSubdomainSummaryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetSubdomainSummaryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 *  Domain summary
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDomainSummaryEx(request *GetDomainSummaryRequest, runtime *RuntimeOptions) (_result *GetDomainSummaryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetDomainSummaryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetDomainSummaryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/statistics/summary"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String("localhost")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDomainSummaryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetDomainSummaryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * GetAppDebugCmd
 * @tags app
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAppDebugCmdEx(request *GetAppDebugCmdRequest, runtime *RuntimeOptions) (_result *GetAppDebugCmdModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetAppDebugCmdModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetAppDebugCmdModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/app/get_debug_cmd"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetAppDebugCmdModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * UpgradeCheckApp
 * @tags app
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpgradeCheckAppEx(request *UpgradeCheckAppRequest, runtime *RuntimeOptions) (_result *UpgradeCheckAppModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpgradeCheckAppModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpgradeCheckAppModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/app/upgrade_check"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpgradeCheckAppModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * BindDevice
 * @tags device
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BindDeviceEx(request *BindDeviceRequest, runtime *RuntimeOptions) (_result *BindDeviceModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &BindDeviceModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*BindDeviceModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/device/bind"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &BindDeviceModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * ListDevice
 * @tags device
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDeviceEx(request *ListDeviceRequest, runtime *RuntimeOptions) (_result *ListDeviceModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListDeviceModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListDeviceModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/device/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListDeviceModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateGroupEx(request *CreateGroupRequest, runtime *RuntimeOptions) (_result *CreateGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteGroupEx(request *DeleteGroupRequest, runtime *RuntimeOptions) (_result *DeleteGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteGroupModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetGroupEx(request *GetGroupRequest, runtime *RuntimeOptions) (_result *GetGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListGroupEx(request *ListGroupRequest, runtime *RuntimeOptions) (_result *ListGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchGroupEx(request *SearchGroupRequest, runtime *RuntimeOptions) (_result *SearchGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateGroupEx(request *UpdateGroupRequest, runtime *RuntimeOptions) (_result *UpdateGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/group/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateMembershipEx(request *CreateMembershipRequest, runtime *RuntimeOptions) (_result *CreateMembershipModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateMembershipModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateMembershipModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateMembershipModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteMembershipEx(request *DeleteMembershipRequest, runtime *RuntimeOptions) (_result *DeleteMembershipModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteMembershipModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteMembershipModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteMembershipModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMembershipEx(request *GetMembershipRequest, runtime *RuntimeOptions) (_result *GetMembershipModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetMembershipModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetMembershipModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetMembershipModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * groupmember
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) HasMemberEx(request *HasMemberRequest, runtime *RuntimeOptions) (_result *HasMemberModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &HasMemberModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*HasMemberModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/has_member"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &HasMemberModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectChildMembershipsEx(request *ListDirectChildMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectChildMembershipsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListDirectChildMembershipsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListDirectChildMembershipsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_child_memberships"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListDirectChildMembershipsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectMembershipsEx(request *ListDirectParentMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectMembershipsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListDirectMembershipsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListDirectMembershipsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_memberships"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListDirectMembershipsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectParentMembershipsEx(request *ListDirectParentMembershipsRequest, runtime *RuntimeOptions) (_result *ListDirectParentMembershipsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListDirectParentMembershipsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListDirectParentMembershipsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/list_direct_parent_memberships"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListDirectParentMembershipsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateMembershipEx(request *UpdateMembershipRequest, runtime *RuntimeOptions) (_result *UpdateMembershipModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateMembershipModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateMembershipModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/membership/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateMembershipModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * CreateSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateSyncMappingEx(request *CreateSyncMappingRequest, runtime *RuntimeOptions) (_result *CreateSyncMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateSyncMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateSyncMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/sync_mapping/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateSyncMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * DeleteSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteSyncMappingEx(request *DeleteSyncMappingRequest, runtime *RuntimeOptions) (_result *DeleteSyncMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteSyncMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteSyncMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/sync_mapping/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &DeleteSyncMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * ListSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListSyncMappingEx(request *ListSyncMappingRequest, runtime *RuntimeOptions) (_result *ListSyncMappingModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListSyncMappingModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListSyncMappingModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/sync_mapping/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListSyncMappingModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddUserToSubdomainEx(request *AddUserToSubdomainRequest, runtime *RuntimeOptions) (_result *AddUserToSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AddUserToSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AddUserToSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/add_user_to_subdomain"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				_result = &AddUserToSubdomainModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateUserEx(request *CreateUserRequest, runtime *RuntimeOptions) (_result *CreateUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateUserModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUserEx(request *DeleteUserRequest, runtime *RuntimeOptions) (_result *DeleteUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteUserModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUserEx(request *GetUserRequest, runtime *RuntimeOptions) (_result *GetUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetUserModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ImportUserEx(request *ImportUserRequest, runtime *RuntimeOptions) (_result *ImportUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ImportUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ImportUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/import"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ImportUserModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUsersEx(request *ListUserRequest, runtime *RuntimeOptions) (_result *ListUsersModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListUsersModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListUsersModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListUsersModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * migrate_user_to_subdomain
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MigrateUserToSubdomainEx(request *MigrateUserToSubdomainRequest, runtime *RuntimeOptions) (_result *MigrateUserToSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &MigrateUserToSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*MigrateUserToSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/migrate_to_subdomain"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &MigrateUserToSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemoveUserFromSubdomainEx(request *RemoveUserFromSubdomainRequest, runtime *RuntimeOptions) (_result *RemoveUserFromSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RemoveUserFromSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RemoveUserFromSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/remove_user_from_subdomain"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				_result = &RemoveUserFromSubdomainModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * rollback_from_subdomain
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RollbackUserFromSubdomainEx(request *RollbackUserFromSubdomainRequest, runtime *RuntimeOptions) (_result *RollbackUserFromSubdomainModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RollbackUserFromSubdomainModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RollbackUserFromSubdomainModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/rollback_from_subdomain"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &RollbackUserFromSubdomainModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUserEx(request *SearchUserRequest, runtime *RuntimeOptions) (_result *SearchUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchUserModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * descriptionnick_nameavatar
 * status
 * role
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateUserEx(request *UpdateUserRequest, runtime *RuntimeOptions) (_result *UpdateUserModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateUserModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateUserModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateUserModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags user_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUserGroupEx(request *SearchUserAndGroupRequest, runtime *RuntimeOptions) (_result *SearchUserGroupModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchUserGroupModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchUserGroupModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/user_group/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchUserGroupModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags face_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MergeEx(request *MergeFaceGroupRequest, runtime *RuntimeOptions) (_result *MergeModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &MergeModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*MergeModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/albums/face_group/merge"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &MergeModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags albums
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UnassignFacegroupItemEx(request *UnAssignFaceGroupItemRequest, runtime *RuntimeOptions) (_result *UnassignFacegroupItemModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UnassignFacegroupItemModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UnassignFacegroupItemModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/albums/unassign_facegroup_item"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &UnassignFacegroupItemModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateStoryEx(request *CreateStoryRequest, runtime *RuntimeOptions) (_result *CreateStoryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateStoryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateStoryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/create_story"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateStoryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteStoryEx(request *DeleteStoryRequest, runtime *RuntimeOptions) (_result *DeleteStoryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteStoryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteStoryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/delete_story"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &DeleteStoryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) FindStoriesEx(request *FindStoriesRequest, runtime *RuntimeOptions) (_result *FindStoriesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &FindStoriesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*FindStoriesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/find_stories"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &FindStoriesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * Drive
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetPhotoCountEx(request *GetImageCountRequest, runtime *RuntimeOptions) (_result *GetPhotoCountModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetPhotoCountModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetPhotoCountModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/get_photo_count"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetPhotoCountModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetStoryEx(request *GetStoryRequest, runtime *RuntimeOptions) (_result *GetStoryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetStoryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetStoryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/get_story"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetStoryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListAddressGroupsEx(request *ListImageAddressGroupsRequest, runtime *RuntimeOptions) (_result *ListAddressGroupsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListAddressGroupsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListAddressGroupsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_address_groups"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListAddressGroupsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFacegroupsEx(request *ListImageFaceGroupsRequest, runtime *RuntimeOptions) (_result *ListFacegroupsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFacegroupsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFacegroupsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_facegroups"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFacegroupsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListTagsEx(request *ListImageTagsRequest, runtime *RuntimeOptions) (_result *ListTagsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListTagsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListTagsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/list_tags"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListTagsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ParseKeywordsEx(request *ParseKeywordsRequest, runtime *RuntimeOptions) (_result *ParseKeywordsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ParseKeywordsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ParseKeywordsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/parse_keywords"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ParseKeywordsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchAddressGroupsEx(request *SearchImageAddressGroupsRequest, runtime *RuntimeOptions) (_result *SearchAddressGroupsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchAddressGroupsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchAddressGroupsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/search_address_groups"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchAddressGroupsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFacegroupInfoEx(request *UpdateFaceGroupInfoRequest, runtime *RuntimeOptions) (_result *UpdateFacegroupInfoModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateFacegroupInfoModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateFacegroupInfoModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/update_facegroup_info"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateFacegroupInfoModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateStoryEx(request *UpdateStoryRequest, runtime *RuntimeOptions) (_result *UpdateStoryModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateStoryModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateStoryModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/image/update_story"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &UpdateStoryModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AddFileEx(request *AddViewFileRequest, runtime *RuntimeOptions) (_result *AddFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &AddFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*AddFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/add_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &AddFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFilesEx(request *CopyViewFilesRequest, runtime *RuntimeOptions) (_result *CopyFilesModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CopyFilesModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CopyFilesModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/copy_files"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(202))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CopyFilesModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateViewEx(request *CreateViewRequest, runtime *RuntimeOptions) (_result *CreateViewModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &CreateViewModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*CreateViewModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/create"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(201))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &CreateViewModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * view_idView
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteViewEx(request *DeleteViewRequest, runtime *RuntimeOptions) (_result *DeleteViewModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &DeleteViewModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*DeleteViewModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/delete"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &DeleteViewModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * view_idView
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetViewEx(request *GetViewRequest, runtime *RuntimeOptions) (_result *GetViewModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &GetViewModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*GetViewModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/get"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &GetViewModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * View
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListViewsEx(request *ListViewsRequest, runtime *RuntimeOptions) (_result *ListViewsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListViewsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListViewsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/list"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListViewsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ViewListFileEx(request *ListViewFilesRequest, runtime *RuntimeOptions) (_result *ViewListFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ViewListFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ViewListFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/list_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ViewListFileModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListFileViewsEx(request *ListFileViewsRequest, runtime *RuntimeOptions) (_result *ListFileViewsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &ListFileViewsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*ListFileViewsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/list_file_views"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &ListFileViewsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) RemoveFileEx(request *RemoveViewFileRequest, runtime *RuntimeOptions) (_result *RemoveFileModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &RemoveFileModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*RemoveFileModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/remove_file"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &RemoveFileModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * View
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchViewsEx(request *SearchViewsRequest, runtime *RuntimeOptions) (_result *SearchViewsModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &SearchViewsModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*SearchViewsModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/search"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(200))) {
				obj, _err = util.ReadAsJSON(response_.Body)
				if _err != nil {
					return _result, _err
				}

				respMap = util.AssertAsMap(obj)
				_result = &SearchViewsModel{}
				_err = tea.Convert(map[string]interface{}{
					"body":    respMap,
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * view
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error undefined undefined
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateViewEx(request *UpdateViewRequest, runtime *RuntimeOptions) (_result *UpdateViewModel, _err error) {
	_err = tea.Validate(request)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Validate(runtime)
	if _err != nil {
		return _result, _err
	}
	_runtime := map[string]interface{}{
		"timeouted":      "retry",
		"readTimeout":    tea.IntValue(runtime.ReadTimeout),
		"connectTimeout": tea.IntValue(runtime.ConnectTimeout),
		"localAddr":      tea.StringValue(runtime.LocalAddr),
		"httpProxy":      tea.StringValue(runtime.HttpProxy),
		"httpsProxy":     tea.StringValue(runtime.HttpsProxy),
		"noProxy":        tea.StringValue(runtime.NoProxy),
		"maxIdleConns":   tea.IntValue(runtime.MaxIdleConns),
		"socks5Proxy":    tea.StringValue(runtime.Socks5Proxy),
		"socks5NetWork":  tea.StringValue(runtime.Socks5NetWork),
		"retry": map[string]interface{}{
			"retryable":   tea.BoolValue(runtime.Autoretry),
			"maxAttempts": tea.IntValue(util.DefaultNumber(runtime.MaxAttempts, tea.Int(3))),
		},
		"backoff": map[string]interface{}{
			"policy": tea.StringValue(util.DefaultString(runtime.BackoffPolicy, tea.String("no"))),
			"period": tea.IntValue(util.DefaultNumber(runtime.BackoffPeriod, tea.Int(1))),
		},
		"ignoreSSL": tea.BoolValue(runtime.IgnoreSSL),
	}

	_resp := &UpdateViewModel{}
	for _retryTimes := 0; tea.BoolValue(tea.AllowRetry(_runtime["retry"], tea.Int(_retryTimes))); _retryTimes++ {
		if _retryTimes > 0 {
			_backoffTime := tea.GetBackoffTime(_runtime["backoff"], tea.Int(_retryTimes))
			if tea.IntValue(_backoffTime) > 0 {
				tea.Sleep(_backoffTime)
			}
		}

		_resp, _err = func() (*UpdateViewModel, error) {
			request_ := tea.NewRequest()
			accesskeyId, _err := client.GetAccessKeyId()
			if _err != nil {
				return _result, _err
			}

			accessKeySecret, _err := client.GetAccessKeySecret()
			if _err != nil {
				return _result, _err
			}

			securityToken, _err := client.GetSecurityToken()
			if _err != nil {
				return _result, _err
			}

			accessToken, _err := client.GetAccessToken()
			if _err != nil {
				return _result, _err
			}

			realReq := util.ToMap(request)
			request_.Protocol = util.DefaultString(client.Protocol, tea.String("https"))
			request_.Method = tea.String("POST")
			request_.Pathname = client.GetPathname(client.Nickname, tea.String("/v2/view/update"))
			request_.Headers = tea.Merge(map[string]*string{
				"user-agent":   client.GetUserAgent(),
				"host":         util.DefaultString(client.Endpoint, tea.String(tea.StringValue(client.DomainId)+".api.aliyunpds.com")),
				"content-type": tea.String("application/json; charset=utf-8"),
			}, request.Httpheaders)
			realReq["httpheaders"] = nil
			if !tea.BoolValue(util.Empty(accessToken)) {
				request_.Headers["authorization"] = tea.String("Bearer " + tea.StringValue(accessToken))
			} else if !tea.BoolValue(util.Empty(accesskeyId)) && !tea.BoolValue(util.Empty(accessKeySecret)) {
				if !tea.BoolValue(util.Empty(securityToken)) {
					request_.Headers["x-acs-security-token"] = securityToken
				}

				request_.Headers["date"] = util.GetDateUTCString()
				request_.Headers["accept"] = tea.String("application/json")
				request_.Headers["x-acs-signature-method"] = tea.String("HMAC-SHA1")
				request_.Headers["x-acs-signature-version"] = tea.String("1.0")
				stringToSign := roautil.GetStringToSign(request_)
				request_.Headers["authorization"] = tea.String("acs " + tea.StringValue(accesskeyId) + ":" + tea.StringValue(roautil.GetSignature(stringToSign, accessKeySecret)))
			}

			request_.Body = tea.ToReader(util.ToJSONString(realReq))
			response_, _err := tea.DoRequest(request_, _runtime)
			if _err != nil {
				return _result, _err
			}
			var respMap map[string]interface{}
			var obj interface{}
			if tea.BoolValue(util.EqualNumber(response_.StatusCode, tea.Int(204))) {
				_result = &UpdateViewModel{}
				_err = tea.Convert(map[string]map[string]*string{
					"headers": response_.Headers,
				}, &_result)
				return _result, _err
			}

			if !tea.BoolValue(util.Empty(response_.Headers["x-ca-error-message"])) {
				_err = tea.NewSDKError(map[string]interface{}{
					"data": map[string]interface{}{
						"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
						"statusCode":    tea.IntValue(response_.StatusCode),
						"statusMessage": tea.StringValue(response_.StatusMessage),
					},
					"message": tea.StringValue(response_.Headers["x-ca-error-message"]),
				})
				return _result, _err
			}

			obj, _err = util.ReadAsJSON(response_.Body)
			if _err != nil {
				return _result, _err
			}

			respMap = util.AssertAsMap(obj)
			_err = tea.NewSDKError(tea.ToMap(map[string]interface{}{
				"data": map[string]interface{}{
					"requestId":     tea.StringValue(response_.Headers["x-ca-request-id"]),
					"statusCode":    tea.IntValue(response_.StatusCode),
					"statusMessage": tea.StringValue(response_.StatusMessage),
				},
			}, respMap))
			return _result, _err
		}()
		if !tea.BoolValue(tea.Retryable(_err)) {
			break
		}
	}

	return _resp, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CancelLink(request *CancelLinkRequest) (_result *CancelLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CancelLinkModel{}
	_body, _err := client.CancelLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CheckExist(request *CheckExistRequest) (_result *CheckExistModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CheckExistModel{}
	_body, _err := client.CheckExistEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * , 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ConfirmLink(request *ConfirmLinkRequest) (_result *ConfirmLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ConfirmLinkModel{}
	_body, _err := client.ConfirmLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * statestate
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) VerifyCode(request *VerifyCodeRequest) (_result *VerifyCodeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &VerifyCodeModel{}
	_body, _err := client.VerifyCodeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetAccessTokenByLinkInfo(request *GetAccessTokenByLinkInfoRequest) (_result *GetAccessTokenByLinkInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetAccessTokenByLinkInfoModel{}
	_body, _err := client.GetAccessTokenByLinkInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfo(request *GetByLinkInfoRequest) (_result *GetLinkInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetLinkInfoModel{}
	_body, _err := client.GetLinkInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetLinkInfoByUserId(request *GetLinkInfoByUserIDRequest) (_result *GetLinkInfoByUserIdModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetLinkInfoByUserIdModel{}
	_body, _err := client.GetLinkInfoByUserIdEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetPublicKey(request *GetPublicKeyRequest) (_result *GetPublicKeyModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetPublicKeyModel{}
	_body, _err := client.GetPublicKeyEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Link(request *AccountLinkRequest) (_result *LinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &LinkModel{}
	_body, _err := client.LinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Login(request *LoginRequest) (_result *LoginModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &LoginModel{}
	_body, _err := client.LoginEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * +
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) Register(request *RegisterRequest) (_result *RegisterModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RegisterModel{}
	_body, _err := client.RegisterEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountRevoke(request *RevokeRequest) (_result *AccountRevokeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AccountRevokeModel{}
	_body, _err := client.AccountRevokeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SendSmsCode(request *SendSmsCodeRequest) (_result *SendSmsCodeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SendSmsCodeModel{}
	_body, _err := client.SendSmsCodeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * refresh_tokenaccess_token
 * @tags account
 * @error InvalidParameterMissing The input parameter {parameter_name} is missing.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AccountToken(request *AccountTokenRequest) (_result *AccountTokenModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AccountTokenModel{}
	_body, _err := client.AccountTokenEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * export audit log
 * @tags audit_log
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ExportAuditLog(request *ExportAuditLogRequest) (_result *ExportAuditLogModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ExportAuditLogModel{}
	_body, _err := client.ExportAuditLogEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * search audit log
 * @tags audit_log
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) SearchAuditLog(request *SearchAuditLogRequest) (_result *SearchAuditLogModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchAuditLogModel{}
	_body, _err := client.SearchAuditLogEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateIdentityToBenefitPkgMapping(request *CreateIdentityToBenefitPkgMappingRequest) (_result *CreateIdentityToBenefitPkgMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateIdentityToBenefitPkgMappingModel{}
	_body, _err := client.CreateIdentityToBenefitPkgMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteIdentityToBenefitPkgMapping(request *DeleteIdentityToBenefitPkgMappingRequest) (_result *DeleteIdentityToBenefitPkgMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteIdentityToBenefitPkgMappingModel{}
	_body, _err := client.DeleteIdentityToBenefitPkgMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetIdentityToBenefitPkgMapping(request *GetIdentityToBenefitPkgMappingRequest) (_result *GetIdentityToBenefitPkgMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetIdentityToBenefitPkgMappingModel{}
	_body, _err := client.GetIdentityToBenefitPkgMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityToBenefitPkgMapping(request *ListIdentityToBenefitPkgMappingRequest) (_result *ListIdentityToBenefitPkgMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListIdentityToBenefitPkgMappingModel{}
	_body, _err := client.ListIdentityToBenefitPkgMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateIdentityToBenefitPkgMapping(request *UpdateIdentityToBenefitPkgMappingRequest) (_result *UpdateIdentityToBenefitPkgMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateIdentityToBenefitPkgMappingModel{}
	_body, _err := client.UpdateIdentityToBenefitPkgMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags benefit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityBenefitPkg(request *ListIdentityBenefitPkgRequest) (_result *ListIdentityBenefitPkgModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListIdentityBenefitPkgModel{}
	_body, _err := client.ListIdentityBenefitPkgEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Store
 * @tags admin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AdminListStores(request *AdminListStoresRequest) (_result *AdminListStoresModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AdminListStoresModel{}
	_body, _err := client.AdminListStoresEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * create subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) CreateSubdomain(request *CreateSubdomainRequest) (_result *CreateSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateSubdomainModel{}
	_body, _err := client.CreateSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * delete subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) DeleteSubdomain(request *DeleteSubdomainRequest) (_result *DeleteSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteSubdomainModel{}
	_body, _err := client.DeleteSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * get subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) GetSubdomain(request *GetSubdomainRequest) (_result *GetSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetSubdomainModel{}
	_body, _err := client.GetSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * list subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListSubdomains(request *ListSubdomainsRequest) (_result *ListSubdomainsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListSubdomainsModel{}
	_body, _err := client.ListSubdomainsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * update subdomain
 * @tags subdomain
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) UpdateSubdomain(request *UpdateSubdomainRequest) (_result *UpdateSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateSubdomainModel{}
	_body, _err := client.UpdateSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * accessToken
 * @tags admin
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 * @error undefined undefined
 */
func (client *Client) GetUserAccessToken(request *GetUserAccessTokenRequest) (_result *GetUserAccessTokenModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetUserAccessTokenModel{}
	_body, _err := client.GetUserAccessTokenEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  ID
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) PunishFile(request *PunishFileRequest) (_result *PunishFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &PunishFileModel{}
	_body, _err := client.PunishFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * id
 * 
 * @tags async_task
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAsyncTaskInfo(request *GetAsyncTaskRequest) (_result *GetAsyncTaskInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetAsyncTaskInfoModel{}
	_body, _err := client.GetAsyncTaskInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * 100
 * @tags batch
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BatchOperation(request *BatchRequest) (_result *BatchOperationModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &BatchOperationModel{}
	_body, _err := client.BatchOperationEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * normallargedrive
 * largedrivelist
 * drive1large
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateDrive(request *CreateDriveRequest) (_result *CreateDriveModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateDriveModel{}
	_body, _err := client.CreateDriveEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteDrive(request *DeleteDriveRequest) (_result *DeleteDriveModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteDriveModel{}
	_body, _err := client.DeleteDriveEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDrive(request *GetDriveRequest) (_result *GetDriveModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetDriveModel{}
	_body, _err := client.GetDriveEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drivedrivedrive
 * drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDefaultDrive(request *GetDefaultDriveRequest) (_result *GetDefaultDriveModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetDefaultDriveModel{}
	_body, _err := client.GetDefaultDriveEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDrives(request *ListDriveRequest) (_result *ListDrivesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListDrivesModel{}
	_body, _err := client.ListDrivesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListMyDrives(request *ListMyDriveRequest) (_result *ListMyDrivesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListMyDrivesModel{}
	_body, _err := client.ListMyDrivesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Drive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchDrives(request *SearchDriveRequest) (_result *SearchDrivesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchDrivesModel{}
	_body, _err := client.SearchDrivesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive_idDrive
 * @tags drive
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateDrive(request *UpdateDriveRequest) (_result *UpdateDriveModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateDriveModel{}
	_body, _err := client.UpdateDriveEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddPermission(request *FileAddPermissionRequest) (_result *AddPermissionModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AddPermissionModel{}
	_body, _err := client.AddPermissionEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * archive_files
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ArchiveFiles(request *CCPArchiveFilesRequest) (_result *ArchiveFilesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ArchiveFilesModel{}
	_body, _err := client.ArchiveFilesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFile(request *CompleteFileRequest) (_result *CompleteFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CompleteFileModel{}
	_body, _err := client.CompleteFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * UCCompleteFileRequest
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CompleteFileWithStoreInfo(request *UCCompleteFileRequest) (_result *CompleteFileWithStoreInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CompleteFileWithStoreInfoModel{}
	_body, _err := client.CompleteFileWithStoreInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFile(request *CopyFileRequest) (_result *CopyFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CopyFileModel{}
	_body, _err := client.CopyFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFile(request *CreateFileRequest) (_result *CreateFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateFileModel{}
	_body, _err := client.CreateFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * rootfile_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithProof(request *CreateFileRequest) (_result *CreateFileWithProofModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateFileWithProofModel{}
	_body, _err := client.CreateFileWithProofEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * CreateFileWithSignature
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateFileWithSignature(request *UCCreateFileRequest) (_result *CreateFileWithSignatureModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateFileWithSignatureModel{}
	_body, _err := client.CreateFileWithSignatureEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteFile(request *DeleteFileRequest) (_result *DeleteFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteFileModel{}
	_body, _err := client.DeleteFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  user tags
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUsertags(request *DeleteFileUserTagsRequest) (_result *DeleteUsertagsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteUsertagsModel{}
	_body, _err := client.DeleteUsertagsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ID
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFile(request *GetFileRequest) (_result *GetFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetFileModel{}
	_body, _err := client.GetFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileByPath(request *GetFileByPathRequest) (_result *GetFileByPathModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetFileByPathModel{}
	_body, _err := client.GetFileByPathEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDownloadUrl(request *GetDownloadUrlRequest) (_result *GetDownloadUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetDownloadUrlModel{}
	_body, _err := client.GetDownloadUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetLastCursor(request *GetLastCursorRequest) (_result *GetLastCursorModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetLastCursorModel{}
	_body, _err := client.GetLastCursorEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * mediaURLm3u8
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMediaPlayUrl(request *GetMediaPlayURLRequest) (_result *GetMediaPlayUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetMediaPlayUrlModel{}
	_body, _err := client.GetMediaPlayUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficeEditUrl(request *GetOfficeEditUrlRequest) (_result *GetOfficeEditUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetOfficeEditUrlModel{}
	_body, _err := client.GetOfficeEditUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * office
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetOfficePreviewUrl(request *GetOfficePreviewUrlRequest) (_result *GetOfficePreviewUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetOfficePreviewUrlModel{}
	_body, _err := client.GetOfficePreviewUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * range
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkDownloadUrl(request *GetShareLinkDownloadURLRequest) (_result *GetShareLinkDownloadUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareLinkDownloadUrlModel{}
	_body, _err := client.GetShareLinkDownloadUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLinkVideoPreviewPlayInfo(request *CCPGetShareLinkVideoPreviewPlayInfoRequest) (_result *GetShareLinkVideoPreviewPlayInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareLinkVideoPreviewPlayInfoModel{}
	_body, _err := client.GetShareLinkVideoPreviewPlayInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * GetFileSignature
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileSignature(request *UCFileGetSignatureRequest) (_result *GetFileSignatureModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetFileSignatureModel{}
	_body, _err := client.GetFileSignatureEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUploadUrl(request *GetUploadUrlRequest) (_result *GetUploadUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetUploadUrlModel{}
	_body, _err := client.GetUploadUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewPlayInfo(request *CCPGetVideoPreviewPlayInfoRequest) (_result *GetVideoPreviewPlayInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetVideoPreviewPlayInfoModel{}
	_body, _err := client.GetVideoPreviewPlayInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewSpriteUrl(request *GetVideoPreviewSpriteURLRequest) (_result *GetVideoPreviewSpriteUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetVideoPreviewSpriteUrlModel{}
	_body, _err := client.GetVideoPreviewSpriteUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetVideoPreviewUrl(request *GetVideoPreviewURLRequest) (_result *GetVideoPreviewUrlModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetVideoPreviewUrlModel{}
	_body, _err := client.GetVideoPreviewUrlEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFile(request *ListFileRequest) (_result *ListFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileModel{}
	_body, _err := client.ListFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * list file activity
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileActivity(request *ListFileActivityRequest) (_result *ListFileActivityModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileActivityModel{}
	_body, _err := client.ListFileActivityEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ShareLinkTokenInvalid ShareToken is invalid. {message}
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByAnonymous(request *ListByAnonymousRequest) (_result *ListFileByAnonymousModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileByAnonymousModel{}
	_body, _err := client.ListFileByAnonymousEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileByCustomIndexKey(request *ListFileByCustomIndexKeyRequest) (_result *ListFileByCustomIndexKeyModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileByCustomIndexKeyModel{}
	_body, _err := client.ListFileByCustomIndexKeyEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive
 * @tags file_delta
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFileDelta(request *ListFileDeltaRequest) (_result *ListFileDeltaModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileDeltaModel{}
	_body, _err := client.ListFileDeltaEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListInheritPermission(request *FileListInheritPermissionRequest) (_result *ListInheritPermissionModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListInheritPermissionModel{}
	_body, _err := client.ListInheritPermissionEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListManageSharingFile(request *ListMangeSharingFileRequest) (_result *ListManageSharingFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListManageSharingFileModel{}
	_body, _err := client.ListManageSharingFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListPermission(request *FileListPermissionRequest) (_result *ListPermissionModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListPermissionModel{}
	_body, _err := client.ListPermissionEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListReceivedFile(request *ListReceivedFileRequest) (_result *ListReceivedFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListReceivedFileModel{}
	_body, _err := client.ListReceivedFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListSharingFile(request *ListSharingFileRequest) (_result *ListSharingFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListSharingFileModel{}
	_body, _err := client.ListSharingFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * upload_id
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUploadedParts(request *ListUploadedPartRequest) (_result *ListUploadedPartsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListUploadedPartsModel{}
	_body, _err := client.ListUploadedPartsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUserPermission(request *FileListUserPermissionRequest) (_result *ListUserPermissionModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListUserPermissionModel{}
	_body, _err := client.ListUserPermissionEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * live_transcode
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) LiveTranscode(request *CCPLiveTranscodeRequest) (_result *LiveTranscodeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &LiveTranscodeModel{}
	_body, _err := client.LiveTranscodeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MoveFile(request *MoveFileRequest) (_result *MoveFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &MoveFileModel{}
	_body, _err := client.MoveFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  user tags
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) PutUsertags(request *PutFileUserTagsRequest) (_result *PutUsertagsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &PutUsertagsModel{}
	_body, _err := client.PutUsertagsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Token
 * @tags file, refresh, office, edit
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) Token(request *RefreshOfficeEditTokenRequest) (_result *TokenModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &TokenModel{}
	_body, _err := client.TokenEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * /
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemovePermission(request *FileRemovePermissionRequest) (_result *RemovePermissionModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RemovePermissionModel{}
	_body, _err := client.RemovePermissionEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ScanFileMeta(request *ScanFileMetaRequest) (_result *ScanFileMetaModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ScanFileMetaModel{}
	_body, _err := client.ScanFileMetaEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * drive
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFile(request *SearchFileRequest) (_result *SearchFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchFileModel{}
	_body, _err := client.SearchFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchFileFpRefs(request *SearchFileFpRefsRequest) (_result *SearchFileFpRefsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchFileFpRefsModel{}
	_body, _err := client.SearchFileFpRefsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error AlreadyExist {resource} has already exists. {extra_msg}
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFile(request *UpdateFileMetaRequest) (_result *UpdateFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateFileModel{}
	_body, _err := client.UpdateFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * UpdateFileUploadContentHash
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFileUploadContentHash(request *UCUpdateUploadContentHashRequest) (_result *UpdateFileUploadContentHashModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateFileUploadContentHashModel{}
	_body, _err := client.UpdateFileUploadContentHashEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * walk file
 * @tags file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) WalkFile(request *CCPWalkFileRequest) (_result *WalkFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &WalkFileModel{}
	_body, _err := client.WalkFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * clear_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ClearRecyclebin(request *ClearRecycleBinRequest) (_result *ClearRecyclebinModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ClearRecyclebinModel{}
	_body, _err := client.ClearRecyclebinEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * list_recyclebin
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListRecyclebin(request *ListFileInRecycleBinRequest) (_result *ListRecyclebinModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListRecyclebinModel{}
	_body, _err := client.ListRecyclebinEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * restore_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RestoreFile(request *RestoreFileRequest) (_result *RestoreFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RestoreFileModel{}
	_body, _err := client.RestoreFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * trash_file
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) TrashFile(request *TrashFileRequest) (_result *TrashFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &TrashFileModel{}
	_body, _err := client.TrashFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ReportEvent(request *ReportEventRequest) (_result *ReportEventModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ReportEventModel{}
	_body, _err := client.ReportEventEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShare(request *CreateShareRequest) (_result *CreateShareModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateShareModel{}
	_body, _err := client.CreateShareEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteShare(request *DeleteShareRequest) (_result *DeleteShareModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteShareModel{}
	_body, _err := client.DeleteShareEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShare(request *GetShareRequest) (_result *GetShareModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareModel{}
	_body, _err := client.GetShareEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShare(request *ListShareRequest) (_result *ListShareModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListShareModel{}
	_body, _err := client.ListShareEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShare(request *UpdateShareRequest) (_result *UpdateShareModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateShareModel{}
	_body, _err := client.UpdateShareEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelShareLink(request *CancelShareLinkRequest) (_result *CancelShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CancelShareLinkModel{}
	_body, _err := client.CancelShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateShareLink(request *CreateShareLinkRequest) (_result *CreateShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateShareLinkModel{}
	_body, _err := client.CreateShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareLink(request *GetShareLinkRequest) (_result *GetShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareLinkModel{}
	_body, _err := client.GetShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareByAnonymous(request *GetShareLinkByAnonymousRequest) (_result *GetShareByAnonymousModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareByAnonymousModel{}
	_body, _err := client.GetShareByAnonymousEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * id
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareId(request *GetShareLinkIDRequest) (_result *GetShareIdModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareIdModel{}
	_body, _err := client.GetShareIdEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * +token
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetShareToken(request *GetShareLinkTokenRequest) (_result *GetShareTokenModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetShareTokenModel{}
	_body, _err := client.GetShareTokenEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListShareLink(request *ListShareLinkRequest) (_result *ListShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListShareLinkModel{}
	_body, _err := client.ListShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchShareLink(request *SearchShareLinkRequest) (_result *SearchShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchShareLinkModel{}
	_body, _err := client.SearchShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags share_link
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateShareLink(request *UpdateShareLinkRequest) (_result *UpdateShareLinkModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateShareLinkModel{}
	_body, _err := client.UpdateShareLinkEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) Assign(request *AssignRequest) (_result *AssignModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AssignModel{}
	_body, _err := client.AssignEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CancelAssign(request *CancelAssignRequest) (_result *CancelAssignModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CancelAssignModel{}
	_body, _err := client.CancelAssignEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags role
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListIdentityRole(request *ListIdentityRoleRequest) (_result *ListIdentityRoleModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListIdentityRoleModel{}
	_body, _err := client.ListIdentityRoleEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  Drive 
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDriveUsedSize(request *GetDriveUsedSizeRequest) (_result *GetDriveUsedSizeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetDriveUsedSizeModel{}
	_body, _err := client.GetDriveUsedSizeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  Domain  Drive 
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetFileCount(request *GetFileCountRequest) (_result *GetFileCountModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetFileCountModel{}
	_body, _err := client.GetFileCountEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  Subdomain summary
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetSubdomainSummary(request *GetSubdomainSummaryRequest) (_result *GetSubdomainSummaryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetSubdomainSummaryModel{}
	_body, _err := client.GetSubdomainSummaryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *  Domain summary
 * @tags statistics
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetDomainSummary(request *GetDomainSummaryRequest) (_result *GetDomainSummaryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetDomainSummaryModel{}
	_body, _err := client.GetDomainSummaryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * GetAppDebugCmd
 * @tags app
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetAppDebugCmd(request *GetAppDebugCmdRequest) (_result *GetAppDebugCmdModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetAppDebugCmdModel{}
	_body, _err := client.GetAppDebugCmdEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * UpgradeCheckApp
 * @tags app
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpgradeCheckApp(request *UpgradeCheckAppRequest) (_result *UpgradeCheckAppModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpgradeCheckAppModel{}
	_body, _err := client.UpgradeCheckAppEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * BindDevice
 * @tags device
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) BindDevice(request *BindDeviceRequest) (_result *BindDeviceModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &BindDeviceModel{}
	_body, _err := client.BindDeviceEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ListDevice
 * @tags device
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDevice(request *ListDeviceRequest) (_result *ListDeviceModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListDeviceModel{}
	_body, _err := client.ListDeviceEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateGroup(request *CreateGroupRequest) (_result *CreateGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateGroupModel{}
	_body, _err := client.CreateGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteGroup(request *DeleteGroupRequest) (_result *DeleteGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteGroupModel{}
	_body, _err := client.DeleteGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetGroup(request *GetGroupRequest) (_result *GetGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetGroupModel{}
	_body, _err := client.GetGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListGroup(request *ListGroupRequest) (_result *ListGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListGroupModel{}
	_body, _err := client.ListGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchGroup(request *SearchGroupRequest) (_result *SearchGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchGroupModel{}
	_body, _err := client.SearchGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateGroup(request *UpdateGroupRequest) (_result *UpdateGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateGroupModel{}
	_body, _err := client.UpdateGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateMembership(request *CreateMembershipRequest) (_result *CreateMembershipModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateMembershipModel{}
	_body, _err := client.CreateMembershipEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteMembership(request *DeleteMembershipRequest) (_result *DeleteMembershipModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteMembershipModel{}
	_body, _err := client.DeleteMembershipEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetMembership(request *GetMembershipRequest) (_result *GetMembershipModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetMembershipModel{}
	_body, _err := client.GetMembershipEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * groupmember
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) HasMember(request *HasMemberRequest) (_result *HasMemberModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &HasMemberModel{}
	_body, _err := client.HasMemberEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectChildMemberships(request *ListDirectChildMembershipsRequest) (_result *ListDirectChildMembershipsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListDirectChildMembershipsModel{}
	_body, _err := client.ListDirectChildMembershipsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectMemberships(request *ListDirectParentMembershipsRequest) (_result *ListDirectMembershipsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListDirectMembershipsModel{}
	_body, _err := client.ListDirectMembershipsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListDirectParentMemberships(request *ListDirectParentMembershipsRequest) (_result *ListDirectParentMembershipsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListDirectParentMembershipsModel{}
	_body, _err := client.ListDirectParentMembershipsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * membership
 * @tags membership
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateMembership(request *UpdateMembershipRequest) (_result *UpdateMembershipModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateMembershipModel{}
	_body, _err := client.UpdateMembershipEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * CreateSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateSyncMapping(request *CreateSyncMappingRequest) (_result *CreateSyncMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateSyncMappingModel{}
	_body, _err := client.CreateSyncMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * DeleteSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteSyncMapping(request *DeleteSyncMappingRequest) (_result *DeleteSyncMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteSyncMappingModel{}
	_body, _err := client.DeleteSyncMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ListSyncMapping
 * @tags sync_mapping
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListSyncMapping(request *ListSyncMappingRequest) (_result *ListSyncMappingModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListSyncMappingModel{}
	_body, _err := client.ListSyncMappingEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) AddUserToSubdomain(request *AddUserToSubdomainRequest) (_result *AddUserToSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AddUserToSubdomainModel{}
	_body, _err := client.AddUserToSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateUser(request *CreateUserRequest) (_result *CreateUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateUserModel{}
	_body, _err := client.CreateUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteUser(request *DeleteUserRequest) (_result *DeleteUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteUserModel{}
	_body, _err := client.DeleteUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetUser(request *GetUserRequest) (_result *GetUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetUserModel{}
	_body, _err := client.GetUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ImportUser(request *ImportUserRequest) (_result *ImportUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ImportUserModel{}
	_body, _err := client.ImportUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListUsers(request *ListUserRequest) (_result *ListUsersModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListUsersModel{}
	_body, _err := client.ListUsersEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * migrate_user_to_subdomain
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) MigrateUserToSubdomain(request *MigrateUserToSubdomainRequest) (_result *MigrateUserToSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &MigrateUserToSubdomainModel{}
	_body, _err := client.MigrateUserToSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RemoveUserFromSubdomain(request *RemoveUserFromSubdomainRequest) (_result *RemoveUserFromSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RemoveUserFromSubdomainModel{}
	_body, _err := client.RemoveUserFromSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * rollback_from_subdomain
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) RollbackUserFromSubdomain(request *RollbackUserFromSubdomainRequest) (_result *RollbackUserFromSubdomainModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RollbackUserFromSubdomainModel{}
	_body, _err := client.RollbackUserFromSubdomainEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUser(request *SearchUserRequest) (_result *SearchUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchUserModel{}
	_body, _err := client.SearchUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * descriptionnick_nameavatar
 * status
 * role
 * @tags user
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateUser(request *UpdateUserRequest) (_result *UpdateUserModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateUserModel{}
	_body, _err := client.UpdateUserEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags user_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchUserGroup(request *SearchUserAndGroupRequest) (_result *SearchUserGroupModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchUserGroupModel{}
	_body, _err := client.SearchUserGroupEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags face_group
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) Merge(request *MergeFaceGroupRequest) (_result *MergeModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &MergeModel{}
	_body, _err := client.MergeEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags albums
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UnassignFacegroupItem(request *UnAssignFaceGroupItemRequest) (_result *UnassignFacegroupItemModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UnassignFacegroupItemModel{}
	_body, _err := client.UnassignFacegroupItemEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateStory(request *CreateStoryRequest) (_result *CreateStoryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateStoryModel{}
	_body, _err := client.CreateStoryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteStory(request *DeleteStoryRequest) (_result *DeleteStoryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteStoryModel{}
	_body, _err := client.DeleteStoryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) FindStories(request *FindStoriesRequest) (_result *FindStoriesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &FindStoriesModel{}
	_body, _err := client.FindStoriesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Drive
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetPhotoCount(request *GetImageCountRequest) (_result *GetPhotoCountModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetPhotoCountModel{}
	_body, _err := client.GetPhotoCountEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetStory(request *GetStoryRequest) (_result *GetStoryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetStoryModel{}
	_body, _err := client.GetStoryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListAddressGroups(request *ListImageAddressGroupsRequest) (_result *ListAddressGroupsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListAddressGroupsModel{}
	_body, _err := client.ListAddressGroupsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListFacegroups(request *ListImageFaceGroupsRequest) (_result *ListFacegroupsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFacegroupsModel{}
	_body, _err := client.ListFacegroupsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListTags(request *ListImageTagsRequest) (_result *ListTagsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListTagsModel{}
	_body, _err := client.ListTagsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ParseKeywords(request *ParseKeywordsRequest) (_result *ParseKeywordsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ParseKeywordsModel{}
	_body, _err := client.ParseKeywordsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchAddressGroups(request *SearchImageAddressGroupsRequest) (_result *SearchAddressGroupsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchAddressGroupsModel{}
	_body, _err := client.SearchAddressGroupsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateFacegroupInfo(request *UpdateFaceGroupInfoRequest) (_result *UpdateFacegroupInfoModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateFacegroupInfoModel{}
	_body, _err := client.UpdateFacegroupInfoEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags image
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateStory(request *UpdateStoryRequest) (_result *UpdateStoryModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateStoryModel{}
	_body, _err := client.UpdateStoryEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error StateConflict User operation is not valid.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) AddFile(request *AddViewFileRequest) (_result *AddFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &AddFileModel{}
	_body, _err := client.AddFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CopyFiles(request *CopyViewFilesRequest) (_result *CopyFilesModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CopyFilesModel{}
	_body, _err := client.CopyFilesEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) CreateView(request *CreateViewRequest) (_result *CreateViewModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &CreateViewModel{}
	_body, _err := client.CreateViewEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * view_idView
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) DeleteView(request *DeleteViewRequest) (_result *DeleteViewModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &DeleteViewModel{}
	_body, _err := client.DeleteViewEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * view_idView
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) GetView(request *GetViewRequest) (_result *GetViewModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &GetViewModel{}
	_body, _err := client.GetViewEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * View
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) ListViews(request *ListViewsRequest) (_result *ListViewsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListViewsModel{}
	_body, _err := client.ListViewsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ViewListFile(request *ListViewFilesRequest) (_result *ViewListFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ViewListFileModel{}
	_body, _err := client.ViewListFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) ListFileViews(request *ListFileViewsRequest) (_result *ListFileViewsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &ListFileViewsModel{}
	_body, _err := client.ListFileViewsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error Forbidden User not authorized to operate on the specified APIs.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error TooManyRequests Too many requests
 * @error InternalError The request has been failed due to some unknown error.
 */
func (client *Client) RemoveFile(request *RemoveViewFileRequest) (_result *RemoveFileModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &RemoveFileModel{}
	_body, _err := client.RemoveFileEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * View
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) SearchViews(request *SearchViewsRequest) (_result *SearchViewsModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &SearchViewsModel{}
	_body, _err := client.SearchViewsEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * view
 * @tags view
 * @error InvalidParameter The input parameter {parameter_name} is not valid.
 * @error AccessTokenInvalid AccessToken is invalid. {message}
 * @error ForbiddenNoPermission No Permission to access resource {resource_name}.
 * @error NotFound The resource {resource_name} cannot be found. Please check.
 * @error undefined undefined
 * @error InternalError The request has been failed due to some unknown error.
 * @error ServiceUnavailable The request has failed due to a temporary failure of the server.
 */
func (client *Client) UpdateView(request *UpdateViewRequest) (_result *UpdateViewModel, _err error) {
	runtime := &RuntimeOptions{}
	_result = &UpdateViewModel{}
	_body, _err := client.UpdateViewEx(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPathname(nickname *string, path *string) (_result *string) {
	if tea.BoolValue(util.Empty(nickname)) {
		_result = path
		return _result
	}

	_result = tea.String("/" + tea.StringValue(nickname) + tea.StringValue(path))
	return _result
}

func (client *Client) SetExpireTime(expireTime *string) (_err error) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		return _err
	}

	client.AccessTokenCredential.SetExpireTime(expireTime)
	return _err
}

func (client *Client) GetExpireTime() (_result *string) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		_result = tea.String("")
		return _result
	}

	expireTime := client.AccessTokenCredential.GetExpireTime()
	_result = expireTime
	return _result
}

func (client *Client) SetRefreshToken(token *string) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		return
	}

	client.AccessTokenCredential.SetRefreshToken(token)
}

func (client *Client) GetRefreshToken() (_result *string) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		_result = tea.String("")
		return _result
	}

	token := client.AccessTokenCredential.GetRefreshToken()
	_result = token
	return _result
}

func (client *Client) SetAccessToken(token *string) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		return
	}

	client.AccessTokenCredential.SetAccessToken(token)
}

func (client *Client) GetAccessToken() (_result *string, _err error) {
	if tea.BoolValue(util.IsUnset(client.AccessTokenCredential)) {
		_result = tea.String("")
		return _result, _err
	}

	token, _err := client.AccessTokenCredential.GetAccessToken()
	if _err != nil {
		return _result, _err
	}

	_result = token
	return _result, _err
}

func (client *Client) SetUserAgent(userAgent *string) {
	client.UserAgent = userAgent
}

func (client *Client) AppendUserAgent(userAgent *string) {
	client.UserAgent = tea.String(tea.StringValue(client.UserAgent) + " " + tea.StringValue(userAgent))
}

func (client *Client) GetUserAgent() (_result *string) {
	userAgent := util.GetUserAgent(client.UserAgent)
	_result = userAgent
	return _result
}

func (client *Client) GetAccessKeyId() (_result *string, _err error) {
	if tea.BoolValue(util.IsUnset(client.Credential)) {
		_result = tea.String("")
		return _result, _err
	}

	accessKeyId, _err := client.Credential.GetAccessKeyId()
	if _err != nil {
		return _result, _err
	}

	_result = accessKeyId
	return _result, _err
}

func (client *Client) GetAccessKeySecret() (_result *string, _err error) {
	if tea.BoolValue(util.IsUnset(client.Credential)) {
		_result = tea.String("")
		return _result, _err
	}

	secret, _err := client.Credential.GetAccessKeySecret()
	if _err != nil {
		return _result, _err
	}

	_result = secret
	return _result, _err
}

func (client *Client) GetSecurityToken() (_result *string, _err error) {
	if tea.BoolValue(util.IsUnset(client.Credential)) {
		_result = tea.String("")
		return _result, _err
	}

	token, _err := client.Credential.GetSecurityToken()
	if _err != nil {
		return _result, _err
	}

	_result = token
	return _result, _err
}
