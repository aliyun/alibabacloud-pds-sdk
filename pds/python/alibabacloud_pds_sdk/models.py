# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict


class RuntimeOptions(TeaModel):
    def __init__(
        self,
        autoretry: bool = None,
        ignore_ssl: bool = None,
        max_attempts: int = None,
        backoff_policy: str = None,
        backoff_period: int = None,
        read_timeout: int = None,
        connect_timeout: int = None,
        http_proxy: str = None,
        https_proxy: str = None,
        no_proxy: str = None,
        max_idle_conns: int = None,
        local_addr: str = None,
        socks_5proxy: str = None,
        socks_5net_work: str = None,
    ):
        # whether to try again
        self.autoretry = autoretry
        # ignore SSL validation
        self.ignore_ssl = ignore_ssl
        # maximum number of retries
        self.max_attempts = max_attempts
        # backoff policy
        self.backoff_policy = backoff_policy
        # backoff period
        self.backoff_period = backoff_period
        # read timeout
        self.read_timeout = read_timeout
        # connect timeout
        self.connect_timeout = connect_timeout
        # http proxy url
        self.http_proxy = http_proxy
        # https Proxy url
        self.https_proxy = https_proxy
        # agent blacklist
        self.no_proxy = no_proxy
        # maximum number of connections
        self.max_idle_conns = max_idle_conns
        # local addr
        self.local_addr = local_addr
        # SOCKS5 proxy
        self.socks_5proxy = socks_5proxy
        # SOCKS5 netWork
        self.socks_5net_work = socks_5net_work

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.autoretry is not None:
            result['autoretry'] = self.autoretry
        if self.ignore_ssl is not None:
            result['ignoreSSL'] = self.ignore_ssl
        if self.max_attempts is not None:
            result['maxAttempts'] = self.max_attempts
        if self.backoff_policy is not None:
            result['backoffPolicy'] = self.backoff_policy
        if self.backoff_period is not None:
            result['backoffPeriod'] = self.backoff_period
        if self.read_timeout is not None:
            result['readTimeout'] = self.read_timeout
        if self.connect_timeout is not None:
            result['connectTimeout'] = self.connect_timeout
        if self.http_proxy is not None:
            result['httpProxy'] = self.http_proxy
        if self.https_proxy is not None:
            result['httpsProxy'] = self.https_proxy
        if self.no_proxy is not None:
            result['noProxy'] = self.no_proxy
        if self.max_idle_conns is not None:
            result['maxIdleConns'] = self.max_idle_conns
        if self.local_addr is not None:
            result['localAddr'] = self.local_addr
        if self.socks_5proxy is not None:
            result['socks5Proxy'] = self.socks_5proxy
        if self.socks_5net_work is not None:
            result['socks5NetWork'] = self.socks_5net_work
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoretry') is not None:
            self.autoretry = m.get('autoretry')
        if m.get('ignoreSSL') is not None:
            self.ignore_ssl = m.get('ignoreSSL')
        if m.get('maxAttempts') is not None:
            self.max_attempts = m.get('maxAttempts')
        if m.get('backoffPolicy') is not None:
            self.backoff_policy = m.get('backoffPolicy')
        if m.get('backoffPeriod') is not None:
            self.backoff_period = m.get('backoffPeriod')
        if m.get('readTimeout') is not None:
            self.read_timeout = m.get('readTimeout')
        if m.get('connectTimeout') is not None:
            self.connect_timeout = m.get('connectTimeout')
        if m.get('httpProxy') is not None:
            self.http_proxy = m.get('httpProxy')
        if m.get('httpsProxy') is not None:
            self.https_proxy = m.get('httpsProxy')
        if m.get('noProxy') is not None:
            self.no_proxy = m.get('noProxy')
        if m.get('maxIdleConns') is not None:
            self.max_idle_conns = m.get('maxIdleConns')
        if m.get('localAddr') is not None:
            self.local_addr = m.get('localAddr')
        if m.get('socks5Proxy') is not None:
            self.socks_5proxy = m.get('socks5Proxy')
        if m.get('socks5NetWork') is not None:
            self.socks_5net_work = m.get('socks5NetWork')
        return self


class Config(TeaModel):
    def __init__(
        self,
        endpoint: str = None,
        domain_id: str = None,
        client_id: str = None,
        refresh_token: str = None,
        client_secret: str = None,
        access_token: str = None,
        expire_time: str = None,
        protocol: str = None,
        type: str = None,
        security_token: str = None,
        access_key_id: str = None,
        access_key_secret: str = None,
        nickname: str = None,
        user_agent: str = None,
    ):
        self.endpoint = endpoint
        self.domain_id = domain_id
        self.client_id = client_id
        self.refresh_token = refresh_token
        self.client_secret = client_secret
        self.access_token = access_token
        self.expire_time = expire_time
        self.protocol = protocol
        self.type = type
        self.security_token = security_token
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret
        self.nickname = nickname
        self.user_agent = user_agent

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '^[a-zA-Z0-9_-]+$')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.domain_id is not None:
            result['domainId'] = self.domain_id
        if self.client_id is not None:
            result['clientId'] = self.client_id
        if self.refresh_token is not None:
            result['refreshToken'] = self.refresh_token
        if self.client_secret is not None:
            result['clientSecret'] = self.client_secret
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.expire_time is not None:
            result['expireTime'] = self.expire_time
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.type is not None:
            result['type'] = self.type
        if self.security_token is not None:
            result['securityToken'] = self.security_token
        if self.access_key_id is not None:
            result['accessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['accessKeySecret'] = self.access_key_secret
        if self.nickname is not None:
            result['nickname'] = self.nickname
        if self.user_agent is not None:
            result['userAgent'] = self.user_agent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('domainId') is not None:
            self.domain_id = m.get('domainId')
        if m.get('clientId') is not None:
            self.client_id = m.get('clientId')
        if m.get('refreshToken') is not None:
            self.refresh_token = m.get('refreshToken')
        if m.get('clientSecret') is not None:
            self.client_secret = m.get('clientSecret')
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('securityToken') is not None:
            self.security_token = m.get('securityToken')
        if m.get('accessKeyId') is not None:
            self.access_key_id = m.get('accessKeyId')
        if m.get('accessKeySecret') is not None:
            self.access_key_secret = m.get('accessKeySecret')
        if m.get('nickname') is not None:
            self.nickname = m.get('nickname')
        if m.get('userAgent') is not None:
            self.user_agent = m.get('userAgent')
        return self


class LinkInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        extra: str = None,
        identity: str = None,
        type: str = None,
    ):
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 当前用户已存在的登录标识
        self.identity = identity
        # 当前用户已存在的登录方式
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AccountAccessTokenResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        access_token: str = None,
        avatar: str = None,
        default_drive_id: str = None,
        default_sbox_drive_id: str = None,
        device_id: str = None,
        device_name: str = None,
        domain_id: str = None,
        exist_link: List[LinkInfo] = None,
        expire_time: str = None,
        expires_in: int = None,
        is_first_login: bool = None,
        need_link: bool = None,
        need_rp_verify: bool = None,
        nick_name: str = None,
        pin_setup: bool = None,
        refresh_token: str = None,
        role: str = None,
        state: str = None,
        status: str = None,
        subdomain_id: str = None,
        token_type: str = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # 用于调用业务接口的accessToken
        self.access_token = access_token
        # 当前用户头像
        self.avatar = avatar
        # Default Drive ID
        self.default_drive_id = default_drive_id
        # Default Sbox Drive ID
        self.default_sbox_drive_id = default_sbox_drive_id
        # device_id 通过device flow 绑定的设备ID
        self.device_id = device_id
        # device_name 通过device flow 绑定的设备名
        self.device_name = device_name
        # domainID 用户登录的domainID
        self.domain_id = domain_id
        # 当前用户已存在的登录方式
        self.exist_link = exist_link
        # accessToken过期时间，ISO时间
        self.expire_time = expire_time
        # accessToken过期时间，单位秒
        self.expires_in = expires_in
        # 用户是否为第一次登录
        self.is_first_login = is_first_login
        # 是否需要绑定
        self.need_link = need_link
        # 用户是否需要进行的实人认证
        self.need_rp_verify = need_rp_verify
        # 当前用户昵称
        self.nick_name = nick_name
        # 用户的数据密码是否设置过
        self.pin_setup = pin_setup
        # 用于刷新accessToken
        self.refresh_token = refresh_token
        # 当前用户角色
        self.role = role
        # 临时权限，用于登录成功后设置密码
        self.state = state
        # 当前用户状态
        self.status = status
        # subdomain_id 用户登录的subdomain_id
        self.subdomain_id = subdomain_id
        # accessToken类型，Bearer
        self.token_type = token_type
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 当前用户ID
        self.user_id = user_id
        # 当前用户名
        self.user_name = user_name

    def validate(self):
        self.validate_required(self.access_token, 'access_token')
        if self.exist_link:
            for k in self.exist_link:
                if k:
                    k.validate()
        self.validate_required(self.need_link, 'need_link')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['access_token'] = self.access_token
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.default_sbox_drive_id is not None:
            result['default_sbox_drive_id'] = self.default_sbox_drive_id
        if self.device_id is not None:
            result['device_id'] = self.device_id
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        result['exist_link'] = []
        if self.exist_link is not None:
            for k in self.exist_link:
                result['exist_link'].append(k.to_map() if k else None)
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.expires_in is not None:
            result['expires_in'] = self.expires_in
        if self.is_first_login is not None:
            result['is_first_login'] = self.is_first_login
        if self.need_link is not None:
            result['need_link'] = self.need_link
        if self.need_rp_verify is not None:
            result['need_rp_verify'] = self.need_rp_verify
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.pin_setup is not None:
            result['pin_setup'] = self.pin_setup
        if self.refresh_token is not None:
            result['refresh_token'] = self.refresh_token
        if self.role is not None:
            result['role'] = self.role
        if self.state is not None:
            result['state'] = self.state
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.token_type is not None:
            result['token_type'] = self.token_type
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_token') is not None:
            self.access_token = m.get('access_token')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('default_sbox_drive_id') is not None:
            self.default_sbox_drive_id = m.get('default_sbox_drive_id')
        if m.get('device_id') is not None:
            self.device_id = m.get('device_id')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        self.exist_link = []
        if m.get('exist_link') is not None:
            for k in m.get('exist_link'):
                temp_model = LinkInfo()
                self.exist_link.append(temp_model.from_map(k))
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('expires_in') is not None:
            self.expires_in = m.get('expires_in')
        if m.get('is_first_login') is not None:
            self.is_first_login = m.get('is_first_login')
        if m.get('need_link') is not None:
            self.need_link = m.get('need_link')
        if m.get('need_rp_verify') is not None:
            self.need_rp_verify = m.get('need_rp_verify')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('pin_setup') is not None:
            self.pin_setup = m.get('pin_setup')
        if m.get('refresh_token') is not None:
            self.refresh_token = m.get('refresh_token')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('token_type') is not None:
            self.token_type = m.get('token_type')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class CancelLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckExistResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        is_exist: bool = None,
        phone_number: str = None,
        phone_region: str = None,
    ):
        # 当前手机号是否存在
        self.is_exist = is_exist
        # 待查询的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region

    def validate(self):
        self.validate_required(self.is_exist, 'is_exist')
        self.validate_required(self.phone_number, 'phone_number')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_exist is not None:
            result['is_exist'] = self.is_exist
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('is_exist') is not None:
            self.is_exist = m.get('is_exist')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        return self


class CheckExistModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CheckExistResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CheckExistResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCodeResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        state: str = None,
    ):
        # 修改密码的临时授权码
        self.state = state

    def validate(self):
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class VerifyCodeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: VerifyCodeResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = VerifyCodeResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAccessTokenByLinkInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class LinkInfoResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        authentication_type: str = None,
        created_at: int = None,
        display_name: str = None,
        domain_id: str = None,
        extra: str = None,
        identity: str = None,
        last_login_time: int = None,
        status: str = None,
        user_id: str = None,
    ):
        # 认证类型
        self.authentication_type = authentication_type
        # 创建时间
        self.created_at = created_at
        # 显示名称
        self.display_name = display_name
        # Domain ID
        self.domain_id = domain_id
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 最后登录时间
        self.last_login_time = last_login_time
        # 状态
        self.status = status
        # 用户ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.authentication_type, 'authentication_type')
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.last_login_time, 'last_login_time')
        self.validate_required(self.status, 'status')
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication_type is not None:
            result['authentication_type'] = self.authentication_type
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.last_login_time is not None:
            result['last_login_time'] = self.last_login_time
        if self.status is not None:
            result['status'] = self.status
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authentication_type') is not None:
            self.authentication_type = m.get('authentication_type')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('last_login_time') is not None:
            self.last_login_time = m.get('last_login_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetLinkInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: LinkInfoResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = LinkInfoResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class LinkInfoListResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[LinkInfoResponse] = None,
    ):
        # items
        self.items = items

    def validate(self):
        self.validate_required(self.items, 'items')
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = LinkInfoResponse()
                self.items.append(temp_model.from_map(k))
        return self


class GetLinkInfoByUserIdModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: LinkInfoListResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = LinkInfoListResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPublicKeyResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        key_pair_id: str = None,
        public_key: str = None,
    ):
        # App ID
        self.app_id = app_id
        self.key_pair_id = key_pair_id
        # RSA加密算法的公钥, PEM格式
        self.public_key = public_key

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.public_key, 'public_key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.key_pair_id is not None:
            result['key_pair_id'] = self.key_pair_id
        if self.public_key is not None:
            result['public_key'] = self.public_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('key_pair_id') is not None:
            self.key_pair_id = m.get('key_pair_id')
        if m.get('public_key') is not None:
            self.public_key = m.get('public_key')
        return self


class GetPublicKeyModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetPublicKeyResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetPublicKeyResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class LinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class LoginModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AccountRevokeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class SendSmsCodeResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        sms_code_id: str = None,
    ):
        # 验证码ID
        self.sms_code_id = sms_code_id

    def validate(self):
        self.validate_required(self.sms_code_id, 'sms_code_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sms_code_id is not None:
            result['sms_code_id'] = self.sms_code_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sms_code_id') is not None:
            self.sms_code_id = m.get('sms_code_id')
        return self


class SendSmsCodeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SendSmsCodeResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SendSmsCodeResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AccountTokenModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AccountAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AccountAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UnlinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class ExportAuditLogResponse(TeaModel):
    """
    导出审计日志response
    """
    def __init__(
        self,
        async_task_id: str = None,
    ):
        self.async_task_id = async_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        return self


class ExportAuditLogModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ExportAuditLogResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ExportAuditLogResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AccountLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        authentication_type: str = None,
        login_type: str = None,
    ):
        # authentication_type
        self.authentication_type = authentication_type
        # login_type
        self.login_type = login_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication_type is not None:
            result['authentication_type'] = self.authentication_type
        if self.login_type is not None:
            result['login_type'] = self.login_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authentication_type') is not None:
            self.authentication_type = m.get('authentication_type')
        if m.get('login_type') is not None:
            self.login_type = m.get('login_type')
        return self


class AuditMgmtLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        file_name: str = None,
        query: str = None,
    ):
        # file_name
        self.file_name = file_name
        # query
        self.query = query

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.query is not None:
            result['query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('query') is not None:
            self.query = m.get('query')
        return self


class DriveLogSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        name: str = None,
        owner_id: str = None,
        owner_name: str = None,
        owner_type: str = None,
        total_size: int = None,
    ):
        # name
        self.name = name
        # owner_id
        self.owner_id = owner_id
        # owner_name
        self.owner_name = owner_name
        # owner_type
        self.owner_type = owner_type
        # total_size
        self.total_size = total_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.owner_id is not None:
            result['owner_id'] = self.owner_id
        if self.owner_name is not None:
            result['owner_name'] = self.owner_name
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owner_id') is not None:
            self.owner_id = m.get('owner_id')
        if m.get('owner_name') is not None:
            self.owner_name = m.get('owner_name')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class DriveLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        name: str = None,
        owner_id: str = None,
        owner_name: str = None,
        owner_type: str = None,
        total_size: int = None,
        update_to: DriveLogSettingDetail = None,
    ):
        # name
        self.name = name
        # owner_id
        self.owner_id = owner_id
        # owner_name
        self.owner_name = owner_name
        # owner_type
        self.owner_type = owner_type
        # total_size
        self.total_size = total_size
        self.update_to = update_to

    def validate(self):
        if self.update_to:
            self.update_to.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.owner_id is not None:
            result['owner_id'] = self.owner_id
        if self.owner_name is not None:
            result['owner_name'] = self.owner_name
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.update_to is not None:
            result['update_to'] = self.update_to.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owner_id') is not None:
            self.owner_id = m.get('owner_id')
        if m.get('owner_name') is not None:
            self.owner_name = m.get('owner_name')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('update_to') is not None:
            temp_model = DriveLogSettingDetail()
            self.update_to = temp_model.from_map(m['update_to'])
        return self


class DomainBuildClient(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        copyright: str = None,
        name: str = None,
    ):
        self.copyright = copyright
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copyright is not None:
            result['copyright'] = self.copyright
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('copyright') is not None:
            self.copyright = m.get('copyright')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DomainBaseInfoLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        name: str = None,
    ):
        # name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DomainCnameInfoLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cert_name: str = None,
        cname: str = None,
    ):
        # cert_name
        self.cert_name = cert_name
        # cname
        self.cname = cname

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cname is not None:
            result['cname'] = self.cname
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cname') is not None:
            self.cname = m.get('cname')
        return self


class DomainFileConfigDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        allow_upload_custom_file_ext_list: List[str] = None,
        allow_upload_file_category_list: List[str] = None,
        recycle_bin_auto_delete_enabled: bool = None,
        recycle_bin_auto_delete_keep_second: int = None,
        same_name_file_upload_mode: str = None,
        single_file_upload_size_limit: int = None,
        web_client_download_mode: str = None,
    ):
        self.allow_upload_custom_file_ext_list = allow_upload_custom_file_ext_list
        self.allow_upload_file_category_list = allow_upload_file_category_list
        self.recycle_bin_auto_delete_enabled = recycle_bin_auto_delete_enabled
        self.recycle_bin_auto_delete_keep_second = recycle_bin_auto_delete_keep_second
        self.same_name_file_upload_mode = same_name_file_upload_mode
        self.single_file_upload_size_limit = single_file_upload_size_limit
        self.web_client_download_mode = web_client_download_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_upload_custom_file_ext_list is not None:
            result['allow_upload_custom_file_ext_list'] = self.allow_upload_custom_file_ext_list
        if self.allow_upload_file_category_list is not None:
            result['allow_upload_file_category_list'] = self.allow_upload_file_category_list
        if self.recycle_bin_auto_delete_enabled is not None:
            result['recycle_bin_auto_delete_enabled'] = self.recycle_bin_auto_delete_enabled
        if self.recycle_bin_auto_delete_keep_second is not None:
            result['recycle_bin_auto_delete_keep_second'] = self.recycle_bin_auto_delete_keep_second
        if self.same_name_file_upload_mode is not None:
            result['same_name_file_upload_mode'] = self.same_name_file_upload_mode
        if self.single_file_upload_size_limit is not None:
            result['single_file_upload_size_limit'] = self.single_file_upload_size_limit
        if self.web_client_download_mode is not None:
            result['web_client_download_mode'] = self.web_client_download_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allow_upload_custom_file_ext_list') is not None:
            self.allow_upload_custom_file_ext_list = m.get('allow_upload_custom_file_ext_list')
        if m.get('allow_upload_file_category_list') is not None:
            self.allow_upload_file_category_list = m.get('allow_upload_file_category_list')
        if m.get('recycle_bin_auto_delete_enabled') is not None:
            self.recycle_bin_auto_delete_enabled = m.get('recycle_bin_auto_delete_enabled')
        if m.get('recycle_bin_auto_delete_keep_second') is not None:
            self.recycle_bin_auto_delete_keep_second = m.get('recycle_bin_auto_delete_keep_second')
        if m.get('same_name_file_upload_mode') is not None:
            self.same_name_file_upload_mode = m.get('same_name_file_upload_mode')
        if m.get('single_file_upload_size_limit') is not None:
            self.single_file_upload_size_limit = m.get('single_file_upload_size_limit')
        if m.get('web_client_download_mode') is not None:
            self.web_client_download_mode = m.get('web_client_download_mode')
        return self


class FileCustomRoleInfoLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        action_list: List[str] = None,
        description: str = None,
        role_name: str = None,
        status: str = None,
    ):
        self.action_list = action_list
        self.description = description
        self.role_name = role_name
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.description is not None:
            result['description'] = self.description
        if self.role_name is not None:
            result['role_name'] = self.role_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('role_name') is not None:
            self.role_name = m.get('role_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ExternalMultiFileRevisionConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        revision_count: int = None,
        revision_merge_enabled: bool = None,
        revision_recycle_period: int = None,
    ):
        self.revision_count = revision_count
        self.revision_merge_enabled = revision_merge_enabled
        self.revision_recycle_period = revision_recycle_period

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.revision_count is not None:
            result['revision_count'] = self.revision_count
        if self.revision_merge_enabled is not None:
            result['revision_merge_enabled'] = self.revision_merge_enabled
        if self.revision_recycle_period is not None:
            result['revision_recycle_period'] = self.revision_recycle_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('revision_count') is not None:
            self.revision_count = m.get('revision_count')
        if m.get('revision_merge_enabled') is not None:
            self.revision_merge_enabled = m.get('revision_merge_enabled')
        if m.get('revision_recycle_period') is not None:
            self.revision_recycle_period = m.get('revision_recycle_period')
        return self


class CustomSideLinkConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        icon: str = None,
        link: str = None,
        text: str = None,
    ):
        self.icon = icon
        self.link = link
        self.text = text

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.icon is not None:
            result['icon'] = self.icon
        if self.link is not None:
            result['link'] = self.link
        if self.text is not None:
            result['text'] = self.text
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('link') is not None:
            self.link = m.get('link')
        if m.get('text') is not None:
            self.text = m.get('text')
        return self


class WxTrustedDomainConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        content: str = None,
        name: str = None,
        show: bool = None,
    ):
        self.content = content
        self.name = name
        self.show = show

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.name is not None:
            result['name'] = self.name
        if self.show is not None:
            result['show'] = self.show
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('show') is not None:
            self.show = m.get('show')
        return self


class DomainSeniorConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        client_download_enable: bool = None,
        csp_frame_ancestors: str = None,
        custom_login_appid: str = None,
        custom_login_url: str = None,
        custom_logout_url: str = None,
        custom_side_link_list: List[CustomSideLinkConfig] = None,
        home_page_bg_image_url: str = None,
        home_page_footer: str = None,
        home_page_footer_2: str = None,
        home_page_slogan: str = None,
        referer_enable: bool = None,
        wx_txt_list: List[WxTrustedDomainConfig] = None,
    ):
        # 桌面端管理
        self.client_download_enable = client_download_enable
        # 安全设置
        self.csp_frame_ancestors = csp_frame_ancestors
        # 自定义登录页面
        self.custom_login_appid = custom_login_appid
        self.custom_login_url = custom_login_url
        self.custom_logout_url = custom_logout_url
        # 自定义链接
        self.custom_side_link_list = custom_side_link_list
        # 界面设置
        self.home_page_bg_image_url = home_page_bg_image_url
        self.home_page_footer = home_page_footer
        self.home_page_footer_2 = home_page_footer_2
        self.home_page_slogan = home_page_slogan
        self.referer_enable = referer_enable
        self.wx_txt_list = wx_txt_list

    def validate(self):
        if self.custom_side_link_list:
            for k in self.custom_side_link_list:
                if k:
                    k.validate()
        if self.wx_txt_list:
            for k in self.wx_txt_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_download_enable is not None:
            result['client_download_enable'] = self.client_download_enable
        if self.csp_frame_ancestors is not None:
            result['csp_frame_ancestors'] = self.csp_frame_ancestors
        if self.custom_login_appid is not None:
            result['custom_login_appid'] = self.custom_login_appid
        if self.custom_login_url is not None:
            result['custom_login_url'] = self.custom_login_url
        if self.custom_logout_url is not None:
            result['custom_logout_url'] = self.custom_logout_url
        result['custom_side_link_list'] = []
        if self.custom_side_link_list is not None:
            for k in self.custom_side_link_list:
                result['custom_side_link_list'].append(k.to_map() if k else None)
        if self.home_page_bg_image_url is not None:
            result['home_page_bg_image_url'] = self.home_page_bg_image_url
        if self.home_page_footer is not None:
            result['home_page_footer'] = self.home_page_footer
        if self.home_page_footer_2 is not None:
            result['home_page_footer2'] = self.home_page_footer_2
        if self.home_page_slogan is not None:
            result['home_page_slogan'] = self.home_page_slogan
        if self.referer_enable is not None:
            result['referer_enable'] = self.referer_enable
        result['wx_txt_list'] = []
        if self.wx_txt_list is not None:
            for k in self.wx_txt_list:
                result['wx_txt_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('client_download_enable') is not None:
            self.client_download_enable = m.get('client_download_enable')
        if m.get('csp_frame_ancestors') is not None:
            self.csp_frame_ancestors = m.get('csp_frame_ancestors')
        if m.get('custom_login_appid') is not None:
            self.custom_login_appid = m.get('custom_login_appid')
        if m.get('custom_login_url') is not None:
            self.custom_login_url = m.get('custom_login_url')
        if m.get('custom_logout_url') is not None:
            self.custom_logout_url = m.get('custom_logout_url')
        self.custom_side_link_list = []
        if m.get('custom_side_link_list') is not None:
            for k in m.get('custom_side_link_list'):
                temp_model = CustomSideLinkConfig()
                self.custom_side_link_list.append(temp_model.from_map(k))
        if m.get('home_page_bg_image_url') is not None:
            self.home_page_bg_image_url = m.get('home_page_bg_image_url')
        if m.get('home_page_footer') is not None:
            self.home_page_footer = m.get('home_page_footer')
        if m.get('home_page_footer2') is not None:
            self.home_page_footer_2 = m.get('home_page_footer2')
        if m.get('home_page_slogan') is not None:
            self.home_page_slogan = m.get('home_page_slogan')
        if m.get('referer_enable') is not None:
            self.referer_enable = m.get('referer_enable')
        self.wx_txt_list = []
        if m.get('wx_txt_list') is not None:
            for k in m.get('wx_txt_list'):
                temp_model = WxTrustedDomainConfig()
                self.wx_txt_list.append(temp_model.from_map(k))
        return self


class EntMgmtLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        build_client: DomainBuildClient = None,
        domain_base_info: DomainBaseInfoLogDetail = None,
        domain_cname_info: DomainCnameInfoLogDetail = None,
        file_config: DomainFileConfigDetail = None,
        file_custom_role_info: FileCustomRoleInfoLogDetail = None,
        file_custom_role_info_updated_to: FileCustomRoleInfoLogDetail = None,
        multi_revision_config: ExternalMultiFileRevisionConfig = None,
        senior_config: DomainSeniorConfig = None,
    ):
        self.build_client = build_client
        self.domain_base_info = domain_base_info
        self.domain_cname_info = domain_cname_info
        self.file_config = file_config
        self.file_custom_role_info = file_custom_role_info
        self.file_custom_role_info_updated_to = file_custom_role_info_updated_to
        self.multi_revision_config = multi_revision_config
        self.senior_config = senior_config

    def validate(self):
        if self.build_client:
            self.build_client.validate()
        if self.domain_base_info:
            self.domain_base_info.validate()
        if self.domain_cname_info:
            self.domain_cname_info.validate()
        if self.file_config:
            self.file_config.validate()
        if self.file_custom_role_info:
            self.file_custom_role_info.validate()
        if self.file_custom_role_info_updated_to:
            self.file_custom_role_info_updated_to.validate()
        if self.multi_revision_config:
            self.multi_revision_config.validate()
        if self.senior_config:
            self.senior_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_client is not None:
            result['build_client'] = self.build_client.to_map()
        if self.domain_base_info is not None:
            result['domain_base_info'] = self.domain_base_info.to_map()
        if self.domain_cname_info is not None:
            result['domain_cname_info'] = self.domain_cname_info.to_map()
        if self.file_config is not None:
            result['file_config'] = self.file_config.to_map()
        if self.file_custom_role_info is not None:
            result['file_custom_role_info'] = self.file_custom_role_info.to_map()
        if self.file_custom_role_info_updated_to is not None:
            result['file_custom_role_info_updated_to'] = self.file_custom_role_info_updated_to.to_map()
        if self.multi_revision_config is not None:
            result['multi_revision_config'] = self.multi_revision_config.to_map()
        if self.senior_config is not None:
            result['senior_config'] = self.senior_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('build_client') is not None:
            temp_model = DomainBuildClient()
            self.build_client = temp_model.from_map(m['build_client'])
        if m.get('domain_base_info') is not None:
            temp_model = DomainBaseInfoLogDetail()
            self.domain_base_info = temp_model.from_map(m['domain_base_info'])
        if m.get('domain_cname_info') is not None:
            temp_model = DomainCnameInfoLogDetail()
            self.domain_cname_info = temp_model.from_map(m['domain_cname_info'])
        if m.get('file_config') is not None:
            temp_model = DomainFileConfigDetail()
            self.file_config = temp_model.from_map(m['file_config'])
        if m.get('file_custom_role_info') is not None:
            temp_model = FileCustomRoleInfoLogDetail()
            self.file_custom_role_info = temp_model.from_map(m['file_custom_role_info'])
        if m.get('file_custom_role_info_updated_to') is not None:
            temp_model = FileCustomRoleInfoLogDetail()
            self.file_custom_role_info_updated_to = temp_model.from_map(m['file_custom_role_info_updated_to'])
        if m.get('multi_revision_config') is not None:
            temp_model = ExternalMultiFileRevisionConfig()
            self.multi_revision_config = temp_model.from_map(m['multi_revision_config'])
        if m.get('senior_config') is not None:
            temp_model = DomainSeniorConfig()
            self.senior_config = temp_model.from_map(m['senior_config'])
        return self


class FileLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        decompress_file_list: List[str] = None,
        new_name: str = None,
        parent_path: str = None,
        rev_version: int = None,
        revision_id: str = None,
        size: int = None,
        to_parent_path: str = None,
        to_parent_path_type: str = None,
        type: str = None,
    ):
        self.decompress_file_list = decompress_file_list
        # new_name
        self.new_name = new_name
        # parent_path
        self.parent_path = parent_path
        # revision_version
        self.rev_version = rev_version
        # revision_id
        self.revision_id = revision_id
        # Size
        self.size = size
        # to_parent_path
        self.to_parent_path = to_parent_path
        # to_parent_path_type
        self.to_parent_path_type = to_parent_path_type
        # type
        self.type = type

    def validate(self):
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.decompress_file_list is not None:
            result['decompress_file_list'] = self.decompress_file_list
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.parent_path is not None:
            result['parent_path'] = self.parent_path
        if self.rev_version is not None:
            result['rev_version'] = self.rev_version
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.size is not None:
            result['size'] = self.size
        if self.to_parent_path is not None:
            result['to_parent_path'] = self.to_parent_path
        if self.to_parent_path_type is not None:
            result['to_parent_path_type'] = self.to_parent_path_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('decompress_file_list') is not None:
            self.decompress_file_list = m.get('decompress_file_list')
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('parent_path') is not None:
            self.parent_path = m.get('parent_path')
        if m.get('rev_version') is not None:
            self.rev_version = m.get('rev_version')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('to_parent_path') is not None:
            self.to_parent_path = m.get('to_parent_path')
        if m.get('to_parent_path_type') is not None:
            self.to_parent_path_type = m.get('to_parent_path_type')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GroupLogSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        name: str = None,
        parent_group_id: str = None,
        parent_group_name: str = None,
    ):
        # name
        self.name = name
        # parent_group_id
        self.parent_group_id = parent_group_id
        # parent_group_name
        self.parent_group_name = parent_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.parent_group_id is not None:
            result['parent_group_id'] = self.parent_group_id
        if self.parent_group_name is not None:
            result['parent_group_name'] = self.parent_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_group_id') is not None:
            self.parent_group_id = m.get('parent_group_id')
        if m.get('parent_group_name') is not None:
            self.parent_group_name = m.get('parent_group_name')
        return self


class GroupLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        name: str = None,
        parent_group_id: str = None,
        parent_group_name: str = None,
        update_to: GroupLogSettingDetail = None,
    ):
        # name
        self.name = name
        # parent_group_id
        self.parent_group_id = parent_group_id
        # parent_group_name
        self.parent_group_name = parent_group_name
        self.update_to = update_to

    def validate(self):
        if self.update_to:
            self.update_to.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.parent_group_id is not None:
            result['parent_group_id'] = self.parent_group_id
        if self.parent_group_name is not None:
            result['parent_group_name'] = self.parent_group_name
        if self.update_to is not None:
            result['update_to'] = self.update_to.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_group_id') is not None:
            self.parent_group_id = m.get('parent_group_id')
        if m.get('parent_group_name') is not None:
            self.parent_group_name = m.get('parent_group_name')
        if m.get('update_to') is not None:
            temp_model = GroupLogSettingDetail()
            self.update_to = temp_model.from_map(m['update_to'])
        return self


class DingSyncConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cron: str = None,
        enabled: bool = None,
    ):
        self.cron = cron
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['cron'] = self.cron
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cron') is not None:
            self.cron = m.get('cron')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class LDAPSyncConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cron: str = None,
        enabled: bool = None,
        group_filter: str = None,
        group_object_class: str = None,
        user_filter: str = None,
        user_object_class: str = None,
    ):
        self.cron = cron
        self.enabled = enabled
        self.group_filter = group_filter
        self.group_object_class = group_object_class
        self.user_filter = user_filter
        self.user_object_class = user_object_class

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['cron'] = self.cron
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.group_filter is not None:
            result['group_filter'] = self.group_filter
        if self.group_object_class is not None:
            result['group_object_class'] = self.group_object_class
        if self.user_filter is not None:
            result['user_filter'] = self.user_filter
        if self.user_object_class is not None:
            result['user_object_class'] = self.user_object_class
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cron') is not None:
            self.cron = m.get('cron')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('group_filter') is not None:
            self.group_filter = m.get('group_filter')
        if m.get('group_object_class') is not None:
            self.group_object_class = m.get('group_object_class')
        if m.get('user_filter') is not None:
            self.user_filter = m.get('user_filter')
        if m.get('user_object_class') is not None:
            self.user_object_class = m.get('user_object_class')
        return self


class LdapConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        admin_dn: str = None,
        admin_password: str = None,
        base_dn: str = None,
        display_name_key: str = None,
        global_uid: str = None,
        host: str = None,
        port: int = None,
        sync_config: LDAPSyncConfig = None,
        type: str = None,
        uid: str = None,
        version: str = None,
    ):
        self.admin_dn = admin_dn
        self.admin_password = admin_password
        self.base_dn = base_dn
        self.display_name_key = display_name_key
        self.global_uid = global_uid
        self.host = host
        self.port = port
        self.sync_config = sync_config
        self.type = type
        self.uid = uid
        self.version = version

    def validate(self):
        if self.sync_config:
            self.sync_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.admin_dn is not None:
            result['admin_dn'] = self.admin_dn
        if self.admin_password is not None:
            result['admin_password'] = self.admin_password
        if self.base_dn is not None:
            result['base_dn'] = self.base_dn
        if self.display_name_key is not None:
            result['display_name_key'] = self.display_name_key
        if self.global_uid is not None:
            result['global_uid'] = self.global_uid
        if self.host is not None:
            result['host'] = self.host
        if self.port is not None:
            result['port'] = self.port
        if self.sync_config is not None:
            result['sync_config'] = self.sync_config.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.uid is not None:
            result['uid'] = self.uid
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('admin_dn') is not None:
            self.admin_dn = m.get('admin_dn')
        if m.get('admin_password') is not None:
            self.admin_password = m.get('admin_password')
        if m.get('base_dn') is not None:
            self.base_dn = m.get('base_dn')
        if m.get('display_name_key') is not None:
            self.display_name_key = m.get('display_name_key')
        if m.get('global_uid') is not None:
            self.global_uid = m.get('global_uid')
        if m.get('host') is not None:
            self.host = m.get('host')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('sync_config') is not None:
            temp_model = LDAPSyncConfig()
            self.sync_config = temp_model.from_map(m['sync_config'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class WeChatSyncConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cron: str = None,
        enabled: bool = None,
        tag_id: str = None,
    ):
        self.cron = cron
        self.enabled = enabled
        self.tag_id = tag_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron is not None:
            result['cron'] = self.cron
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.tag_id is not None:
            result['tag_id'] = self.tag_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cron') is not None:
            self.cron = m.get('cron')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('tag_id') is not None:
            self.tag_id = m.get('tag_id')
        return self


class LoginMgmtLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        ding_sync_config: DingSyncConfig = None,
        enable: bool = None,
        ldap_config: LdapConfig = None,
        wechat_sync_config: WeChatSyncConfig = None,
    ):
        # app_id
        self.app_id = app_id
        self.ding_sync_config = ding_sync_config
        # enable
        self.enable = enable
        self.ldap_config = ldap_config
        self.wechat_sync_config = wechat_sync_config

    def validate(self):
        if self.ding_sync_config:
            self.ding_sync_config.validate()
        if self.ldap_config:
            self.ldap_config.validate()
        if self.wechat_sync_config:
            self.wechat_sync_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.ding_sync_config is not None:
            result['ding_sync_config'] = self.ding_sync_config.to_map()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.ldap_config is not None:
            result['ldap_config'] = self.ldap_config.to_map()
        if self.wechat_sync_config is not None:
            result['wechat_sync_config'] = self.wechat_sync_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('ding_sync_config') is not None:
            temp_model = DingSyncConfig()
            self.ding_sync_config = temp_model.from_map(m['ding_sync_config'])
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('ldap_config') is not None:
            temp_model = LdapConfig()
            self.ldap_config = temp_model.from_map(m['ldap_config'])
        if m.get('wechat_sync_config') is not None:
            temp_model = WeChatSyncConfig()
            self.wechat_sync_config = temp_model.from_map(m['wechat_sync_config'])
        return self


class MembershipLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
        member_name: str = None,
        member_type: str = None,
    ):
        # group_id
        self.group_id = group_id
        # group_name
        self.group_name = group_name
        # member_name
        self.member_name = member_name
        # member_type
        self.member_type = member_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.member_name is not None:
            result['member_name'] = self.member_name
        if self.member_type is not None:
            result['member_type'] = self.member_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('member_name') is not None:
            self.member_name = m.get('member_name')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        return self


class RoleLogSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        role_tag_description: str = None,
        role_tag_name: str = None,
    ):
        # role_tag_description
        self.role_tag_description = role_tag_description
        # role_tag_name
        self.role_tag_name = role_tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_tag_description is not None:
            result['role_tag_description'] = self.role_tag_description
        if self.role_tag_name is not None:
            result['role_tag_name'] = self.role_tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('role_tag_description') is not None:
            self.role_tag_description = m.get('role_tag_description')
        if m.get('role_tag_name') is not None:
            self.role_tag_name = m.get('role_tag_name')
        return self


class RoleLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        manage_resource_id: str = None,
        manage_resource_name: str = None,
        manage_resource_type: str = None,
        member_type: str = None,
        role_id: str = None,
        role_tag_description: str = None,
        role_tag_name: str = None,
        update_to: RoleLogSettingDetail = None,
    ):
        # manage_resource_id
        self.manage_resource_id = manage_resource_id
        # manage_resource_name
        self.manage_resource_name = manage_resource_name
        # manage_resource_type
        self.manage_resource_type = manage_resource_type
        # member_type
        self.member_type = member_type
        # role_id
        self.role_id = role_id
        # role_tag_description
        self.role_tag_description = role_tag_description
        # role_tag_name
        self.role_tag_name = role_tag_name
        self.update_to = update_to

    def validate(self):
        if self.update_to:
            self.update_to.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.manage_resource_id is not None:
            result['manage_resource_id'] = self.manage_resource_id
        if self.manage_resource_name is not None:
            result['manage_resource_name'] = self.manage_resource_name
        if self.manage_resource_type is not None:
            result['manage_resource_type'] = self.manage_resource_type
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.role_tag_description is not None:
            result['role_tag_description'] = self.role_tag_description
        if self.role_tag_name is not None:
            result['role_tag_name'] = self.role_tag_name
        if self.update_to is not None:
            result['update_to'] = self.update_to.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('manage_resource_id') is not None:
            self.manage_resource_id = m.get('manage_resource_id')
        if m.get('manage_resource_name') is not None:
            self.manage_resource_name = m.get('manage_resource_name')
        if m.get('manage_resource_type') is not None:
            self.manage_resource_type = m.get('manage_resource_type')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('role_tag_description') is not None:
            self.role_tag_description = m.get('role_tag_description')
        if m.get('role_tag_name') is not None:
            self.role_tag_name = m.get('role_tag_name')
        if m.get('update_to') is not None:
            temp_model = RoleLogSettingDetail()
            self.update_to = temp_model.from_map(m['update_to'])
        return self


class ShareConfigLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enable: bool = None,
    ):
        # enable
        self.enable = enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        return self


class ShareLinkConfigLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enable: bool = None,
    ):
        # enable
        self.enable = enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        return self


class WatermarkEnableConfig(TeaModel):
    """
    WatermarkEnableConfig 功能开关及显示配置
    """
    def __init__(
        self,
        display_access_user_name: bool = None,
        display_custom_text: str = None,
        display_share_link_creator_name: bool = None,
        enable_doc_preview: bool = None,
        enable_on_preview: bool = None,
    ):
        self.display_access_user_name = display_access_user_name
        self.display_custom_text = display_custom_text
        self.display_share_link_creator_name = display_share_link_creator_name
        self.enable_doc_preview = enable_doc_preview
        self.enable_on_preview = enable_on_preview

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_access_user_name is not None:
            result['display_access_user_name'] = self.display_access_user_name
        if self.display_custom_text is not None:
            result['display_custom_text'] = self.display_custom_text
        if self.display_share_link_creator_name is not None:
            result['display_shareLink_creator_name'] = self.display_share_link_creator_name
        if self.enable_doc_preview is not None:
            result['enable_doc_preview'] = self.enable_doc_preview
        if self.enable_on_preview is not None:
            result['enable_on_preview'] = self.enable_on_preview
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('display_access_user_name') is not None:
            self.display_access_user_name = m.get('display_access_user_name')
        if m.get('display_custom_text') is not None:
            self.display_custom_text = m.get('display_custom_text')
        if m.get('display_shareLink_creator_name') is not None:
            self.display_share_link_creator_name = m.get('display_shareLink_creator_name')
        if m.get('enable_doc_preview') is not None:
            self.enable_doc_preview = m.get('enable_doc_preview')
        if m.get('enable_on_preview') is not None:
            self.enable_on_preview = m.get('enable_on_preview')
        return self


class SecurityLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        share_config: ShareConfigLogDetail = None,
        share_link_config: ShareLinkConfigLogDetail = None,
        watermark_config: WatermarkEnableConfig = None,
    ):
        self.share_config = share_config
        self.share_link_config = share_link_config
        self.watermark_config = watermark_config

    def validate(self):
        if self.share_config:
            self.share_config.validate()
        if self.share_link_config:
            self.share_link_config.validate()
        if self.watermark_config:
            self.watermark_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.share_config is not None:
            result['share_config'] = self.share_config.to_map()
        if self.share_link_config is not None:
            result['share_link_config'] = self.share_link_config.to_map()
        if self.watermark_config is not None:
            result['watermark_config'] = self.watermark_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('share_config') is not None:
            temp_model = ShareConfigLogDetail()
            self.share_config = temp_model.from_map(m['share_config'])
        if m.get('share_link_config') is not None:
            temp_model = ShareLinkConfigLogDetail()
            self.share_link_config = temp_model.from_map(m['share_link_config'])
        if m.get('watermark_config') is not None:
            temp_model = WatermarkEnableConfig()
            self.watermark_config = temp_model.from_map(m['watermark_config'])
        return self


class ShareLinkLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        creatable: bool = None,
        enable_preview: bool = None,
        enable_save_download: bool = None,
        enable_visible: bool = None,
        expiration: str = None,
        has_multi_object: bool = None,
        has_pwd: bool = None,
        office_editable: bool = None,
        preview_limit: int = None,
        require_login: bool = None,
        save_download_limit: int = None,
        share_created_at: str = None,
        share_creator_id: str = None,
        share_creator_name: str = None,
        share_id: str = None,
        to_parent_path: str = None,
        to_parent_path_type: str = None,
        type: str = None,
    ):
        # creatable
        self.creatable = creatable
        # enable_preview
        self.enable_preview = enable_preview
        # enable_save_download
        self.enable_save_download = enable_save_download
        # enable_visible
        self.enable_visible = enable_visible
        # expiration
        self.expiration = expiration
        # has_multi_object
        self.has_multi_object = has_multi_object
        # has_pwd
        self.has_pwd = has_pwd
        # office_editable
        self.office_editable = office_editable
        # preview_limit
        self.preview_limit = preview_limit
        # require_login
        self.require_login = require_login
        # save_download_limit
        self.save_download_limit = save_download_limit
        # share_created_at
        self.share_created_at = share_created_at
        # share_creator_id
        self.share_creator_id = share_creator_id
        # share_creator_name
        self.share_creator_name = share_creator_name
        # share_id (脱敏)
        self.share_id = share_id
        # to_parent_path
        self.to_parent_path = to_parent_path
        # to_parent_path_type
        self.to_parent_path_type = to_parent_path_type
        # type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.enable_preview is not None:
            result['enable_preview'] = self.enable_preview
        if self.enable_save_download is not None:
            result['enable_save_download'] = self.enable_save_download
        if self.enable_visible is not None:
            result['enable_visible'] = self.enable_visible
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.has_multi_object is not None:
            result['has_multi_object'] = self.has_multi_object
        if self.has_pwd is not None:
            result['has_pwd'] = self.has_pwd
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.share_created_at is not None:
            result['share_created_at'] = self.share_created_at
        if self.share_creator_id is not None:
            result['share_creator_id'] = self.share_creator_id
        if self.share_creator_name is not None:
            result['share_creator_name'] = self.share_creator_name
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_parent_path is not None:
            result['to_parent_path'] = self.to_parent_path
        if self.to_parent_path_type is not None:
            result['to_parent_path_type'] = self.to_parent_path_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('enable_preview') is not None:
            self.enable_preview = m.get('enable_preview')
        if m.get('enable_save_download') is not None:
            self.enable_save_download = m.get('enable_save_download')
        if m.get('enable_visible') is not None:
            self.enable_visible = m.get('enable_visible')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('has_multi_object') is not None:
            self.has_multi_object = m.get('has_multi_object')
        if m.get('has_pwd') is not None:
            self.has_pwd = m.get('has_pwd')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('share_created_at') is not None:
            self.share_created_at = m.get('share_created_at')
        if m.get('share_creator_id') is not None:
            self.share_creator_id = m.get('share_creator_id')
        if m.get('share_creator_name') is not None:
            self.share_creator_name = m.get('share_creator_name')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_parent_path') is not None:
            self.to_parent_path = m.get('to_parent_path')
        if m.get('to_parent_path_type') is not None:
            self.to_parent_path_type = m.get('to_parent_path_type')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ShareLogSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        disinherit_sub_group: bool = None,
        expiration: str = None,
        permissions: List[str] = None,
        role_id: str = None,
        role_name: str = None,
    ):
        # disinherit_sub_group
        self.disinherit_sub_group = disinherit_sub_group
        # expiration
        self.expiration = expiration
        # permissions
        self.permissions = permissions
        # role_id
        self.role_id = role_id
        # role_name
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disinherit_sub_group is not None:
            result['disinherit_sub_group'] = self.disinherit_sub_group
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.role_name is not None:
            result['role_name'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disinherit_sub_group') is not None:
            self.disinherit_sub_group = m.get('disinherit_sub_group')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('role_name') is not None:
            self.role_name = m.get('role_name')
        return self


class ShareLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        disinherit_sub_group: bool = None,
        expiration: str = None,
        parent_path: str = None,
        permissions: List[str] = None,
        role_id: str = None,
        role_name: str = None,
        share_to_id: str = None,
        share_to_name: str = None,
        share_to_type: str = None,
        type: str = None,
        update_to: ShareLogSettingDetail = None,
    ):
        # disinherit_sub_group
        self.disinherit_sub_group = disinherit_sub_group
        # expiration
        self.expiration = expiration
        # parent_path
        self.parent_path = parent_path
        # permissions
        self.permissions = permissions
        # role_id
        self.role_id = role_id
        # role_name
        self.role_name = role_name
        # share_to_id
        self.share_to_id = share_to_id
        # share_to_name
        self.share_to_name = share_to_name
        # share_to_type
        self.share_to_type = share_to_type
        # type
        self.type = type
        self.update_to = update_to

    def validate(self):
        if self.update_to:
            self.update_to.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disinherit_sub_group is not None:
            result['disinherit_sub_group'] = self.disinherit_sub_group
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.parent_path is not None:
            result['parent_path'] = self.parent_path
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.role_name is not None:
            result['role_name'] = self.role_name
        if self.share_to_id is not None:
            result['share_to_id'] = self.share_to_id
        if self.share_to_name is not None:
            result['share_to_name'] = self.share_to_name
        if self.share_to_type is not None:
            result['share_to_type'] = self.share_to_type
        if self.type is not None:
            result['type'] = self.type
        if self.update_to is not None:
            result['update_to'] = self.update_to.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disinherit_sub_group') is not None:
            self.disinherit_sub_group = m.get('disinherit_sub_group')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('parent_path') is not None:
            self.parent_path = m.get('parent_path')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('role_name') is not None:
            self.role_name = m.get('role_name')
        if m.get('share_to_id') is not None:
            self.share_to_id = m.get('share_to_id')
        if m.get('share_to_name') is not None:
            self.share_to_name = m.get('share_to_name')
        if m.get('share_to_type') is not None:
            self.share_to_type = m.get('share_to_type')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('update_to') is not None:
            temp_model = ShareLogSettingDetail()
            self.update_to = temp_model.from_map(m['update_to'])
        return self


class UserLogSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        expired_at: int = None,
        name: str = None,
        role_id: str = None,
    ):
        self.expired_at = expired_at
        # name
        self.name = name
        # role_id
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.name is not None:
            result['name'] = self.name
        if self.role_id is not None:
            result['role_id'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        return self


class UserLogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        email: str = None,
        expired_at: int = None,
        name: str = None,
        phone: str = None,
        role_id: str = None,
        update_to: UserLogSettingDetail = None,
    ):
        # email
        self.email = email
        self.expired_at = expired_at
        # name
        self.name = name
        # phone
        self.phone = phone
        # role_id
        self.role_id = role_id
        self.update_to = update_to

    def validate(self):
        if self.update_to:
            self.update_to.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.name is not None:
            result['name'] = self.name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.update_to is not None:
            result['update_to'] = self.update_to.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('update_to') is not None:
            temp_model = UserLogSettingDetail()
            self.update_to = temp_model.from_map(m['update_to'])
        return self


class LogDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        account_log_detail: AccountLogDetail = None,
        audit_mgmt_log_detail: AuditMgmtLogDetail = None,
        drive_log_detail: DriveLogDetail = None,
        ent_mgmt_log_detail: EntMgmtLogDetail = None,
        file_log_detail: FileLogDetail = None,
        group_log_detail: GroupLogDetail = None,
        login_mgmt_log_detail: LoginMgmtLogDetail = None,
        membership_log_detail: MembershipLogDetail = None,
        role_log_detail: RoleLogDetail = None,
        security_log_detail: SecurityLogDetail = None,
        share_link_log_detail: ShareLinkLogDetail = None,
        share_log_detail: ShareLogDetail = None,
        user_log_detail: UserLogDetail = None,
    ):
        self.account_log_detail = account_log_detail
        self.audit_mgmt_log_detail = audit_mgmt_log_detail
        self.drive_log_detail = drive_log_detail
        self.ent_mgmt_log_detail = ent_mgmt_log_detail
        self.file_log_detail = file_log_detail
        self.group_log_detail = group_log_detail
        self.login_mgmt_log_detail = login_mgmt_log_detail
        self.membership_log_detail = membership_log_detail
        self.role_log_detail = role_log_detail
        self.security_log_detail = security_log_detail
        self.share_link_log_detail = share_link_log_detail
        self.share_log_detail = share_log_detail
        self.user_log_detail = user_log_detail

    def validate(self):
        if self.account_log_detail:
            self.account_log_detail.validate()
        if self.audit_mgmt_log_detail:
            self.audit_mgmt_log_detail.validate()
        if self.drive_log_detail:
            self.drive_log_detail.validate()
        if self.ent_mgmt_log_detail:
            self.ent_mgmt_log_detail.validate()
        if self.file_log_detail:
            self.file_log_detail.validate()
        if self.group_log_detail:
            self.group_log_detail.validate()
        if self.login_mgmt_log_detail:
            self.login_mgmt_log_detail.validate()
        if self.membership_log_detail:
            self.membership_log_detail.validate()
        if self.role_log_detail:
            self.role_log_detail.validate()
        if self.security_log_detail:
            self.security_log_detail.validate()
        if self.share_link_log_detail:
            self.share_link_log_detail.validate()
        if self.share_log_detail:
            self.share_log_detail.validate()
        if self.user_log_detail:
            self.user_log_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_log_detail is not None:
            result['account_log_detail'] = self.account_log_detail.to_map()
        if self.audit_mgmt_log_detail is not None:
            result['audit_mgmt_log_detail'] = self.audit_mgmt_log_detail.to_map()
        if self.drive_log_detail is not None:
            result['drive_log_detail'] = self.drive_log_detail.to_map()
        if self.ent_mgmt_log_detail is not None:
            result['ent_mgmt_log_detail'] = self.ent_mgmt_log_detail.to_map()
        if self.file_log_detail is not None:
            result['file_log_detail'] = self.file_log_detail.to_map()
        if self.group_log_detail is not None:
            result['group_log_detail'] = self.group_log_detail.to_map()
        if self.login_mgmt_log_detail is not None:
            result['login_mgmt_log_detail'] = self.login_mgmt_log_detail.to_map()
        if self.membership_log_detail is not None:
            result['membership_log_detail'] = self.membership_log_detail.to_map()
        if self.role_log_detail is not None:
            result['role_log_detail'] = self.role_log_detail.to_map()
        if self.security_log_detail is not None:
            result['security_log_detail'] = self.security_log_detail.to_map()
        if self.share_link_log_detail is not None:
            result['share_link_log_detail'] = self.share_link_log_detail.to_map()
        if self.share_log_detail is not None:
            result['share_log_detail'] = self.share_log_detail.to_map()
        if self.user_log_detail is not None:
            result['user_log_detail'] = self.user_log_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account_log_detail') is not None:
            temp_model = AccountLogDetail()
            self.account_log_detail = temp_model.from_map(m['account_log_detail'])
        if m.get('audit_mgmt_log_detail') is not None:
            temp_model = AuditMgmtLogDetail()
            self.audit_mgmt_log_detail = temp_model.from_map(m['audit_mgmt_log_detail'])
        if m.get('drive_log_detail') is not None:
            temp_model = DriveLogDetail()
            self.drive_log_detail = temp_model.from_map(m['drive_log_detail'])
        if m.get('ent_mgmt_log_detail') is not None:
            temp_model = EntMgmtLogDetail()
            self.ent_mgmt_log_detail = temp_model.from_map(m['ent_mgmt_log_detail'])
        if m.get('file_log_detail') is not None:
            temp_model = FileLogDetail()
            self.file_log_detail = temp_model.from_map(m['file_log_detail'])
        if m.get('group_log_detail') is not None:
            temp_model = GroupLogDetail()
            self.group_log_detail = temp_model.from_map(m['group_log_detail'])
        if m.get('login_mgmt_log_detail') is not None:
            temp_model = LoginMgmtLogDetail()
            self.login_mgmt_log_detail = temp_model.from_map(m['login_mgmt_log_detail'])
        if m.get('membership_log_detail') is not None:
            temp_model = MembershipLogDetail()
            self.membership_log_detail = temp_model.from_map(m['membership_log_detail'])
        if m.get('role_log_detail') is not None:
            temp_model = RoleLogDetail()
            self.role_log_detail = temp_model.from_map(m['role_log_detail'])
        if m.get('security_log_detail') is not None:
            temp_model = SecurityLogDetail()
            self.security_log_detail = temp_model.from_map(m['security_log_detail'])
        if m.get('share_link_log_detail') is not None:
            temp_model = ShareLinkLogDetail()
            self.share_link_log_detail = temp_model.from_map(m['share_link_log_detail'])
        if m.get('share_log_detail') is not None:
            temp_model = ShareLogDetail()
            self.share_log_detail = temp_model.from_map(m['share_log_detail'])
        if m.get('user_log_detail') is not None:
            temp_model = UserLogDetail()
            self.user_log_detail = temp_model.from_map(m['user_log_detail'])
        return self


class BaseAuditLogResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        client_device: str = None,
        client_ip: str = None,
        client_type: str = None,
        client_version: str = None,
        acted_at: str = None,
        action_category: str = None,
        action_type: str = None,
        actor_id: str = None,
        actor_name: str = None,
        actor_type: str = None,
        detail: LogDetail = None,
        file_path_type: str = None,
        log_id: str = None,
        object_id: str = None,
        object_name: str = None,
    ):
        # 客户端设备
        self.client_device = client_device
        # 客户端IP
        self.client_ip = client_ip
        # 客户端类型
        self.client_type = client_type
        # 客户端版本
        self.client_version = client_version
        # 操作时间
        self.acted_at = acted_at
        # 操作分类
        self.action_category = action_category
        # 操作类型
        self.action_type = action_type
        # 操作者ID
        self.actor_id = actor_id
        # 操作者名称
        self.actor_name = actor_name
        # 操作者类型
        self.actor_type = actor_type
        self.detail = detail
        # 文件空间类型
        self.file_path_type = file_path_type
        # 唯一标识一条日志
        self.log_id = log_id
        # 对象ID
        self.object_id = object_id
        # 对象名
        self.object_name = object_name

    def validate(self):
        if self.detail:
            self.detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_device is not None:
            result['ClientDevice'] = self.client_device
        if self.client_ip is not None:
            result['ClientIP'] = self.client_ip
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.acted_at is not None:
            result['acted_at'] = self.acted_at
        if self.action_category is not None:
            result['action_category'] = self.action_category
        if self.action_type is not None:
            result['action_type'] = self.action_type
        if self.actor_id is not None:
            result['actor_id'] = self.actor_id
        if self.actor_name is not None:
            result['actor_name'] = self.actor_name
        if self.actor_type is not None:
            result['actor_type'] = self.actor_type
        if self.detail is not None:
            result['detail'] = self.detail.to_map()
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.log_id is not None:
            result['log_id'] = self.log_id
        if self.object_id is not None:
            result['object_id'] = self.object_id
        if self.object_name is not None:
            result['object_name'] = self.object_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientDevice') is not None:
            self.client_device = m.get('ClientDevice')
        if m.get('ClientIP') is not None:
            self.client_ip = m.get('ClientIP')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('acted_at') is not None:
            self.acted_at = m.get('acted_at')
        if m.get('action_category') is not None:
            self.action_category = m.get('action_category')
        if m.get('action_type') is not None:
            self.action_type = m.get('action_type')
        if m.get('actor_id') is not None:
            self.actor_id = m.get('actor_id')
        if m.get('actor_name') is not None:
            self.actor_name = m.get('actor_name')
        if m.get('actor_type') is not None:
            self.actor_type = m.get('actor_type')
        if m.get('detail') is not None:
            temp_model = LogDetail()
            self.detail = temp_model.from_map(m['detail'])
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('log_id') is not None:
            self.log_id = m.get('log_id')
        if m.get('object_id') is not None:
            self.object_id = m.get('object_id')
        if m.get('object_name') is not None:
            self.object_name = m.get('object_name')
        return self


class SearchAuditLogResponse(TeaModel):
    """
    查询审计日志response
    """
    def __init__(
        self,
        items: List[BaseAuditLogResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseAuditLogResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class SearchAuditLogModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchAuditLogResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchAuditLogResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIdentityToBenefitPkgMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class CreateIdentityToBenefitPkgMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateIdentityToBenefitPkgMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateIdentityToBenefitPkgMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIdentityToBenefitPkgMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteIdentityToBenefitPkgMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteIdentityToBenefitPkgMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteIdentityToBenefitPkgMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BenefitPkgDeliveryInfoResponse(TeaModel):
    """
    Benefit package delivery info
    """
    def __init__(
        self,
        amount: int = None,
        created_at: str = None,
        expire_time: str = None,
        is_permanent: bool = None,
    ):
        # 权益包下发的数量
        self.amount = amount
        # 权益包下发的创建时间
        self.created_at = created_at
        # 权益包下发的超期时间，is_permanent为false时，返回有效值
        self.expire_time = expire_time
        # 权益包是否永久有效
        self.is_permanent = is_permanent

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['amount'] = self.amount
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.is_permanent is not None:
            result['is_permanent'] = self.is_permanent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('amount') is not None:
            self.amount = m.get('amount')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('is_permanent') is not None:
            self.is_permanent = m.get('is_permanent')
        return self


class BaseIdentityToBenefitPkgMappingResponse(TeaModel):
    """
    Identity to benefit pkg mapping info
    """
    def __init__(
        self,
        benefit_pkg_computation_rule: str = None,
        benefit_pkg_id: str = None,
        benefit_pkg_name: str = None,
        benefit_pkg_owner_id: str = None,
        benefit_pkg_priority: int = None,
        benefit_pkg_type: str = None,
        created_at: str = None,
        custom_benefit_meta: dict = None,
        delivery_info_list: List[BenefitPkgDeliveryInfoResponse] = None,
        identity_id: str = None,
        identity_type: str = None,
        updated_at: str = None,
    ):
        self.benefit_pkg_computation_rule = benefit_pkg_computation_rule
        self.benefit_pkg_id = benefit_pkg_id
        self.benefit_pkg_name = benefit_pkg_name
        self.benefit_pkg_owner_id = benefit_pkg_owner_id
        self.benefit_pkg_priority = benefit_pkg_priority
        self.benefit_pkg_type = benefit_pkg_type
        self.created_at = created_at
        self.custom_benefit_meta = custom_benefit_meta
        self.delivery_info_list = delivery_info_list
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.updated_at = updated_at

    def validate(self):
        if self.delivery_info_list:
            for k in self.delivery_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.benefit_pkg_computation_rule is not None:
            result['benefit_pkg_computation_rule'] = self.benefit_pkg_computation_rule
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.benefit_pkg_name is not None:
            result['benefit_pkg_name'] = self.benefit_pkg_name
        if self.benefit_pkg_owner_id is not None:
            result['benefit_pkg_owner_id'] = self.benefit_pkg_owner_id
        if self.benefit_pkg_priority is not None:
            result['benefit_pkg_priority'] = self.benefit_pkg_priority
        if self.benefit_pkg_type is not None:
            result['benefit_pkg_type'] = self.benefit_pkg_type
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.custom_benefit_meta is not None:
            result['custom_benefit_meta'] = self.custom_benefit_meta
        result['delivery_info_list'] = []
        if self.delivery_info_list is not None:
            for k in self.delivery_info_list:
                result['delivery_info_list'].append(k.to_map() if k else None)
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('benefit_pkg_computation_rule') is not None:
            self.benefit_pkg_computation_rule = m.get('benefit_pkg_computation_rule')
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('benefit_pkg_name') is not None:
            self.benefit_pkg_name = m.get('benefit_pkg_name')
        if m.get('benefit_pkg_owner_id') is not None:
            self.benefit_pkg_owner_id = m.get('benefit_pkg_owner_id')
        if m.get('benefit_pkg_priority') is not None:
            self.benefit_pkg_priority = m.get('benefit_pkg_priority')
        if m.get('benefit_pkg_type') is not None:
            self.benefit_pkg_type = m.get('benefit_pkg_type')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('custom_benefit_meta') is not None:
            self.custom_benefit_meta = m.get('custom_benefit_meta')
        self.delivery_info_list = []
        if m.get('delivery_info_list') is not None:
            for k in m.get('delivery_info_list'):
                temp_model = BenefitPkgDeliveryInfoResponse()
                self.delivery_info_list.append(temp_model.from_map(k))
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class GetIdentityToBenefitPkgMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BaseIdentityToBenefitPkgMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BaseIdentityToBenefitPkgMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIdentityToBenefitPkgMappingResponse(TeaModel):
    """
    List identity to benefit pkg mapping info
    """
    def __init__(
        self,
        items: List[BaseIdentityToBenefitPkgMappingResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseIdentityToBenefitPkgMappingResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListIdentityToBenefitPkgMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListIdentityToBenefitPkgMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListIdentityToBenefitPkgMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIdentityToBenefitPkgMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class UpdateIdentityToBenefitPkgMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateIdentityToBenefitPkgMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateIdentityToBenefitPkgMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BenefitMetaResponse(TeaModel):
    """
    Benefit meta response
    """
    def __init__(
        self,
        config: str = None,
        enabled: bool = None,
        quota: int = None,
    ):
        # 权益的配置
        self.config = config
        # 权益的开关
        self.enabled = enabled
        # 权益的配额
        self.quota = quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['config'] = self.config
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.quota is not None:
            result['quota'] = self.quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('quota') is not None:
            self.quota = m.get('quota')
        return self


class BenefitBaseResponse(TeaModel):
    """
    Benefit base info of benefit package
    """
    def __init__(
        self,
        benefit_id: str = None,
        benefit_meta: BenefitMetaResponse = None,
        benefit_pkg_id: str = None,
        name: str = None,
    ):
        # 权益的唯一标识
        self.benefit_id = benefit_id
        self.benefit_meta = benefit_meta
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # 权益的名称
        self.name = name

    def validate(self):
        if self.benefit_meta:
            self.benefit_meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.benefit_id is not None:
            result['benefit_id'] = self.benefit_id
        if self.benefit_meta is not None:
            result['benefit_meta'] = self.benefit_meta.to_map()
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('benefit_id') is not None:
            self.benefit_id = m.get('benefit_id')
        if m.get('benefit_meta') is not None:
            temp_model = BenefitMetaResponse()
            self.benefit_meta = temp_model.from_map(m['benefit_meta'])
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class IdentityBenefitPkgResponse(TeaModel):
    """
    Identity benefit package response
    """
    def __init__(
        self,
        benefit_list: List[BenefitBaseResponse] = None,
        benefit_pkg_id: str = None,
        delivery_info_list: List[BenefitPkgDeliveryInfoResponse] = None,
        name: str = None,
    ):
        # 权益包中的权益列表
        self.benefit_list = benefit_list
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # 权益包的下发信息
        self.delivery_info_list = delivery_info_list
        # 权益包的名称
        self.name = name

    def validate(self):
        if self.benefit_list:
            for k in self.benefit_list:
                if k:
                    k.validate()
        if self.delivery_info_list:
            for k in self.delivery_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['benefit_list'] = []
        if self.benefit_list is not None:
            for k in self.benefit_list:
                result['benefit_list'].append(k.to_map() if k else None)
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        result['delivery_info_list'] = []
        if self.delivery_info_list is not None:
            for k in self.delivery_info_list:
                result['delivery_info_list'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.benefit_list = []
        if m.get('benefit_list') is not None:
            for k in m.get('benefit_list'):
                temp_model = BenefitBaseResponse()
                self.benefit_list.append(temp_model.from_map(k))
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        self.delivery_info_list = []
        if m.get('delivery_info_list') is not None:
            for k in m.get('delivery_info_list'):
                temp_model = BenefitPkgDeliveryInfoResponse()
                self.delivery_info_list.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListIdentityBenefitPkgResponse(TeaModel):
    """
    List identity benefit package response
    """
    def __init__(
        self,
        items: List[IdentityBenefitPkgResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = IdentityBenefitPkgResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListIdentityBenefitPkgModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListIdentityBenefitPkgResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListIdentityBenefitPkgResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class WhitePercentConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        percent: int = None,
        total: int = None,
    ):
        self.percent = percent
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.percent is not None:
            result['percent'] = self.percent
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('percent') is not None:
            self.percent = m.get('percent')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class Store(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        accelerate_endpoint: str = None,
        base_path: str = None,
        bucket: str = None,
        cdn_endpoint: str = None,
        cdn_ratelimit_disable: bool = None,
        cdn_timelimit: str = None,
        cdn_url_auth_key: str = None,
        customized_accelerate_endpoint: str = None,
        customized_cdn_endpoint: str = None,
        customized_endpoint: str = None,
        customized_internal_endpoint: str = None,
        endpoint: str = None,
        enet_endpoint: str = None,
        enet_percent_config: WhitePercentConfig = None,
        internal_endpoint: str = None,
        location: str = None,
        ownership: str = None,
        policy: str = None,
        role_arn: str = None,
        store_id: str = None,
        type: str = None,
    ):
        # 全球加速地址
        self.accelerate_endpoint = accelerate_endpoint
        # 存储公共前缀
        self.base_path = base_path
        # bucket名称
        self.bucket = bucket
        # 内容分发地址
        self.cdn_endpoint = cdn_endpoint
        # 命中限速用户时是否关闭CDN地址返回
        self.cdn_ratelimit_disable = cdn_ratelimit_disable
        # CDN时间控制
        self.cdn_timelimit = cdn_timelimit
        # CDN鉴权key
        self.cdn_url_auth_key = cdn_url_auth_key
        # 自定义全球加速地址
        self.customized_accelerate_endpoint = customized_accelerate_endpoint
        # 自定义内容分发地址
        self.customized_cdn_endpoint = customized_cdn_endpoint
        # 自定义Public访问地址
        self.customized_endpoint = customized_endpoint
        # 自定义vpc访问地址
        self.customized_internal_endpoint = customized_internal_endpoint
        # Public访问地址
        self.endpoint = endpoint
        # 冷流地址
        self.enet_endpoint = enet_endpoint
        self.enet_percent_config = enet_percent_config
        # vpc访问地址
        self.internal_endpoint = internal_endpoint
        # 地点
        self.location = location
        # 存储归属，system表示系统提供，custom表示使用自己的存储
        self.ownership = ownership
        # Policy授权,system类型store会将bucket权限授予当前云账号
        self.policy = policy
        # 访问Bucket的角色ARN
        self.role_arn = role_arn
        # store ID
        self.store_id = store_id
        # 存储类型，当前只支持oss
        self.type = type

    def validate(self):
        self.validate_required(self.bucket, 'bucket')
        self.validate_required(self.endpoint, 'endpoint')
        if self.enet_percent_config:
            self.enet_percent_config.validate()
        self.validate_required(self.ownership, 'ownership')
        self.validate_required(self.policy, 'policy')
        self.validate_required(self.store_id, 'store_id')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accelerate_endpoint is not None:
            result['accelerate_endpoint'] = self.accelerate_endpoint
        if self.base_path is not None:
            result['base_path'] = self.base_path
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.cdn_endpoint is not None:
            result['cdn_endpoint'] = self.cdn_endpoint
        if self.cdn_ratelimit_disable is not None:
            result['cdn_ratelimit_disable'] = self.cdn_ratelimit_disable
        if self.cdn_timelimit is not None:
            result['cdn_timelimit'] = self.cdn_timelimit
        if self.cdn_url_auth_key is not None:
            result['cdn_url_auth_key'] = self.cdn_url_auth_key
        if self.customized_accelerate_endpoint is not None:
            result['customized_accelerate_endpoint'] = self.customized_accelerate_endpoint
        if self.customized_cdn_endpoint is not None:
            result['customized_cdn_endpoint'] = self.customized_cdn_endpoint
        if self.customized_endpoint is not None:
            result['customized_endpoint'] = self.customized_endpoint
        if self.customized_internal_endpoint is not None:
            result['customized_internal_endpoint'] = self.customized_internal_endpoint
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.enet_endpoint is not None:
            result['enet_endpoint'] = self.enet_endpoint
        if self.enet_percent_config is not None:
            result['enet_percent_config'] = self.enet_percent_config.to_map()
        if self.internal_endpoint is not None:
            result['internal_endpoint'] = self.internal_endpoint
        if self.location is not None:
            result['location'] = self.location
        if self.ownership is not None:
            result['ownership'] = self.ownership
        if self.policy is not None:
            result['policy'] = self.policy
        if self.role_arn is not None:
            result['role_arn'] = self.role_arn
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accelerate_endpoint') is not None:
            self.accelerate_endpoint = m.get('accelerate_endpoint')
        if m.get('base_path') is not None:
            self.base_path = m.get('base_path')
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('cdn_endpoint') is not None:
            self.cdn_endpoint = m.get('cdn_endpoint')
        if m.get('cdn_ratelimit_disable') is not None:
            self.cdn_ratelimit_disable = m.get('cdn_ratelimit_disable')
        if m.get('cdn_timelimit') is not None:
            self.cdn_timelimit = m.get('cdn_timelimit')
        if m.get('cdn_url_auth_key') is not None:
            self.cdn_url_auth_key = m.get('cdn_url_auth_key')
        if m.get('customized_accelerate_endpoint') is not None:
            self.customized_accelerate_endpoint = m.get('customized_accelerate_endpoint')
        if m.get('customized_cdn_endpoint') is not None:
            self.customized_cdn_endpoint = m.get('customized_cdn_endpoint')
        if m.get('customized_endpoint') is not None:
            self.customized_endpoint = m.get('customized_endpoint')
        if m.get('customized_internal_endpoint') is not None:
            self.customized_internal_endpoint = m.get('customized_internal_endpoint')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('enet_endpoint') is not None:
            self.enet_endpoint = m.get('enet_endpoint')
        if m.get('enet_percent_config') is not None:
            temp_model = WhitePercentConfig()
            self.enet_percent_config = temp_model.from_map(m['enet_percent_config'])
        if m.get('internal_endpoint') is not None:
            self.internal_endpoint = m.get('internal_endpoint')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('ownership') is not None:
            self.ownership = m.get('ownership')
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        if m.get('role_arn') is not None:
            self.role_arn = m.get('role_arn')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListStoresResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[Store] = None,
    ):
        # Store 列表
        self.items = items

    def validate(self):
        self.validate_required(self.items, 'items')
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = Store()
                self.items.append(temp_model.from_map(k))
        return self


class AdminListStoresModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListStoresResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListStoresResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSubdomainResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        subdomain_id: str = None,
    ):
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class CreateSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSubdomainResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        subdomain_id: str = None,
    ):
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class DeleteSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ShareDetailResponse(TeaModel):
    """
    share detail response
    """
    def __init__(
        self,
        access_quota: int = None,
        exceed_access_quota: bool = None,
    ):
        # 企业未配置独立域名时，允许的访问次数
        self.access_quota = access_quota
        # 企业未配置独立域名时，是否超过允许的访问次数
        self.exceed_access_quota = exceed_access_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_quota is not None:
            result['access_quota'] = self.access_quota
        if self.exceed_access_quota is not None:
            result['exceed_access_quota'] = self.exceed_access_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_quota') is not None:
            self.access_quota = m.get('access_quota')
        if m.get('exceed_access_quota') is not None:
            self.exceed_access_quota = m.get('exceed_access_quota')
        return self


class ShareLinkDetailResponse(TeaModel):
    """
    share_link detail response
    """
    def __init__(
        self,
        access_quota: int = None,
        enable_nvc_share_token: bool = None,
        enable_office_editable: bool = None,
        exceed_access_quota: bool = None,
    ):
        # 企业未配置独立域名时，允许的访问次数
        self.access_quota = access_quota
        # 是否启用分享token验证码功能
        self.enable_nvc_share_token = enable_nvc_share_token
        # 企业是否开通了分享可在线编辑的文档的功能
        self.enable_office_editable = enable_office_editable
        # 企业未配置独立域名时，是否超过允许的访问次数
        self.exceed_access_quota = exceed_access_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_quota is not None:
            result['access_quota'] = self.access_quota
        if self.enable_nvc_share_token is not None:
            result['enable_nvc_share_token'] = self.enable_nvc_share_token
        if self.enable_office_editable is not None:
            result['enable_office_editable'] = self.enable_office_editable
        if self.exceed_access_quota is not None:
            result['exceed_access_quota'] = self.exceed_access_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_quota') is not None:
            self.access_quota = m.get('access_quota')
        if m.get('enable_nvc_share_token') is not None:
            self.enable_nvc_share_token = m.get('enable_nvc_share_token')
        if m.get('enable_office_editable') is not None:
            self.enable_office_editable = m.get('enable_office_editable')
        if m.get('exceed_access_quota') is not None:
            self.exceed_access_quota = m.get('exceed_access_quota')
        return self


class GetSubdomainResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: str = None,
        description: str = None,
        group_singe_drive_enable: bool = None,
        name: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        status: int = None,
        subdomain_id: str = None,
        total_size: int = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_quota: int = None,
        user_single_drive_enabled: bool = None,
    ):
        # 创建时间
        self.created_at = created_at
        # 描述
        self.description = description
        self.group_singe_drive_enable = group_singe_drive_enable
        # 名称
        self.name = name
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 当前状态
        self.status = status
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id
        # 逻辑空间quota，-1表示无限制，单位为字节
        self.total_size = total_size
        # 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，-1表示无限制
        self.user_quota = user_quota
        self.user_single_drive_enabled = user_single_drive_enabled

    def validate(self):
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.description, 'description')
        self.validate_required(self.name, 'name')
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        self.validate_required(self.subdomain_id, 'subdomain_id')
        self.validate_required(self.total_size, 'total_size')
        self.validate_required(self.updated_at, 'updated_at')
        self.validate_required(self.user_quota, 'user_quota')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.group_singe_drive_enable is not None:
            result['group_singe_drive_enable'] = self.group_singe_drive_enable
        if self.name is not None:
            result['name'] = self.name
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_quota is not None:
            result['user_quota'] = self.user_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_singe_drive_enable') is not None:
            self.group_singe_drive_enable = m.get('group_singe_drive_enable')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_quota') is not None:
            self.user_quota = m.get('user_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        return self


class GetSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseSubdomainResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: str = None,
        description: str = None,
        group_singe_drive_enable: bool = None,
        name: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        status: int = None,
        subdomain_id: str = None,
        total_size: int = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_quota: int = None,
        user_single_drive_enabled: bool = None,
    ):
        # 创建时间
        self.created_at = created_at
        # 描述
        self.description = description
        self.group_singe_drive_enable = group_singe_drive_enable
        # 名称
        self.name = name
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 当前状态
        self.status = status
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id
        # 逻辑空间quota，-1表示无限制，单位为字节
        self.total_size = total_size
        # 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，-1表示无限制
        self.user_quota = user_quota
        self.user_single_drive_enabled = user_single_drive_enabled

    def validate(self):
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.description, 'description')
        self.validate_required(self.name, 'name')
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        self.validate_required(self.subdomain_id, 'subdomain_id')
        self.validate_required(self.total_size, 'total_size')
        self.validate_required(self.updated_at, 'updated_at')
        self.validate_required(self.user_quota, 'user_quota')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.group_singe_drive_enable is not None:
            result['group_singe_drive_enable'] = self.group_singe_drive_enable
        if self.name is not None:
            result['name'] = self.name
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_quota is not None:
            result['user_quota'] = self.user_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_singe_drive_enable') is not None:
            self.group_singe_drive_enable = m.get('group_singe_drive_enable')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_quota') is not None:
            self.user_quota = m.get('user_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        return self


class ListSubdomainsResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[BaseSubdomainResponse] = None,
        next_marker: str = None,
    ):
        # 分页的 subdomain 数据
        self.items = items
        # 分页游标，可以用作下次list的起点
        self.next_marker = next_marker

    def validate(self):
        self.validate_required(self.items, 'items')
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        self.validate_required(self.next_marker, 'next_marker')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseSubdomainResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListSubdomainsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListSubdomainsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListSubdomainsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSubdomainResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class UpdateSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserAccessTokenResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        access_token: str = None,
        default_drive_id: str = None,
        expire_time: str = None,
        expires_in: int = None,
        refresh_token: str = None,
        role: str = None,
        token_type: str = None,
        user_id: str = None,
    ):
        # 用于调用业务接口的accessToken
        self.access_token = access_token
        # Default Drive ID
        self.default_drive_id = default_drive_id
        # accessToken过期时间，ISO时间
        self.expire_time = expire_time
        # accessToken过期时间，单位秒
        self.expires_in = expires_in
        # 用于刷新accessToken
        self.refresh_token = refresh_token
        # 当前用户角色
        self.role = role
        # accessToken类型，Bearer
        self.token_type = token_type
        # 当前用户ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.access_token, 'access_token')
        self.validate_required(self.default_drive_id, 'default_drive_id')
        self.validate_required(self.expire_time, 'expire_time')
        self.validate_required(self.expires_in, 'expires_in')
        self.validate_required(self.role, 'role')
        self.validate_required(self.token_type, 'token_type')
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['access_token'] = self.access_token
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.expires_in is not None:
            result['expires_in'] = self.expires_in
        if self.refresh_token is not None:
            result['refresh_token'] = self.refresh_token
        if self.role is not None:
            result['role'] = self.role
        if self.token_type is not None:
            result['token_type'] = self.token_type
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_token') is not None:
            self.access_token = m.get('access_token')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('expires_in') is not None:
            self.expires_in = m.get('expires_in')
        if m.get('refresh_token') is not None:
            self.refresh_token = m.get('refresh_token')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('token_type') is not None:
            self.token_type = m.get('token_type')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetUserAccessTokenModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetUserAccessTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetUserAccessTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class PunishFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetAsyncTaskResponse(TeaModel):
    """
    Get AsyncTask Response
    """
    def __init__(
        self,
        async_task_id: str = None,
        consumed_process: int = None,
        err_code: int = None,
        message: str = None,
        punished_file_count: int = None,
        state: str = None,
        status: str = None,
        total_process: int = None,
        url: str = None,
    ):
        # async_task_id
        # type:string
        self.async_task_id = async_task_id
        # consumed_process
        self.consumed_process = consumed_process
        # err_code
        self.err_code = err_code
        # message
        self.message = message
        # punished_file_count
        self.punished_file_count = punished_file_count
        # state
        self.state = state
        # status
        self.status = status
        # total_process
        self.total_process = total_process
        # download_url
        # example
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.consumed_process is not None:
            result['consumed_process'] = self.consumed_process
        if self.err_code is not None:
            result['err_code'] = self.err_code
        if self.message is not None:
            result['message'] = self.message
        if self.punished_file_count is not None:
            result['punished_file_count'] = self.punished_file_count
        if self.state is not None:
            result['state'] = self.state
        if self.status is not None:
            result['status'] = self.status
        if self.total_process is not None:
            result['total_process'] = self.total_process
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('consumed_process') is not None:
            self.consumed_process = m.get('consumed_process')
        if m.get('err_code') is not None:
            self.err_code = m.get('err_code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('punished_file_count') is not None:
            self.punished_file_count = m.get('punished_file_count')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('total_process') is not None:
            self.total_process = m.get('total_process')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAsyncTaskInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetAsyncTaskResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetAsyncTaskResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchSubResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        body: dict = None,
        id: str = None,
        status: int = None,
    ):
        # body 子请求的返回结果，可参考对于子请求文档 json 字符串
        self.body = body
        # id 请求带过来的id, 可以跟 request 进行关联
        self.id = id
        # status 子请求的返回状态码，可参考对于子请求文档
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.id is not None:
            result['id'] = self.id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class BatchResponse(TeaModel):
    """
    batch operation response
    """
    def __init__(
        self,
        responses: List[BatchSubResponse] = None,
    ):
        # responses 返回结果合集
        self.responses = responses

    def validate(self):
        if self.responses:
            for k in self.responses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['responses'] = []
        if self.responses is not None:
            for k in self.responses:
                result['responses'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.responses = []
        if m.get('responses') is not None:
            for k in m.get('responses'):
                temp_model = BatchSubResponse()
                self.responses.append(temp_model.from_map(k))
        return self


class BatchOperationModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BatchResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BatchResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDriveResponse(TeaModel):
    """
    Create drive response
    """
    def __init__(
        self,
        domain_id: str = None,
        drive_id: str = None,
    ):
        # Domain ID
        self.domain_id = domain_id
        # Drive ID
        self.drive_id = drive_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class CreateDriveModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDriveModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetDriveResponse(TeaModel):
    """
    Get drive response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        category: str = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        drive_name: str = None,
        drive_type: str = None,
        encrypt_data_access: bool = None,
        encrypt_mode: str = None,
        owner: str = None,
        owner_type: str = None,
        permission: dict = None,
        relative_path: str = None,
        status: str = None,
        store_id: str = None,
        subdomain_id: str = None,
        total_size: int = None,
        updated_at: str = None,
        used_size: int = None,
    ):
        self.action_list = action_list
        self.category = category
        self.created_at = created_at
        # Drive 创建者
        self.creator = creator
        # Drive 备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Drive ID
        self.drive_id = drive_id
        # Drive 名称
        self.drive_name = drive_name
        # Drive 类型
        self.drive_type = drive_type
        self.encrypt_data_access = encrypt_data_access
        self.encrypt_mode = encrypt_mode
        # Drive 所有者
        self.owner = owner
        # Drive 所有者类型
        self.owner_type = owner_type
        self.permission = permission
        # Drive存储基于store的相对路径，domain的PathType为OSSPath时返回
        self.relative_path = relative_path
        # Drive 状态
        self.status = status
        # 存储 ID, domain的PathType为OSSPath时返回
        self.store_id = store_id
        # subdomain_id
        self.subdomain_id = subdomain_id
        # Drive 空间总量
        self.total_size = total_size
        self.updated_at = updated_at
        # Drive 空间已使用量
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.category is not None:
            result['category'] = self.category
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.drive_type is not None:
            result['drive_type'] = self.drive_type
        if self.encrypt_data_access is not None:
            result['encrypt_data_access'] = self.encrypt_data_access
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permission is not None:
            result['permission'] = self.permission
        if self.relative_path is not None:
            result['relative_path'] = self.relative_path
        if self.status is not None:
            result['status'] = self.status
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('drive_type') is not None:
            self.drive_type = m.get('drive_type')
        if m.get('encrypt_data_access') is not None:
            self.encrypt_data_access = m.get('encrypt_data_access')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('relative_path') is not None:
            self.relative_path = m.get('relative_path')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class GetDriveModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDefaultDriveModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseDriveResponse(TeaModel):
    """
    Base drive response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        category: str = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        drive_name: str = None,
        drive_type: str = None,
        encrypt_data_access: bool = None,
        encrypt_mode: str = None,
        owner: str = None,
        owner_type: str = None,
        permission: dict = None,
        relative_path: str = None,
        status: str = None,
        store_id: str = None,
        subdomain_id: str = None,
        total_size: int = None,
        updated_at: str = None,
        used_size: int = None,
    ):
        self.action_list = action_list
        self.category = category
        self.created_at = created_at
        # Drive 创建者
        self.creator = creator
        # Drive 备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Drive ID
        self.drive_id = drive_id
        # Drive 名称
        self.drive_name = drive_name
        # Drive 类型
        self.drive_type = drive_type
        self.encrypt_data_access = encrypt_data_access
        self.encrypt_mode = encrypt_mode
        # Drive 所有者
        self.owner = owner
        # Drive 所有者类型
        self.owner_type = owner_type
        self.permission = permission
        # Drive存储基于store的相对路径，domain的PathType为OSSPath时返回
        self.relative_path = relative_path
        # Drive 状态
        self.status = status
        # 存储 ID, domain的PathType为OSSPath时返回
        self.store_id = store_id
        # subdomain_id
        self.subdomain_id = subdomain_id
        # Drive 空间总量
        self.total_size = total_size
        self.updated_at = updated_at
        # Drive 空间已使用量
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.category is not None:
            result['category'] = self.category
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.drive_type is not None:
            result['drive_type'] = self.drive_type
        if self.encrypt_data_access is not None:
            result['encrypt_data_access'] = self.encrypt_data_access
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permission is not None:
            result['permission'] = self.permission
        if self.relative_path is not None:
            result['relative_path'] = self.relative_path
        if self.status is not None:
            result['status'] = self.status
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('drive_type') is not None:
            self.drive_type = m.get('drive_type')
        if m.get('encrypt_data_access') is not None:
            self.encrypt_data_access = m.get('encrypt_data_access')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('relative_path') is not None:
            self.relative_path = m.get('relative_path')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class ListDriveResponse(TeaModel):
    """
    list drive response
    """
    def __init__(
        self,
        items: List[BaseDriveResponse] = None,
        next_marker: str = None,
    ):
        # Drive 列表
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseDriveResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListDrivesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMyDrivesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchDriveResponse(TeaModel):
    """
    search drive response
    """
    def __init__(
        self,
        items: List[BaseDriveResponse] = None,
        next_marker: str = None,
    ):
        # Drive 列表
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseDriveResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class SearchDrivesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDriveResponse(TeaModel):
    """
    Update drive response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        category: str = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        drive_name: str = None,
        drive_type: str = None,
        encrypt_data_access: bool = None,
        encrypt_mode: str = None,
        owner: str = None,
        owner_type: str = None,
        permission: dict = None,
        relative_path: str = None,
        status: str = None,
        store_id: str = None,
        subdomain_id: str = None,
        total_size: int = None,
        updated_at: str = None,
        used_size: int = None,
    ):
        self.action_list = action_list
        self.category = category
        self.created_at = created_at
        # Drive 创建者
        self.creator = creator
        # Drive 备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Drive ID
        self.drive_id = drive_id
        # Drive 名称
        self.drive_name = drive_name
        # Drive 类型
        self.drive_type = drive_type
        self.encrypt_data_access = encrypt_data_access
        self.encrypt_mode = encrypt_mode
        # Drive 所有者
        self.owner = owner
        # Drive 所有者类型
        self.owner_type = owner_type
        self.permission = permission
        # Drive存储基于store的相对路径，domain的PathType为OSSPath时返回
        self.relative_path = relative_path
        # Drive 状态
        self.status = status
        # 存储 ID, domain的PathType为OSSPath时返回
        self.store_id = store_id
        # subdomain_id
        self.subdomain_id = subdomain_id
        # Drive 空间总量
        self.total_size = total_size
        self.updated_at = updated_at
        # Drive 空间已使用量
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.category is not None:
            result['category'] = self.category
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.drive_type is not None:
            result['drive_type'] = self.drive_type
        if self.encrypt_data_access is not None:
            result['encrypt_data_access'] = self.encrypt_data_access
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permission is not None:
            result['permission'] = self.permission
        if self.relative_path is not None:
            result['relative_path'] = self.relative_path
        if self.status is not None:
            result['status'] = self.status
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('drive_type') is not None:
            self.drive_type = m.get('drive_type')
        if m.get('encrypt_data_access') is not None:
            self.encrypt_data_access = m.get('encrypt_data_access')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('relative_path') is not None:
            self.relative_path = m.get('relative_path')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class UpdateDriveModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateDriveResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateDriveResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPermissionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class CCPArchiveFilesResponse(TeaModel):
    """
    打包下载response
    """
    def __init__(
        self,
        async_task_id: str = None,
    ):
        self.async_task_id = async_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        return self


class ArchiveFilesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPArchiveFilesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPArchiveFilesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CroppingBoundary(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        height: int = None,
        left: int = None,
        top: int = None,
        width: int = None,
    ):
        self.height = height
        self.left = left
        self.top = top
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['height'] = self.height
        if self.left is not None:
            result['left'] = self.left
        if self.top is not None:
            result['top'] = self.top
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('left') is not None:
            self.left = m.get('left')
        if m.get('top') is not None:
            self.top = m.get('top')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class CroppingSuggestionItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        aspect_ratio: str = None,
        cropping_boundary: CroppingBoundary = None,
        score: float = None,
    ):
        self.aspect_ratio = aspect_ratio
        self.cropping_boundary = cropping_boundary
        self.score = score

    def validate(self):
        if self.cropping_boundary:
            self.cropping_boundary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aspect_ratio is not None:
            result['aspect_ratio'] = self.aspect_ratio
        if self.cropping_boundary is not None:
            result['cropping_boundary'] = self.cropping_boundary.to_map()
        if self.score is not None:
            result['score'] = self.score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aspect_ratio') is not None:
            self.aspect_ratio = m.get('aspect_ratio')
        if m.get('cropping_boundary') is not None:
            temp_model = CroppingBoundary()
            self.cropping_boundary = temp_model.from_map(m['cropping_boundary'])
        if m.get('score') is not None:
            self.score = m.get('score')
        return self


class FaceThumbnail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        face_group_id: str = None,
        face_id: str = None,
        face_thumbnail: str = None,
    ):
        self.face_group_id = face_group_id
        self.face_id = face_id
        self.face_thumbnail = face_thumbnail

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.face_group_id is not None:
            result['face_group_id'] = self.face_group_id
        if self.face_id is not None:
            result['face_id'] = self.face_id
        if self.face_thumbnail is not None:
            result['face_thumbnail'] = self.face_thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('face_group_id') is not None:
            self.face_group_id = m.get('face_group_id')
        if m.get('face_id') is not None:
            self.face_id = m.get('face_id')
        if m.get('face_thumbnail') is not None:
            self.face_thumbnail = m.get('face_thumbnail')
        return self


class ImageQuality(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        clarity: float = None,
        clarity_score: float = None,
        color: float = None,
        color_score: float = None,
        composition_score: float = None,
        contrast: float = None,
        contrast_score: float = None,
        exposure: float = None,
        exposure_score: float = None,
        overall_score: float = None,
    ):
        self.clarity = clarity
        self.clarity_score = clarity_score
        self.color = color
        self.color_score = color_score
        self.composition_score = composition_score
        self.contrast = contrast
        self.contrast_score = contrast_score
        self.exposure = exposure
        self.exposure_score = exposure_score
        self.overall_score = overall_score

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clarity is not None:
            result['clarity'] = self.clarity
        if self.clarity_score is not None:
            result['clarity_score'] = self.clarity_score
        if self.color is not None:
            result['color'] = self.color
        if self.color_score is not None:
            result['color_score'] = self.color_score
        if self.composition_score is not None:
            result['composition_score'] = self.composition_score
        if self.contrast is not None:
            result['contrast'] = self.contrast
        if self.contrast_score is not None:
            result['contrast_score'] = self.contrast_score
        if self.exposure is not None:
            result['exposure'] = self.exposure
        if self.exposure_score is not None:
            result['exposure_score'] = self.exposure_score
        if self.overall_score is not None:
            result['overall_score'] = self.overall_score
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clarity') is not None:
            self.clarity = m.get('clarity')
        if m.get('clarity_score') is not None:
            self.clarity_score = m.get('clarity_score')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('color_score') is not None:
            self.color_score = m.get('color_score')
        if m.get('composition_score') is not None:
            self.composition_score = m.get('composition_score')
        if m.get('contrast') is not None:
            self.contrast = m.get('contrast')
        if m.get('contrast_score') is not None:
            self.contrast_score = m.get('contrast_score')
        if m.get('exposure') is not None:
            self.exposure = m.get('exposure')
        if m.get('exposure_score') is not None:
            self.exposure_score = m.get('exposure_score')
        if m.get('overall_score') is not None:
            self.overall_score = m.get('overall_score')
        return self


class SystemTag(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        centric_score: float = None,
        confidence: float = None,
        en_name: str = None,
        name: str = None,
        parent_en_name: str = None,
        parent_name: str = None,
        source: str = None,
        tag_level: int = None,
    ):
        self.centric_score = centric_score
        self.confidence = confidence
        self.en_name = en_name
        self.name = name
        self.parent_en_name = parent_en_name
        self.parent_name = parent_name
        self.source = source
        self.tag_level = tag_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.centric_score is not None:
            result['centric_score'] = self.centric_score
        if self.confidence is not None:
            result['confidence'] = self.confidence
        if self.en_name is not None:
            result['en_name'] = self.en_name
        if self.name is not None:
            result['name'] = self.name
        if self.parent_en_name is not None:
            result['parent_en_name'] = self.parent_en_name
        if self.parent_name is not None:
            result['parent_name'] = self.parent_name
        if self.source is not None:
            result['source'] = self.source
        if self.tag_level is not None:
            result['tag_level'] = self.tag_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('centric_score') is not None:
            self.centric_score = m.get('centric_score')
        if m.get('confidence') is not None:
            self.confidence = m.get('confidence')
        if m.get('en_name') is not None:
            self.en_name = m.get('en_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_en_name') is not None:
            self.parent_en_name = m.get('parent_en_name')
        if m.get('parent_name') is not None:
            self.parent_name = m.get('parent_name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('tag_level') is not None:
            self.tag_level = m.get('tag_level')
        return self


class ImageMediaResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address_line: str = None,
        city: str = None,
        country: str = None,
        cropping_suggestion: List[CroppingSuggestionItem] = None,
        district: str = None,
        exif: str = None,
        faces: str = None,
        faces_thumbnail: List[FaceThumbnail] = None,
        height: int = None,
        image_quality: ImageQuality = None,
        image_tags: List[SystemTag] = None,
        location: str = None,
        province: str = None,
        time: str = None,
        township: str = None,
        width: int = None,
    ):
        # address_line
        self.address_line = address_line
        # city
        self.city = city
        # country
        self.country = country
        # cropping_suggestion
        self.cropping_suggestion = cropping_suggestion
        # district
        self.district = district
        # exif json string
        self.exif = exif
        # faces json string
        self.faces = faces
        # faces_thumbnail_list
        self.faces_thumbnail = faces_thumbnail
        # height
        self.height = height
        self.image_quality = image_quality
        # system_tags
        self.image_tags = image_tags
        # location
        self.location = location
        # province
        self.province = province
        # time
        self.time = time
        # township
        self.township = township
        # width
        self.width = width

    def validate(self):
        if self.cropping_suggestion:
            for k in self.cropping_suggestion:
                if k:
                    k.validate()
        if self.faces_thumbnail:
            for k in self.faces_thumbnail:
                if k:
                    k.validate()
        if self.image_quality:
            self.image_quality.validate()
        if self.image_tags:
            for k in self.image_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_line is not None:
            result['address_line'] = self.address_line
        if self.city is not None:
            result['city'] = self.city
        if self.country is not None:
            result['country'] = self.country
        result['cropping_suggestion'] = []
        if self.cropping_suggestion is not None:
            for k in self.cropping_suggestion:
                result['cropping_suggestion'].append(k.to_map() if k else None)
        if self.district is not None:
            result['district'] = self.district
        if self.exif is not None:
            result['exif'] = self.exif
        if self.faces is not None:
            result['faces'] = self.faces
        result['faces_thumbnail'] = []
        if self.faces_thumbnail is not None:
            for k in self.faces_thumbnail:
                result['faces_thumbnail'].append(k.to_map() if k else None)
        if self.height is not None:
            result['height'] = self.height
        if self.image_quality is not None:
            result['image_quality'] = self.image_quality.to_map()
        result['image_tags'] = []
        if self.image_tags is not None:
            for k in self.image_tags:
                result['image_tags'].append(k.to_map() if k else None)
        if self.location is not None:
            result['location'] = self.location
        if self.province is not None:
            result['province'] = self.province
        if self.time is not None:
            result['time'] = self.time
        if self.township is not None:
            result['township'] = self.township
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_line') is not None:
            self.address_line = m.get('address_line')
        if m.get('city') is not None:
            self.city = m.get('city')
        if m.get('country') is not None:
            self.country = m.get('country')
        self.cropping_suggestion = []
        if m.get('cropping_suggestion') is not None:
            for k in m.get('cropping_suggestion'):
                temp_model = CroppingSuggestionItem()
                self.cropping_suggestion.append(temp_model.from_map(k))
        if m.get('district') is not None:
            self.district = m.get('district')
        if m.get('exif') is not None:
            self.exif = m.get('exif')
        if m.get('faces') is not None:
            self.faces = m.get('faces')
        self.faces_thumbnail = []
        if m.get('faces_thumbnail') is not None:
            for k in m.get('faces_thumbnail'):
                temp_model = FaceThumbnail()
                self.faces_thumbnail.append(temp_model.from_map(k))
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('image_quality') is not None:
            temp_model = ImageQuality()
            self.image_quality = temp_model.from_map(m['image_quality'])
        self.image_tags = []
        if m.get('image_tags') is not None:
            for k in m.get('image_tags'):
                temp_model = SystemTag()
                self.image_tags.append(temp_model.from_map(k))
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('province') is not None:
            self.province = m.get('province')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('township') is not None:
            self.township = m.get('township')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoMediaAudioStream(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bit_rate: str = None,
        channel_layout: str = None,
        channels: int = None,
        code_name: str = None,
        duration: str = None,
        sample_rate: str = None,
    ):
        # bit_rate 音频比特率 单位：bps
        self.bit_rate = bit_rate
        # channel_layout 声道布局
        self.channel_layout = channel_layout
        # channels 音频数/声道数
        self.channels = channels
        # code_name 音频编码模式
        self.code_name = code_name
        # duration 单位 秒
        self.duration = duration
        # sample_rate 音频采样率
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bit_rate is not None:
            result['bit_rate'] = self.bit_rate
        if self.channel_layout is not None:
            result['channel_layout'] = self.channel_layout
        if self.channels is not None:
            result['channels'] = self.channels
        if self.code_name is not None:
            result['code_name'] = self.code_name
        if self.duration is not None:
            result['duration'] = self.duration
        if self.sample_rate is not None:
            result['sample_rate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bit_rate') is not None:
            self.bit_rate = m.get('bit_rate')
        if m.get('channel_layout') is not None:
            self.channel_layout = m.get('channel_layout')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        if m.get('code_name') is not None:
            self.code_name = m.get('code_name')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('sample_rate') is not None:
            self.sample_rate = m.get('sample_rate')
        return self


class VideoMediaVideoStream(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bitrate: str = None,
        clarity: str = None,
        code_name: str = None,
        duration: str = None,
        fps: str = None,
        rotate: str = None,
    ):
        # bitrate 视频比特率 单位：bps
        self.bitrate = bitrate
        # clarity 清晰度（扫描）
        self.clarity = clarity
        # code_name 视频编码模式
        self.code_name = code_name
        # duration 单位 秒
        self.duration = duration
        # fps 视频平均帧率
        self.fps = fps
        # rotate 视频横屏 竖屏
        self.rotate = rotate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.clarity is not None:
            result['clarity'] = self.clarity
        if self.code_name is not None:
            result['code_name'] = self.code_name
        if self.duration is not None:
            result['duration'] = self.duration
        if self.fps is not None:
            result['fps'] = self.fps
        if self.rotate is not None:
            result['rotate'] = self.rotate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('clarity') is not None:
            self.clarity = m.get('clarity')
        if m.get('code_name') is not None:
            self.code_name = m.get('code_name')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('fps') is not None:
            self.fps = m.get('fps')
        if m.get('rotate') is not None:
            self.rotate = m.get('rotate')
        return self


class VideoMediaResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address_line: str = None,
        city: str = None,
        country: str = None,
        district: str = None,
        duration: str = None,
        height: int = None,
        image_tags: List[SystemTag] = None,
        location: str = None,
        province: str = None,
        time: str = None,
        township: str = None,
        video_media_audio_stream: List[VideoMediaAudioStream] = None,
        video_media_video_stream: List[VideoMediaVideoStream] = None,
        width: int = None,
    ):
        # address_line
        self.address_line = address_line
        # city
        self.city = city
        # country
        self.country = country
        # district
        self.district = district
        # duration 单位 秒
        self.duration = duration
        # height
        self.height = height
        # system_tags
        self.image_tags = image_tags
        # location
        self.location = location
        # province
        self.province = province
        # time
        self.time = time
        # township
        self.township = township
        self.video_media_audio_stream = video_media_audio_stream
        self.video_media_video_stream = video_media_video_stream
        # width
        self.width = width

    def validate(self):
        if self.image_tags:
            for k in self.image_tags:
                if k:
                    k.validate()
        if self.video_media_audio_stream:
            for k in self.video_media_audio_stream:
                if k:
                    k.validate()
        if self.video_media_video_stream:
            for k in self.video_media_video_stream:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_line is not None:
            result['address_line'] = self.address_line
        if self.city is not None:
            result['city'] = self.city
        if self.country is not None:
            result['country'] = self.country
        if self.district is not None:
            result['district'] = self.district
        if self.duration is not None:
            result['duration'] = self.duration
        if self.height is not None:
            result['height'] = self.height
        result['image_tags'] = []
        if self.image_tags is not None:
            for k in self.image_tags:
                result['image_tags'].append(k.to_map() if k else None)
        if self.location is not None:
            result['location'] = self.location
        if self.province is not None:
            result['province'] = self.province
        if self.time is not None:
            result['time'] = self.time
        if self.township is not None:
            result['township'] = self.township
        result['video_media_audio_stream'] = []
        if self.video_media_audio_stream is not None:
            for k in self.video_media_audio_stream:
                result['video_media_audio_stream'].append(k.to_map() if k else None)
        result['video_media_video_stream'] = []
        if self.video_media_video_stream is not None:
            for k in self.video_media_video_stream:
                result['video_media_video_stream'].append(k.to_map() if k else None)
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_line') is not None:
            self.address_line = m.get('address_line')
        if m.get('city') is not None:
            self.city = m.get('city')
        if m.get('country') is not None:
            self.country = m.get('country')
        if m.get('district') is not None:
            self.district = m.get('district')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('height') is not None:
            self.height = m.get('height')
        self.image_tags = []
        if m.get('image_tags') is not None:
            for k in m.get('image_tags'):
                temp_model = SystemTag()
                self.image_tags.append(temp_model.from_map(k))
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('province') is not None:
            self.province = m.get('province')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('township') is not None:
            self.township = m.get('township')
        self.video_media_audio_stream = []
        if m.get('video_media_audio_stream') is not None:
            for k in m.get('video_media_audio_stream'):
                temp_model = VideoMediaAudioStream()
                self.video_media_audio_stream.append(temp_model.from_map(k))
        self.video_media_video_stream = []
        if m.get('video_media_video_stream') is not None:
            for k in m.get('video_media_video_stream'):
                temp_model = VideoMediaVideoStream()
                self.video_media_video_stream.append(temp_model.from_map(k))
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoPreviewAudioMeta(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bitrate: float = None,
        channels: int = None,
        duration: float = None,
        sample_rate: float = None,
    ):
        # bitrate
        self.bitrate = bitrate
        # channels
        self.channels = channels
        # duration
        self.duration = duration
        # sample_rate
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.channels is not None:
            result['channels'] = self.channels
        if self.duration is not None:
            result['duration'] = self.duration
        if self.sample_rate is not None:
            result['sample_rate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('sample_rate') is not None:
            self.sample_rate = m.get('sample_rate')
        return self


class VideoPreviewAudioMusicMeta(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        album: str = None,
        artist: str = None,
        cover_url: str = None,
        title: str = None,
    ):
        # album
        self.album = album
        # artist
        self.artist = artist
        # cover_url
        self.cover_url = cover_url
        # title
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.album is not None:
            result['album'] = self.album
        if self.artist is not None:
            result['artist'] = self.artist
        if self.cover_url is not None:
            result['cover_url'] = self.cover_url
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('album') is not None:
            self.album = m.get('album')
        if m.get('artist') is not None:
            self.artist = m.get('artist')
        if m.get('cover_url') is not None:
            self.cover_url = m.get('cover_url')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class VideoPreviewTranscode(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        status: str = None,
        template_id: str = None,
    ):
        # status
        self.status = status
        # template_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.template_id is not None:
            result['template_id'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        return self


class VideoPreviewSpriteResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        col: int = None,
        count: int = None,
        frame_count: int = None,
        frame_height: int = None,
        frame_width: int = None,
        row: int = None,
        status: str = None,
    ):
        # col
        self.col = col
        # count
        self.count = count
        # frame_count
        self.frame_count = frame_count
        # frame_height
        self.frame_height = frame_height
        # frame_width
        self.frame_width = frame_width
        # row
        self.row = row
        # status
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col is not None:
            result['col'] = self.col
        if self.count is not None:
            result['count'] = self.count
        if self.frame_count is not None:
            result['frame_count'] = self.frame_count
        if self.frame_height is not None:
            result['frame_height'] = self.frame_height
        if self.frame_width is not None:
            result['frame_width'] = self.frame_width
        if self.row is not None:
            result['row'] = self.row
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('col') is not None:
            self.col = m.get('col')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('frame_count') is not None:
            self.frame_count = m.get('frame_count')
        if m.get('frame_height') is not None:
            self.frame_height = m.get('frame_height')
        if m.get('frame_width') is not None:
            self.frame_width = m.get('frame_width')
        if m.get('row') is not None:
            self.row = m.get('row')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class VideoPreviewResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        audio_channels: int = None,
        audio_format: str = None,
        audio_meta: VideoPreviewAudioMeta = None,
        audio_music_meta: VideoPreviewAudioMusicMeta = None,
        audio_sample_rate: str = None,
        audio_template_list: List[VideoPreviewTranscode] = None,
        bitrate: str = None,
        duration: str = None,
        frame_rate: str = None,
        height: int = None,
        sprite_info: VideoPreviewSpriteResponse = None,
        template_list: List[VideoPreviewTranscode] = None,
        thumbnail: str = None,
        video_format: str = None,
        width: int = None,
    ):
        # audio_channels
        self.audio_channels = audio_channels
        # audio_format
        self.audio_format = audio_format
        self.audio_meta = audio_meta
        self.audio_music_meta = audio_music_meta
        # audio_sample_rate
        self.audio_sample_rate = audio_sample_rate
        # audio_template_list
        self.audio_template_list = audio_template_list
        # bitrate
        self.bitrate = bitrate
        # duration
        self.duration = duration
        # frame_rate
        self.frame_rate = frame_rate
        # height
        self.height = height
        self.sprite_info = sprite_info
        # template_list
        self.template_list = template_list
        # thumbnail
        self.thumbnail = thumbnail
        # video_format
        self.video_format = video_format
        # width
        self.width = width

    def validate(self):
        if self.audio_meta:
            self.audio_meta.validate()
        if self.audio_music_meta:
            self.audio_music_meta.validate()
        if self.audio_template_list:
            for k in self.audio_template_list:
                if k:
                    k.validate()
        if self.sprite_info:
            self.sprite_info.validate()
        if self.template_list:
            for k in self.template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_channels is not None:
            result['audio_channels'] = self.audio_channels
        if self.audio_format is not None:
            result['audio_format'] = self.audio_format
        if self.audio_meta is not None:
            result['audio_meta'] = self.audio_meta.to_map()
        if self.audio_music_meta is not None:
            result['audio_music_meta'] = self.audio_music_meta.to_map()
        if self.audio_sample_rate is not None:
            result['audio_sample_rate'] = self.audio_sample_rate
        result['audio_template_list'] = []
        if self.audio_template_list is not None:
            for k in self.audio_template_list:
                result['audio_template_list'].append(k.to_map() if k else None)
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.duration is not None:
            result['duration'] = self.duration
        if self.frame_rate is not None:
            result['frame_rate'] = self.frame_rate
        if self.height is not None:
            result['height'] = self.height
        if self.sprite_info is not None:
            result['sprite_info'] = self.sprite_info.to_map()
        result['template_list'] = []
        if self.template_list is not None:
            for k in self.template_list:
                result['template_list'].append(k.to_map() if k else None)
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.video_format is not None:
            result['video_format'] = self.video_format
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_channels') is not None:
            self.audio_channels = m.get('audio_channels')
        if m.get('audio_format') is not None:
            self.audio_format = m.get('audio_format')
        if m.get('audio_meta') is not None:
            temp_model = VideoPreviewAudioMeta()
            self.audio_meta = temp_model.from_map(m['audio_meta'])
        if m.get('audio_music_meta') is not None:
            temp_model = VideoPreviewAudioMusicMeta()
            self.audio_music_meta = temp_model.from_map(m['audio_music_meta'])
        if m.get('audio_sample_rate') is not None:
            self.audio_sample_rate = m.get('audio_sample_rate')
        self.audio_template_list = []
        if m.get('audio_template_list') is not None:
            for k in m.get('audio_template_list'):
                temp_model = VideoPreviewTranscode()
                self.audio_template_list.append(temp_model.from_map(k))
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('frame_rate') is not None:
            self.frame_rate = m.get('frame_rate')
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('sprite_info') is not None:
            temp_model = VideoPreviewSpriteResponse()
            self.sprite_info = temp_model.from_map(m['sprite_info'])
        self.template_list = []
        if m.get('template_list') is not None:
            for k in m.get('template_list'):
                temp_model = VideoPreviewTranscode()
                self.template_list.append(temp_model.from_map(k))
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('video_format') is not None:
            self.video_format = m.get('video_format')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class CompleteFileResponse(TeaModel):
    """
    complete file response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        location: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        stream_locations: dict = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        # location
        self.location = location
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        self.stream_locations = stream_locations
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.location is not None:
            result['location'] = self.location
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.stream_locations is not None:
            result['stream_locations'] = self.stream_locations
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('stream_locations') is not None:
            self.stream_locations = m.get('stream_locations')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class CompleteFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CompleteFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CompleteFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UCCompleteFileResponse(TeaModel):
    """
    UCCompleteFileResponse
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        bucket_name: str = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        endpoint: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        object_key: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # bucket_name
        self.bucket_name = bucket_name
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # endpoint
        self.endpoint = endpoint
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # object_key
        self.object_key = object_key
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.bucket_name is not None:
            result['bucket_name'] = self.bucket_name
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.object_key is not None:
            result['object_key'] = self.object_key
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('bucket_name') is not None:
            self.bucket_name = m.get('bucket_name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class CompleteFileWithStoreInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UCCompleteFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UCCompleteFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyFileResponse(TeaModel):
    """
    文件拷贝 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # DomainID
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class CopyFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CopyFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CopyFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadFormInfo(TeaModel):
    """
    使用form上传所需字段
    """
    def __init__(
        self,
        bucket_name: str = None,
        object_key: str = None,
        oss_access_key_id: str = None,
        oss_end_point: str = None,
        oss_security_token: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.bucket_name = bucket_name
        self.object_key = object_key
        self.oss_access_key_id = oss_access_key_id
        self.oss_end_point = oss_end_point
        self.oss_security_token = oss_security_token
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket_name is not None:
            result['bucket_name'] = self.bucket_name
        if self.object_key is not None:
            result['object_key'] = self.object_key
        if self.oss_access_key_id is not None:
            result['oss_access_key_id'] = self.oss_access_key_id
        if self.oss_end_point is not None:
            result['oss_end_point'] = self.oss_end_point
        if self.oss_security_token is not None:
            result['oss_security_token'] = self.oss_security_token
        if self.policy is not None:
            result['policy'] = self.policy
        if self.signature is not None:
            result['signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucket_name') is not None:
            self.bucket_name = m.get('bucket_name')
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        if m.get('oss_access_key_id') is not None:
            self.oss_access_key_id = m.get('oss_access_key_id')
        if m.get('oss_end_point') is not None:
            self.oss_end_point = m.get('oss_end_point')
        if m.get('oss_security_token') is not None:
            self.oss_security_token = m.get('oss_security_token')
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        if m.get('signature') is not None:
            self.signature = m.get('signature')
        return self


class SHA1CTX(TeaModel):
    """
    对应OSS Sha1的结构体，定义在 gitlab.alibaba-inc.com/oss/parallel_hash.go OSSSha1Digest
    type OSSSha1Digest struct {
    h   [5]uint32         // h是计算sha1时存放中间结果的变量，参与每一轮Sha1的计算，必不可少，最后的Sha1值也由这几个数字决定
    x   [BlockSize]byte   // 上一轮计算非64字节对齐时，不足64节的内容会保存在这里
    nx  int               // 上一轮计算数据长度取模64的结果，64字节对齐时这个值为0
    len uint64            // 到上一个数据块为止的总长度，字节，用来计算 OSSRequestSha1Ctx 中的Nl, Nh
    }
    SHA1CTX 是 OSSSha1Digest 的简化
    当每轮计算Sha1的数据长度为64位对齐时，nx固定为0，x长度为0，只需包含h和len；part_offset对应OSSSha1Digest的len
    """
    def __init__(
        self,
        h: List[int] = None,
        part_offset: int = None,
    ):
        self.h = h
        self.part_offset = part_offset

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.h is not None:
            result['h'] = self.h
        if self.part_offset is not None:
            result['part_offset'] = self.part_offset
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('h') is not None:
            self.h = m.get('h')
        if m.get('part_offset') is not None:
            self.part_offset = m.get('part_offset')
        return self


class UploadPartInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        content_type: str = None,
        etag: str = None,
        internal_upload_form_info: UploadFormInfo = None,
        internal_upload_url: str = None,
        parallel_sha_1ctx: SHA1CTX = None,
        part_number: int = None,
        part_size: int = None,
        upload_form_info: UploadFormInfo = None,
        upload_url: str = None,
    ):
        # content_type
        self.content_type = content_type
        # etag
        self.etag = etag
        self.internal_upload_form_info = internal_upload_form_info
        # internal_upload_url
        self.internal_upload_url = internal_upload_url
        self.parallel_sha_1ctx = parallel_sha_1ctx
        # PartNumber
        self.part_number = part_number
        # PartSize：
        self.part_size = part_size
        self.upload_form_info = upload_form_info
        # upload_url
        self.upload_url = upload_url

    def validate(self):
        if self.internal_upload_form_info:
            self.internal_upload_form_info.validate()
        if self.parallel_sha_1ctx:
            self.parallel_sha_1ctx.validate()
        if self.part_number is not None:
            self.validate_maximum(self.part_number, 'part_number', 10000)
            self.validate_minimum(self.part_number, 'part_number', 1)
        if self.part_size is not None:
            self.validate_maximum(self.part_size, 'part_size', 5368709120)
        if self.upload_form_info:
            self.upload_form_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.etag is not None:
            result['etag'] = self.etag
        if self.internal_upload_form_info is not None:
            result['internal_upload_form_info'] = self.internal_upload_form_info.to_map()
        if self.internal_upload_url is not None:
            result['internal_upload_url'] = self.internal_upload_url
        if self.parallel_sha_1ctx is not None:
            result['parallel_sha1_ctx'] = self.parallel_sha_1ctx.to_map()
        if self.part_number is not None:
            result['part_number'] = self.part_number
        if self.part_size is not None:
            result['part_size'] = self.part_size
        if self.upload_form_info is not None:
            result['upload_form_info'] = self.upload_form_info.to_map()
        if self.upload_url is not None:
            result['upload_url'] = self.upload_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('etag') is not None:
            self.etag = m.get('etag')
        if m.get('internal_upload_form_info') is not None:
            temp_model = UploadFormInfo()
            self.internal_upload_form_info = temp_model.from_map(m['internal_upload_form_info'])
        if m.get('internal_upload_url') is not None:
            self.internal_upload_url = m.get('internal_upload_url')
        if m.get('parallel_sha1_ctx') is not None:
            temp_model = SHA1CTX()
            self.parallel_sha_1ctx = temp_model.from_map(m['parallel_sha1_ctx'])
        if m.get('part_number') is not None:
            self.part_number = m.get('part_number')
        if m.get('part_size') is not None:
            self.part_size = m.get('part_size')
        if m.get('upload_form_info') is not None:
            temp_model = UploadFormInfo()
            self.upload_form_info = temp_model.from_map(m['upload_form_info'])
        if m.get('upload_url') is not None:
            self.upload_url = m.get('upload_url')
        return self


class CreateFileResponse(TeaModel):
    """
    Create file response
    """
    def __init__(
        self,
        domain_id: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        exist: bool = None,
        file_id: str = None,
        file_name: str = None,
        location: str = None,
        parent_file_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        rapid_upload: bool = None,
        revision_id: str = None,
        share_id: str = None,
        status: str = None,
        streams_upload_info: dict = None,
        type: str = None,
        upload_id: str = None,
    ):
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # exist
        # type: boolean
        self.exist = exist
        # file_id
        self.file_id = file_id
        # file_name
        self.file_name = file_name
        # location
        self.location = location
        # parent_file_id
        self.parent_file_id = parent_file_id
        # part_info_list
        self.part_info_list = part_info_list
        # rapid_upload
        # type: boolean
        self.rapid_upload = rapid_upload
        # revision_id
        self.revision_id = revision_id
        # share_id
        self.share_id = share_id
        # status
        self.status = status
        # streams_upload_info
        self.streams_upload_info = streams_upload_info
        # type
        self.type = type
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_max_length(self.domain_id, 'domain_id', 50)
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9]{1,50}')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.file_name is not None:
            self.validate_max_length(self.file_name, 'file_name', 255)
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.exist is not None:
            result['exist'] = self.exist
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.location is not None:
            result['location'] = self.location
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.rapid_upload is not None:
            result['rapid_upload'] = self.rapid_upload
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.status is not None:
            result['status'] = self.status
        if self.streams_upload_info is not None:
            result['streams_upload_info'] = self.streams_upload_info
        if self.type is not None:
            result['type'] = self.type
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('exist') is not None:
            self.exist = m.get('exist')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('rapid_upload') is not None:
            self.rapid_upload = m.get('rapid_upload')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_upload_info') is not None:
            self.streams_upload_info = m.get('streams_upload_info')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class CreateFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileWithProofModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class Callback(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        body: str = None,
        url: str = None,
    ):
        self.body = body
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class SignatureInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bucket: str = None,
        canonicalized_resource: str = None,
        endpoint: str = None,
        headers: dict = None,
        object_key: str = None,
        signature: str = None,
        str_to_sign: str = None,
    ):
        self.bucket = bucket
        self.canonicalized_resource = canonicalized_resource
        self.endpoint = endpoint
        self.headers = headers
        self.object_key = object_key
        self.signature = signature
        self.str_to_sign = str_to_sign

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.canonicalized_resource is not None:
            result['canonicalized_resource'] = self.canonicalized_resource
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.headers is not None:
            result['headers'] = self.headers
        if self.object_key is not None:
            result['object_key'] = self.object_key
        if self.signature is not None:
            result['signature'] = self.signature
        if self.str_to_sign is not None:
            result['str_to_sign'] = self.str_to_sign
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('canonicalized_resource') is not None:
            self.canonicalized_resource = m.get('canonicalized_resource')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        if m.get('signature') is not None:
            self.signature = m.get('signature')
        if m.get('str_to_sign') is not None:
            self.str_to_sign = m.get('str_to_sign')
        return self


class UCCreateFileResponse(TeaModel):
    """
    UCCreateFileResponse
    """
    def __init__(
        self,
        callback: Callback = None,
        domain_id: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        exist: bool = None,
        file_id: str = None,
        file_name: str = None,
        location: str = None,
        parent_file_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        rapid_upload: bool = None,
        revision_id: str = None,
        share_id: str = None,
        signature: SignatureInfo = None,
        status: str = None,
        streams_upload_info: dict = None,
        type: str = None,
        upload_id: str = None,
        upload_type: str = None,
    ):
        self.callback = callback
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # exist
        # type: boolean
        self.exist = exist
        # file_id
        self.file_id = file_id
        # file_name
        self.file_name = file_name
        # location
        self.location = location
        # parent_file_id
        self.parent_file_id = parent_file_id
        # part_info_list
        self.part_info_list = part_info_list
        # rapid_upload
        # type: boolean
        self.rapid_upload = rapid_upload
        # revision_id
        self.revision_id = revision_id
        # share_id
        self.share_id = share_id
        self.signature = signature
        # status
        self.status = status
        # streams_upload_info
        self.streams_upload_info = streams_upload_info
        # type
        self.type = type
        # upload_id
        self.upload_id = upload_id
        # upload_type
        self.upload_type = upload_type

    def validate(self):
        if self.callback:
            self.callback.validate()
        if self.domain_id is not None:
            self.validate_max_length(self.domain_id, 'domain_id', 50)
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9]{1,50}')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.file_name is not None:
            self.validate_max_length(self.file_name, 'file_name', 255)
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback is not None:
            result['callback'] = self.callback.to_map()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.exist is not None:
            result['exist'] = self.exist
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.location is not None:
            result['location'] = self.location
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.rapid_upload is not None:
            result['rapid_upload'] = self.rapid_upload
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.streams_upload_info is not None:
            result['streams_upload_info'] = self.streams_upload_info
        if self.type is not None:
            result['type'] = self.type
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.upload_type is not None:
            result['upload_type'] = self.upload_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('callback') is not None:
            temp_model = Callback()
            self.callback = temp_model.from_map(m['callback'])
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('exist') is not None:
            self.exist = m.get('exist')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('rapid_upload') is not None:
            self.rapid_upload = m.get('rapid_upload')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('signature') is not None:
            temp_model = SignatureInfo()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_upload_info') is not None:
            self.streams_upload_info = m.get('streams_upload_info')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('upload_type') is not None:
            self.upload_type = m.get('upload_type')
        return self


class CreateFileWithSignatureModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UCCreateFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UCCreateFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFileResponse(TeaModel):
    """
    删除文件 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class DeleteFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUsertagsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetFileResponse(TeaModel):
    """
    获取文件元数据response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed: bool = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # Trashed
        # type: boolean
        self.trashed = trashed
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed is not None:
            result['trashed'] = self.trashed
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed') is not None:
            self.trashed = m.get('trashed')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class GetFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileByPathResponse(TeaModel):
    """
    根据路径获取文件元数据response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed: bool = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # Trashed
        # type: boolean
        self.trashed = trashed
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed is not None:
            result['trashed'] = self.trashed
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed') is not None:
            self.trashed = m.get('trashed')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class GetFileByPathModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetFileByPathResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetFileByPathResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDownloadUrlResponse(TeaModel):
    """
    获取download url response
    """
    def __init__(
        self,
        cdn_url: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        crc_64hash: str = None,
        domain_id: str = None,
        drive_id: str = None,
        expiration: str = None,
        file_id: str = None,
        internal_url: str = None,
        method: str = None,
        punish_flag: int = None,
        revision_id: str = None,
        size: int = None,
        streams_info: dict = None,
        streams_url: dict = None,
        url: str = None,
    ):
        # cdn_url
        self.cdn_url = cdn_url
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # crc64_hash
        self.crc_64hash = crc_64hash
        # DomainID
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # expiration
        self.expiration = expiration
        # file_id
        self.file_id = file_id
        # internal_url
        self.internal_url = internal_url
        # method
        self.method = method
        # PunishFlag
        self.punish_flag = punish_flag
        # revision_id
        self.revision_id = revision_id
        # size
        self.size = size
        # streams info
        self.streams_info = streams_info
        # streams url info
        self.streams_url = streams_url
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cdn_url is not None:
            result['cdn_url'] = self.cdn_url
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.internal_url is not None:
            result['internal_url'] = self.internal_url
        if self.method is not None:
            result['method'] = self.method
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.size is not None:
            result['size'] = self.size
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.streams_url is not None:
            result['streams_url'] = self.streams_url
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cdn_url') is not None:
            self.cdn_url = m.get('cdn_url')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('internal_url') is not None:
            self.internal_url = m.get('internal_url')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('streams_url') is not None:
            self.streams_url = m.get('streams_url')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetDownloadUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetDownloadUrlResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetDownloadUrlResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class FaceBoundary(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        height: int = None,
        left: int = None,
        top: int = None,
        width: int = None,
    ):
        self.height = height
        self.left = left
        self.top = top
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ImageFaceGroupResponse(TeaModel):
    """
    人脸分组信息
    """
    def __init__(
        self,
        created_at: str = None,
        group_cover_face_boundary: FaceBoundary = None,
        group_cover_file_id: str = None,
        group_cover_height: int = None,
        group_cover_url: str = None,
        group_cover_width: int = None,
        group_id: str = None,
        group_name: str = None,
        image_count: int = None,
        remarks: str = None,
        remarks_array: List[str] = None,
        updated_at: str = None,
    ):
        # 人脸分组生成时间
        self.created_at = created_at
        self.group_cover_face_boundary = group_cover_face_boundary
        # group_cover_file_id
        self.group_cover_file_id = group_cover_file_id
        # group_cover_height
        self.group_cover_height = group_cover_height
        # 人脸分组封面头像地址
        self.group_cover_url = group_cover_url
        # group_cover_width
        self.group_cover_width = group_cover_width
        # 人脸分组 ID
        self.group_id = group_id
        # 人脸分组名称
        self.group_name = group_name
        # 照片个数
        self.image_count = image_count
        # remarks
        self.remarks = remarks
        # remarks_array
        self.remarks_array = remarks_array
        # 人脸分组修改时间
        self.updated_at = updated_at

    def validate(self):
        if self.group_cover_face_boundary:
            self.group_cover_face_boundary.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.group_cover_face_boundary is not None:
            result['group_cover_face_boundary'] = self.group_cover_face_boundary.to_map()
        if self.group_cover_file_id is not None:
            result['group_cover_file_id'] = self.group_cover_file_id
        if self.group_cover_height is not None:
            result['group_cover_height'] = self.group_cover_height
        if self.group_cover_url is not None:
            result['group_cover_url'] = self.group_cover_url
        if self.group_cover_width is not None:
            result['group_cover_width'] = self.group_cover_width
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.image_count is not None:
            result['image_count'] = self.image_count
        if self.remarks is not None:
            result['remarks'] = self.remarks
        if self.remarks_array is not None:
            result['remarks_array'] = self.remarks_array
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('group_cover_face_boundary') is not None:
            temp_model = FaceBoundary()
            self.group_cover_face_boundary = temp_model.from_map(m['group_cover_face_boundary'])
        if m.get('group_cover_file_id') is not None:
            self.group_cover_file_id = m.get('group_cover_file_id')
        if m.get('group_cover_height') is not None:
            self.group_cover_height = m.get('group_cover_height')
        if m.get('group_cover_url') is not None:
            self.group_cover_url = m.get('group_cover_url')
        if m.get('group_cover_width') is not None:
            self.group_cover_width = m.get('group_cover_width')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('image_count') is not None:
            self.image_count = m.get('image_count')
        if m.get('remarks') is not None:
            self.remarks = m.get('remarks')
        if m.get('remarks_array') is not None:
            self.remarks_array = m.get('remarks_array')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ImageFaceGroupsResponse(TeaModel):
    """
    人脸分组数组
    """
    def __init__(
        self,
        face_groups: List[ImageFaceGroupResponse] = None,
    ):
        self.face_groups = face_groups

    def validate(self):
        if self.face_groups:
            for k in self.face_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['face_groups'] = []
        if self.face_groups is not None:
            for k in self.face_groups:
                result['face_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.face_groups = []
        if m.get('face_groups') is not None:
            for k in m.get('face_groups'):
                temp_model = ImageFaceGroupResponse()
                self.face_groups.append(temp_model.from_map(k))
        return self


class GetFacegroupsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ImageFaceGroupsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ImageFaceGroupsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLastCursorResponse(TeaModel):
    """
    get last file op cursor response
    """
    def __init__(
        self,
        cursor: str = None,
    ):
        self.cursor = cursor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['cursor'] = self.cursor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cursor') is not None:
            self.cursor = m.get('cursor')
        return self


class GetLastCursorModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetLastCursorResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetLastCursorResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaPlayURLResponse(TeaModel):
    """
    get_media_play_url response
    """
    def __init__(
        self,
        url: str = None,
    ):
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetMediaPlayUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetMediaPlayURLResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetMediaPlayURLResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AudioPreviewPlayInfoMetaResponse(TeaModel):
    """
    音频转码信息meta响应
    """
    def __init__(
        self,
        bitrate: int = None,
        channels: int = None,
        duration: float = None,
        sample_rate: int = None,
    ):
        # bitrate, 码率
        self.bitrate = bitrate
        # channels, 声道数
        self.channels = channels
        # duration, 视频长度
        self.duration = duration
        # sample_rate, 采样率
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.channels is not None:
            result['channels'] = self.channels
        if self.duration is not None:
            result['duration'] = self.duration
        if self.sample_rate is not None:
            result['sample_rate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('sample_rate') is not None:
            self.sample_rate = m.get('sample_rate')
        return self


class VideoPreviewOfflineAudioTranscodingTaskResponse(TeaModel):
    """
    离线音频转码task响应
    """
    def __init__(
        self,
        status: str = None,
        template_bitrate: int = None,
        template_id: str = None,
        template_name: str = None,
        url: str = None,
    ):
        # status, 转码状态
        self.status = status
        # template_bitrate, 音频码率，单位Kbps
        self.template_bitrate = template_bitrate
        # template_id, 转码模板id
        self.template_id = template_id
        # template_name, 模板文案id
        self.template_name = template_name
        # url, 播放地址
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.template_bitrate is not None:
            result['template_bitrate'] = self.template_bitrate
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.template_name is not None:
            result['template_name'] = self.template_name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_bitrate') is not None:
            self.template_bitrate = m.get('template_bitrate')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('template_name') is not None:
            self.template_name = m.get('template_name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class AudioPreviewPlayInfoResponse(TeaModel):
    """
    音频转码信息响应
    """
    def __init__(
        self,
        meta: AudioPreviewPlayInfoMetaResponse = None,
        offline_audio_list: List[VideoPreviewOfflineAudioTranscodingTaskResponse] = None,
    ):
        self.meta = meta
        # 离线转码有效
        self.offline_audio_list = offline_audio_list

    def validate(self):
        if self.meta:
            self.meta.validate()
        if self.offline_audio_list:
            for k in self.offline_audio_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta is not None:
            result['meta'] = self.meta.to_map()
        result['offline_audio_list'] = []
        if self.offline_audio_list is not None:
            for k in self.offline_audio_list:
                result['offline_audio_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('meta') is not None:
            temp_model = AudioPreviewPlayInfoMetaResponse()
            self.meta = temp_model.from_map(m['meta'])
        self.offline_audio_list = []
        if m.get('offline_audio_list') is not None:
            for k in m.get('offline_audio_list'):
                temp_model = VideoPreviewOfflineAudioTranscodingTaskResponse()
                self.offline_audio_list.append(temp_model.from_map(k))
        return self


class LiveTranscodingSubtitleTaskResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        language: str = None,
        status: str = None,
        url: str = None,
    ):
        # language, 字幕语言
        self.language = language
        # status
        self.status = status
        # url, finished 的时候才存在
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language is not None:
            result['language'] = self.language
        if self.status is not None:
            result['status'] = self.status
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class LiveTranscodingTaskResponse(TeaModel):
    """
    实时转码task响应
    """
    def __init__(
        self,
        keep_original_resolution: bool = None,
        preview_url: str = None,
        stage: str = None,
        status: str = None,
        template_height: int = None,
        template_id: str = None,
        template_name: str = None,
        template_width: int = None,
        url: str = None,
    ):
        # keep_original_resolution 转码后的视频分辨率是否保持原画(template分辨率大于当前视频)
        self.keep_original_resolution = keep_original_resolution
        # preview_url, 视频片段预览播放地址
        self.preview_url = preview_url
        # stage, 实时转码内部状态(Deprecated)
        self.stage = stage
        # status, 转码状态
        self.status = status
        # template_height
        self.template_height = template_height
        # template_id, 转码模板id
        self.template_id = template_id
        # template_name, 模板文案id
        self.template_name = template_name
        # template_width
        self.template_width = template_width
        # url, 视频播放地址
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keep_original_resolution is not None:
            result['keep_original_resolution'] = self.keep_original_resolution
        if self.preview_url is not None:
            result['preview_url'] = self.preview_url
        if self.stage is not None:
            result['stage'] = self.stage
        if self.status is not None:
            result['status'] = self.status
        if self.template_height is not None:
            result['template_height'] = self.template_height
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.template_name is not None:
            result['template_name'] = self.template_name
        if self.template_width is not None:
            result['template_width'] = self.template_width
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keep_original_resolution') is not None:
            self.keep_original_resolution = m.get('keep_original_resolution')
        if m.get('preview_url') is not None:
            self.preview_url = m.get('preview_url')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_height') is not None:
            self.template_height = m.get('template_height')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('template_name') is not None:
            self.template_name = m.get('template_name')
        if m.get('template_width') is not None:
            self.template_width = m.get('template_width')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class LiveTranscodingMetaResponse(TeaModel):
    """
    实时转码meta响应
    """
    def __init__(
        self,
        ts_pre_count: int = None,
        ts_segment: int = None,
        ts_total_count: int = None,
    ):
        # ts_pre_count
        self.ts_pre_count = ts_pre_count
        # ts_segment
        self.ts_segment = ts_segment
        # ts_total_count
        self.ts_total_count = ts_total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts_pre_count is not None:
            result['ts_pre_count'] = self.ts_pre_count
        if self.ts_segment is not None:
            result['ts_segment'] = self.ts_segment
        if self.ts_total_count is not None:
            result['ts_total_count'] = self.ts_total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ts_pre_count') is not None:
            self.ts_pre_count = m.get('ts_pre_count')
        if m.get('ts_segment') is not None:
            self.ts_segment = m.get('ts_segment')
        if m.get('ts_total_count') is not None:
            self.ts_total_count = m.get('ts_total_count')
        return self


class VideoPreviewPlayInfoMetaResponse(TeaModel):
    """
    视频转码meta响应
    """
    def __init__(
        self,
        duration: float = None,
        height: int = None,
        live_transcoding_meta: LiveTranscodingMetaResponse = None,
        width: int = None,
    ):
        # duration, 视频长度
        self.duration = duration
        # height, 视频高度
        self.height = height
        self.live_transcoding_meta = live_transcoding_meta
        # width, 视频宽度
        self.width = width

    def validate(self):
        if self.live_transcoding_meta:
            self.live_transcoding_meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.height is not None:
            result['height'] = self.height
        if self.live_transcoding_meta is not None:
            result['live_transcoding_meta'] = self.live_transcoding_meta.to_map()
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('live_transcoding_meta') is not None:
            temp_model = LiveTranscodingMetaResponse()
            self.live_transcoding_meta = temp_model.from_map(m['live_transcoding_meta'])
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoPreviewOfflineVideoTranscodingTaskResponse(TeaModel):
    """
    离线视频转码task响应
    """
    def __init__(
        self,
        keep_original_resolution: bool = None,
        protection_system: str = None,
        status: str = None,
        template_id: str = None,
        url: str = None,
    ):
        # keep_original_resolution 转码后的视频分辨率是否保持原画(template分辨率大于当前视频)
        self.keep_original_resolution = keep_original_resolution
        # protection_system DRM加密方式
        self.protection_system = protection_system
        # status, 转码状态
        self.status = status
        # template_id, 转码模板id
        self.template_id = template_id
        # url, 视频播放地址
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keep_original_resolution is not None:
            result['keep_original_resolution'] = self.keep_original_resolution
        if self.protection_system is not None:
            result['protection_system'] = self.protection_system
        if self.status is not None:
            result['status'] = self.status
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keep_original_resolution') is not None:
            self.keep_original_resolution = m.get('keep_original_resolution')
        if m.get('protection_system') is not None:
            self.protection_system = m.get('protection_system')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class QuickVideoTaskResponse(TeaModel):
    """
    快速转码task响应
    """
    def __init__(
        self,
        status: str = None,
        template_height: int = None,
        template_id: str = None,
        template_name: str = None,
        template_width: int = None,
        url: str = None,
    ):
        # status, 转码状态
        self.status = status
        # template_height
        self.template_height = template_height
        # template_id, 转码模板id
        self.template_id = template_id
        # template_name, 模板文案id
        self.template_name = template_name
        # template_width
        self.template_width = template_width
        # url, 视频播放地址
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.template_height is not None:
            result['template_height'] = self.template_height
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.template_name is not None:
            result['template_name'] = self.template_name
        if self.template_width is not None:
            result['template_width'] = self.template_width
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_height') is not None:
            self.template_height = m.get('template_height')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('template_name') is not None:
            self.template_name = m.get('template_name')
        if m.get('template_width') is not None:
            self.template_width = m.get('template_width')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class VideoPreviewPlayInfoResponse(TeaModel):
    """
    转码信息响应
    """
    def __init__(
        self,
        category: str = None,
        live_transcoding_subtitle_task_list: List[LiveTranscodingSubtitleTaskResponse] = None,
        live_transcoding_task_list: List[LiveTranscodingTaskResponse] = None,
        master_url: str = None,
        meta: VideoPreviewPlayInfoMetaResponse = None,
        offline_video_transcoding_list: List[VideoPreviewOfflineVideoTranscodingTaskResponse] = None,
        quick_video_list: List[QuickVideoTaskResponse] = None,
    ):
        # deprecated, 使用外层Response中的同名字段替代
        # category，此字段为保持兼容而继续存在
        self.category = category
        self.live_transcoding_subtitle_task_list = live_transcoding_subtitle_task_list
        # 边转边播有效
        self.live_transcoding_task_list = live_transcoding_task_list
        # master playlist 播放地址
        self.master_url = master_url
        self.meta = meta
        # 离线转码有效
        self.offline_video_transcoding_list = offline_video_transcoding_list
        # imm边转边播
        self.quick_video_list = quick_video_list

    def validate(self):
        if self.live_transcoding_subtitle_task_list:
            for k in self.live_transcoding_subtitle_task_list:
                if k:
                    k.validate()
        if self.live_transcoding_task_list:
            for k in self.live_transcoding_task_list:
                if k:
                    k.validate()
        if self.meta:
            self.meta.validate()
        if self.offline_video_transcoding_list:
            for k in self.offline_video_transcoding_list:
                if k:
                    k.validate()
        if self.quick_video_list:
            for k in self.quick_video_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        result['live_transcoding_subtitle_task_list'] = []
        if self.live_transcoding_subtitle_task_list is not None:
            for k in self.live_transcoding_subtitle_task_list:
                result['live_transcoding_subtitle_task_list'].append(k.to_map() if k else None)
        result['live_transcoding_task_list'] = []
        if self.live_transcoding_task_list is not None:
            for k in self.live_transcoding_task_list:
                result['live_transcoding_task_list'].append(k.to_map() if k else None)
        if self.master_url is not None:
            result['master_url'] = self.master_url
        if self.meta is not None:
            result['meta'] = self.meta.to_map()
        result['offline_video_transcoding_list'] = []
        if self.offline_video_transcoding_list is not None:
            for k in self.offline_video_transcoding_list:
                result['offline_video_transcoding_list'].append(k.to_map() if k else None)
        result['quick_video_list'] = []
        if self.quick_video_list is not None:
            for k in self.quick_video_list:
                result['quick_video_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        self.live_transcoding_subtitle_task_list = []
        if m.get('live_transcoding_subtitle_task_list') is not None:
            for k in m.get('live_transcoding_subtitle_task_list'):
                temp_model = LiveTranscodingSubtitleTaskResponse()
                self.live_transcoding_subtitle_task_list.append(temp_model.from_map(k))
        self.live_transcoding_task_list = []
        if m.get('live_transcoding_task_list') is not None:
            for k in m.get('live_transcoding_task_list'):
                temp_model = LiveTranscodingTaskResponse()
                self.live_transcoding_task_list.append(temp_model.from_map(k))
        if m.get('master_url') is not None:
            self.master_url = m.get('master_url')
        if m.get('meta') is not None:
            temp_model = VideoPreviewPlayInfoMetaResponse()
            self.meta = temp_model.from_map(m['meta'])
        self.offline_video_transcoding_list = []
        if m.get('offline_video_transcoding_list') is not None:
            for k in m.get('offline_video_transcoding_list'):
                temp_model = VideoPreviewOfflineVideoTranscodingTaskResponse()
                self.offline_video_transcoding_list.append(temp_model.from_map(k))
        self.quick_video_list = []
        if m.get('quick_video_list') is not None:
            for k in m.get('quick_video_list'):
                temp_model = QuickVideoTaskResponse()
                self.quick_video_list.append(temp_model.from_map(k))
        return self


class CCPGetVideoPreviewPlayInfoResponse(TeaModel):
    """
    获取转码信息响应
    """
    def __init__(
        self,
        audio_preview_play_info: AudioPreviewPlayInfoResponse = None,
        category: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        share_id: str = None,
        video_preview_play_info: VideoPreviewPlayInfoResponse = None,
    ):
        self.audio_preview_play_info = audio_preview_play_info
        # category
        self.category = category
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # share_id
        self.share_id = share_id
        self.video_preview_play_info = video_preview_play_info

    def validate(self):
        if self.audio_preview_play_info:
            self.audio_preview_play_info.validate()
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.video_preview_play_info:
            self.video_preview_play_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_preview_play_info is not None:
            result['audio_preview_play_info'] = self.audio_preview_play_info.to_map()
        if self.category is not None:
            result['category'] = self.category
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.video_preview_play_info is not None:
            result['video_preview_play_info'] = self.video_preview_play_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_preview_play_info') is not None:
            temp_model = AudioPreviewPlayInfoResponse()
            self.audio_preview_play_info = temp_model.from_map(m['audio_preview_play_info'])
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('video_preview_play_info') is not None:
            temp_model = VideoPreviewPlayInfoResponse()
            self.video_preview_play_info = temp_model.from_map(m['video_preview_play_info'])
        return self


class GetMediaPreviewInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPGetVideoPreviewPlayInfoResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPGetVideoPreviewPlayInfoResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CCPGetVideoPreviewPlayMetaResponse(TeaModel):
    """
    获取播放元信息响应
    """
    def __init__(
        self,
        audio_preview_play_meta: AudioPreviewPlayInfoResponse = None,
        category: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        share_id: str = None,
        video_preview_play_meta: VideoPreviewPlayInfoResponse = None,
    ):
        self.audio_preview_play_meta = audio_preview_play_meta
        # category
        self.category = category
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # share_id
        self.share_id = share_id
        self.video_preview_play_meta = video_preview_play_meta

    def validate(self):
        if self.audio_preview_play_meta:
            self.audio_preview_play_meta.validate()
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.video_preview_play_meta:
            self.video_preview_play_meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_preview_play_meta is not None:
            result['audio_preview_play_meta'] = self.audio_preview_play_meta.to_map()
        if self.category is not None:
            result['category'] = self.category
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.video_preview_play_meta is not None:
            result['video_preview_play_meta'] = self.video_preview_play_meta.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_preview_play_meta') is not None:
            temp_model = AudioPreviewPlayInfoResponse()
            self.audio_preview_play_meta = temp_model.from_map(m['audio_preview_play_meta'])
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('video_preview_play_meta') is not None:
            temp_model = VideoPreviewPlayInfoResponse()
            self.video_preview_play_meta = temp_model.from_map(m['video_preview_play_meta'])
        return self


class GetMediaPreviewMetaModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPGetVideoPreviewPlayMetaResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPGetVideoPreviewPlayMetaResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOfficeEditUrlResponse(TeaModel):
    """
    获取office文档在线编辑地址 response
    """
    def __init__(
        self,
        edit_url: str = None,
        office_access_token: str = None,
        office_refresh_token: str = None,
    ):
        # EditUrl
        self.edit_url = edit_url
        # AccessToken
        self.office_access_token = office_access_token
        # RefreshToken
        self.office_refresh_token = office_refresh_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edit_url is not None:
            result['edit_url'] = self.edit_url
        if self.office_access_token is not None:
            result['office_access_token'] = self.office_access_token
        if self.office_refresh_token is not None:
            result['office_refresh_token'] = self.office_refresh_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('edit_url') is not None:
            self.edit_url = m.get('edit_url')
        if m.get('office_access_token') is not None:
            self.office_access_token = m.get('office_access_token')
        if m.get('office_refresh_token') is not None:
            self.office_refresh_token = m.get('office_refresh_token')
        return self


class GetOfficeEditUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetOfficeEditUrlResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetOfficeEditUrlResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOfficePreviewUrlResponse(TeaModel):
    """
    获取文档预览地址 response
    """
    def __init__(
        self,
        access_token: str = None,
        preview_url: str = None,
    ):
        # AccessToken
        self.access_token = access_token
        # preview_url
        self.preview_url = preview_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['access_token'] = self.access_token
        if self.preview_url is not None:
            result['preview_url'] = self.preview_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_token') is not None:
            self.access_token = m.get('access_token')
        if m.get('preview_url') is not None:
            self.preview_url = m.get('preview_url')
        return self


class GetOfficePreviewUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetOfficePreviewUrlResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetOfficePreviewUrlResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class MediaPlayInfoTemplate(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        status: str = None,
        template_id: str = None,
        url: str = None,
    ):
        # status
        self.status = status
        # template_id
        self.template_id = template_id
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetShareLinkDownloadURLResponse(TeaModel):
    """
    获取分享中文件数据response
    """
    def __init__(
        self,
        audio_template_list: List[MediaPlayInfoTemplate] = None,
        download_url: str = None,
        streams_info: dict = None,
        streams_url: dict = None,
        thumbnail: str = None,
        url: str = None,
        video_template_list: List[MediaPlayInfoTemplate] = None,
    ):
        # audio_template_list
        self.audio_template_list = audio_template_list
        # download_url
        self.download_url = download_url
        # @Deprecated streams url info
        self.streams_info = streams_info
        # streams url info
        self.streams_url = streams_url
        # thumbnail
        self.thumbnail = thumbnail
        # url
        self.url = url
        # video_template_list
        self.video_template_list = video_template_list

    def validate(self):
        if self.audio_template_list:
            for k in self.audio_template_list:
                if k:
                    k.validate()
        if self.video_template_list:
            for k in self.video_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['audio_template_list'] = []
        if self.audio_template_list is not None:
            for k in self.audio_template_list:
                result['audio_template_list'].append(k.to_map() if k else None)
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.streams_url is not None:
            result['streams_url'] = self.streams_url
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.url is not None:
            result['url'] = self.url
        result['video_template_list'] = []
        if self.video_template_list is not None:
            for k in self.video_template_list:
                result['video_template_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_template_list = []
        if m.get('audio_template_list') is not None:
            for k in m.get('audio_template_list'):
                temp_model = MediaPlayInfoTemplate()
                self.audio_template_list.append(temp_model.from_map(k))
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('streams_url') is not None:
            self.streams_url = m.get('streams_url')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('url') is not None:
            self.url = m.get('url')
        self.video_template_list = []
        if m.get('video_template_list') is not None:
            for k in m.get('video_template_list'):
                temp_model = MediaPlayInfoTemplate()
                self.video_template_list.append(temp_model.from_map(k))
        return self


class GetShareLinkDownloadUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetShareLinkDownloadURLResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetShareLinkDownloadURLResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CCPGetShareLinkVideoPreviewPlayInfoResponse(TeaModel):
    """
    获取分享中媒体播放地址response
    """
    def __init__(
        self,
        audio_preview_play_info: AudioPreviewPlayInfoResponse = None,
        category: str = None,
        file_id: str = None,
        share_id: str = None,
        video_preview_play_info: VideoPreviewPlayInfoResponse = None,
    ):
        self.audio_preview_play_info = audio_preview_play_info
        # category
        self.category = category
        # file_id
        self.file_id = file_id
        # share_id
        self.share_id = share_id
        self.video_preview_play_info = video_preview_play_info

    def validate(self):
        if self.audio_preview_play_info:
            self.audio_preview_play_info.validate()
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.video_preview_play_info:
            self.video_preview_play_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_preview_play_info is not None:
            result['audio_preview_play_info'] = self.audio_preview_play_info.to_map()
        if self.category is not None:
            result['category'] = self.category
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.video_preview_play_info is not None:
            result['video_preview_play_info'] = self.video_preview_play_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_preview_play_info') is not None:
            temp_model = AudioPreviewPlayInfoResponse()
            self.audio_preview_play_info = temp_model.from_map(m['audio_preview_play_info'])
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('video_preview_play_info') is not None:
            temp_model = VideoPreviewPlayInfoResponse()
            self.video_preview_play_info = temp_model.from_map(m['video_preview_play_info'])
        return self


class GetShareLinkVideoPreviewPlayInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPGetShareLinkVideoPreviewPlayInfoResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPGetShareLinkVideoPreviewPlayInfoResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UCGetSignatureResponse(TeaModel):
    """
    UCGetSignatureResponse
    """
    def __init__(
        self,
        bucket: str = None,
        canonicalized_resource: str = None,
        endpoint: str = None,
        headers: dict = None,
        object_key: str = None,
        signature: str = None,
        str_to_sign: str = None,
    ):
        self.bucket = bucket
        self.canonicalized_resource = canonicalized_resource
        self.endpoint = endpoint
        self.headers = headers
        self.object_key = object_key
        self.signature = signature
        self.str_to_sign = str_to_sign

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.canonicalized_resource is not None:
            result['canonicalized_resource'] = self.canonicalized_resource
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.headers is not None:
            result['headers'] = self.headers
        if self.object_key is not None:
            result['object_key'] = self.object_key
        if self.signature is not None:
            result['signature'] = self.signature
        if self.str_to_sign is not None:
            result['str_to_sign'] = self.str_to_sign
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('canonicalized_resource') is not None:
            self.canonicalized_resource = m.get('canonicalized_resource')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        if m.get('signature') is not None:
            self.signature = m.get('signature')
        if m.get('str_to_sign') is not None:
            self.str_to_sign = m.get('str_to_sign')
        return self


class GetFileSignatureModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UCGetSignatureResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UCGetSignatureResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUploadUrlResponse(TeaModel):
    """
    Get UploadUrl Response
    """
    def __init__(
        self,
        create_at: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # created_at
        self.create_at = create_at
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # part_info_list
        self.part_info_list = part_info_list
        # share_id
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_at is not None:
            result['create_at'] = self.create_at
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('create_at') is not None:
            self.create_at = m.get('create_at')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class GetUploadUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetUploadUrlResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetUploadUrlResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoPreviewPlayInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPGetVideoPreviewPlayInfoResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPGetVideoPreviewPlayInfoResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoPreviewPlayMetaModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPGetVideoPreviewPlayMetaResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPGetVideoPreviewPlayMetaResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoPreviewSpriteURLResponse(TeaModel):
    """
    获取视频雪碧图地址 url response
    """
    def __init__(
        self,
        col: int = None,
        count: int = None,
        frame_count: int = None,
        frame_height: int = None,
        frame_width: int = None,
        row: int = None,
        sprite_url_list: List[str] = None,
    ):
        # col
        self.col = col
        # count
        self.count = count
        # frame_count
        self.frame_count = frame_count
        # frame_height
        self.frame_height = frame_height
        # frame_width
        self.frame_width = frame_width
        # row
        self.row = row
        # sprite_url_list
        self.sprite_url_list = sprite_url_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.col is not None:
            result['col'] = self.col
        if self.count is not None:
            result['count'] = self.count
        if self.frame_count is not None:
            result['frame_count'] = self.frame_count
        if self.frame_height is not None:
            result['frame_height'] = self.frame_height
        if self.frame_width is not None:
            result['frame_width'] = self.frame_width
        if self.row is not None:
            result['row'] = self.row
        if self.sprite_url_list is not None:
            result['sprite_url_list'] = self.sprite_url_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('col') is not None:
            self.col = m.get('col')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('frame_count') is not None:
            self.frame_count = m.get('frame_count')
        if m.get('frame_height') is not None:
            self.frame_height = m.get('frame_height')
        if m.get('frame_width') is not None:
            self.frame_width = m.get('frame_width')
        if m.get('row') is not None:
            self.row = m.get('row')
        if m.get('sprite_url_list') is not None:
            self.sprite_url_list = m.get('sprite_url_list')
        return self


class GetVideoPreviewSpriteUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetVideoPreviewSpriteURLResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetVideoPreviewSpriteURLResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVideoPreviewURLResponse(TeaModel):
    """
    获取视频文件播放 url response
    """
    def __init__(
        self,
        preview_url: str = None,
    ):
        # preview_url
        self.preview_url = preview_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.preview_url is not None:
            result['preview_url'] = self.preview_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('preview_url') is not None:
            self.preview_url = m.get('preview_url')
        return self


class GetVideoPreviewUrlModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetVideoPreviewURLResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetVideoPreviewURLResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseCCPFileResponse(TeaModel):
    """
    Base file response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class ListFileResponse(TeaModel):
    """
    List file response
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
        punished_file_count: int = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker
        # punished_file_count
        self.punished_file_count = punished_file_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.punished_file_count is not None:
            result['punished_file_count'] = self.punished_file_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('punished_file_count') is not None:
            self.punished_file_count = m.get('punished_file_count')
        return self


class ListFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ActorAliUser(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        ali_user_id: str = None,
        ali_user_type: str = None,
        as_user_id: str = None,
    ):
        # AliUserID
        self.ali_user_id = ali_user_id
        # AliUserType
        self.ali_user_type = ali_user_type
        # AsUserID
        self.as_user_id = as_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_user_id is not None:
            result['ali_user_id'] = self.ali_user_id
        if self.ali_user_type is not None:
            result['ali_user_type'] = self.ali_user_type
        if self.as_user_id is not None:
            result['as_user_id'] = self.as_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ali_user_id') is not None:
            self.ali_user_id = m.get('ali_user_id')
        if m.get('ali_user_type') is not None:
            self.ali_user_type = m.get('ali_user_type')
        if m.get('as_user_id') is not None:
            self.as_user_id = m.get('as_user_id')
        return self


class ActorAnonymousUser(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class ActorShareLinkUser(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        creator: str = None,
        share_id: str = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # Creator
        self.creator = creator
        # ShareID
        self.share_id = share_id
        # UserID
        self.user_id = user_id
        # UserName
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class ActorSystem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        event_type: str = None,
    ):
        # EventType
        self.event_type = event_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['event_type'] = self.event_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('event_type') is not None:
            self.event_type = m.get('event_type')
        return self


class ActorUser(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        user_id: str = None,
        user_name: str = None,
    ):
        # UserID
        self.user_id = user_id
        # UserName
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class Actor(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        ali_user: ActorAliUser = None,
        anonymous_user: ActorAnonymousUser = None,
        share_link_user: ActorShareLinkUser = None,
        system: ActorSystem = None,
        user: ActorUser = None,
    ):
        self.ali_user = ali_user
        self.anonymous_user = anonymous_user
        self.share_link_user = share_link_user
        self.system = system
        self.user = user

    def validate(self):
        if self.ali_user:
            self.ali_user.validate()
        if self.anonymous_user:
            self.anonymous_user.validate()
        if self.share_link_user:
            self.share_link_user.validate()
        if self.system:
            self.system.validate()
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_user is not None:
            result['ali_user'] = self.ali_user.to_map()
        if self.anonymous_user is not None:
            result['anonymous_user'] = self.anonymous_user.to_map()
        if self.share_link_user is not None:
            result['share_link_user'] = self.share_link_user.to_map()
        if self.system is not None:
            result['system'] = self.system.to_map()
        if self.user is not None:
            result['user'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ali_user') is not None:
            temp_model = ActorAliUser()
            self.ali_user = temp_model.from_map(m['ali_user'])
        if m.get('anonymous_user') is not None:
            temp_model = ActorAnonymousUser()
            self.anonymous_user = temp_model.from_map(m['anonymous_user'])
        if m.get('share_link_user') is not None:
            temp_model = ActorShareLinkUser()
            self.share_link_user = temp_model.from_map(m['share_link_user'])
        if m.get('system') is not None:
            temp_model = ActorSystem()
            self.system = temp_model.from_map(m['system'])
        if m.get('user') is not None:
            temp_model = ActorUser()
            self.user = temp_model.from_map(m['user'])
        return self


class CreateDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        create_type: str = None,
        is_over_write: bool = None,
        src_file_id: str = None,
    ):
        # CreateType
        self.create_type = create_type
        self.is_over_write = is_over_write
        # SrcFileID
        self.src_file_id = src_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_type is not None:
            result['create_type'] = self.create_type
        if self.is_over_write is not None:
            result['is_over_write'] = self.is_over_write
        if self.src_file_id is not None:
            result['src_file_id'] = self.src_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('create_type') is not None:
            self.create_type = m.get('create_type')
        if m.get('is_over_write') is not None:
            self.is_over_write = m.get('is_over_write')
        if m.get('src_file_id') is not None:
            self.src_file_id = m.get('src_file_id')
        return self


class DeleteDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        src_parent_file_id: str = None,
        tgt_parent_file_id: str = None,
    ):
        # SrcParentFileID
        self.src_parent_file_id = src_parent_file_id
        # TgtParentFileID
        self.tgt_parent_file_id = tgt_parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.src_parent_file_id is not None:
            result['src_parent_file_id'] = self.src_parent_file_id
        if self.tgt_parent_file_id is not None:
            result['tgt_parent_file_id'] = self.tgt_parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('src_parent_file_id') is not None:
            self.src_parent_file_id = m.get('src_parent_file_id')
        if m.get('tgt_parent_file_id') is not None:
            self.tgt_parent_file_id = m.get('tgt_parent_file_id')
        return self


class EditDetail(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class MoveDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        src_parent_file_id: str = None,
        tgt_parent_file_id: str = None,
    ):
        # SrcParentFileID
        self.src_parent_file_id = src_parent_file_id
        # TgtParentFileID
        self.tgt_parent_file_id = tgt_parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.src_parent_file_id is not None:
            result['src_parent_file_id'] = self.src_parent_file_id
        if self.tgt_parent_file_id is not None:
            result['tgt_parent_file_id'] = self.tgt_parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('src_parent_file_id') is not None:
            self.src_parent_file_id = m.get('src_parent_file_id')
        if m.get('tgt_parent_file_id') is not None:
            self.tgt_parent_file_id = m.get('tgt_parent_file_id')
        return self


class RenameDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        new_name: str = None,
        old_name: str = None,
    ):
        # NewName
        self.new_name = new_name
        # OldName
        self.old_name = old_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.old_name is not None:
            result['old_name'] = self.old_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('old_name') is not None:
            self.old_name = m.get('old_name')
        return self


class RestoreDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        src_parent_file_id: str = None,
        tgt_parent_file_id: str = None,
    ):
        # SrcParentFileID
        self.src_parent_file_id = src_parent_file_id
        # TgtParentFileID
        self.tgt_parent_file_id = tgt_parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.src_parent_file_id is not None:
            result['src_parent_file_id'] = self.src_parent_file_id
        if self.tgt_parent_file_id is not None:
            result['tgt_parent_file_id'] = self.tgt_parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('src_parent_file_id') is not None:
            self.src_parent_file_id = m.get('src_parent_file_id')
        if m.get('tgt_parent_file_id') is not None:
            self.tgt_parent_file_id = m.get('tgt_parent_file_id')
        return self


class TrashDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        src_parent_file_id: str = None,
        tgt_parent_file_id: str = None,
    ):
        # SrcParentFileID
        self.src_parent_file_id = src_parent_file_id
        # TgtParentFileID
        self.tgt_parent_file_id = tgt_parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.src_parent_file_id is not None:
            result['src_parent_file_id'] = self.src_parent_file_id
        if self.tgt_parent_file_id is not None:
            result['tgt_parent_file_id'] = self.tgt_parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('src_parent_file_id') is not None:
            self.src_parent_file_id = m.get('src_parent_file_id')
        if m.get('tgt_parent_file_id') is not None:
            self.tgt_parent_file_id = m.get('tgt_parent_file_id')
        return self


class ActionDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        create: CreateDetail = None,
        delete: DeleteDetail = None,
        edit: EditDetail = None,
        move: MoveDetail = None,
        rename: RenameDetail = None,
        restore: RestoreDetail = None,
        trash: TrashDetail = None,
    ):
        self.create = create
        self.delete = delete
        self.edit = edit
        self.move = move
        self.rename = rename
        self.restore = restore
        self.trash = trash

    def validate(self):
        if self.create:
            self.create.validate()
        if self.delete:
            self.delete.validate()
        if self.edit:
            self.edit.validate()
        if self.move:
            self.move.validate()
        if self.rename:
            self.rename.validate()
        if self.restore:
            self.restore.validate()
        if self.trash:
            self.trash.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create is not None:
            result['create'] = self.create.to_map()
        if self.delete is not None:
            result['delete'] = self.delete.to_map()
        if self.edit is not None:
            result['edit'] = self.edit.to_map()
        if self.move is not None:
            result['move'] = self.move.to_map()
        if self.rename is not None:
            result['rename'] = self.rename.to_map()
        if self.restore is not None:
            result['restore'] = self.restore.to_map()
        if self.trash is not None:
            result['trash'] = self.trash.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('create') is not None:
            temp_model = CreateDetail()
            self.create = temp_model.from_map(m['create'])
        if m.get('delete') is not None:
            temp_model = DeleteDetail()
            self.delete = temp_model.from_map(m['delete'])
        if m.get('edit') is not None:
            temp_model = EditDetail()
            self.edit = temp_model.from_map(m['edit'])
        if m.get('move') is not None:
            temp_model = MoveDetail()
            self.move = temp_model.from_map(m['move'])
        if m.get('rename') is not None:
            temp_model = RenameDetail()
            self.rename = temp_model.from_map(m['rename'])
        if m.get('restore') is not None:
            temp_model = RestoreDetail()
            self.restore = temp_model.from_map(m['restore'])
        if m.get('trash') is not None:
            temp_model = TrashDetail()
            self.trash = temp_model.from_map(m['trash'])
        return self


class Target(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        file_id: str = None,
        file_name: str = None,
        file_type: str = None,
    ):
        # FileID
        self.file_id = file_id
        # FileName
        self.file_name = file_name
        # FileType
        self.file_type = file_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.file_type is not None:
            result['file_type'] = self.file_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('file_type') is not None:
            self.file_type = m.get('file_type')
        return self


class TimeRange(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        end_time: str = None,
        start_time: str = None,
    ):
        # EndTime
        self.end_time = end_time
        # StartTime
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.start_time is not None:
            result['start_time'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        return self


class FileActivity(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        actors: List[Actor] = None,
        primary_action_detail: ActionDetail = None,
        targets: List[Target] = None,
        time_range: TimeRange = None,
        timestamp: str = None,
    ):
        # Actors
        self.actors = actors
        self.primary_action_detail = primary_action_detail
        # Targets
        self.targets = targets
        self.time_range = time_range
        # Timestamp
        self.timestamp = timestamp

    def validate(self):
        if self.actors:
            for k in self.actors:
                if k:
                    k.validate()
        if self.primary_action_detail:
            self.primary_action_detail.validate()
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()
        if self.time_range:
            self.time_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actors'] = []
        if self.actors is not None:
            for k in self.actors:
                result['actors'].append(k.to_map() if k else None)
        if self.primary_action_detail is not None:
            result['primary_action_detail'] = self.primary_action_detail.to_map()
        result['targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['targets'].append(k.to_map() if k else None)
        if self.time_range is not None:
            result['time_range'] = self.time_range.to_map()
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actors = []
        if m.get('actors') is not None:
            for k in m.get('actors'):
                temp_model = Actor()
                self.actors.append(temp_model.from_map(k))
        if m.get('primary_action_detail') is not None:
            temp_model = ActionDetail()
            self.primary_action_detail = temp_model.from_map(m['primary_action_detail'])
        self.targets = []
        if m.get('targets') is not None:
            for k in m.get('targets'):
                temp_model = Target()
                self.targets.append(temp_model.from_map(k))
        if m.get('time_range') is not None:
            temp_model = TimeRange()
            self.time_range = temp_model.from_map(m['time_range'])
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class ListFileActivityResponse(TeaModel):
    """
    list file activity response
    """
    def __init__(
        self,
        activities: List[FileActivity] = None,
        next_marker: str = None,
    ):
        # Activities
        self.activities = activities
        # NextMarker
        self.next_marker = next_marker

    def validate(self):
        if self.activities:
            for k in self.activities:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['activities'] = []
        if self.activities is not None:
            for k in self.activities:
                result['activities'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activities = []
        if m.get('activities') is not None:
            for k in m.get('activities'):
                temp_model = FileActivity()
                self.activities.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListFileActivityModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileActivityResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileActivityResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseFileAnonymousResponse(TeaModel):
    """
    list_file_by_anonymous base response
    """
    def __init__(
        self,
        file_id: str = None,
        name: str = None,
        size: int = None,
        thumbnail: str = None,
        type: str = None,
        updated_at: str = None,
    ):
        # file_id
        self.file_id = file_id
        # name
        self.name = name
        # size, type=file时才有效
        self.size = size
        # thumbnail
        self.thumbnail = thumbnail
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.name is not None:
            result['name'] = self.name
        if self.size is not None:
            result['size'] = self.size
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ListByAnonymousResponse(TeaModel):
    """
    list_file_by_anonymous response
    """
    def __init__(
        self,
        items: List[BaseFileAnonymousResponse] = None,
        next_marker: str = None,
        punished_file_count: int = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker
        # punished_file_count
        self.punished_file_count = punished_file_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.punished_file_count is not None:
            result['punished_file_count'] = self.punished_file_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseFileAnonymousResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('punished_file_count') is not None:
            self.punished_file_count = m.get('punished_file_count')
        return self


class ListFileByAnonymousModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListByAnonymousResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListByAnonymousResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFileByCustomIndexKeyModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeltaExtInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        move_type: str = None,
        src_name: str = None,
        src_parent_file_id: str = None,
    ):
        self.move_type = move_type
        self.src_name = src_name
        self.src_parent_file_id = src_parent_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.move_type is not None:
            result['move_type'] = self.move_type
        if self.src_name is not None:
            result['src_name'] = self.src_name
        if self.src_parent_file_id is not None:
            result['src_parent_file_id'] = self.src_parent_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('move_type') is not None:
            self.move_type = m.get('move_type')
        if m.get('src_name') is not None:
            self.src_name = m.get('src_name')
        if m.get('src_parent_file_id') is not None:
            self.src_parent_file_id = m.get('src_parent_file_id')
        return self


class FileDeltaResponse(TeaModel):
    """
    the file op info
    """
    def __init__(
        self,
        current_category: str = None,
        ext_info: DeltaExtInfo = None,
        file: BaseCCPFileResponse = None,
        file_id: str = None,
        op: str = None,
    ):
        self.current_category = current_category
        self.ext_info = ext_info
        self.file = file
        self.file_id = file_id
        self.op = op

    def validate(self):
        if self.ext_info:
            self.ext_info.validate()
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_category is not None:
            result['current_category'] = self.current_category
        if self.ext_info is not None:
            result['ext_info'] = self.ext_info.to_map()
        if self.file is not None:
            result['file'] = self.file.to_map()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current_category') is not None:
            self.current_category = m.get('current_category')
        if m.get('ext_info') is not None:
            temp_model = DeltaExtInfo()
            self.ext_info = temp_model.from_map(m['ext_info'])
        if m.get('file') is not None:
            temp_model = BaseCCPFileResponse()
            self.file = temp_model.from_map(m['file'])
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class ListFileDeltaResponse(TeaModel):
    """
    list file op response
    """
    def __init__(
        self,
        cursor: str = None,
        has_more: bool = None,
        items: List[FileDeltaResponse] = None,
    ):
        # cursor
        self.cursor = cursor
        # has_more
        self.has_more = has_more
        # items
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['cursor'] = self.cursor
        if self.has_more is not None:
            result['has_more'] = self.has_more
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cursor') is not None:
            self.cursor = m.get('cursor')
        if m.get('has_more') is not None:
            self.has_more = m.get('has_more')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = FileDeltaResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListFileDeltaModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileDeltaResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileDeltaResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class Identity(TeaModel):
    """
    表示用户或团队
    """
    def __init__(
        self,
        identity_id: str = None,
        identity_name: str = None,
        identity_type: str = None,
    ):
        # 用户或团队的ID
        self.identity_id = identity_id
        # 显示名称
        self.identity_name = identity_name
        # 类型，目前可传：IT_User(用户)、IT_Group(团队)
        self.identity_type = identity_type

    def validate(self):
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_name is not None:
            result['identity_name'] = self.identity_name
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_name') is not None:
            self.identity_name = m.get('identity_name')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        return self


class FilePermissionMember(TeaModel):
    """
    文件被共享/授权的成员列表
    """
    def __init__(
        self,
        disinherit_sub_group: bool = None,
        expire_time: int = None,
        identity: Identity = None,
        role_id: str = None,
    ):
        # 子团队禁止继承此权限
        self.disinherit_sub_group = disinherit_sub_group
        # 过期时间，传入时间戳，单位毫秒
        self.expire_time = expire_time
        self.identity = identity
        # 授予的角色，目前支持：SystemFileOwner(文件协同)、SystemFileDownloader(下载者)、SystemFileEditor(编辑者)、SystemFileEditorWithoutDelete(无删除编辑者)、SystemFileEditorWithoutShareLink(无分享编辑者)、SystemFileMetaViewer(可见列表)、SystemFileUploader(上传者)、SystemFileUploaderAndDownloader(上传/下载者)、SystemFileDownloaderWithShareLink(下载/分享者)、SystemFileUploaderAndDownloaderWithShareLink(上传/下载/分享者)、SystemFileUploaderAndViewer(预览/上传者)、SystemFileUploaderWithShareLink(上传/分享者)、SystemFileViewer(预览者)
        self.role_id = role_id

    def validate(self):
        self.validate_required(self.expire_time, 'expire_time')
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.role_id, 'role_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disinherit_sub_group is not None:
            result['disinherit_sub_group'] = self.disinherit_sub_group
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.role_id is not None:
            result['role_id'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disinherit_sub_group') is not None:
            self.disinherit_sub_group = m.get('disinherit_sub_group')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        return self


class BaseFileListInheritPermissionResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        file_id: str = None,
        member: FilePermissionMember = None,
    ):
        # 被授权的文件ID
        self.file_id = file_id
        self.member = member

    def validate(self):
        self.validate_required(self.file_id, 'file_id')
        if self.member:
            self.member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.member is not None:
            result['member'] = self.member.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('member') is not None:
            temp_model = FilePermissionMember()
            self.member = temp_model.from_map(m['member'])
        return self


class FileListInheritPermissionResponse(TeaModel):
    """
    文件继承共享/授权的列表
    """
    def __init__(
        self,
        items: List[BaseFileListInheritPermissionResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseFileListInheritPermissionResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListInheritPermissionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: FileListInheritPermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = FileListInheritPermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListManageSharingFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPermissionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: List[FilePermissionMember] = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            for k in self.body:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        result['body'] = []
        if self.body is not None:
            for k in self.body:
                result['body'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        self.body = []
        if m.get('body') is not None:
            for k in m.get('body'):
                temp_model = FilePermissionMember()
                self.body.append(temp_model.from_map(k))
        return self


class ListReceivedFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSharingFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUploadedPartResponse(TeaModel):
    """
    获取签名 response
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        next_part_number_marker: str = None,
        parallel_upload: bool = None,
        upload_id: str = None,
        uploaded_parts: List[UploadPartInfo] = None,
    ):
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # next_part_number_marker
        self.next_part_number_marker = next_part_number_marker
        self.parallel_upload = parallel_upload
        # upload_id
        self.upload_id = upload_id
        # uploaded_parts
        self.uploaded_parts = uploaded_parts

    def validate(self):
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.uploaded_parts:
            for k in self.uploaded_parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.next_part_number_marker is not None:
            result['next_part_number_marker'] = self.next_part_number_marker
        if self.parallel_upload is not None:
            result['parallel_upload'] = self.parallel_upload
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        result['uploaded_parts'] = []
        if self.uploaded_parts is not None:
            for k in self.uploaded_parts:
                result['uploaded_parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('next_part_number_marker') is not None:
            self.next_part_number_marker = m.get('next_part_number_marker')
        if m.get('parallel_upload') is not None:
            self.parallel_upload = m.get('parallel_upload')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        self.uploaded_parts = []
        if m.get('uploaded_parts') is not None:
            for k in m.get('uploaded_parts'):
                temp_model = UploadPartInfo()
                self.uploaded_parts.append(temp_model.from_map(k))
        return self


class ListUploadedPartsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListUploadedPartResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListUploadedPartResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseFileUserPermissionResponse(TeaModel):
    """
    用户文件共享/授权列表返回信息
    """
    def __init__(
        self,
        can_access: bool = None,
        created_at: int = None,
        creator: str = None,
        disinherit_sub_group: bool = None,
        domain_id: str = None,
        drive_id: str = None,
        expire_time: int = None,
        file_full_path: str = None,
        file_id: str = None,
        identity: Identity = None,
        role_id: str = None,
    ):
        # 当前用户是否能访问此授权
        self.can_access = can_access
        # 创建时间
        self.created_at = created_at
        # 创建者的UserID
        self.creator = creator
        # 是否禁用子团队继承
        self.disinherit_sub_group = disinherit_sub_group
        # domain_id
        self.domain_id = domain_id
        # 被授权的driveID
        self.drive_id = drive_id
        # 过期时间
        self.expire_time = expire_time
        # 授权的文件ID
        self.file_full_path = file_full_path
        # 授权的文件ID
        self.file_id = file_id
        self.identity = identity
        # 授予的角色
        self.role_id = role_id

    def validate(self):
        self.validate_required(self.can_access, 'can_access')
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.creator, 'creator')
        self.validate_required(self.disinherit_sub_group, 'disinherit_sub_group')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.expire_time, 'expire_time')
        self.validate_required(self.file_full_path, 'file_full_path')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.role_id, 'role_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_access is not None:
            result['can_access'] = self.can_access
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.disinherit_sub_group is not None:
            result['disinherit_sub_group'] = self.disinherit_sub_group
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.file_full_path is not None:
            result['file_full_path'] = self.file_full_path
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.role_id is not None:
            result['role_id'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('can_access') is not None:
            self.can_access = m.get('can_access')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('disinherit_sub_group') is not None:
            self.disinherit_sub_group = m.get('disinherit_sub_group')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('file_full_path') is not None:
            self.file_full_path = m.get('file_full_path')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        return self


class FileListUserPermissionResponse(TeaModel):
    """
    用户所有的文件共享/授权列表请求
    """
    def __init__(
        self,
        items: List[BaseFileUserPermissionResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseFileUserPermissionResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListUserPermissionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: FileListUserPermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = FileListUserPermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CCPLiveTranscodeResponse(TeaModel):
    """
    CCPLiveTranscodeResponse
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class LiveTranscodeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPLiveTranscodeResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPLiveTranscodeResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveFileResponse(TeaModel):
    """
    文件移动 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        exist: bool = None,
        file_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # DomainID
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # exist
        # type: boolean
        self.exist = exist
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.exist is not None:
            result['exist'] = self.exist
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('exist') is not None:
            self.exist = m.get('exist')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class MoveFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: MoveFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = MoveFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class PutFileUserTagsResponse(TeaModel):
    """
    更新文件 user tags response
    """
    def __init__(
        self,
        file_id: str = None,
    ):
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.file_id is not None:
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class PutUsertagsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: PutFileUserTagsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = PutFileUserTagsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshOfficeEditTokenResponse(TeaModel):
    """
    刷新office文档在线编辑凭证 response
    """
    def __init__(
        self,
        office_access_token: str = None,
        office_refresh_token: str = None,
    ):
        # AccessToken
        self.office_access_token = office_access_token
        # RefreshToken
        self.office_refresh_token = office_refresh_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_access_token is not None:
            result['office_access_token'] = self.office_access_token
        if self.office_refresh_token is not None:
            result['office_refresh_token'] = self.office_refresh_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('office_access_token') is not None:
            self.office_access_token = m.get('office_access_token')
        if m.get('office_refresh_token') is not None:
            self.office_refresh_token = m.get('office_refresh_token')
        return self


class TokenModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: RefreshOfficeEditTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = RefreshOfficeEditTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RemovePermissionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class DeleteRevisionResponse(TeaModel):
    """
    删除版本response
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteFileRevisionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteRevisionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteRevisionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRevisionResponse(TeaModel):
    """
    获取版本response
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_id: str = None,
        is_latest_version: bool = None,
        keep_forever: bool = None,
        revision_create_reason: str = None,
        revision_description: str = None,
        revision_id: str = None,
        revision_name: str = None,
        revision_version: int = None,
        size: int = None,
        streams_info: dict = None,
        thumbnail: str = None,
        updated_at: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # is_latest_version
        # type: boolean
        self.is_latest_version = is_latest_version
        # keep_forever
        # type: boolean
        self.keep_forever = keep_forever
        # revision_create_reason
        # type: string
        self.revision_create_reason = revision_create_reason
        # revision_description
        # type: string
        self.revision_description = revision_description
        # revision_id
        self.revision_id = revision_id
        # revision_name
        # name
        self.revision_name = revision_name
        # revision_version
        self.revision_version = revision_version
        # Size
        self.size = size
        # @Deprecated streams url info
        self.streams_info = streams_info
        # thumbnail
        self.thumbnail = thumbnail
        # updated_at
        self.updated_at = updated_at
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.revision_create_reason is not None:
            self.validate_max_length(self.revision_create_reason, 'revision_create_reason', 1024)
        if self.revision_description is not None:
            self.validate_max_length(self.revision_description, 'revision_description', 1024)
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9]{1,50}')
        if self.revision_name is not None:
            self.validate_pattern(self.revision_name, 'revision_name', '[a-zA-Z0-9.-]{1,1000}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.is_latest_version is not None:
            result['is_latest_version'] = self.is_latest_version
        if self.keep_forever is not None:
            result['keep_forever'] = self.keep_forever
        if self.revision_create_reason is not None:
            result['revision_create_reason'] = self.revision_create_reason
        if self.revision_description is not None:
            result['revision_description'] = self.revision_description
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_name is not None:
            result['revision_name'] = self.revision_name
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.size is not None:
            result['size'] = self.size
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('is_latest_version') is not None:
            self.is_latest_version = m.get('is_latest_version')
        if m.get('keep_forever') is not None:
            self.keep_forever = m.get('keep_forever')
        if m.get('revision_create_reason') is not None:
            self.revision_create_reason = m.get('revision_create_reason')
        if m.get('revision_description') is not None:
            self.revision_description = m.get('revision_description')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_name') is not None:
            self.revision_name = m.get('revision_name')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetFileRevisionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetRevisionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetRevisionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseRevisionResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_id: str = None,
        is_latest_version: bool = None,
        keep_forever: bool = None,
        revision_create_reason: str = None,
        revision_description: str = None,
        revision_id: str = None,
        revision_name: str = None,
        revision_version: int = None,
        size: int = None,
        thumbnail: str = None,
        updated_at: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # DomainID
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # is_latest_version
        # type: boolean
        self.is_latest_version = is_latest_version
        # keep_forever
        # type: boolean
        self.keep_forever = keep_forever
        # revision_create_reason
        # type: string
        self.revision_create_reason = revision_create_reason
        # revision_description
        # type: string
        self.revision_description = revision_description
        # revision_id
        self.revision_id = revision_id
        # revision_name
        # name
        self.revision_name = revision_name
        # revision_version
        self.revision_version = revision_version
        # Size
        self.size = size
        # thumbnail
        self.thumbnail = thumbnail
        # updated_at
        self.updated_at = updated_at
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.revision_create_reason is not None:
            self.validate_max_length(self.revision_create_reason, 'revision_create_reason', 1024)
        if self.revision_description is not None:
            self.validate_max_length(self.revision_description, 'revision_description', 1024)
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9]{1,50}')
        if self.revision_name is not None:
            self.validate_pattern(self.revision_name, 'revision_name', '[a-zA-Z0-9.-]{1,1000}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.is_latest_version is not None:
            result['is_latest_version'] = self.is_latest_version
        if self.keep_forever is not None:
            result['keep_forever'] = self.keep_forever
        if self.revision_create_reason is not None:
            result['revision_create_reason'] = self.revision_create_reason
        if self.revision_description is not None:
            result['revision_description'] = self.revision_description
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_name is not None:
            result['revision_name'] = self.revision_name
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.size is not None:
            result['size'] = self.size
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('is_latest_version') is not None:
            self.is_latest_version = m.get('is_latest_version')
        if m.get('keep_forever') is not None:
            self.keep_forever = m.get('keep_forever')
        if m.get('revision_create_reason') is not None:
            self.revision_create_reason = m.get('revision_create_reason')
        if m.get('revision_description') is not None:
            self.revision_description = m.get('revision_description')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_name') is not None:
            self.revision_name = m.get('revision_name')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListRevisionResponse(TeaModel):
    """
    列举版本response
    """
    def __init__(
        self,
        items: List[BaseRevisionResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseRevisionResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListFileRevisionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListRevisionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListRevisionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RestoreFileRevisionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetRevisionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetRevisionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFileRevisionModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetRevisionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetRevisionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ScanFileMetaResponse(TeaModel):
    """
    scan file meta response
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ScanFileMetaModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ScanFileMetaResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ScanFileMetaResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchFileResponse(TeaModel):
    """
    search file response
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker
        # total_count
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class SearchFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class FpRef(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_revision_id: str = None,
    ):
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # file_revision_id
        self.file_revision_id = file_revision_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_revision_id is not None:
            result['file_revision_id'] = self.file_revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_revision_id') is not None:
            self.file_revision_id = m.get('file_revision_id')
        return self


class SearchFileFpRefsResponse(TeaModel):
    """
    search file response
    """
    def __init__(
        self,
        items: List[FpRef] = None,
        next_marker: str = None,
    ):
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = FpRef()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class SearchFileFpRefsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchFileFpRefsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchFileFpRefsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFileMetaResponse(TeaModel):
    """
    更新文件元数据 response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class UpdateFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateFileMetaResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateFileMetaResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UCUpdateUploadContentHashResponse(TeaModel):
    """
    UCUpdateUploadContentHashResponse
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_md_5: str = None,
        drive_id: str = None,
        file_id: str = None,
        is_rapid_upload: bool = None,
        size: int = None,
        update_time: str = None,
        upload_id: str = None,
    ):
        self.content_hash = content_hash
        self.content_hash_name = content_hash_name
        self.content_md_5 = content_md_5
        self.drive_id = drive_id
        self.file_id = file_id
        self.is_rapid_upload = is_rapid_upload
        self.size = size
        self.update_time = update_time
        self.upload_id = upload_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.is_rapid_upload is not None:
            result['is_rapid_upload'] = self.is_rapid_upload
        if self.size is not None:
            result['size'] = self.size
        if self.update_time is not None:
            result['update_time'] = self.update_time
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('is_rapid_upload') is not None:
            self.is_rapid_upload = m.get('is_rapid_upload')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('update_time') is not None:
            self.update_time = m.get('update_time')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class UpdateFileUploadContentHashModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UCUpdateUploadContentHashResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UCUpdateUploadContentHashResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CCPVideoDRMLicenseResponse(TeaModel):
    """
    DRM License response
    """
    def __init__(
        self,
        data: str = None,
        device_info: str = None,
        states: int = None,
    ):
        # drm_data
        self.data = data
        # device_info
        self.device_info = device_info
        # states
        self.states = states

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.device_info is not None:
            result['device_info'] = self.device_info
        if self.states is not None:
            result['states'] = self.states
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('device_info') is not None:
            self.device_info = m.get('device_info')
        if m.get('states') is not None:
            self.states = m.get('states')
        return self


class VideoDrmLicenseModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPVideoDRMLicenseResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPVideoDRMLicenseResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CCPWalkFileResponse(TeaModel):
    """
    列举文件response
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
        punished_file_count: int = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker
        # punished_file_count
        self.punished_file_count = punished_file_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.punished_file_count is not None:
            result['punished_file_count'] = self.punished_file_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('punished_file_count') is not None:
            self.punished_file_count = m.get('punished_file_count')
        return self


class WalkFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CCPWalkFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CCPWalkFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearRecycleBinResponse(TeaModel):
    """
    ClearRecycleBinResponse
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        task_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # task_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class ClearRecyclebinModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ClearRecycleBinResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ClearRecycleBinResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRecyclebinModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RestoreFileResponse(TeaModel):
    """
    还原文件response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class RestoreFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: RestoreFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = RestoreFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class TrashFileResponse(TeaModel):
    """
    删除文件到回收站response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class TrashFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: TrashFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = TrashFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ReportEventResponse(TeaModel):
    """
    report_event operation response
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class ReportEventModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ReportEventResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ReportEventResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateShareResponse(TeaModel):
    """
    Create share response
    """
    def __init__(
        self,
        domain_id: str = None,
        share_id: str = None,
    ):
        # domain_id
        self.domain_id = domain_id
        # share_id
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class CreateShareModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateShareResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateShareResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteShareModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class SharePermissionPolicy(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        file_id: str = None,
        file_path: str = None,
        permission_inheritable: bool = None,
        permission_list: List[str] = None,
        permission_type: str = None,
    ):
        self.file_id = file_id
        self.file_path = file_path
        self.permission_inheritable = permission_inheritable
        self.permission_list = permission_list
        self.permission_type = permission_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.permission_inheritable is not None:
            result['permission_inheritable'] = self.permission_inheritable
        if self.permission_list is not None:
            result['permission_list'] = self.permission_list
        if self.permission_type is not None:
            result['permission_type'] = self.permission_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('permission_inheritable') is not None:
            self.permission_inheritable = m.get('permission_inheritable')
        if m.get('permission_list') is not None:
            self.permission_list = m.get('permission_list')
        if m.get('permission_type') is not None:
            self.permission_type = m.get('permission_type')
        return self


class GetShareResponse(TeaModel):
    """
    Get share response
    """
    def __init__(
        self,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        expiration: str = None,
        expired: bool = None,
        owner: str = None,
        owner_type: str = None,
        permissions: List[str] = None,
        share_file_id: str = None,
        share_file_path: str = None,
        share_id: str = None,
        share_name: str = None,
        share_policy: List[SharePermissionPolicy] = None,
        status: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # owner
        self.owner = owner
        # owner
        self.owner_type = owner_type
        # permissions
        self.permissions = permissions
        # share_file_id
        self.share_file_id = share_file_id
        # share_path
        self.share_file_path = share_file_path
        # share_id
        self.share_id = share_id
        # share_name
        self.share_name = share_name
        self.share_policy = share_policy
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.share_policy:
            for k in self.share_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.share_file_id is not None:
            result['share_file_id'] = self.share_file_id
        if self.share_file_path is not None:
            result['share_file_path'] = self.share_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_name is not None:
            result['share_name'] = self.share_name
        result['share_policy'] = []
        if self.share_policy is not None:
            for k in self.share_policy:
                result['share_policy'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('share_file_id') is not None:
            self.share_file_id = m.get('share_file_id')
        if m.get('share_file_path') is not None:
            self.share_file_path = m.get('share_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        self.share_policy = []
        if m.get('share_policy') is not None:
            for k in m.get('share_policy'):
                temp_model = SharePermissionPolicy()
                self.share_policy.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class GetShareModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetShareResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetShareResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseShareResponse(TeaModel):
    """
    List share response
    """
    def __init__(
        self,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        expiration: str = None,
        expired: bool = None,
        owner: str = None,
        owner_type: str = None,
        permissions: List[str] = None,
        share_file_id: str = None,
        share_file_path: str = None,
        share_id: str = None,
        share_name: str = None,
        share_policy: List[SharePermissionPolicy] = None,
        status: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # owner
        self.owner = owner
        # owner
        self.owner_type = owner_type
        # permissions
        self.permissions = permissions
        # share_file_id
        self.share_file_id = share_file_id
        # share_path
        self.share_file_path = share_file_path
        # share_id
        self.share_id = share_id
        # share_name
        self.share_name = share_name
        self.share_policy = share_policy
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.share_policy:
            for k in self.share_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.share_file_id is not None:
            result['share_file_id'] = self.share_file_id
        if self.share_file_path is not None:
            result['share_file_path'] = self.share_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_name is not None:
            result['share_name'] = self.share_name
        result['share_policy'] = []
        if self.share_policy is not None:
            for k in self.share_policy:
                result['share_policy'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('share_file_id') is not None:
            self.share_file_id = m.get('share_file_id')
        if m.get('share_file_path') is not None:
            self.share_file_path = m.get('share_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        self.share_policy = []
        if m.get('share_policy') is not None:
            for k in m.get('share_policy'):
                temp_model = SharePermissionPolicy()
                self.share_policy.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ListShareResponse(TeaModel):
    """
    List share response
    """
    def __init__(
        self,
        items: List[BaseShareResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseShareResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListShareModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListShareResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListShareResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateShareResponse(TeaModel):
    """
    Update share response
    """
    def __init__(
        self,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_id: str = None,
        expiration: str = None,
        expired: bool = None,
        owner: str = None,
        owner_type: str = None,
        permissions: List[str] = None,
        share_file_id: str = None,
        share_file_path: str = None,
        share_id: str = None,
        share_name: str = None,
        share_policy: List[SharePermissionPolicy] = None,
        status: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # owner
        self.owner = owner
        # owner
        self.owner_type = owner_type
        # permissions
        self.permissions = permissions
        # share_file_id
        self.share_file_id = share_file_id
        # share_path
        self.share_file_path = share_file_path
        # share_id
        self.share_id = share_id
        # share_name
        self.share_name = share_name
        self.share_policy = share_policy
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.share_policy:
            for k in self.share_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.share_file_id is not None:
            result['share_file_id'] = self.share_file_id
        if self.share_file_path is not None:
            result['share_file_path'] = self.share_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_name is not None:
            result['share_name'] = self.share_name
        result['share_policy'] = []
        if self.share_policy is not None:
            for k in self.share_policy:
                result['share_policy'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('share_file_id') is not None:
            self.share_file_id = m.get('share_file_id')
        if m.get('share_file_path') is not None:
            self.share_file_path = m.get('share_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        self.share_policy = []
        if m.get('share_policy') is not None:
            for k in m.get('share_policy'):
                temp_model = SharePermissionPolicy()
                self.share_policy.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class UpdateShareModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateShareResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateShareResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class ShareFile(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class CreateShareLinkResponse(TeaModel):
    """
    create_share_link response
    """
    def __init__(
        self,
        access_count: int = None,
        category: str = None,
        comments: str = None,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_count: int = None,
        download_limit: int = None,
        drive_file_list: List[ShareFile] = None,
        drive_id: str = None,
        enable_file_changed_notify: bool = None,
        expiration: str = None,
        expired: bool = None,
        file_id: str = None,
        file_id_list: List[str] = None,
        file_path_list: List[str] = None,
        is_subscribed: bool = None,
        num_of_subscribers: int = None,
        office_editable: bool = None,
        preview_count: int = None,
        preview_limit: int = None,
        report_count: int = None,
        require_login: bool = None,
        save_count: int = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_all_files: bool = None,
        share_icon: str = None,
        share_id: str = None,
        share_msg: str = None,
        share_name: str = None,
        share_policy: str = None,
        share_pwd: str = None,
        share_url: str = None,
        status: str = None,
        updated_at: str = None,
        video_preview_count: int = None,
        view_id: str = None,
    ):
        # access_count
        self.access_count = access_count
        # Category
        self.category = category
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 下载次数
        self.download_count = download_count
        # 分享下载次数限制
        self.download_limit = download_limit
        # file_list
        self.drive_file_list = drive_file_list
        # drive_id
        self.drive_id = drive_id
        # enable_file_changed_notify
        self.enable_file_changed_notify = enable_file_changed_notify
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # file_id
        self.file_id = file_id
        # file_id_list
        self.file_id_list = file_id_list
        # file_id_list
        self.file_path_list = file_path_list
        # is_subscribed
        self.is_subscribed = is_subscribed
        # num_of_subscribers
        self.num_of_subscribers = num_of_subscribers
        # 允许在线编辑文档
        self.office_editable = office_editable
        # preview_count
        self.preview_count = preview_count
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 举报次数
        self.report_count = report_count
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 转存次数
        self.save_count = save_count
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # 是否分享整个drive中的文件，仅文件分享才有效，true时file_id_list字段无效
        self.share_all_files = share_all_files
        # share_icon
        self.share_icon = share_icon
        # share_id
        self.share_id = share_id
        # share_msg
        self.share_msg = share_msg
        # share_name
        self.share_name = share_name
        # share_policy
        self.share_policy = share_policy
        # share_pwd
        self.share_pwd = share_pwd
        # share_url
        self.share_url = share_url
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at
        # 音视频播放次数
        self.video_preview_count = video_preview_count
        # ViewID
        self.view_id = view_id

    def validate(self):
        if self.drive_file_list:
            for k in self.drive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['access_count'] = self.access_count
        if self.category is not None:
            result['category'] = self.category
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        result['drive_file_list'] = []
        if self.drive_file_list is not None:
            for k in self.drive_file_list:
                result['drive_file_list'].append(k.to_map() if k else None)
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.enable_file_changed_notify is not None:
            result['enable_file_changed_notify'] = self.enable_file_changed_notify
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_list is not None:
            result['file_id_list'] = self.file_id_list
        if self.file_path_list is not None:
            result['file_path_list'] = self.file_path_list
        if self.is_subscribed is not None:
            result['is_subscribed'] = self.is_subscribed
        if self.num_of_subscribers is not None:
            result['num_of_subscribers'] = self.num_of_subscribers
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_all_files is not None:
            result['share_all_files'] = self.share_all_files
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_msg is not None:
            result['share_msg'] = self.share_msg
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.share_policy is not None:
            result['share_policy'] = self.share_policy
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        if self.share_url is not None:
            result['share_url'] = self.share_url
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_count') is not None:
            self.access_count = m.get('access_count')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        self.drive_file_list = []
        if m.get('drive_file_list') is not None:
            for k in m.get('drive_file_list'):
                temp_model = ShareFile()
                self.drive_file_list.append(temp_model.from_map(k))
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('enable_file_changed_notify') is not None:
            self.enable_file_changed_notify = m.get('enable_file_changed_notify')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_list') is not None:
            self.file_id_list = m.get('file_id_list')
        if m.get('file_path_list') is not None:
            self.file_path_list = m.get('file_path_list')
        if m.get('is_subscribed') is not None:
            self.is_subscribed = m.get('is_subscribed')
        if m.get('num_of_subscribers') is not None:
            self.num_of_subscribers = m.get('num_of_subscribers')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_all_files') is not None:
            self.share_all_files = m.get('share_all_files')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_msg') is not None:
            self.share_msg = m.get('share_msg')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('share_policy') is not None:
            self.share_policy = m.get('share_policy')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        if m.get('share_url') is not None:
            self.share_url = m.get('share_url')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class CreateShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateShareLinkResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateShareLinkResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseShareLinkResponse(TeaModel):
    """
    list_share_link response
    """
    def __init__(
        self,
        access_count: int = None,
        category: str = None,
        comments: str = None,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_count: int = None,
        download_limit: int = None,
        drive_file_list: List[ShareFile] = None,
        drive_id: str = None,
        enable_file_changed_notify: bool = None,
        expiration: str = None,
        expired: bool = None,
        file_id: str = None,
        file_id_list: List[str] = None,
        file_path_list: List[str] = None,
        is_subscribed: bool = None,
        num_of_subscribers: int = None,
        office_editable: bool = None,
        preview_count: int = None,
        preview_limit: int = None,
        report_count: int = None,
        require_login: bool = None,
        save_count: int = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_all_files: bool = None,
        share_icon: str = None,
        share_id: str = None,
        share_msg: str = None,
        share_name: str = None,
        share_policy: str = None,
        share_pwd: str = None,
        share_url: str = None,
        status: str = None,
        updated_at: str = None,
        video_preview_count: int = None,
        view_id: str = None,
    ):
        # access_count
        self.access_count = access_count
        # Category
        self.category = category
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 下载次数
        self.download_count = download_count
        # 分享下载次数限制
        self.download_limit = download_limit
        # file_list
        self.drive_file_list = drive_file_list
        # drive_id
        self.drive_id = drive_id
        # enable_file_changed_notify
        self.enable_file_changed_notify = enable_file_changed_notify
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # file_id
        self.file_id = file_id
        # file_id_list
        self.file_id_list = file_id_list
        # file_id_list
        self.file_path_list = file_path_list
        # is_subscribed
        self.is_subscribed = is_subscribed
        # num_of_subscribers
        self.num_of_subscribers = num_of_subscribers
        # 允许在线编辑文档
        self.office_editable = office_editable
        # preview_count
        self.preview_count = preview_count
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 举报次数
        self.report_count = report_count
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 转存次数
        self.save_count = save_count
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # 是否分享整个drive中的文件，仅文件分享才有效，true时file_id_list字段无效
        self.share_all_files = share_all_files
        # share_icon
        self.share_icon = share_icon
        # share_id
        self.share_id = share_id
        # share_msg
        self.share_msg = share_msg
        # share_name
        self.share_name = share_name
        # share_policy
        self.share_policy = share_policy
        # share_pwd
        self.share_pwd = share_pwd
        # share_url
        self.share_url = share_url
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at
        # 音视频播放次数
        self.video_preview_count = video_preview_count
        # ViewID
        self.view_id = view_id

    def validate(self):
        if self.drive_file_list:
            for k in self.drive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['access_count'] = self.access_count
        if self.category is not None:
            result['category'] = self.category
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        result['drive_file_list'] = []
        if self.drive_file_list is not None:
            for k in self.drive_file_list:
                result['drive_file_list'].append(k.to_map() if k else None)
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.enable_file_changed_notify is not None:
            result['enable_file_changed_notify'] = self.enable_file_changed_notify
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_list is not None:
            result['file_id_list'] = self.file_id_list
        if self.file_path_list is not None:
            result['file_path_list'] = self.file_path_list
        if self.is_subscribed is not None:
            result['is_subscribed'] = self.is_subscribed
        if self.num_of_subscribers is not None:
            result['num_of_subscribers'] = self.num_of_subscribers
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_all_files is not None:
            result['share_all_files'] = self.share_all_files
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_msg is not None:
            result['share_msg'] = self.share_msg
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.share_policy is not None:
            result['share_policy'] = self.share_policy
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        if self.share_url is not None:
            result['share_url'] = self.share_url
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_count') is not None:
            self.access_count = m.get('access_count')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        self.drive_file_list = []
        if m.get('drive_file_list') is not None:
            for k in m.get('drive_file_list'):
                temp_model = ShareFile()
                self.drive_file_list.append(temp_model.from_map(k))
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('enable_file_changed_notify') is not None:
            self.enable_file_changed_notify = m.get('enable_file_changed_notify')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_list') is not None:
            self.file_id_list = m.get('file_id_list')
        if m.get('file_path_list') is not None:
            self.file_path_list = m.get('file_path_list')
        if m.get('is_subscribed') is not None:
            self.is_subscribed = m.get('is_subscribed')
        if m.get('num_of_subscribers') is not None:
            self.num_of_subscribers = m.get('num_of_subscribers')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_all_files') is not None:
            self.share_all_files = m.get('share_all_files')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_msg') is not None:
            self.share_msg = m.get('share_msg')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('share_policy') is not None:
            self.share_policy = m.get('share_policy')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        if m.get('share_url') is not None:
            self.share_url = m.get('share_url')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class GetShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BaseShareLinkResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BaseShareLinkResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetShareLinkByAnonymousResponse(TeaModel):
    """
    get_share_link_by_anonymous response
    """
    def __init__(
        self,
        access_count: int = None,
        avatar: str = None,
        category: str = None,
        comments: str = None,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_phone: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_count: int = None,
        download_limit: int = None,
        expiration: str = None,
        file_count: int = None,
        has_pwd: bool = None,
        need_check_pwd: bool = None,
        office_editable: bool = None,
        preview_count: int = None,
        preview_limit: int = None,
        report_count: int = None,
        require_login: bool = None,
        save_count: int = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_icon: str = None,
        share_name: str = None,
        updated_at: str = None,
        video_preview_count: int = None,
    ):
        # access_count
        self.access_count = access_count
        # avatar
        self.avatar = avatar
        # 文件分享大类
        self.category = category
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_phone
        self.creator_phone = creator_phone
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 下载次数
        self.download_count = download_count
        # 分享下载次数限制
        self.download_limit = download_limit
        # expiration
        self.expiration = expiration
        # file_count
        self.file_count = file_count
        # has_pwd
        self.has_pwd = has_pwd
        # need_check_pwd
        self.need_check_pwd = need_check_pwd
        # 允许在线编辑文档
        self.office_editable = office_editable
        # preview_count
        self.preview_count = preview_count
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 举报次数
        self.report_count = report_count
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 转存次数
        self.save_count = save_count
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # share_icon
        self.share_icon = share_icon
        # share_name
        self.share_name = share_name
        # updated_at
        self.updated_at = updated_at
        # 音视频播放次数
        self.video_preview_count = video_preview_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['access_count'] = self.access_count
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.category is not None:
            result['category'] = self.category
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_phone is not None:
            result['creator_phone'] = self.creator_phone
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.file_count is not None:
            result['file_count'] = self.file_count
        if self.has_pwd is not None:
            result['has_pwd'] = self.has_pwd
        if self.need_check_pwd is not None:
            result['need_check_pwd'] = self.need_check_pwd
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_count') is not None:
            self.access_count = m.get('access_count')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_phone') is not None:
            self.creator_phone = m.get('creator_phone')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        if m.get('has_pwd') is not None:
            self.has_pwd = m.get('has_pwd')
        if m.get('need_check_pwd') is not None:
            self.need_check_pwd = m.get('need_check_pwd')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        return self


class GetShareByAnonymousModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetShareLinkByAnonymousResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetShareLinkByAnonymousResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetShareLinkIDResponse(TeaModel):
    """
    get_share_id response
    """
    def __init__(
        self,
        share_id: str = None,
        share_pwd: str = None,
    ):
        # share_id
        self.share_id = share_id
        # share_pwd
        self.share_pwd = share_pwd

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        return self


class GetShareIdModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetShareLinkIDResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetShareLinkIDResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetShareLinkTokenResponse(TeaModel):
    """
    get_share_token response
    """
    def __init__(
        self,
        expire_time: str = None,
        expires_in: int = None,
        share_token: str = None,
    ):
        # expire_time
        self.expire_time = expire_time
        # expires_in
        self.expires_in = expires_in
        # share_token
        self.share_token = share_token

    def validate(self):
        self.validate_required(self.expire_time, 'expire_time')
        self.validate_required(self.expires_in, 'expires_in')
        self.validate_required(self.share_token, 'share_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.expires_in is not None:
            result['expires_in'] = self.expires_in
        if self.share_token is not None:
            result['share_token'] = self.share_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('expires_in') is not None:
            self.expires_in = m.get('expires_in')
        if m.get('share_token') is not None:
            self.share_token = m.get('share_token')
        return self


class GetShareTokenModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetShareLinkTokenResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetShareLinkTokenResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListShareLinkResponse(TeaModel):
    """
    list_share_link response
    """
    def __init__(
        self,
        items: List[BaseShareLinkResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseShareLinkResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListShareLinkResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListShareLinkResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ReportShareLinkEventModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ReportEventResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ReportEventResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchShareLinkResponse(TeaModel):
    """
    search_share_link response
    """
    def __init__(
        self,
        items: List[BaseShareLinkResponse] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker
        # total_count
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseShareLinkResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class SearchShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchShareLinkResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchShareLinkResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateShareLinkResponse(TeaModel):
    """
    update_share_link response
    """
    def __init__(
        self,
        access_count: int = None,
        category: str = None,
        comments: str = None,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        created_at: str = None,
        creator: str = None,
        description: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_count: int = None,
        download_limit: int = None,
        drive_file_list: List[ShareFile] = None,
        drive_id: str = None,
        enable_file_changed_notify: bool = None,
        expiration: str = None,
        expired: bool = None,
        file_id: str = None,
        file_id_list: List[str] = None,
        file_path_list: List[str] = None,
        is_subscribed: bool = None,
        num_of_subscribers: int = None,
        office_editable: bool = None,
        preview_count: int = None,
        preview_limit: int = None,
        report_count: int = None,
        require_login: bool = None,
        save_count: int = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_all_files: bool = None,
        share_icon: str = None,
        share_id: str = None,
        share_msg: str = None,
        share_name: str = None,
        share_policy: str = None,
        share_pwd: str = None,
        share_url: str = None,
        status: str = None,
        updated_at: str = None,
        video_preview_count: int = None,
        view_id: str = None,
    ):
        # access_count
        self.access_count = access_count
        # Category
        self.category = category
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 下载次数
        self.download_count = download_count
        # 分享下载次数限制
        self.download_limit = download_limit
        # file_list
        self.drive_file_list = drive_file_list
        # drive_id
        self.drive_id = drive_id
        # enable_file_changed_notify
        self.enable_file_changed_notify = enable_file_changed_notify
        # expiration
        self.expiration = expiration
        # expired
        self.expired = expired
        # file_id
        self.file_id = file_id
        # file_id_list
        self.file_id_list = file_id_list
        # file_id_list
        self.file_path_list = file_path_list
        # is_subscribed
        self.is_subscribed = is_subscribed
        # num_of_subscribers
        self.num_of_subscribers = num_of_subscribers
        # 允许在线编辑文档
        self.office_editable = office_editable
        # preview_count
        self.preview_count = preview_count
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 举报次数
        self.report_count = report_count
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 转存次数
        self.save_count = save_count
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # 是否分享整个drive中的文件，仅文件分享才有效，true时file_id_list字段无效
        self.share_all_files = share_all_files
        # share_icon
        self.share_icon = share_icon
        # share_id
        self.share_id = share_id
        # share_msg
        self.share_msg = share_msg
        # share_name
        self.share_name = share_name
        # share_policy
        self.share_policy = share_policy
        # share_pwd
        self.share_pwd = share_pwd
        # share_url
        self.share_url = share_url
        # status
        self.status = status
        # updated_at
        self.updated_at = updated_at
        # 音视频播放次数
        self.video_preview_count = video_preview_count
        # ViewID
        self.view_id = view_id

    def validate(self):
        if self.drive_file_list:
            for k in self.drive_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['access_count'] = self.access_count
        if self.category is not None:
            result['category'] = self.category
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        result['drive_file_list'] = []
        if self.drive_file_list is not None:
            for k in self.drive_file_list:
                result['drive_file_list'].append(k.to_map() if k else None)
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.enable_file_changed_notify is not None:
            result['enable_file_changed_notify'] = self.enable_file_changed_notify
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.expired is not None:
            result['expired'] = self.expired
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_list is not None:
            result['file_id_list'] = self.file_id_list
        if self.file_path_list is not None:
            result['file_path_list'] = self.file_path_list
        if self.is_subscribed is not None:
            result['is_subscribed'] = self.is_subscribed
        if self.num_of_subscribers is not None:
            result['num_of_subscribers'] = self.num_of_subscribers
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_all_files is not None:
            result['share_all_files'] = self.share_all_files
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_msg is not None:
            result['share_msg'] = self.share_msg
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.share_policy is not None:
            result['share_policy'] = self.share_policy
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        if self.share_url is not None:
            result['share_url'] = self.share_url
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_count') is not None:
            self.access_count = m.get('access_count')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        self.drive_file_list = []
        if m.get('drive_file_list') is not None:
            for k in m.get('drive_file_list'):
                temp_model = ShareFile()
                self.drive_file_list.append(temp_model.from_map(k))
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('enable_file_changed_notify') is not None:
            self.enable_file_changed_notify = m.get('enable_file_changed_notify')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('expired') is not None:
            self.expired = m.get('expired')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_list') is not None:
            self.file_id_list = m.get('file_id_list')
        if m.get('file_path_list') is not None:
            self.file_path_list = m.get('file_path_list')
        if m.get('is_subscribed') is not None:
            self.is_subscribed = m.get('is_subscribed')
        if m.get('num_of_subscribers') is not None:
            self.num_of_subscribers = m.get('num_of_subscribers')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_all_files') is not None:
            self.share_all_files = m.get('share_all_files')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_msg') is not None:
            self.share_msg = m.get('share_msg')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('share_policy') is not None:
            self.share_policy = m.get('share_policy')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        if m.get('share_url') is not None:
            self.share_url = m.get('share_url')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class UpdateShareLinkModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateShareLinkResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateShareLinkResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseActionItemResponse(TeaModel):
    """
    action response
    """
    def __init__(
        self,
        action: str = None,
    ):
        self.action = action

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        return self


class IPCondition(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        client_ip: List[str] = None,
    ):
        self.client_ip = client_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_ip is not None:
            result['client_ip'] = self.client_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('client_ip') is not None:
            self.client_ip = m.get('client_ip')
        return self


class StringCondition(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        vpc_id: List[str] = None,
    ):
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_id is not None:
            result['vpc_id'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('vpc_id') is not None:
            self.vpc_id = m.get('vpc_id')
        return self


class Condition(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        ip_equals: IPCondition = None,
        ip_not_equals: IPCondition = None,
        string_like: StringCondition = None,
        string_not_like: StringCondition = None,
    ):
        self.ip_equals = ip_equals
        self.ip_not_equals = ip_not_equals
        self.string_like = string_like
        self.string_not_like = string_not_like

    def validate(self):
        if self.ip_equals:
            self.ip_equals.validate()
        if self.ip_not_equals:
            self.ip_not_equals.validate()
        if self.string_like:
            self.string_like.validate()
        if self.string_not_like:
            self.string_not_like.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_equals is not None:
            result['ip_equals'] = self.ip_equals.to_map()
        if self.ip_not_equals is not None:
            result['ip_not_equals'] = self.ip_not_equals.to_map()
        if self.string_like is not None:
            result['string_like'] = self.string_like.to_map()
        if self.string_not_like is not None:
            result['string_not_like'] = self.string_not_like.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ip_equals') is not None:
            temp_model = IPCondition()
            self.ip_equals = temp_model.from_map(m['ip_equals'])
        if m.get('ip_not_equals') is not None:
            temp_model = IPCondition()
            self.ip_not_equals = temp_model.from_map(m['ip_not_equals'])
        if m.get('string_like') is not None:
            temp_model = StringCondition()
            self.string_like = temp_model.from_map(m['string_like'])
        if m.get('string_not_like') is not None:
            temp_model = StringCondition()
            self.string_not_like = temp_model.from_map(m['string_not_like'])
        return self


class BasePermissionResponse(TeaModel):
    """
    权限记录 response
    """
    def __init__(
        self,
        action_list: List[BaseActionItemResponse] = None,
        collection: str = None,
        condition: Condition = None,
        created_at: int = None,
        effect: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
        updated_at: int = None,
        user_tags: List[str] = None,
    ):
        self.action_list = action_list
        self.collection = collection
        self.condition = condition
        self.created_at = created_at
        self.effect = effect
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type
        self.updated_at = updated_at
        self.user_tags = user_tags

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['action_list'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['action_list'].append(k.to_map() if k else None)
        if self.collection is not None:
            result['collection'] = self.collection
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.effect is not None:
            result['effect'] = self.effect
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.resource is not None:
            result['resource'] = self.resource
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_list = []
        if m.get('action_list') is not None:
            for k in m.get('action_list'):
                temp_model = BaseActionItemResponse()
                self.action_list.append(temp_model.from_map(k))
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        return self


class CreateModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BasePermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BasePermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BasePermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BasePermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPermissionResponse(TeaModel):
    """
    列举权限记录 response
    """
    def __init__(
        self,
        domain_id: str = None,
        items: List[BasePermissionResponse] = None,
        next_marker: str = None,
    ):
        self.domain_id = domain_id
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BasePermissionResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListPermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListPermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchPermissionResponse(TeaModel):
    """
    列举权限记录 response
    """
    def __init__(
        self,
        domain_id: str = None,
        items: List[BasePermissionResponse] = None,
        next_marker: str = None,
    ):
        self.domain_id = domain_id
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BasePermissionResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class SearchModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchPermissionResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchPermissionResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class AssignModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class CancelAssignModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class BaseAssignmentResponse(TeaModel):
    """
    List identity role response item
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        domain_id: str = None,
        identity: Identity = None,
        manage_resource_id: str = None,
        manage_resource_type: str = None,
        role_id: str = None,
        updated_at: int = None,
    ):
        # 创建时间
        self.created_at = created_at
        # 创建者的UserID
        self.creator = creator
        # domain_id
        self.domain_id = domain_id
        self.identity = identity
        # 管辖的资源ID
        self.manage_resource_id = manage_resource_id
        # 管辖的资源类型
        self.manage_resource_type = manage_resource_type
        # 授予的角色
        self.role_id = role_id
        # 修改时间
        self.updated_at = updated_at

    def validate(self):
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.creator, 'creator')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.manage_resource_id, 'manage_resource_id')
        self.validate_required(self.manage_resource_type, 'manage_resource_type')
        self.validate_required(self.role_id, 'role_id')
        self.validate_required(self.updated_at, 'updated_at')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.manage_resource_id is not None:
            result['manage_resource_id'] = self.manage_resource_id
        if self.manage_resource_type is not None:
            result['manage_resource_type'] = self.manage_resource_type
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('manage_resource_id') is not None:
            self.manage_resource_id = m.get('manage_resource_id')
        if m.get('manage_resource_type') is not None:
            self.manage_resource_type = m.get('manage_resource_type')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class BaseRoleMemberResponse(TeaModel):
    """
    List identity role response
    """
    def __init__(
        self,
        assignment_list: List[BaseAssignmentResponse] = None,
        domain_id: str = None,
        identity: Identity = None,
        identity_name: str = None,
        is_admin: bool = None,
        subdomain_id: str = None,
    ):
        # 当前用户或团队分配的角色列表
        self.assignment_list = assignment_list
        # domain_id
        self.domain_id = domain_id
        self.identity = identity
        # 查询的用户或团队的名称
        self.identity_name = identity_name
        # 是否为管理员
        self.is_admin = is_admin
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.assignment_list, 'assignment_list')
        if self.assignment_list:
            for k in self.assignment_list:
                if k:
                    k.validate()
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.identity_name, 'identity_name')
        self.validate_required(self.is_admin, 'is_admin')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['assignment_list'] = []
        if self.assignment_list is not None:
            for k in self.assignment_list:
                result['assignment_list'].append(k.to_map() if k else None)
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.identity_name is not None:
            result['identity_name'] = self.identity_name
        if self.is_admin is not None:
            result['is_admin'] = self.is_admin
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.assignment_list = []
        if m.get('assignment_list') is not None:
            for k in m.get('assignment_list'):
                temp_model = BaseAssignmentResponse()
                self.assignment_list.append(temp_model.from_map(k))
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('identity_name') is not None:
            self.identity_name = m.get('identity_name')
        if m.get('is_admin') is not None:
            self.is_admin = m.get('is_admin')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListIdentityRoleModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BaseRoleMemberResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BaseRoleMemberResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDriveUsedSizeResponse(TeaModel):
    """
    GetDriveUsedSizeResponse
    """
    def __init__(
        self,
        used_size: int = None,
    ):
        # used_size
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class GetDriveUsedSizeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetDriveUsedSizeResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetDriveUsedSizeResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileCountResponse(TeaModel):
    """
    GetFileCountResponse
    """
    def __init__(
        self,
        file_count: int = None,
    ):
        # file_count
        self.file_count = file_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_count is not None:
            result['file_count'] = self.file_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        return self


class GetFileCountModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetFileCountResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetFileCountResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SubdomainSummaryResponse(TeaModel):
    """
    SubdomainSummaryResponse
    """
    def __init__(
        self,
        drive_count: int = None,
        state: str = None,
        statistics_time: int = None,
        used_size: int = None,
        user_count: int = None,
    ):
        # drive_count
        self.drive_count = drive_count
        # state
        self.state = state
        # statistics_time
        self.statistics_time = statistics_time
        # used_size
        self.used_size = used_size
        # user_count
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_count is not None:
            result['drive_count'] = self.drive_count
        if self.state is not None:
            result['state'] = self.state
        if self.statistics_time is not None:
            result['statistics_time'] = self.statistics_time
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.user_count is not None:
            result['user_count'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_count') is not None:
            self.drive_count = m.get('drive_count')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('statistics_time') is not None:
            self.statistics_time = m.get('statistics_time')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('user_count') is not None:
            self.user_count = m.get('user_count')
        return self


class GetSubdomainSummaryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SubdomainSummaryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SubdomainSummaryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DomainSummaryResponse(TeaModel):
    """
    DomainSummaryResponse
    """
    def __init__(
        self,
        drive_count: int = None,
        file_count: int = None,
        state: str = None,
        statistics_time: int = None,
        used_flow: int = None,
        used_size: int = None,
        user_count: int = None,
    ):
        # drive_count
        self.drive_count = drive_count
        # file_count
        self.file_count = file_count
        # state
        self.state = state
        # statistics_time
        self.statistics_time = statistics_time
        # used_flow
        self.used_flow = used_flow
        # used_size
        self.used_size = used_size
        # user_count
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_count is not None:
            result['drive_count'] = self.drive_count
        if self.file_count is not None:
            result['file_count'] = self.file_count
        if self.state is not None:
            result['state'] = self.state
        if self.statistics_time is not None:
            result['statistics_time'] = self.statistics_time
        if self.used_flow is not None:
            result['used_flow'] = self.used_flow
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.user_count is not None:
            result['user_count'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_count') is not None:
            self.drive_count = m.get('drive_count')
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('statistics_time') is not None:
            self.statistics_time = m.get('statistics_time')
        if m.get('used_flow') is not None:
            self.used_flow = m.get('used_flow')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('user_count') is not None:
            self.user_count = m.get('user_count')
        return self


class GetDomainSummaryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DomainSummaryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DomainSummaryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAppDebugCmdResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cmd: str = None,
    ):
        # cmd
        self.cmd = cmd

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cmd is not None:
            result['cmd'] = self.cmd
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cmd') is not None:
            self.cmd = m.get('cmd')
        return self


class GetAppDebugCmdModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetAppDebugCmdResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetAppDebugCmdResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeCheckAppResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        option: str = None,
        release_date: str = None,
        release_notes_url: str = None,
        url: str = None,
        version: str = None,
    ):
        # option
        self.option = option
        # release_date
        self.release_date = release_date
        # release_notes_url
        self.release_notes_url = release_notes_url
        # url
        self.url = url
        # version
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option is not None:
            result['option'] = self.option
        if self.release_date is not None:
            result['release_date'] = self.release_date
        if self.release_notes_url is not None:
            result['release_notes_url'] = self.release_notes_url
        if self.url is not None:
            result['url'] = self.url
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('option') is not None:
            self.option = m.get('option')
        if m.get('release_date') is not None:
            self.release_date = m.get('release_date')
        if m.get('release_notes_url') is not None:
            self.release_notes_url = m.get('release_notes_url')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class UpgradeCheckAppModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpgradeCheckAppResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpgradeCheckAppResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BindDeviceResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: str = None,
        device_id: str = None,
        device_info: str = None,
        device_name: str = None,
        device_type: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # device_id
        self.device_id = device_id
        # device_info
        self.device_info = device_info
        # device_name
        self.device_name = device_name
        # device_type
        self.device_type = device_type
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.device_id is not None:
            result['device_id'] = self.device_id
        if self.device_info is not None:
            result['device_info'] = self.device_info
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.device_type is not None:
            result['device_type'] = self.device_type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('device_id') is not None:
            self.device_id = m.get('device_id')
        if m.get('device_info') is not None:
            self.device_info = m.get('device_info')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('device_type') is not None:
            self.device_type = m.get('device_type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class BindDeviceModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BindDeviceResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BindDeviceResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeviceItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: str = None,
        device_id: str = None,
        device_info: str = None,
        device_name: str = None,
        device_type: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # device_id
        self.device_id = device_id
        # device_info
        self.device_info = device_info
        # device_name
        self.device_name = device_name
        # device_type
        self.device_type = device_type
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.device_id is not None:
            result['device_id'] = self.device_id
        if self.device_info is not None:
            result['device_info'] = self.device_info
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.device_type is not None:
            result['device_type'] = self.device_type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('device_id') is not None:
            self.device_id = m.get('device_id')
        if m.get('device_info') is not None:
            self.device_info = m.get('device_info')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('device_type') is not None:
            self.device_type = m.get('device_type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ListDeviceResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[DeviceItem] = None,
        marker: str = None,
    ):
        # items
        self.items = items
        # marker
        self.marker = marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = DeviceItem()
                self.items.append(temp_model.from_map(k))
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListDeviceModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDeviceResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDeviceResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        group_name: str = None,
        is_sync: bool = None,
        permission: dict = None,
        updated_at: int = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        # group name
        self.group_name = group_name
        self.is_sync = is_sync
        self.permission = permission
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.permission is not None:
            result['permission'] = self.permission
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class CreateGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        group_name: str = None,
        is_sync: bool = None,
        permission: dict = None,
        updated_at: int = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        # group name
        self.group_name = group_name
        self.is_sync = is_sync
        self.permission = permission
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.permission is not None:
            result['permission'] = self.permission
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class GetGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        group_name: str = None,
        is_sync: bool = None,
        permission: dict = None,
        updated_at: int = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        # group name
        self.group_name = group_name
        self.is_sync = is_sync
        self.permission = permission
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.permission is not None:
            result['permission'] = self.permission
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ListGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[BaseGroupResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseGroupResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[BaseGroupResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseGroupResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class SearchGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGroupResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        group_name: str = None,
        is_sync: bool = None,
        permission: dict = None,
        updated_at: int = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        # group name
        self.group_name = group_name
        self.is_sync = is_sync
        self.permission = permission
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.permission is not None:
            result['permission'] = self.permission
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class UpdateGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        is_sync: bool = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        updated_at: int = None,
        user_id: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # 描述
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        self.is_sync = is_sync
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # updated_at
        self.updated_at = updated_at
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class CreateMembershipModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateMembershipResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateMembershipResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteMembershipModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteMembershipResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteMembershipResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        is_sync: bool = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        updated_at: int = None,
        user_id: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # 描述
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        self.is_sync = is_sync
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # updated_at
        self.updated_at = updated_at
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetMembershipModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetMembershipResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetMembershipResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class HasMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class HasMemberModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: HasMembershipResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = HasMembershipResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        is_sync: bool = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        updated_at: int = None,
        user_id: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # 描述
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        self.is_sync = is_sync
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # updated_at
        self.updated_at = updated_at
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ListDirectChildMembershipsResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[BaseMembershipResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseMembershipResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListDirectChildMembershipsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDirectChildMembershipsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDirectChildMembershipsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDirectParentMembershipsResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[BaseMembershipResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseMembershipResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListDirectMembershipsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDirectParentMembershipsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDirectParentMembershipsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDirectParentMembershipsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListDirectParentMembershipsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListDirectParentMembershipsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMembershipResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        group_id: str = None,
        is_sync: bool = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        updated_at: int = None,
        user_id: str = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # 描述
        self.description = description
        # domain id
        self.domain_id = domain_id
        # group id
        self.group_id = group_id
        self.is_sync = is_sync
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # updated_at
        self.updated_at = updated_at
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class UpdateMembershipModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateMembershipResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateMembershipResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSyncMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_id: str = None,
        exist: bool = None,
        file_id: str = None,
        name: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # exist
        self.exist = exist
        # file_id
        self.file_id = file_id
        # name string
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.exist is not None:
            result['exist'] = self.exist
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('exist') is not None:
            self.exist = m.get('exist')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateSyncMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateSyncMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateSyncMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSyncMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteSyncMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteSyncMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteSyncMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncMappingItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: str = None,
        custom_meta: str = None,
        device_name: str = None,
        drive_id: str = None,
        file_id: str = None,
        fs_id: str = None,
        local_path: str = None,
        sync_mode: str = None,
        updated_at: str = None,
    ):
        # created_at
        self.created_at = created_at
        # custom_meta
        self.custom_meta = custom_meta
        # device_name
        self.device_name = device_name
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # fs_id
        self.fs_id = fs_id
        # local_path
        self.local_path = local_path
        # sync_mode
        self.sync_mode = sync_mode
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.custom_meta is not None:
            result['custom_meta'] = self.custom_meta
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.fs_id is not None:
            result['fs_id'] = self.fs_id
        if self.local_path is not None:
            result['local_path'] = self.local_path
        if self.sync_mode is not None:
            result['sync_mode'] = self.sync_mode
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('custom_meta') is not None:
            self.custom_meta = m.get('custom_meta')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('fs_id') is not None:
            self.fs_id = m.get('fs_id')
        if m.get('local_path') is not None:
            self.local_path = m.get('local_path')
        if m.get('sync_mode') is not None:
            self.sync_mode = m.get('sync_mode')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class ListSyncMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[SyncMappingItem] = None,
        marker: str = None,
    ):
        # items
        self.items = items
        # marker
        self.marker = marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = SyncMappingItem()
                self.items.append(temp_model.from_map(k))
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListSyncMappingModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListSyncMappingResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListSyncMappingResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AddUserToSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class PunishmentResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        ends_at: str = None,
        impermanent: bool = None,
        punish_flag: int = None,
        starts_at: str = None,
    ):
        self.ends_at = ends_at
        # ActionCode  string `json:"action_code,omitempty"` // 无需求暂不提供
        self.impermanent = impermanent
        self.punish_flag = punish_flag
        self.starts_at = starts_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ends_at is not None:
            result['ends_at'] = self.ends_at
        if self.impermanent is not None:
            result['impermanent'] = self.impermanent
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.starts_at is not None:
            result['starts_at'] = self.starts_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ends_at') is not None:
            self.ends_at = m.get('ends_at')
        if m.get('impermanent') is not None:
            self.impermanent = m.get('impermanent')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('starts_at') is not None:
            self.starts_at = m.get('starts_at')
        return self


class CreateUserResponse(TeaModel):
    """
    Create user response
    """
    def __init__(
        self,
        avatar: str = None,
        created_at: int = None,
        creator: str = None,
        default_drive_id: str = None,
        default_location: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        domain_id: str = None,
        email: str = None,
        expired_at: int = None,
        is_sync: bool = None,
        last_login_time: int = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        permission: dict = None,
        phone: str = None,
        phone_region: str = None,
        punish_flag: int = None,
        punishments: List[PunishmentResponse] = None,
        role: str = None,
        status: str = None,
        updated_at: int = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # 头像
        self.avatar = avatar
        # 用户创建时间
        self.created_at = created_at
        # creator
        self.creator = creator
        # 默认 Drive ID
        self.default_drive_id = default_drive_id
        self.default_location = default_location
        # 禁止用户自行修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 用户备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.is_sync = is_sync
        self.last_login_time = last_login_time
        # 下次登录强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        self.permission = permission
        # 电话
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户处罚标志
        self.punish_flag = punish_flag
        self.punishments = punishments
        # 角色
        self.role = role
        # 用户状态
        self.status = status
        # 用户修改时间
        self.updated_at = updated_at
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id
        # 用户名称
        self.user_name = user_name

    def validate(self):
        if self.punishments:
            for k in self.punishments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.default_location is not None:
            result['default_location'] = self.default_location
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.last_login_time is not None:
            result['last_login_time'] = self.last_login_time
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.permission is not None:
            result['permission'] = self.permission
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        result['punishments'] = []
        if self.punishments is not None:
            for k in self.punishments:
                result['punishments'].append(k.to_map() if k else None)
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('default_location') is not None:
            self.default_location = m.get('default_location')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('last_login_time') is not None:
            self.last_login_time = m.get('last_login_time')
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        self.punishments = []
        if m.get('punishments') is not None:
            for k in m.get('punishments'):
                temp_model = PunishmentResponse()
                self.punishments.append(temp_model.from_map(k))
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class CreateUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetUserResponse(TeaModel):
    """
    Get user response
    """
    def __init__(
        self,
        avatar: str = None,
        created_at: int = None,
        creator: str = None,
        default_drive_id: str = None,
        default_location: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        domain_id: str = None,
        email: str = None,
        expired_at: int = None,
        is_sync: bool = None,
        last_login_time: int = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        permission: dict = None,
        phone: str = None,
        phone_region: str = None,
        punish_flag: int = None,
        punishments: List[PunishmentResponse] = None,
        role: str = None,
        status: str = None,
        updated_at: int = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # 头像
        self.avatar = avatar
        # 用户创建时间
        self.created_at = created_at
        # creator
        self.creator = creator
        # 默认 Drive ID
        self.default_drive_id = default_drive_id
        self.default_location = default_location
        # 禁止用户自行修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 用户备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.is_sync = is_sync
        self.last_login_time = last_login_time
        # 下次登录强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        self.permission = permission
        # 电话
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户处罚标志
        self.punish_flag = punish_flag
        self.punishments = punishments
        # 角色
        self.role = role
        # 用户状态
        self.status = status
        # 用户修改时间
        self.updated_at = updated_at
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id
        # 用户名称
        self.user_name = user_name

    def validate(self):
        if self.punishments:
            for k in self.punishments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.default_location is not None:
            result['default_location'] = self.default_location
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.last_login_time is not None:
            result['last_login_time'] = self.last_login_time
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.permission is not None:
            result['permission'] = self.permission
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        result['punishments'] = []
        if self.punishments is not None:
            for k in self.punishments:
                result['punishments'].append(k.to_map() if k else None)
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('default_location') is not None:
            self.default_location = m.get('default_location')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('last_login_time') is not None:
            self.last_login_time = m.get('last_login_time')
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        self.punishments = []
        if m.get('punishments') is not None:
            for k in m.get('punishments'):
                temp_model = PunishmentResponse()
                self.punishments.append(temp_model.from_map(k))
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class GetUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class BaseUserResponse(TeaModel):
    """
    Base user response
    """
    def __init__(
        self,
        avatar: str = None,
        created_at: int = None,
        creator: str = None,
        default_drive_id: str = None,
        default_location: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        domain_id: str = None,
        email: str = None,
        expired_at: int = None,
        is_sync: bool = None,
        last_login_time: int = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        permission: dict = None,
        phone: str = None,
        phone_region: str = None,
        punish_flag: int = None,
        punishments: List[PunishmentResponse] = None,
        role: str = None,
        status: str = None,
        updated_at: int = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # 头像
        self.avatar = avatar
        # 用户创建时间
        self.created_at = created_at
        # creator
        self.creator = creator
        # 默认 Drive ID
        self.default_drive_id = default_drive_id
        self.default_location = default_location
        # 禁止用户自行修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 用户备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.is_sync = is_sync
        self.last_login_time = last_login_time
        # 下次登录强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        self.permission = permission
        # 电话
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户处罚标志
        self.punish_flag = punish_flag
        self.punishments = punishments
        # 角色
        self.role = role
        # 用户状态
        self.status = status
        # 用户修改时间
        self.updated_at = updated_at
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id
        # 用户名称
        self.user_name = user_name

    def validate(self):
        if self.punishments:
            for k in self.punishments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.default_location is not None:
            result['default_location'] = self.default_location
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.last_login_time is not None:
            result['last_login_time'] = self.last_login_time
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.permission is not None:
            result['permission'] = self.permission
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        result['punishments'] = []
        if self.punishments is not None:
            for k in self.punishments:
                result['punishments'].append(k.to_map() if k else None)
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('default_location') is not None:
            self.default_location = m.get('default_location')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('last_login_time') is not None:
            self.last_login_time = m.get('last_login_time')
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        self.punishments = []
        if m.get('punishments') is not None:
            for k in m.get('punishments'):
                temp_model = PunishmentResponse()
                self.punishments.append(temp_model.from_map(k))
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class ImportUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: BaseUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = BaseUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserResponse(TeaModel):
    """
    List user response
    """
    def __init__(
        self,
        items: List[BaseUserResponse] = None,
        next_marker: str = None,
    ):
        self.items = items
        # 翻页标记
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseUserResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListUsersModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class MigrateUserToSubdomainResponse(TeaModel):
    """
    MigrateUserToSubdomainResponse
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class MigrateUserToSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: MigrateUserToSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = MigrateUserToSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveUserFromSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class RollbackUserFromSubdomainResponse(TeaModel):
    """
    RollbackUserFromSubdomainResponse
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class RollbackUserFromSubdomainModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: RollbackUserFromSubdomainResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = RollbackUserFromSubdomainResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUserResponse(TeaModel):
    """
    Update user response
    """
    def __init__(
        self,
        avatar: str = None,
        created_at: int = None,
        creator: str = None,
        default_drive_id: str = None,
        default_location: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        domain_id: str = None,
        email: str = None,
        expired_at: int = None,
        is_sync: bool = None,
        last_login_time: int = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        permission: dict = None,
        phone: str = None,
        phone_region: str = None,
        punish_flag: int = None,
        punishments: List[PunishmentResponse] = None,
        role: str = None,
        status: str = None,
        updated_at: int = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        # 头像
        self.avatar = avatar
        # 用户创建时间
        self.created_at = created_at
        # creator
        self.creator = creator
        # 默认 Drive ID
        self.default_drive_id = default_drive_id
        self.default_location = default_location
        # 禁止用户自行修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 用户备注信息
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.is_sync = is_sync
        self.last_login_time = last_login_time
        # 下次登录强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        self.permission = permission
        # 电话
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户处罚标志
        self.punish_flag = punish_flag
        self.punishments = punishments
        # 角色
        self.role = role
        # 用户状态
        self.status = status
        # 用户修改时间
        self.updated_at = updated_at
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id
        # 用户名称
        self.user_name = user_name

    def validate(self):
        if self.punishments:
            for k in self.punishments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_drive_id is not None:
            result['default_drive_id'] = self.default_drive_id
        if self.default_location is not None:
            result['default_location'] = self.default_location
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.last_login_time is not None:
            result['last_login_time'] = self.last_login_time
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.permission is not None:
            result['permission'] = self.permission
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        result['punishments'] = []
        if self.punishments is not None:
            for k in self.punishments:
                result['punishments'].append(k.to_map() if k else None)
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('default_drive_id') is not None:
            self.default_drive_id = m.get('default_drive_id')
        if m.get('default_location') is not None:
            self.default_location = m.get('default_location')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('last_login_time') is not None:
            self.last_login_time = m.get('last_login_time')
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        self.punishments = []
        if m.get('punishments') is not None:
            for k in m.get('punishments'):
                temp_model = PunishmentResponse()
                self.punishments.append(temp_model.from_map(k))
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class UpdateUserModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateUserResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateUserResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchUserAndGroupResponse(TeaModel):
    """
    Search user and group response
    """
    def __init__(
        self,
        groups: List[BaseGroupResponse] = None,
        next_marker: str = None,
        users: List[BaseUserResponse] = None,
    ):
        self.groups = groups
        # 翻页标记
        self.next_marker = next_marker
        self.users = users

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        result['users'] = []
        if self.users is not None:
            for k in self.users:
                result['users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = BaseGroupResponse()
                self.groups.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        self.users = []
        if m.get('users') is not None:
            for k in m.get('users'):
                temp_model = BaseUserResponse()
                self.users.append(temp_model.from_map(k))
        return self


class SearchUserGroupModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchUserAndGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchUserAndGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class MergeFaceGroupResponse(TeaModel):
    """
    merge face group response
    """
    def __init__(
        self,
        status: str = None,
        task_id: str = None,
    ):
        self.status = status
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class MergeModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: MergeFaceGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = MergeFaceGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassignFacegroupItemModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetDriveDataProcessTemplateResponse(TeaModel):
    """
    get drive data process template response
    """
    def __init__(
        self,
        template_id: str = None,
    ):
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['template_id'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        return self


class GetDataProcessTemplateModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetDriveDataProcessTemplateResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetDriveDataProcessTemplateResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDriveDataProcessTemplateResponse(TeaModel):
    """
    update drive data process template response
    """
    def __init__(
        self,
        drive_id: str = None,
        template_id: str = None,
    ):
        self.drive_id = drive_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.template_id is not None:
            result['template_id'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        return self


class UpdateDataProcessTemplateModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateDriveDataProcessTemplateResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateDriveDataProcessTemplateResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AddStoryFile(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_id: str = None,
        revision_id: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_id = file_id
        self.revision_id = revision_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.error_message is not None:
            result['error_message'] = self.error_message
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('error_message') is not None:
            self.error_message = m.get('error_message')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        return self


class AddStoryFilesResponse(TeaModel):
    """
    add story files response
    """
    def __init__(
        self,
        drive_id: str = None,
        files: List[AddStoryFile] = None,
        request_id: str = None,
        story_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # files
        self.files = files
        # request_id
        self.request_id = request_id
        # story_id
        self.story_id = story_id

    def validate(self):
        if self.files:
            for k in self.files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['request_id'] = self.request_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = AddStoryFile()
                self.files.append(temp_model.from_map(k))
        if m.get('request_id') is not None:
            self.request_id = m.get('request_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class AddStoryFilesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AddStoryFilesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AddStoryFilesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomizedStoryResponse(TeaModel):
    """
    生成自定义故事
    """
    def __init__(
        self,
        drive_id: str = None,
        story_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        self.story_id = story_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class CreateCustomizedStoryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateCustomizedStoryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateCustomizedStoryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimilarImageClusterTaskResponse(TeaModel):
    """
    create similar image cluster task response
    """
    def __init__(
        self,
        task_id: str = None,
    ):
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class CreateSimilarImageClusterTaskModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateSimilarImageClusterTaskResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateSimilarImageClusterTaskResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStoryResponse(TeaModel):
    """
    生成故事
    """
    def __init__(
        self,
        drive_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class CreateStoryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateStoryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateStoryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLocationDateClusterResponse(TeaModel):
    """
    delete locationCluster response
    """
    def __init__(
        self,
        cluster_id: str = None,
        drive_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.drive_id = drive_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class DeleteLocationDateClusterModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteLocationDateClusterResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteLocationDateClusterResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStoryResponse(TeaModel):
    """
    删除故事
    """
    def __init__(
        self,
        drive_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class DeleteStoryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: DeleteStoryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = DeleteStoryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStoryResponse(TeaModel):
    """
    生成故事
    """
    def __init__(
        self,
        cover_file_id: str = None,
        cover_file_thumbnail_url: str = None,
        created_at: str = None,
        custom_id: str = None,
        custom_labels: dict = None,
        face_group_ids: List[str] = None,
        story_end_time: str = None,
        story_file_list: List[BaseCCPFileResponse] = None,
        story_id: str = None,
        story_name: str = None,
        story_start_time: str = None,
        story_sub_type: str = None,
        story_type: str = None,
        updated_at: str = None,
    ):
        # cover_file_id
        self.cover_file_id = cover_file_id
        # cover_file_url
        self.cover_file_thumbnail_url = cover_file_thumbnail_url
        # created_at
        self.created_at = created_at
        # custom_id
        self.custom_id = custom_id
        # custom_labels
        self.custom_labels = custom_labels
        # face_group_ids
        self.face_group_ids = face_group_ids
        # story_end_time
        self.story_end_time = story_end_time
        self.story_file_list = story_file_list
        # story_id
        self.story_id = story_id
        # story_name
        self.story_name = story_name
        # story_start_time
        self.story_start_time = story_start_time
        # story_sub_type
        self.story_sub_type = story_sub_type
        # story_type
        self.story_type = story_type
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.story_file_list:
            for k in self.story_file_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_file_id is not None:
            result['cover_file_id'] = self.cover_file_id
        if self.cover_file_thumbnail_url is not None:
            result['cover_file_thumbnail_url'] = self.cover_file_thumbnail_url
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.custom_id is not None:
            result['custom_id'] = self.custom_id
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.face_group_ids is not None:
            result['face_group_ids'] = self.face_group_ids
        if self.story_end_time is not None:
            result['story_end_time'] = self.story_end_time
        result['story_file_list'] = []
        if self.story_file_list is not None:
            for k in self.story_file_list:
                result['story_file_list'].append(k.to_map() if k else None)
        if self.story_id is not None:
            result['story_id'] = self.story_id
        if self.story_name is not None:
            result['story_name'] = self.story_name
        if self.story_start_time is not None:
            result['story_start_time'] = self.story_start_time
        if self.story_sub_type is not None:
            result['story_sub_type'] = self.story_sub_type
        if self.story_type is not None:
            result['story_type'] = self.story_type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cover_file_id') is not None:
            self.cover_file_id = m.get('cover_file_id')
        if m.get('cover_file_thumbnail_url') is not None:
            self.cover_file_thumbnail_url = m.get('cover_file_thumbnail_url')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('custom_id') is not None:
            self.custom_id = m.get('custom_id')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('face_group_ids') is not None:
            self.face_group_ids = m.get('face_group_ids')
        if m.get('story_end_time') is not None:
            self.story_end_time = m.get('story_end_time')
        self.story_file_list = []
        if m.get('story_file_list') is not None:
            for k in m.get('story_file_list'):
                temp_model = BaseCCPFileResponse()
                self.story_file_list.append(temp_model.from_map(k))
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        if m.get('story_name') is not None:
            self.story_name = m.get('story_name')
        if m.get('story_start_time') is not None:
            self.story_start_time = m.get('story_start_time')
        if m.get('story_sub_type') is not None:
            self.story_sub_type = m.get('story_sub_type')
        if m.get('story_type') is not None:
            self.story_type = m.get('story_type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class FindStoriesResponse(TeaModel):
    """
    查询故事
    """
    def __init__(
        self,
        items: List[GetStoryResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = GetStoryResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class FindStoriesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: FindStoriesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = FindStoriesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFacegroupInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ImageFaceGroupResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ImageFaceGroupResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetImageCountResponse(TeaModel):
    """
    获取云照片个数结果
    """
    def __init__(
        self,
        image_count: int = None,
    ):
        # image_count
        self.image_count = image_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_count is not None:
            result['image_count'] = self.image_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('image_count') is not None:
            self.image_count = m.get('image_count')
        return self


class GetPhotoCountModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetImageCountResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetImageCountResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStoryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetStoryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetStoryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTaskStatusResponse(TeaModel):
    """
    get task status response
    """
    def __init__(
        self,
        status: str = None,
    ):
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetTaskStatusModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetTaskStatusResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetTaskStatusResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class Address(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address_line: str = None,
        city: str = None,
        country: str = None,
        district: str = None,
        location: str = None,
        province: str = None,
        township: str = None,
    ):
        self.address_line = address_line
        self.city = city
        self.country = country
        self.district = district
        self.location = location
        self.province = province
        self.township = township

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_line is not None:
            result['address_line'] = self.address_line
        if self.city is not None:
            result['city'] = self.city
        if self.country is not None:
            result['country'] = self.country
        if self.district is not None:
            result['district'] = self.district
        if self.location is not None:
            result['location'] = self.location
        if self.province is not None:
            result['province'] = self.province
        if self.township is not None:
            result['township'] = self.township
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_line') is not None:
            self.address_line = m.get('address_line')
        if m.get('city') is not None:
            self.city = m.get('city')
        if m.get('country') is not None:
            self.country = m.get('country')
        if m.get('district') is not None:
            self.district = m.get('district')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('province') is not None:
            self.province = m.get('province')
        if m.get('township') is not None:
            self.township = m.get('township')
        return self


class ImageAddressResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address_detail: Address = None,
        count: int = None,
        cover_file_id: str = None,
        cover_url: str = None,
        location: str = None,
        name: str = None,
    ):
        self.address_detail = address_detail
        # 聚类地点计数
        self.count = count
        # cover_file_id
        self.cover_file_id = cover_file_id
        # 聚类地点封面图片地址
        self.cover_url = cover_url
        # 经纬度
        self.location = location
        # 聚类地点名称
        self.name = name

    def validate(self):
        if self.address_detail:
            self.address_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_detail is not None:
            result['address_detail'] = self.address_detail.to_map()
        if self.count is not None:
            result['count'] = self.count
        if self.cover_file_id is not None:
            result['cover_file_id'] = self.cover_file_id
        if self.cover_url is not None:
            result['cover_url'] = self.cover_url
        if self.location is not None:
            result['location'] = self.location
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_detail') is not None:
            temp_model = Address()
            self.address_detail = temp_model.from_map(m['address_detail'])
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('cover_file_id') is not None:
            self.cover_file_id = m.get('cover_file_id')
        if m.get('cover_url') is not None:
            self.cover_url = m.get('cover_url')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListImageAddressGroupsResponse(TeaModel):
    """
    展示地点分组集合
    """
    def __init__(
        self,
        items: List[ImageAddressResponse] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.next_marker = next_marker
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ImageAddressResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class ListAddressGroupsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListImageAddressGroupsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListImageAddressGroupsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListImageFaceGroupsResponse(TeaModel):
    """
    展示人脸分组集合
    """
    def __init__(
        self,
        items: List[ImageFaceGroupResponse] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.next_marker = next_marker
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ImageFaceGroupResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class ListFacegroupsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListImageFaceGroupsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListImageFaceGroupsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ImageTagResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        count: int = None,
        cover_file_category: str = None,
        cover_file_id: str = None,
        cover_overall_score: float = None,
        cover_tag_confidence: float = None,
        cover_url: str = None,
        name: str = None,
    ):
        # 聚类标签计数
        self.count = count
        # cover_file_category
        self.cover_file_category = cover_file_category
        # cover_file_id
        self.cover_file_id = cover_file_id
        # cover_score
        self.cover_overall_score = cover_overall_score
        # cover_tag_confidence
        self.cover_tag_confidence = cover_tag_confidence
        # 聚类标签封面图片地址
        self.cover_url = cover_url
        # 聚类标签名称
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.cover_file_category is not None:
            result['cover_file_category'] = self.cover_file_category
        if self.cover_file_id is not None:
            result['cover_file_id'] = self.cover_file_id
        if self.cover_overall_score is not None:
            result['cover_overall_score'] = self.cover_overall_score
        if self.cover_tag_confidence is not None:
            result['cover_tag_confidence'] = self.cover_tag_confidence
        if self.cover_url is not None:
            result['cover_url'] = self.cover_url
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('cover_file_category') is not None:
            self.cover_file_category = m.get('cover_file_category')
        if m.get('cover_file_id') is not None:
            self.cover_file_id = m.get('cover_file_id')
        if m.get('cover_overall_score') is not None:
            self.cover_overall_score = m.get('cover_overall_score')
        if m.get('cover_tag_confidence') is not None:
            self.cover_tag_confidence = m.get('cover_tag_confidence')
        if m.get('cover_url') is not None:
            self.cover_url = m.get('cover_url')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListImageTagsResponse(TeaModel):
    """
    展示标签集合
    """
    def __init__(
        self,
        tags: List[ImageTagResponse] = None,
    ):
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ImageTagResponse()
                self.tags.append(temp_model.from_map(k))
        return self


class ListTagsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListImageTagsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListImageTagsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ParseTimeRange(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        end: str = None,
        start: str = None,
    ):
        self.end = end
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['end'] = self.end
        if self.start is not None:
            result['start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('start') is not None:
            self.start = m.get('start')
        return self


class ParseKeywordsResponse(TeaModel):
    """
    parse keywords response
    """
    def __init__(
        self,
        address_line: str = None,
        tags: List[SystemTag] = None,
        time_range: ParseTimeRange = None,
    ):
        # AddressLine
        self.address_line = address_line
        self.tags = tags
        self.time_range = time_range

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.time_range:
            self.time_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_line is not None:
            result['address_line'] = self.address_line
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.time_range is not None:
            result['time_range'] = self.time_range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_line') is not None:
            self.address_line = m.get('address_line')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = SystemTag()
                self.tags.append(temp_model.from_map(k))
        if m.get('time_range') is not None:
            temp_model = ParseTimeRange()
            self.time_range = temp_model.from_map(m['time_range'])
        return self


class ParseKeywordsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ParseKeywordsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ParseKeywordsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class LocationDateCluster(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address: Address = None,
        cluster_id: str = None,
        created_at: str = None,
        custom_labels: dict = None,
        drive_id: str = None,
        end_time: str = None,
        level: str = None,
        start_time: str = None,
        title: str = None,
        updated_at: str = None,
    ):
        self.address = address
        self.cluster_id = cluster_id
        self.created_at = created_at
        self.custom_labels = custom_labels
        self.drive_id = drive_id
        self.end_time = end_time
        self.level = level
        self.start_time = start_time
        self.title = title
        self.updated_at = updated_at

    def validate(self):
        if self.address:
            self.address.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['address'] = self.address.to_map()
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.level is not None:
            result['level'] = self.level
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.title is not None:
            result['title'] = self.title
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address') is not None:
            temp_model = Address()
            self.address = temp_model.from_map(m['address'])
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class QueryLocationClustersResponse(TeaModel):
    """
    query locationCluster response
    """
    def __init__(
        self,
        location_date_clusters: List[LocationDateCluster] = None,
        next_marker: str = None,
    ):
        self.location_date_clusters = location_date_clusters
        self.next_marker = next_marker

    def validate(self):
        if self.location_date_clusters:
            for k in self.location_date_clusters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['location_date_clusters'] = []
        if self.location_date_clusters is not None:
            for k in self.location_date_clusters:
                result['location_date_clusters'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.location_date_clusters = []
        if m.get('location_date_clusters') is not None:
            for k in m.get('location_date_clusters'):
                temp_model = LocationDateCluster()
                self.location_date_clusters.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class QueryLocationDateClusterModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: QueryLocationClustersResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = QueryLocationClustersResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SimilarImageCluster(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        files: List[BaseCCPFileResponse] = None,
    ):
        self.files = files

    def validate(self):
        if self.files:
            for k in self.files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = BaseCCPFileResponse()
                self.files.append(temp_model.from_map(k))
        return self


class QuerySimilarImageClusterResponse(TeaModel):
    """
    query similar image cluster response
    """
    def __init__(
        self,
        next_marker: str = None,
        similar_image_clusters: List[SimilarImageCluster] = None,
    ):
        self.next_marker = next_marker
        self.similar_image_clusters = similar_image_clusters

    def validate(self):
        if self.similar_image_clusters:
            for k in self.similar_image_clusters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        result['similar_image_clusters'] = []
        if self.similar_image_clusters is not None:
            for k in self.similar_image_clusters:
                result['similar_image_clusters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        self.similar_image_clusters = []
        if m.get('similar_image_clusters') is not None:
            for k in m.get('similar_image_clusters'):
                temp_model = SimilarImageCluster()
                self.similar_image_clusters.append(temp_model.from_map(k))
        return self


class QuerySimilarImageClustersModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: QuerySimilarImageClusterResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = QuerySimilarImageClusterResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveStoryFilesResponse(TeaModel):
    """
    remove story files response
    """
    def __init__(
        self,
        drive_id: str = None,
        request_id: str = None,
        story_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # request_id
        self.request_id = request_id
        # story_id
        self.story_id = story_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.request_id is not None:
            result['request_id'] = self.request_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('request_id') is not None:
            self.request_id = m.get('request_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class RemoveStoryFilesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: RemoveStoryFilesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = RemoveStoryFilesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchImageAddressGroupsResponse(TeaModel):
    """
    展示地点分组列表
    """
    def __init__(
        self,
        items: List[ImageAddressResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ImageAddressResponse()
                self.items.append(temp_model.from_map(k))
        return self


class SearchAddressGroupsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchImageAddressGroupsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchImageAddressGroupsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AggregationsGroup(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        count: int = None,
        value: str = None,
    ):
        self.count = count
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class Aggregation(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        field: str = None,
        groups: List[AggregationsGroup] = None,
        operation: str = None,
        value: float = None,
    ):
        self.field = field
        self.groups = groups
        self.operation = operation
        self.value = value

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        if self.operation is not None:
            result['operation'] = self.operation
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = AggregationsGroup()
                self.groups.append(temp_model.from_map(k))
        if m.get('operation') is not None:
            self.operation = m.get('operation')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class SimpleQueryResponse(TeaModel):
    """
    simple query response
    """
    def __init__(
        self,
        aggregations: List[Aggregation] = None,
        files: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
    ):
        self.aggregations = aggregations
        self.files = files
        self.next_marker = next_marker

    def validate(self):
        if self.aggregations:
            for k in self.aggregations:
                if k:
                    k.validate()
        if self.files:
            for k in self.files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['aggregations'] = []
        if self.aggregations is not None:
            for k in self.aggregations:
                result['aggregations'].append(k.to_map() if k else None)
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aggregations = []
        if m.get('aggregations') is not None:
            for k in m.get('aggregations'):
                temp_model = Aggregation()
                self.aggregations.append(temp_model.from_map(k))
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = BaseCCPFileResponse()
                self.files.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ImageSimpleQueryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SimpleQueryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SimpleQueryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFaceGroupInfoResponse(TeaModel):
    """
    更新人脸分组信息结果
    """
    def __init__(
        self,
        drive_id: str = None,
        group_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # group_id
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        return self


class UpdateFacegroupInfoModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateFaceGroupInfoResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateFaceGroupInfoResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLocationDateClusterResponse(TeaModel):
    """
    update locationCluster response
    """
    def __init__(
        self,
        cluster_id: str = None,
        drive_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.drive_id = drive_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class UpdateLocationDateClusterModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateLocationDateClusterResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateLocationDateClusterResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateStoryResponse(TeaModel):
    """
    update story response
    """
    def __init__(
        self,
        drive_id: str = None,
        story_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # story_id
        self.story_id = story_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class UpdateStoryModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: UpdateStoryResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = UpdateStoryResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class AddViewFileResponse(TeaModel):
    """
    add file to view response
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        view_id: str = None,
    ):
        self.drive_id = drive_id
        self.file_id = file_id
        self.view_id = view_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class AddFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: AddViewFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = AddViewFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyViewFilesResponse(TeaModel):
    """
    copy view files
    """
    def __init__(
        self,
        async_task_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        return self


class CopyFilesModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CopyViewFilesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CopyViewFilesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateViewResponse(TeaModel):
    """
    创建逻辑视图
    """
    def __init__(
        self,
        category: str = None,
        owner: str = None,
        view_id: str = None,
    ):
        self.category = category
        self.owner = owner
        self.view_id = view_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.owner is not None:
            result['owner'] = self.owner
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class CreateViewModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: CreateViewResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = CreateViewResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteViewModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class GetViewResponse(TeaModel):
    """
    获取指定逻辑视图信息
    """
    def __init__(
        self,
        category: str = None,
        created_at: str = None,
        description: str = None,
        ex_fields_info: dict = None,
        file_count: int = None,
        name: str = None,
        owner: str = None,
        updated_at: str = None,
        view_id: str = None,
    ):
        self.category = category
        self.created_at = created_at
        self.description = description
        self.ex_fields_info = ex_fields_info
        self.file_count = file_count
        self.name = name
        self.owner = owner
        self.updated_at = updated_at
        self.view_id = view_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_count is not None:
            result['file_count'] = self.file_count
        if self.name is not None:
            result['name'] = self.name
        if self.owner is not None:
            result['owner'] = self.owner
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class GetViewModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetViewResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetViewResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class GetViewFileResponse(TeaModel):
    """
    get view file response
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        fields: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        file_revision_id: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        joined_at: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
        view_id: str = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        self.fields = fields
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        self.file_revision_id = file_revision_id
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        self.joined_at = joined_at
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata
        self.view_id = view_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.file_revision_id is not None:
            result['file_revision_id'] = self.file_revision_id
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.joined_at is not None:
            result['joined_at'] = self.joined_at
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('file_revision_id') is not None:
            self.file_revision_id = m.get('file_revision_id')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('joined_at') is not None:
            self.joined_at = m.get('joined_at')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class GetViewFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: GetViewFileResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = GetViewFileResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListViewsResponse(TeaModel):
    """
    获取逻辑视图列表信息
    """
    def __init__(
        self,
        items: List[GetViewResponse] = None,
        next_marker: str = None,
    ):
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = GetViewResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListViewsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListViewsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListViewsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ViewFileItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        fields: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        file_revision_id: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        joined_at: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
        view_id: str = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        self.fields = fields
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        self.file_revision_id = file_revision_id
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        self.joined_at = joined_at
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata
        self.view_id = view_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.file_revision_id is not None:
            result['file_revision_id'] = self.file_revision_id
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.joined_at is not None:
            result['joined_at'] = self.joined_at
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('file_revision_id') is not None:
            self.file_revision_id = m.get('file_revision_id')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('joined_at') is not None:
            self.joined_at = m.get('joined_at')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class ListViewFilesResponse(TeaModel):
    """
    list view files response
    """
    def __init__(
        self,
        items: List[ViewFileItem] = None,
        next_marker: str = None,
    ):
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ViewFileItem()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ViewListFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListViewFilesResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListViewFilesResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFileViewsResponse(TeaModel):
    """
    list file view ids
    """
    def __init__(
        self,
        items: List[GetViewResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = GetViewResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListFileViewsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: ListFileViewsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = ListFileViewsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class SearchViewsResponse(TeaModel):
    """
    获取逻辑视图列表信息
    """
    def __init__(
        self,
        items: List[GetViewResponse] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.next_marker = next_marker
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = GetViewResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class SearchViewsModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchViewsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchViewsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class ViewSearchFileModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        body: SearchViewsResponse = None,
    ):
        self.headers = headers
        self.body = body

    def validate(self):
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('body') is not None:
            temp_model = SearchViewsResponse()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateViewModel(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
    ):
        self.headers = headers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        return self


class AccountLinkRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        custom_identity: str = None,
        detail: str = None,
        extra: str = None,
        identity: str = None,
        status: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.custom_identity = custom_identity
        # 账号信息
        self.detail = detail
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 状态
        self.status = status
        # 认证类型
        self.type = type
        # 绑定的user_id
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.type, 'type')
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.custom_identity is not None:
            result['custom_identity'] = self.custom_identity
        if self.detail is not None:
            result['detail'] = self.detail
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('custom_identity') is not None:
            self.custom_identity = m.get('custom_identity')
        if m.get('detail') is not None:
            self.detail = m.get('detail')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class AccountTokenRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        app_id: str = None,
        grant_type: str = None,
        refresh_token: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # App ID, 当前访问的App
        self.app_id = app_id
        # 只能填refresh_token
        self.grant_type = grant_type
        # refresh token, 登录时返回的
        self.refresh_token = refresh_token

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.grant_type, 'grant_type')
        self.validate_required(self.refresh_token, 'refresh_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.grant_type is not None:
            result['grant_type'] = self.grant_type
        if self.refresh_token is not None:
            result['refresh_token'] = self.refresh_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('grant_type') is not None:
            self.grant_type = m.get('grant_type')
        if m.get('refresh_token') is not None:
            self.refresh_token = m.get('refresh_token')
        return self


class AccountUnLinkRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        extra: str = None,
        identity: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 认证类型
        self.type = type
        # 解绑定的user_id
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.type, 'type')
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ActionItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        action: str = None,
        effect: str = None,
        inherited: bool = None,
        inherited_from: str = None,
    ):
        self.action = action
        self.effect = effect
        self.inherited = inherited
        self.inherited_from = inherited_from

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        if self.effect is not None:
            result['effect'] = self.effect
        if self.inherited is not None:
            result['inherited'] = self.inherited
        if self.inherited_from is not None:
            result['inherited_from'] = self.inherited_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('inherited') is not None:
            self.inherited = m.get('inherited')
        if m.get('inherited_from') is not None:
            self.inherited_from = m.get('inherited_from')
        return self


class AddStoreRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        base_path: str = None,
        bucket: str = None,
        domain_id: str = None,
        endpoint: str = None,
        ownership: str = None,
        role_arn: str = None,
        type: str = None,
    ):
        # 存储公共前缀
        self.base_path = base_path
        # bucket名称
        self.bucket = bucket
        # domain ID
        self.domain_id = domain_id
        # 存储访问地址
        self.endpoint = endpoint
        # 存储归属，system表示系统提供，custom表示使用自己的存储
        self.ownership = ownership
        # 访问Bucket的角色ARN
        self.role_arn = role_arn
        # 存储类型，当前只支持oss
        self.type = type

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.endpoint, 'endpoint')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.base_path is not None:
            result['base_path'] = self.base_path
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.ownership is not None:
            result['ownership'] = self.ownership
        if self.role_arn is not None:
            result['role_arn'] = self.role_arn
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('base_path') is not None:
            self.base_path = m.get('base_path')
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('ownership') is not None:
            self.ownership = m.get('ownership')
        if m.get('role_arn') is not None:
            self.role_arn = m.get('role_arn')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class StoryFile(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        revision_id: str = None,
    ):
        self.drive_id = drive_id
        self.file_id = file_id
        self.revision_id = revision_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        return self


class AddStoryFilesRequest(TeaModel):
    """
    add story files request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        files: List[StoryFile] = None,
        story_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        self.files = files
        # story_id
        self.story_id = story_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.files:
            for k in self.files:
                if k:
                    k.validate()
        self.validate_required(self.story_id, 'story_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = StoryFile()
                self.files.append(temp_model.from_map(k))
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class AddViewFileRequest(TeaModel):
    """
    add file to view
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        drive_id: str = None,
        fields: dict = None,
        file_id: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        self.drive_id = drive_id
        self.fields = fields
        self.file_id = file_id
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class AlbumsBaseRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class AppAccessStrategy(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        effect: str = None,
        except_app_id_list: List[str] = None,
    ):
        self.effect = effect
        self.except_app_id_list = except_app_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['effect'] = self.effect
        if self.except_app_id_list is not None:
            result['except_app_id_list'] = self.except_app_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('except_app_id_list') is not None:
            self.except_app_id_list = m.get('except_app_id_list')
        return self


class ArchiveListRequest(TeaModel):
    """
    预览压缩包结构
    """
    def __init__(
        self,
        format: str = None,
        request_id: str = None,
        archive_type: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        password: str = None,
    ):
        # 格式类型，如果是uc，使用特殊格式
        self.format = format
        self.request_id = request_id
        self.archive_type = archive_type
        self.domain_id = domain_id
        # TODO 增加对ShareID的支持
        self.drive_id = drive_id
        self.file_id = file_id
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.request_id is not None:
            result['RequestID'] = self.request_id
        if self.archive_type is not None:
            result['archive_type'] = self.archive_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.password is not None:
            result['password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('RequestID') is not None:
            self.request_id = m.get('RequestID')
        if m.get('archive_type') is not None:
            self.archive_type = m.get('archive_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('password') is not None:
            self.password = m.get('password')
        return self


class ArchiveListResponse(TeaModel):
    """
    预览压缩包结构 response
    """
    def __init__(
        self,
        file_list: dict = None,
        state: str = None,
        task_id: str = None,
    ):
        self.file_list = file_list
        self.state = state
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_list is not None:
            result['file_list'] = self.file_list
        if self.state is not None:
            result['state'] = self.state
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_list') is not None:
            self.file_list = m.get('file_list')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class ArchiveStatusRequest(TeaModel):
    """
    获取解压任务状态
    """
    def __init__(
        self,
        format: str = None,
        request_id: str = None,
        archive_type: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        password: str = None,
        task_id: str = None,
    ):
        # 格式类型，如果是uc，使用特殊格式
        self.format = format
        self.request_id = request_id
        self.archive_type = archive_type
        self.domain_id = domain_id
        # TODO 增加对ShareID的支持
        self.drive_id = drive_id
        self.file_id = file_id
        self.password = password
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.request_id is not None:
            result['RequestID'] = self.request_id
        if self.archive_type is not None:
            result['archive_type'] = self.archive_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.password is not None:
            result['password'] = self.password
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('RequestID') is not None:
            self.request_id = m.get('RequestID')
        if m.get('archive_type') is not None:
            self.archive_type = m.get('archive_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class ArchiveStatusResponse(TeaModel):
    """
    ArchiveStatusResponse response
    """
    def __init__(
        self,
        file_list: dict = None,
        progress: int = None,
        state: str = None,
        task_id: str = None,
    ):
        self.file_list = file_list
        self.progress = progress
        self.state = state
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_list is not None:
            result['file_list'] = self.file_list
        if self.progress is not None:
            result['progress'] = self.progress
        if self.state is not None:
            result['state'] = self.state
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_list') is not None:
            self.file_list = m.get('file_list')
        if m.get('progress') is not None:
            self.progress = m.get('progress')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class ArchiveUncompressRequest(TeaModel):
    """
    解压
    """
    def __init__(
        self,
        format: str = None,
        request_id: str = None,
        archive_type: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_list: List[str] = None,
        password: str = None,
        target_drive_id: str = None,
        target_file_id: str = None,
    ):
        # 格式类型，如果是uc，使用特殊格式
        self.format = format
        self.request_id = request_id
        self.archive_type = archive_type
        self.domain_id = domain_id
        # TODO 增加对ShareID的支持
        self.drive_id = drive_id
        self.file_id = file_id
        self.file_list = file_list
        self.password = password
        self.target_drive_id = target_drive_id
        self.target_file_id = target_file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.request_id is not None:
            result['RequestID'] = self.request_id
        if self.archive_type is not None:
            result['archive_type'] = self.archive_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_list is not None:
            result['file_list'] = self.file_list
        if self.password is not None:
            result['password'] = self.password
        if self.target_drive_id is not None:
            result['target_drive_id'] = self.target_drive_id
        if self.target_file_id is not None:
            result['target_file_id'] = self.target_file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('RequestID') is not None:
            self.request_id = m.get('RequestID')
        if m.get('archive_type') is not None:
            self.archive_type = m.get('archive_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_list') is not None:
            self.file_list = m.get('file_list')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('target_drive_id') is not None:
            self.target_drive_id = m.get('target_drive_id')
        if m.get('target_file_id') is not None:
            self.target_file_id = m.get('target_file_id')
        return self


class ArchiveUncompressResponse(TeaModel):
    """
    解压 response
    """
    def __init__(
        self,
        state: str = None,
        task_id: str = None,
    ):
        self.state = state
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['state'] = self.state
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class AuthConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        app_scheme: str = None,
        app_secret: str = None,
        callback_security: bool = None,
        ding_sync_config: DingSyncConfig = None,
        enable: bool = None,
        encoding_aes_key: str = None,
        endpoint: str = None,
        enterprise_id: str = None,
        ldap_config: LdapConfig = None,
        login_page_headers: dict = None,
        login_page_template: str = None,
        login_page_vars: dict = None,
        token: str = None,
        we_chat_sync_config: WeChatSyncConfig = None,
        white_list_config: dict = None,
        white_list_enable: bool = None,
    ):
        self.app_id = app_id
        self.app_scheme = app_scheme
        self.app_secret = app_secret
        self.callback_security = callback_security
        self.ding_sync_config = ding_sync_config
        self.enable = enable
        self.encoding_aes_key = encoding_aes_key
        self.endpoint = endpoint
        self.enterprise_id = enterprise_id
        self.ldap_config = ldap_config
        self.login_page_headers = login_page_headers
        self.login_page_template = login_page_template
        self.login_page_vars = login_page_vars
        self.token = token
        self.we_chat_sync_config = we_chat_sync_config
        self.white_list_config = white_list_config
        self.white_list_enable = white_list_enable

    def validate(self):
        if self.ding_sync_config:
            self.ding_sync_config.validate()
        if self.ldap_config:
            self.ldap_config.validate()
        if self.we_chat_sync_config:
            self.we_chat_sync_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_scheme is not None:
            result['app_scheme'] = self.app_scheme
        if self.app_secret is not None:
            result['app_secret'] = self.app_secret
        if self.callback_security is not None:
            result['callback_security'] = self.callback_security
        if self.ding_sync_config is not None:
            result['ding_sync_config'] = self.ding_sync_config.to_map()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.encoding_aes_key is not None:
            result['encoding_aes_key'] = self.encoding_aes_key
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.enterprise_id is not None:
            result['enterprise_id'] = self.enterprise_id
        if self.ldap_config is not None:
            result['ldap_config'] = self.ldap_config.to_map()
        if self.login_page_headers is not None:
            result['login_page_headers'] = self.login_page_headers
        if self.login_page_template is not None:
            result['login_page_template'] = self.login_page_template
        if self.login_page_vars is not None:
            result['login_page_vars'] = self.login_page_vars
        if self.token is not None:
            result['token'] = self.token
        if self.we_chat_sync_config is not None:
            result['we_chat_sync_config'] = self.we_chat_sync_config.to_map()
        if self.white_list_config is not None:
            result['white_list_config'] = self.white_list_config
        if self.white_list_enable is not None:
            result['white_list_enable'] = self.white_list_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_scheme') is not None:
            self.app_scheme = m.get('app_scheme')
        if m.get('app_secret') is not None:
            self.app_secret = m.get('app_secret')
        if m.get('callback_security') is not None:
            self.callback_security = m.get('callback_security')
        if m.get('ding_sync_config') is not None:
            temp_model = DingSyncConfig()
            self.ding_sync_config = temp_model.from_map(m['ding_sync_config'])
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('encoding_aes_key') is not None:
            self.encoding_aes_key = m.get('encoding_aes_key')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('enterprise_id') is not None:
            self.enterprise_id = m.get('enterprise_id')
        if m.get('ldap_config') is not None:
            temp_model = LdapConfig()
            self.ldap_config = temp_model.from_map(m['ldap_config'])
        if m.get('login_page_headers') is not None:
            self.login_page_headers = m.get('login_page_headers')
        if m.get('login_page_template') is not None:
            self.login_page_template = m.get('login_page_template')
        if m.get('login_page_vars') is not None:
            self.login_page_vars = m.get('login_page_vars')
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('we_chat_sync_config') is not None:
            temp_model = WeChatSyncConfig()
            self.we_chat_sync_config = temp_model.from_map(m['we_chat_sync_config'])
        if m.get('white_list_config') is not None:
            self.white_list_config = m.get('white_list_config')
        if m.get('white_list_enable') is not None:
            self.white_list_enable = m.get('white_list_enable')
        return self


class AuthorizeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        client_id: str = None,
        domain_id: str = None,
        hide_consent: bool = None,
        login_type: str = None,
        redirect_uri: str = None,
        response_type: str = None,
        scope: List[str] = None,
        state: str = None,
        user_code: str = None,
    ):
        # Client ID, 此处填写创建App时返回的AppID
        self.client_id = client_id
        # 内部使用
        self.domain_id = domain_id
        # 是否隐藏同意页面
        self.hide_consent = hide_consent
        # 鉴权方式，目前支持ding,ram鉴权
        self.login_type = login_type
        # 回调地址, 此处填写创建App时填写的回调地址
        self.redirect_uri = redirect_uri
        # 返回类型, 只能填写code
        self.response_type = response_type
        # 申请的权限列表, 默认为所有权限
        self.scope = scope
        # 用户自定义字段，会在鉴权成功后的callback带回
        self.state = state
        # 内部使用
        self.user_code = user_code

    def validate(self):
        self.validate_required(self.client_id, 'client_id')
        self.validate_required(self.redirect_uri, 'redirect_uri')
        self.validate_required(self.response_type, 'response_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientID'] = self.client_id
        if self.domain_id is not None:
            result['DomainID'] = self.domain_id
        if self.hide_consent is not None:
            result['HideConsent'] = self.hide_consent
        if self.login_type is not None:
            result['LoginType'] = self.login_type
        if self.redirect_uri is not None:
            result['RedirectUri'] = self.redirect_uri
        if self.response_type is not None:
            result['ResponseType'] = self.response_type
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.state is not None:
            result['State'] = self.state
        if self.user_code is not None:
            result['UserCode'] = self.user_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientID') is not None:
            self.client_id = m.get('ClientID')
        if m.get('DomainID') is not None:
            self.domain_id = m.get('DomainID')
        if m.get('HideConsent') is not None:
            self.hide_consent = m.get('HideConsent')
        if m.get('LoginType') is not None:
            self.login_type = m.get('LoginType')
        if m.get('RedirectUri') is not None:
            self.redirect_uri = m.get('RedirectUri')
        if m.get('ResponseType') is not None:
            self.response_type = m.get('ResponseType')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserCode') is not None:
            self.user_code = m.get('UserCode')
        return self


class BackUpConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        folder_id: str = None,
        photo_folder_id: str = None,
        sub_folder: dict = None,
        video_folder_id: str = None,
    ):
        # folder_id
        self.folder_id = folder_id
        # photo_folder_id
        self.photo_folder_id = photo_folder_id
        # sub_folder
        self.sub_folder = sub_folder
        # video_folder_id
        self.video_folder_id = video_folder_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_id is not None:
            result['folder_id'] = self.folder_id
        if self.photo_folder_id is not None:
            result['photo_folder_id'] = self.photo_folder_id
        if self.sub_folder is not None:
            result['sub_folder'] = self.sub_folder
        if self.video_folder_id is not None:
            result['video_folder_id'] = self.video_folder_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('folder_id') is not None:
            self.folder_id = m.get('folder_id')
        if m.get('photo_folder_id') is not None:
            self.photo_folder_id = m.get('photo_folder_id')
        if m.get('sub_folder') is not None:
            self.sub_folder = m.get('sub_folder')
        if m.get('video_folder_id') is not None:
            self.video_folder_id = m.get('video_folder_id')
        return self


class BaseAdditionDataRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        addition_data: dict = None,
    ):
        # addition_data
        self.addition_data = addition_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        return self


class BaseAdditionDataV2Request(TeaModel):
    """
    从value只支持string升级为支持所有类型的附加数据，按需升级
    """
    def __init__(
        self,
        addition_data: dict = None,
    ):
        # addition_data
        self.addition_data = addition_data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        return self


class BaseAuthentication(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        email: str = None,
        phone_number: str = None,
        phone_region: str = None,
    ):
        # 邮箱
        self.email = email
        # 待发送验证短信的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['email'] = self.email
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        return self


class BaseCompleteFileRequest(TeaModel):
    """
    complete file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        crc_64hash: str = None,
        drive_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # crc64_hash
        self.crc_64hash = crc_64hash
        # drive_id
        self.drive_id = drive_id
        # part_info_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class BaseCreateFileRequest(TeaModel):
    """
    create file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        content_md_5: str = None,
        content_type: str = None,
        name: str = None,
        part_info_list: List[UploadPartInfo] = None,
        size: int = None,
        type: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # ContentMd5
        self.content_md_5 = content_md_5
        # ContentType
        self.content_type = content_type
        # Name
        self.name = name
        # part_info_list
        self.part_info_list = part_info_list
        # Size
        self.size = size
        # Type
        self.type = type

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.name is not None:
            result['name'] = self.name
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.size is not None:
            result['size'] = self.size
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class BaseFileDeltaInfo(TeaModel):
    """
    the delta file info
    """
    def __init__(
        self,
        action_list: List[str] = None,
        auto_delete_left_sec: int = None,
        category: str = None,
        characteristic_hash: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        creator_id: str = None,
        creator_name: str = None,
        creator_type: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_extension: str = None,
        file_id: str = None,
        file_path_type: str = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaResponse = None,
        investigation_status: int = None,
        labels: List[str] = None,
        last_modifier_id: str = None,
        last_modifier_name: str = None,
        last_modifier_type: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        parent_file_id: str = None,
        punish_flag: int = None,
        punish_reason: str = None,
        revision_id: str = None,
        revision_version: int = None,
        share_id: str = None,
        size: int = None,
        starred: bool = None,
        status: str = None,
        streams_info: dict = None,
        sync_device_flag: bool = None,
        sync_flag: bool = None,
        sync_meta: str = None,
        thumbnail: str = None,
        thumbnail_urls: dict = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
        user_meta: str = None,
        user_tags: dict = None,
        video_media_metadata: VideoMediaResponse = None,
        video_preview_metadata: VideoPreviewResponse = None,
    ):
        # action_list
        self.action_list = action_list
        # auto_delete_left_sec
        self.auto_delete_left_sec = auto_delete_left_sec
        # category
        self.category = category
        # CharacteristicHash
        self.characteristic_hash = characteristic_hash
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # creator_id
        self.creator_id = creator_id
        # creator_name
        self.creator_name = creator_name
        # creator_type
        self.creator_type = creator_type
        # custom_field_1
        self.custom_field_1 = custom_field_1
        # custom_field_2
        self.custom_field_2 = custom_field_2
        # custom_type
        self.custom_type = custom_type
        # description
        self.description = description
        # DomainID
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_extension
        self.file_extension = file_extension
        # file_id
        self.file_id = file_id
        # TODO 先不在API上透出该字段，file_path_type目前在edm中返回；path type是否在PDS通用逻辑中展示，展示的含义是什么，需要再做分析
        self.file_path_type = file_path_type
        # Hidden
        # type: boolean
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # InvestigationStatus
        self.investigation_status = investigation_status
        # labels
        self.labels = labels
        # last_modifier_id
        self.last_modifier_id = last_modifier_id
        # last_modifier_name
        self.last_modifier_name = last_modifier_name
        # last_modifier_type
        self.last_modifier_type = last_modifier_type
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        self.meta = meta
        # mime_extension
        self.mime_extension = mime_extension
        # mime_type
        self.mime_type = mime_type
        # name
        self.name = name
        # parent_file_id
        self.parent_file_id = parent_file_id
        # PunishFlag
        self.punish_flag = punish_flag
        # PunishReason
        self.punish_reason = punish_reason
        # revision_id
        self.revision_id = revision_id
        # revision_version
        self.revision_version = revision_version
        self.share_id = share_id
        # Size
        self.size = size
        # starred
        # type: boolean
        self.starred = starred
        # status
        self.status = status
        # @Deprecated streams url info
        self.streams_info = streams_info
        # sync_device_flag
        self.sync_device_flag = sync_device_flag
        # sync_flag
        self.sync_flag = sync_flag
        # sync_meta
        self.sync_meta = sync_meta
        # thumbnail
        self.thumbnail = thumbnail
        # thumbnail_urls
        self.thumbnail_urls = thumbnail_urls
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata
        self.video_preview_metadata = video_preview_metadata

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        if self.video_media_metadata:
            self.video_media_metadata.validate()
        if self.video_preview_metadata:
            self.video_preview_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_list is not None:
            result['action_list'] = self.action_list
        if self.auto_delete_left_sec is not None:
            result['auto_delete_left_sec'] = self.auto_delete_left_sec
        if self.category is not None:
            result['category'] = self.category
        if self.characteristic_hash is not None:
            result['characteristic_hash'] = self.characteristic_hash
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator_id is not None:
            result['creator_id'] = self.creator_id
        if self.creator_name is not None:
            result['creator_name'] = self.creator_name
        if self.creator_type is not None:
            result['creator_type'] = self.creator_type
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.investigation_status is not None:
            result['investigation_status'] = self.investigation_status
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_modifier_id is not None:
            result['last_modifier_id'] = self.last_modifier_id
        if self.last_modifier_name is not None:
            result['last_modifier_name'] = self.last_modifier_name
        if self.last_modifier_type is not None:
            result['last_modifier_type'] = self.last_modifier_type
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.punish_flag is not None:
            result['punish_flag'] = self.punish_flag
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_version is not None:
            result['revision_version'] = self.revision_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.sync_device_flag is not None:
            result['sync_device_flag'] = self.sync_device_flag
        if self.sync_flag is not None:
            result['sync_flag'] = self.sync_flag
        if self.sync_meta is not None:
            result['sync_meta'] = self.sync_meta
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.thumbnail_urls is not None:
            result['thumbnail_urls'] = self.thumbnail_urls
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        if self.video_preview_metadata is not None:
            result['video_preview_metadata'] = self.video_preview_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_list') is not None:
            self.action_list = m.get('action_list')
        if m.get('auto_delete_left_sec') is not None:
            self.auto_delete_left_sec = m.get('auto_delete_left_sec')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('characteristic_hash') is not None:
            self.characteristic_hash = m.get('characteristic_hash')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator_id') is not None:
            self.creator_id = m.get('creator_id')
        if m.get('creator_name') is not None:
            self.creator_name = m.get('creator_name')
        if m.get('creator_type') is not None:
            self.creator_type = m.get('creator_type')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaResponse()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('investigation_status') is not None:
            self.investigation_status = m.get('investigation_status')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_modifier_id') is not None:
            self.last_modifier_id = m.get('last_modifier_id')
        if m.get('last_modifier_name') is not None:
            self.last_modifier_name = m.get('last_modifier_name')
        if m.get('last_modifier_type') is not None:
            self.last_modifier_type = m.get('last_modifier_type')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('punish_flag') is not None:
            self.punish_flag = m.get('punish_flag')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_version') is not None:
            self.revision_version = m.get('revision_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('sync_device_flag') is not None:
            self.sync_device_flag = m.get('sync_device_flag')
        if m.get('sync_flag') is not None:
            self.sync_flag = m.get('sync_flag')
        if m.get('sync_meta') is not None:
            self.sync_meta = m.get('sync_meta')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('thumbnail_urls') is not None:
            self.thumbnail_urls = m.get('thumbnail_urls')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaResponse()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        if m.get('video_preview_metadata') is not None:
            temp_model = VideoPreviewResponse()
            self.video_preview_metadata = temp_model.from_map(m['video_preview_metadata'])
        return self


class BaseFileProcessRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        office_thumbnail_process: str = None,
        video_thumbnail_process: str = None,
    ):
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class BaseGetUploadUrlRequest(TeaModel):
    """
    获取文件上传URL
    """
    def __init__(
        self,
        content_md_5: str = None,
        drive_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # content_md5
        self.content_md_5 = content_md_5
        # drive_id
        self.drive_id = drive_id
        # upload_part_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.content_md_5 is not None:
            self.validate_max_length(self.content_md_5, 'content_md_5', 32)
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        self.validate_required(self.upload_id, 'upload_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class BaseHostingFileResponse(TeaModel):
    """
    Base file response
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_path: str = None,
        name: str = None,
        parent_file_path: str = None,
        share_id: str = None,
        size: int = None,
        status: str = None,
        thumbnail: str = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_path
        self.file_path = file_path
        # name
        self.name = name
        # parent_file_id
        self.parent_file_path = parent_file_path
        # share_id
        self.share_id = share_id
        # Size
        self.size = size
        # status
        self.status = status
        # thumbnail
        self.thumbnail = thumbnail
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_path is not None:
            self.validate_max_length(self.parent_file_path, 'parent_file_path', 50)
            self.validate_pattern(self.parent_file_path, 'parent_file_path', '[a-z0-9]{1,50}')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class BaseImageProcessRequest(TeaModel):
    """
    Base image process
    """
    def __init__(
        self,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        office_thumbnail_process: str = None,
        video_thumbnail_process: str = None,
    ):
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class BaseListFileRequest(TeaModel):
    """
    list file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        drive_id: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        thumbnail_processes: dict = None,
        video_thumbnail_process: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        self.thumbnail_processes = thumbnail_processes
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class BaseMediaResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        address_line: str = None,
        city: str = None,
        country: str = None,
        district: str = None,
        height: int = None,
        image_tags: List[SystemTag] = None,
        location: str = None,
        province: str = None,
        time: str = None,
        township: str = None,
        width: int = None,
    ):
        # address_line
        self.address_line = address_line
        # city
        self.city = city
        # country
        self.country = country
        # district
        self.district = district
        # height
        self.height = height
        # system_tags
        self.image_tags = image_tags
        # location
        self.location = location
        # province
        self.province = province
        # time
        self.time = time
        # township
        self.township = township
        # width
        self.width = width

    def validate(self):
        if self.image_tags:
            for k in self.image_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_line is not None:
            result['address_line'] = self.address_line
        if self.city is not None:
            result['city'] = self.city
        if self.country is not None:
            result['country'] = self.country
        if self.district is not None:
            result['district'] = self.district
        if self.height is not None:
            result['height'] = self.height
        result['image_tags'] = []
        if self.image_tags is not None:
            for k in self.image_tags:
                result['image_tags'].append(k.to_map() if k else None)
        if self.location is not None:
            result['location'] = self.location
        if self.province is not None:
            result['province'] = self.province
        if self.time is not None:
            result['time'] = self.time
        if self.township is not None:
            result['township'] = self.township
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_line') is not None:
            self.address_line = m.get('address_line')
        if m.get('city') is not None:
            self.city = m.get('city')
        if m.get('country') is not None:
            self.country = m.get('country')
        if m.get('district') is not None:
            self.district = m.get('district')
        if m.get('height') is not None:
            self.height = m.get('height')
        self.image_tags = []
        if m.get('image_tags') is not None:
            for k in m.get('image_tags'):
                temp_model = SystemTag()
                self.image_tags.append(temp_model.from_map(k))
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('province') is not None:
            self.province = m.get('province')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('township') is not None:
            self.township = m.get('township')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class BaseMoveFileRequest(TeaModel):
    """
    文件移动请求
    """
    def __init__(
        self,
        drive_id: str = None,
        new_name: str = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # new_name
        self.new_name = new_name
        self.share_id = share_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.new_name is not None:
            self.validate_max_length(self.new_name, 'new_name', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class BaseRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        category: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        # category
        self.category = category
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class BaseRevisionRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        revision_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # revision_id
        self.revision_id = revision_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.revision_id, 'revision_id')
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        return self


class BaseSortShareLinkRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        order_by: str = None,
        order_direction: str = None,
    ):
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        return self


class UserTag(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class BaseUserTagsRequest(TeaModel):
    """
    user_tags 字段
    """
    def __init__(
        self,
        user_tags: List[UserTag] = None,
    ):
        # user_tags
        self.user_tags = user_tags

    def validate(self):
        if self.user_tags:
            for k in self.user_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['user_tags'] = []
        if self.user_tags is not None:
            for k in self.user_tags:
                result['user_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_tags = []
        if m.get('user_tags') is not None:
            for k in m.get('user_tags'):
                temp_model = UserTag()
                self.user_tags.append(temp_model.from_map(k))
        return self


class BatchSubRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        body: dict = None,
        headers: dict = None,
        id: str = None,
        method: str = None,
        url: str = None,
    ):
        # body 子请求的请求参数 json 字符串，可参考对于子请求文档, 当指定了body 必须传headers ： "Content-Type" 对应的类型，目前子请求入参是"application/json"
        self.body = body
        # headers 请求头，表示body传入数据的类型
        self.headers = headers
        # id 用于request 和 response关联， 不允许重复
        self.id = id
        # method
        self.method = method
        # url 子请求的api path路径， 可参考对于子请求文档
        self.url = url

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.method, 'method')
        self.validate_required(self.url, 'url')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.headers is not None:
            result['headers'] = self.headers
        if self.id is not None:
            result['id'] = self.id
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class BatchRequest(TeaModel):
    """
    批处理
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        requests: List[BatchSubRequest] = None,
        resource: str = None,
    ):
        self.httpheaders = httpheaders
        # Requests 请求合集
        self.requests = requests
        # 支持的资源类型
        self.resource = resource

    def validate(self):
        self.validate_required(self.requests, 'requests')
        if self.requests:
            for k in self.requests:
                if k:
                    k.validate()
        self.validate_required(self.resource, 'resource')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        result['requests'] = []
        if self.requests is not None:
            for k in self.requests:
                result['requests'].append(k.to_map() if k else None)
        if self.resource is not None:
            result['resource'] = self.resource
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        self.requests = []
        if m.get('requests') is not None:
            for k in m.get('requests'):
                temp_model = BatchSubRequest()
                self.requests.append(temp_model.from_map(k))
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        return self


class FileInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        file_id: str = None,
    ):
        self.file_id = file_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class CCPArchiveFilesRequest(TeaModel):
    """
    打包下载
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_ids: List[str] = None,
        files: List[FileInfo] = None,
        name: str = None,
        recursive: bool = None,
        referer: str = None,
        share_id: str = None,
        task_category: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        self.file_ids = file_ids
        self.files = files
        # file_name
        self.name = name
        self.recursive = recursive
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.task_category = task_category

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.files:
            for k in self.files:
                if k:
                    k.validate()
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_ids is not None:
            result['file_ids'] = self.file_ids
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.recursive is not None:
            result['recursive'] = self.recursive
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.task_category is not None:
            result['task_category'] = self.task_category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_ids') is not None:
            self.file_ids = m.get('file_ids')
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = FileInfo()
                self.files.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('recursive') is not None:
            self.recursive = m.get('recursive')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('task_category') is not None:
            self.task_category = m.get('task_category')
        return self


class CCPArchiveRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        format: str = None,
        request_id: str = None,
        archive_type: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        password: str = None,
    ):
        # 格式类型，如果是uc，使用特殊格式
        self.format = format
        self.request_id = request_id
        self.archive_type = archive_type
        self.domain_id = domain_id
        # TODO 增加对ShareID的支持
        self.drive_id = drive_id
        self.file_id = file_id
        self.password = password

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.request_id is not None:
            result['RequestID'] = self.request_id
        if self.archive_type is not None:
            result['archive_type'] = self.archive_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.password is not None:
            result['password'] = self.password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('RequestID') is not None:
            self.request_id = m.get('RequestID')
        if m.get('archive_type') is not None:
            self.archive_type = m.get('archive_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('password') is not None:
            self.password = m.get('password')
        return self


class CCPArchiveResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        state: str = None,
    ):
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class CCPGetDirSizeInfoRequest(TeaModel):
    """
    获取文件夹size信息
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class CCPGetFolderInfoRequest(TeaModel):
    """
    获取文件夹信息
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class CCPGetFolderInfoResponse(TeaModel):
    """
    获取文件夹信息
    """
    def __init__(
        self,
        total_size: int = None,
        used_size: int = None,
    ):
        # total_size
        self.total_size = total_size
        # used_size
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class CCPGetShareLinkVideoPreviewPlayInfoRequest(TeaModel):
    """
    获取分享中文件媒体播放地址的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        get_preview_url: bool = None,
        get_subtitle_info: bool = None,
        get_without_url: bool = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        location: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        subtitle_language_list: List[str] = None,
        template_id: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # get_preview_url
        self.get_preview_url = get_preview_url
        # get_subtitle_info
        self.get_subtitle_info = get_subtitle_info
        # get_without_url
        self.get_without_url = get_without_url
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # location
        self.location = location
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # share_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # subtitle_language_list, 根据语言获取压制在视频中的字幕, 不传则取所有
        self.subtitle_language_list = subtitle_language_list
        # template_id
        self.template_id = template_id
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.share_id, 'share_id')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 600)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.get_preview_url is not None:
            result['get_preview_url'] = self.get_preview_url
        if self.get_subtitle_info is not None:
            result['get_subtitle_info'] = self.get_subtitle_info
        if self.get_without_url is not None:
            result['get_without_url'] = self.get_without_url
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.location is not None:
            result['location'] = self.location
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.subtitle_language_list is not None:
            result['subtitle_language_list'] = self.subtitle_language_list
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('get_preview_url') is not None:
            self.get_preview_url = m.get('get_preview_url')
        if m.get('get_subtitle_info') is not None:
            self.get_subtitle_info = m.get('get_subtitle_info')
        if m.get('get_without_url') is not None:
            self.get_without_url = m.get('get_without_url')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('subtitle_language_list') is not None:
            self.subtitle_language_list = m.get('subtitle_language_list')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class CCPGetVideoPreviewPlayInfoRequest(TeaModel):
    """
    获取转码信息请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        get_master_url: bool = None,
        get_preview_url: bool = None,
        get_subtitle_info: bool = None,
        get_without_url: bool = None,
        location: str = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
        sign_token: str = None,
        subtitle_language_list: List[str] = None,
        template_id: str = None,
        url_expire_sec: int = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # 获取master playlist播放地址，仅在quick_video中有效
        self.get_master_url = get_master_url
        # get_preview_url
        self.get_preview_url = get_preview_url
        # get_subtitle_info
        self.get_subtitle_info = get_subtitle_info
        # get_without_url
        self.get_without_url = get_without_url
        # location
        self.location = location
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # subtitle_language_list, 根据语言获取压制在视频中的字幕, 不传则取所有
        self.subtitle_language_list = subtitle_language_list
        # template_id
        self.template_id = template_id
        # url_expire_sec
        self.url_expire_sec = url_expire_sec

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.get_master_url is not None:
            result['get_master_url'] = self.get_master_url
        if self.get_preview_url is not None:
            result['get_preview_url'] = self.get_preview_url
        if self.get_subtitle_info is not None:
            result['get_subtitle_info'] = self.get_subtitle_info
        if self.get_without_url is not None:
            result['get_without_url'] = self.get_without_url
        if self.location is not None:
            result['location'] = self.location
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.subtitle_language_list is not None:
            result['subtitle_language_list'] = self.subtitle_language_list
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('get_master_url') is not None:
            self.get_master_url = m.get('get_master_url')
        if m.get('get_preview_url') is not None:
            self.get_preview_url = m.get('get_preview_url')
        if m.get('get_subtitle_info') is not None:
            self.get_subtitle_info = m.get('get_subtitle_info')
        if m.get('get_without_url') is not None:
            self.get_without_url = m.get('get_without_url')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('subtitle_language_list') is not None:
            self.subtitle_language_list = m.get('subtitle_language_list')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        return self


class CCPGetVideoPreviewPlayMetaRequest(TeaModel):
    """
    获取转码播放元信息请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class CCPLiveTranscodeRequest(TeaModel):
    """
    触发实时转码
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        object_path: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # object_path
        self.object_path = object_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.object_path is not None:
            result['object_path'] = self.object_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('object_path') is not None:
            self.object_path = m.get('object_path')
        return self


class CCPVideoDRMLicenseRequest(TeaModel):
    """
    获取视频DRM License
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drm_type: str = None,
        license_request: str = None,
    ):
        self.httpheaders = httpheaders
        # drmType
        self.drm_type = drm_type
        # licenseRequest
        self.license_request = license_request

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drm_type is not None:
            result['drmType'] = self.drm_type
        if self.license_request is not None:
            result['licenseRequest'] = self.license_request
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drmType') is not None:
            self.drm_type = m.get('drmType')
        if m.get('licenseRequest') is not None:
            self.license_request = m.get('licenseRequest')
        return self


class CCPWalkFileRequest(TeaModel):
    """
    遍历文件
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        all: bool = None,
        before_updated_at: str = None,
        category: str = None,
        drive_id: str = None,
        fields: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        location: str = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        order_direction: str = None,
        parent_file_id: str = None,
        parent_file_id_path: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        starred: bool = None,
        status: str = None,
        thumbnail_processes: dict = None,
        type: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # all
        self.all = all
        # before_updated_at
        self.before_updated_at = before_updated_at
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # location
        self.location = location
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # ParentFileID
        self.parent_file_id = parent_file_id
        self.parent_file_id_path = parent_file_id_path
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # starred
        self.starred = starred
        # status
        self.status = status
        self.thumbnail_processes = thumbnail_processes
        # type
        self.type = type
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.all is not None:
            result['all'] = self.all
        if self.before_updated_at is not None:
            result['before_updated_at'] = self.before_updated_at
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.location is not None:
            result['location'] = self.location
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.parent_file_id_path is not None:
            result['parent_file_id_path'] = self.parent_file_id_path
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.type is not None:
            result['type'] = self.type
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('all') is not None:
            self.all = m.get('all')
        if m.get('before_updated_at') is not None:
            self.before_updated_at = m.get('before_updated_at')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('parent_file_id_path') is not None:
            self.parent_file_id_path = m.get('parent_file_id_path')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class CancelLinkRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        temporary_token: str = None,
    ):
        self.httpheaders = httpheaders
        # 待绑定的临时token，此token只能访问绑定、取消绑定接口
        self.temporary_token = temporary_token

    def validate(self):
        self.validate_required(self.temporary_token, 'temporary_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.temporary_token is not None:
            result['temporary_token'] = self.temporary_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('temporary_token') is not None:
            self.temporary_token = m.get('temporary_token')
        return self


class CancelRPVerifyRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        user_id: str = None,
    ):
        # User ID, 当前访问的用户
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class CancelShareLinkRequest(TeaModel):
    """
    cancel_share_link request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # share_id
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class Captcha(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        captcha: str = None,
        captcha_format: str = None,
        captcha_id: str = None,
    ):
        # 图片验证码，base64格式
        self.captcha = captcha
        # 图片格式
        self.captcha_format = captcha_format
        # 图片验证码ID
        self.captcha_id = captcha_id

    def validate(self):
        self.validate_required(self.captcha, 'captcha')
        self.validate_required(self.captcha_format, 'captcha_format')
        self.validate_required(self.captcha_id, 'captcha_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.captcha is not None:
            result['captcha'] = self.captcha
        if self.captcha_format is not None:
            result['captcha_format'] = self.captcha_format
        if self.captcha_id is not None:
            result['captcha_id'] = self.captcha_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('captcha') is not None:
            self.captcha = m.get('captcha')
        if m.get('captcha_format') is not None:
            self.captcha_format = m.get('captcha_format')
        if m.get('captcha_id') is not None:
            self.captcha_id = m.get('captcha_id')
        return self


class CcpCallback(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        body: dict = None,
        url: str = None,
    ):
        self.body = body
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CertInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cert_id: str = None,
        cert_body: str = None,
        cert_name: str = None,
        cert_privatekey: str = None,
    ):
        self.cert_id = cert_id
        # cert body
        self.cert_body = cert_body
        # cert name
        self.cert_name = cert_name
        # cert privatekey
        self.cert_privatekey = cert_privatekey

    def validate(self):
        self.validate_required(self.cert_body, 'cert_body')
        self.validate_required(self.cert_name, 'cert_name')
        self.validate_required(self.cert_privatekey, 'cert_privatekey')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertID'] = self.cert_id
        if self.cert_body is not None:
            result['cert_body'] = self.cert_body
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cert_privatekey is not None:
            result['cert_privatekey'] = self.cert_privatekey
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertID') is not None:
            self.cert_id = m.get('CertID')
        if m.get('cert_body') is not None:
            self.cert_body = m.get('cert_body')
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cert_privatekey') is not None:
            self.cert_privatekey = m.get('cert_privatekey')
        return self


class CheckExistRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        email: str = None,
        phone_number: str = None,
        phone_region: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # 邮箱
        self.email = email
        # 待发送验证短信的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region

    def validate(self):
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.email is not None:
            result['email'] = self.email
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        return self


class ClearRecycleBinRequest(TeaModel):
    """
    清空回收站
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        task_category: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        self.task_category = task_category

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.task_category is not None:
            result['task_category'] = self.task_category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('task_category') is not None:
            self.task_category = m.get('task_category')
        return self


class CompleteFileRequest(TeaModel):
    """
    合并文件上传任务
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        crc_64hash: str = None,
        drive_id: str = None,
        file_id: str = None,
        last_revision_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # crc64_hash
        self.crc_64hash = crc_64hash
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.last_revision_id = last_revision_id
        # part_info_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.last_revision_id is not None:
            result['last_revision_id'] = self.last_revision_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('last_revision_id') is not None:
            self.last_revision_id = m.get('last_revision_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class ConfirmLinkRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        temporary_token: str = None,
    ):
        self.httpheaders = httpheaders
        # 待绑定的临时token，此token只能访问绑定、取消绑定接口
        self.temporary_token = temporary_token

    def validate(self):
        self.validate_required(self.temporary_token, 'temporary_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.temporary_token is not None:
            result['temporary_token'] = self.temporary_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('temporary_token') is not None:
            self.temporary_token = m.get('temporary_token')
        return self


class KeepUserTags(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        all: bool = None,
        keys: List[str] = None,
    ):
        self.all = all
        self.keys = keys

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['all'] = self.all
        if self.keys is not None:
            result['keys'] = self.keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('all') is not None:
            self.all = m.get('all')
        if m.get('keys') is not None:
            self.keys = m.get('keys')
        return self


class CopyFileRequest(TeaModel):
    """
    文件拷贝
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        auto_rename: bool = None,
        batch_id: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        keep_user_tags: KeepUserTags = None,
        new_name: str = None,
        referer: str = None,
        share_id: str = None,
        to_drive_id: str = None,
        to_parent_file_id: str = None,
        to_share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # auto_rename
        # type: boolean
        self.auto_rename = auto_rename
        self.batch_id = batch_id
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        self.keep_user_tags = keep_user_tags
        # new_name
        self.new_name = new_name
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        # to_drive_id
        self.to_drive_id = to_drive_id
        # to_parent_file_id
        self.to_parent_file_id = to_parent_file_id
        # to_drive_id
        self.to_share_id = to_share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.keep_user_tags:
            self.keep_user_tags.validate()
        if self.new_name is not None:
            self.validate_max_length(self.new_name, 'new_name', 1024)
        if self.to_drive_id is not None:
            self.validate_pattern(self.to_drive_id, 'to_drive_id', '[0-9]+')
        self.validate_required(self.to_parent_file_id, 'to_parent_file_id')
        if self.to_parent_file_id is not None:
            self.validate_max_length(self.to_parent_file_id, 'to_parent_file_id', 50)
            self.validate_pattern(self.to_parent_file_id, 'to_parent_file_id', '[a-z0-9.-_]{1,50}')
        if self.to_share_id is not None:
            self.validate_pattern(self.to_share_id, 'to_share_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.auto_rename is not None:
            result['auto_rename'] = self.auto_rename
        if self.batch_id is not None:
            result['batch_id'] = self.batch_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.keep_user_tags is not None:
            result['keep_user_tags'] = self.keep_user_tags.to_map()
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_drive_id is not None:
            result['to_drive_id'] = self.to_drive_id
        if self.to_parent_file_id is not None:
            result['to_parent_file_id'] = self.to_parent_file_id
        if self.to_share_id is not None:
            result['to_share_id'] = self.to_share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('auto_rename') is not None:
            self.auto_rename = m.get('auto_rename')
        if m.get('batch_id') is not None:
            self.batch_id = m.get('batch_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('keep_user_tags') is not None:
            temp_model = KeepUserTags()
            self.keep_user_tags = temp_model.from_map(m['keep_user_tags'])
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_drive_id') is not None:
            self.to_drive_id = m.get('to_drive_id')
        if m.get('to_parent_file_id') is not None:
            self.to_parent_file_id = m.get('to_parent_file_id')
        if m.get('to_share_id') is not None:
            self.to_share_id = m.get('to_share_id')
        return self


class CopyViewFilesRequest(TeaModel):
    """
    Copy view files
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        auto_rename: bool = None,
        category: str = None,
        drive_file_list: List[ShareFile] = None,
        referer: str = None,
        share_id: str = None,
        to_drive_id: str = None,
        to_parent_file_id: str = None,
        to_view_id: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # auto_rename
        # type: boolean
        self.auto_rename = auto_rename
        # category
        self.category = category
        self.drive_file_list = drive_file_list
        self.referer = referer
        # share_id
        self.share_id = share_id
        # to_drive_id
        self.to_drive_id = to_drive_id
        # to_parent_file_id
        self.to_parent_file_id = to_parent_file_id
        # to_view_id
        self.to_view_id = to_view_id
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        if self.drive_file_list:
            for k in self.drive_file_list:
                if k:
                    k.validate()
        if self.to_drive_id is not None:
            self.validate_pattern(self.to_drive_id, 'to_drive_id', '[0-9]+')
        self.validate_required(self.to_parent_file_id, 'to_parent_file_id')
        if self.to_parent_file_id is not None:
            self.validate_max_length(self.to_parent_file_id, 'to_parent_file_id', 50)
            self.validate_pattern(self.to_parent_file_id, 'to_parent_file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.to_view_id, 'to_view_id')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.auto_rename is not None:
            result['auto_rename'] = self.auto_rename
        if self.category is not None:
            result['category'] = self.category
        result['drive_file_list'] = []
        if self.drive_file_list is not None:
            for k in self.drive_file_list:
                result['drive_file_list'].append(k.to_map() if k else None)
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_drive_id is not None:
            result['to_drive_id'] = self.to_drive_id
        if self.to_parent_file_id is not None:
            result['to_parent_file_id'] = self.to_parent_file_id
        if self.to_view_id is not None:
            result['to_view_id'] = self.to_view_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('auto_rename') is not None:
            self.auto_rename = m.get('auto_rename')
        if m.get('category') is not None:
            self.category = m.get('category')
        self.drive_file_list = []
        if m.get('drive_file_list') is not None:
            for k in m.get('drive_file_list'):
                temp_model = ShareFile()
                self.drive_file_list.append(temp_model.from_map(k))
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_drive_id') is not None:
            self.to_drive_id = m.get('to_drive_id')
        if m.get('to_parent_file_id') is not None:
            self.to_parent_file_id = m.get('to_parent_file_id')
        if m.get('to_view_id') is not None:
            self.to_view_id = m.get('to_view_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class CorsRule(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        allowed_header: List[str] = None,
        allowed_method: List[str] = None,
        allowed_origin: List[str] = None,
        expose_header: List[str] = None,
        max_age_seconds: int = None,
    ):
        # AllowedHeader
        self.allowed_header = allowed_header
        # AllowedMethod
        self.allowed_method = allowed_method
        # AllowedOrigin
        self.allowed_origin = allowed_origin
        # ExposeHeader
        self.expose_header = expose_header
        # MaxAgeSeconds
        self.max_age_seconds = max_age_seconds

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allowed_header is not None:
            result['allowed_header'] = self.allowed_header
        if self.allowed_method is not None:
            result['allowed_method'] = self.allowed_method
        if self.allowed_origin is not None:
            result['allowed_origin'] = self.allowed_origin
        if self.expose_header is not None:
            result['expose_header'] = self.expose_header
        if self.max_age_seconds is not None:
            result['max_age_seconds'] = self.max_age_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowed_header') is not None:
            self.allowed_header = m.get('allowed_header')
        if m.get('allowed_method') is not None:
            self.allowed_method = m.get('allowed_method')
        if m.get('allowed_origin') is not None:
            self.allowed_origin = m.get('allowed_origin')
        if m.get('expose_header') is not None:
            self.expose_header = m.get('expose_header')
        if m.get('max_age_seconds') is not None:
            self.max_age_seconds = m.get('max_age_seconds')
        return self


class CreateAppRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_name: str = None,
        description: str = None,
        is_third_party: bool = None,
        logo: str = None,
        public_key: str = None,
        redirect_uri: str = None,
        scope: List[str] = None,
        type: str = None,
    ):
        # App名称
        self.app_name = app_name
        # App描述
        self.description = description
        # 是否是domain私有App
        self.is_third_party = is_third_party
        # App图标
        self.logo = logo
        # RSA加密算法的公钥, PEM格式
        self.public_key = public_key
        # App回调地址
        self.redirect_uri = redirect_uri
        # App权限列表
        self.scope = scope
        # App类型
        self.type = type

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        if self.app_name is not None:
            self.validate_max_length(self.app_name, 'app_name', 128)
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 128)
        self.validate_required(self.logo, 'logo')
        self.validate_required(self.public_key, 'public_key')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.description is not None:
            result['description'] = self.description
        if self.is_third_party is not None:
            result['is_third_party'] = self.is_third_party
        if self.logo is not None:
            result['logo'] = self.logo
        if self.public_key is not None:
            result['public_key'] = self.public_key
        if self.redirect_uri is not None:
            result['redirect_uri'] = self.redirect_uri
        if self.scope is not None:
            result['scope'] = self.scope
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('is_third_party') is not None:
            self.is_third_party = m.get('is_third_party')
        if m.get('logo') is not None:
            self.logo = m.get('logo')
        if m.get('public_key') is not None:
            self.public_key = m.get('public_key')
        if m.get('redirect_uri') is not None:
            self.redirect_uri = m.get('redirect_uri')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateCustomizedStoryRequest(TeaModel):
    """
    # Create custom story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        custom_labels: dict = None,
        drive_id: str = None,
        story_cover: StoryFile = None,
        story_files: List[StoryFile] = None,
        story_name: str = None,
        story_sub_type: str = None,
        story_type: str = None,
    ):
        self.httpheaders = httpheaders
        # custom_labels
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        self.story_cover = story_cover
        # story_file_ids
        self.story_files = story_files
        # story_name
        self.story_name = story_name
        # story_sub_type
        self.story_sub_type = story_sub_type
        # story_type
        self.story_type = story_type

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.story_cover:
            self.story_cover.validate()
        if self.story_files:
            for k in self.story_files:
                if k:
                    k.validate()
        self.validate_required(self.story_type, 'story_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.story_cover is not None:
            result['story_cover'] = self.story_cover.to_map()
        result['story_files'] = []
        if self.story_files is not None:
            for k in self.story_files:
                result['story_files'].append(k.to_map() if k else None)
        if self.story_name is not None:
            result['story_name'] = self.story_name
        if self.story_sub_type is not None:
            result['story_sub_type'] = self.story_sub_type
        if self.story_type is not None:
            result['story_type'] = self.story_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('story_cover') is not None:
            temp_model = StoryFile()
            self.story_cover = temp_model.from_map(m['story_cover'])
        self.story_files = []
        if m.get('story_files') is not None:
            for k in m.get('story_files'):
                temp_model = StoryFile()
                self.story_files.append(temp_model.from_map(k))
        if m.get('story_name') is not None:
            self.story_name = m.get('story_name')
        if m.get('story_sub_type') is not None:
            self.story_sub_type = m.get('story_sub_type')
        if m.get('story_type') is not None:
            self.story_type = m.get('story_type')
        return self


class CreateDomainRequest(TeaModel):
    """
    create domain request
    """
    def __init__(
        self,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        data_hash_name: str = None,
        description: str = None,
        domain_name: str = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        group_single_drive_enabled: bool = None,
        independent_store: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        mode: str = None,
        parent_domain_id: str = None,
        path_type: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        sharable: bool = None,
        size_quota: int = None,
        store_level: str = None,
        store_region_list: List[str] = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
    ):
        # 登录相关信息
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 启用钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 启用 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        # Domain 描述
        self.description = description
        # Domain 名称
        self.domain_name = domain_name
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        # 单团队单drive
        self.group_single_drive_enabled = group_single_drive_enabled
        self.independent_store = independent_store
        # 开启自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # Domain 类型
        self.mode = mode
        # 父 Domain ID
        self.parent_domain_id = parent_domain_id
        # Domain 类型
        self.path_type = path_type
        self.published_app_access_strategy = published_app_access_strategy
        # 开启分享
        self.sharable = sharable
        # 逻辑空间quota，默认为-1，无限制，单位为字节
        self.size_quota = size_quota
        # 存储级别
        self.store_level = store_level
        # 存储 Region 列表
        self.store_region_list = store_region_list
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，默认为-1，无限制
        self.user_count_quota = user_count_quota
        # 单用户单drive
        self.user_single_drive_enabled = user_single_drive_enabled

    def validate(self):
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.description is not None:
            result['description'] = self.description
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.independent_store is not None:
            result['independent_store'] = self.independent_store
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.mode is not None:
            result['mode'] = self.mode
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        if self.path_type is not None:
            result['path_type'] = self.path_type
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.store_level is not None:
            result['store_level'] = self.store_level
        if self.store_region_list is not None:
            result['store_region_list'] = self.store_region_list
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('independent_store') is not None:
            self.independent_store = m.get('independent_store')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        if m.get('path_type') is not None:
            self.path_type = m.get('path_type')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('store_level') is not None:
            self.store_level = m.get('store_level')
        if m.get('store_region_list') is not None:
            self.store_region_list = m.get('store_region_list')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        return self


class CreateDriveRequest(TeaModel):
    """
    create drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        default: bool = None,
        description: str = None,
        drive_name: str = None,
        drive_type: str = None,
        encrypt_mode: str = None,
        location: str = None,
        owner: str = None,
        owner_type: str = None,
        relative_path: str = None,
        status: str = None,
        store_id: str = None,
        subdomain_id: str = None,
        total_size: int = None,
    ):
        self.httpheaders = httpheaders
        self.category = category
        # 是否默认drive, 只允许设置一个默认drive
        self.default = default
        # 描述信息
        self.description = description
        # Drive 名称
        self.drive_name = drive_name
        # Drive类型
        self.drive_type = drive_type
        self.encrypt_mode = encrypt_mode
        # location
        self.location = location
        # 所属者
        self.owner = owner
        # 所属者
        self.owner_type = owner_type
        # domain的PathType为OSSPath时必选。 Drive存储基于store的相对路径
        self.relative_path = relative_path
        # 状态
        self.status = status
        # StoreID , domain的PathType为OSSPath时必选
        self.store_id = store_id
        # Subdomain ID
        self.subdomain_id = subdomain_id
        # 总大小,单位Byte [如果设置 -1 代表不限制]
        self.total_size = total_size

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        self.validate_required(self.drive_name, 'drive_name')
        if self.drive_name is not None:
            self.validate_max_length(self.drive_name, 'drive_name', 1024)
        self.validate_required(self.owner, 'owner')
        self.validate_required(self.owner_type, 'owner_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.default is not None:
            result['default'] = self.default
        if self.description is not None:
            result['description'] = self.description
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.drive_type is not None:
            result['drive_type'] = self.drive_type
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.location is not None:
            result['location'] = self.location
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.relative_path is not None:
            result['relative_path'] = self.relative_path
        if self.status is not None:
            result['status'] = self.status
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('default') is not None:
            self.default = m.get('default')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('drive_type') is not None:
            self.drive_type = m.get('drive_type')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('relative_path') is not None:
            self.relative_path = m.get('relative_path')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class ImageMediaMetadata(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        height: int = None,
        taken_at: str = None,
        width: int = None,
    ):
        # height
        self.height = height
        # taken_at
        self.taken_at = taken_at
        # width：
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['height'] = self.height
        if self.taken_at is not None:
            result['taken_at'] = self.taken_at
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('taken_at') is not None:
            self.taken_at = m.get('taken_at')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoMediaMetadata(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        duration: str = None,
        taken_at: str = None,
    ):
        # Duration
        self.duration = duration
        # taken_at
        self.taken_at = taken_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.taken_at is not None:
            result['taken_at'] = self.taken_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('taken_at') is not None:
            self.taken_at = m.get('taken_at')
        return self


class CreateFileRequest(TeaModel):
    """
    创建文件
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        auto_rename: bool = None,
        category: str = None,
        check_name_mode: str = None,
        check_parent_file_id_path: str = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_md_5: str = None,
        content_type: str = None,
        create_reason: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        description: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        file_id: str = None,
        force_upload_to_location: bool = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaMetadata = None,
        labels: List[str] = None,
        last_revision_id: str = None,
        last_updated_at: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        location: str = None,
        meta: str = None,
        name: str = None,
        need_merge_period_revision: bool = None,
        parallel_upload: bool = None,
        parent_file_id: str = None,
        parent_file_id_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        pre_hash: str = None,
        proof_code: str = None,
        proof_seed: str = None,
        proof_version: str = None,
        share_id: str = None,
        size: int = None,
        streams_info: dict = None,
        type: str = None,
        upload_type: str = None,
        user_meta: str = None,
        user_tags: List[UserTag] = None,
        video_media_metadata: VideoMediaMetadata = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        self.auto_rename = auto_rename
        # category
        self.category = category
        # check_name_mode
        self.check_name_mode = check_name_mode
        self.check_parent_file_id_path = check_parent_file_id_path
        # content_hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # ContentMd5
        self.content_md_5 = content_md_5
        # ContentType
        self.content_type = content_type
        self.create_reason = create_reason
        self.custom_field_1 = custom_field_1
        self.custom_field_2 = custom_field_2
        self.custom_type = custom_type
        # description
        self.description = description
        # drive_id
        self.drive_id = drive_id
        self.encrypt_mode = encrypt_mode
        # file_id
        self.file_id = file_id
        # force_upload_to_location
        self.force_upload_to_location = force_upload_to_location
        # hidden
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # labels
        self.labels = labels
        self.last_revision_id = last_revision_id
        # last_updated_at
        self.last_updated_at = last_updated_at
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        # location
        self.location = location
        self.meta = meta
        # Name
        self.name = name
        self.need_merge_period_revision = need_merge_period_revision
        self.parallel_upload = parallel_upload
        # parent_file_id
        self.parent_file_id = parent_file_id
        self.parent_file_id_path = parent_file_id_path
        # part_info_list
        self.part_info_list = part_info_list
        # pre_hash
        self.pre_hash = pre_hash
        # proof_code
        self.proof_code = proof_code
        # proof_seed
        self.proof_seed = proof_seed
        # proof_version
        self.proof_version = proof_version
        # share_id
        # example
        self.share_id = share_id
        # Size
        self.size = size
        # streams_info
        self.streams_info = streams_info
        # Type
        self.type = type
        self.upload_type = upload_type
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        self.validate_required(self.type, 'type')
        if self.user_tags:
            for k in self.user_tags:
                if k:
                    k.validate()
        if self.video_media_metadata:
            self.video_media_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.auto_rename is not None:
            result['auto_rename'] = self.auto_rename
        if self.category is not None:
            result['category'] = self.category
        if self.check_name_mode is not None:
            result['check_name_mode'] = self.check_name_mode
        if self.check_parent_file_id_path is not None:
            result['check_parent_file_id_path'] = self.check_parent_file_id_path
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.create_reason is not None:
            result['create_reason'] = self.create_reason
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.force_upload_to_location is not None:
            result['force_upload_to_location'] = self.force_upload_to_location
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_revision_id is not None:
            result['last_revision_id'] = self.last_revision_id
        if self.last_updated_at is not None:
            result['last_updated_at'] = self.last_updated_at
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.location is not None:
            result['location'] = self.location
        if self.meta is not None:
            result['meta'] = self.meta
        if self.name is not None:
            result['name'] = self.name
        if self.need_merge_period_revision is not None:
            result['need_merge_period_revision'] = self.need_merge_period_revision
        if self.parallel_upload is not None:
            result['parallel_upload'] = self.parallel_upload
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.parent_file_id_path is not None:
            result['parent_file_id_path'] = self.parent_file_id_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.pre_hash is not None:
            result['pre_hash'] = self.pre_hash
        if self.proof_code is not None:
            result['proof_code'] = self.proof_code
        if self.proof_seed is not None:
            result['proof_seed'] = self.proof_seed
        if self.proof_version is not None:
            result['proof_version'] = self.proof_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.type is not None:
            result['type'] = self.type
        if self.upload_type is not None:
            result['upload_type'] = self.upload_type
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        result['user_tags'] = []
        if self.user_tags is not None:
            for k in self.user_tags:
                result['user_tags'].append(k.to_map() if k else None)
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('auto_rename') is not None:
            self.auto_rename = m.get('auto_rename')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('check_name_mode') is not None:
            self.check_name_mode = m.get('check_name_mode')
        if m.get('check_parent_file_id_path') is not None:
            self.check_parent_file_id_path = m.get('check_parent_file_id_path')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('create_reason') is not None:
            self.create_reason = m.get('create_reason')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('force_upload_to_location') is not None:
            self.force_upload_to_location = m.get('force_upload_to_location')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaMetadata()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_revision_id') is not None:
            self.last_revision_id = m.get('last_revision_id')
        if m.get('last_updated_at') is not None:
            self.last_updated_at = m.get('last_updated_at')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('need_merge_period_revision') is not None:
            self.need_merge_period_revision = m.get('need_merge_period_revision')
        if m.get('parallel_upload') is not None:
            self.parallel_upload = m.get('parallel_upload')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('parent_file_id_path') is not None:
            self.parent_file_id_path = m.get('parent_file_id_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('pre_hash') is not None:
            self.pre_hash = m.get('pre_hash')
        if m.get('proof_code') is not None:
            self.proof_code = m.get('proof_code')
        if m.get('proof_seed') is not None:
            self.proof_seed = m.get('proof_seed')
        if m.get('proof_version') is not None:
            self.proof_version = m.get('proof_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upload_type') is not None:
            self.upload_type = m.get('upload_type')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        self.user_tags = []
        if m.get('user_tags') is not None:
            for k in m.get('user_tags'):
                temp_model = UserTag()
                self.user_tags.append(temp_model.from_map(k))
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaMetadata()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        return self


class CreateShareLinkPermissionRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        creatable: bool = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_limit: int = None,
        office_editable: bool = None,
        preview_limit: int = None,
        require_login: bool = None,
        save_download_limit: int = None,
        save_limit: int = None,
    ):
        # 允许上传
        self.creatable = creatable
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 分享下载次数限制
        self.download_limit = download_limit
        # 允许在线编辑文档
        self.office_editable = office_editable
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        return self


class CreateShareLinkRequest(TeaModel):
    """
    create_share_link request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        comments: str = None,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        description: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_limit: int = None,
        drive_file_list: List[ShareFile] = None,
        drive_id: str = None,
        enable_file_changed_notify: bool = None,
        expiration: str = None,
        file_id: str = None,
        file_id_list: List[str] = None,
        file_path_list: List[str] = None,
        filter_group: str = None,
        office_editable: bool = None,
        preview_limit: int = None,
        referer: str = None,
        require_login: bool = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_all_files: bool = None,
        share_icon: str = None,
        share_name: str = None,
        share_pwd: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # description
        self.description = description
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 分享下载次数限制
        self.download_limit = download_limit
        # 多drive使用该字段，view分享支持跨drive，使用该字段，如果为空，则是分享view下所有文件
        self.drive_file_list = drive_file_list
        # 单drive使用以下字段，文件共享目前使用该字段
        # drive_id
        self.drive_id = drive_id
        # enable_file_changed_notify
        self.enable_file_changed_notify = enable_file_changed_notify
        # expiration
        self.expiration = expiration
        # file_id
        self.file_id = file_id
        # file_id_list
        self.file_id_list = file_id_list
        # file_path_list
        self.file_path_list = file_path_list
        # filter_group
        self.filter_group = filter_group
        # 允许在线编辑文档
        self.office_editable = office_editable
        # 分享预览次数限制
        self.preview_limit = preview_limit
        self.referer = referer
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # 是否分享整个drive中的文件，仅文件分享才有效，true时file_id_list字段无效
        self.share_all_files = share_all_files
        # share_icon
        self.share_icon = share_icon
        # share_name
        self.share_name = share_name
        # share_pwd
        self.share_pwd = share_pwd
        # user_id, only admin or aksk can set
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        if self.drive_file_list:
            for k in self.drive_file_list:
                if k:
                    k.validate()
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.description is not None:
            result['description'] = self.description
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        result['drive_file_list'] = []
        if self.drive_file_list is not None:
            for k in self.drive_file_list:
                result['drive_file_list'].append(k.to_map() if k else None)
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.enable_file_changed_notify is not None:
            result['enable_file_changed_notify'] = self.enable_file_changed_notify
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_list is not None:
            result['file_id_list'] = self.file_id_list
        if self.file_path_list is not None:
            result['file_path_list'] = self.file_path_list
        if self.filter_group is not None:
            result['filter_group'] = self.filter_group
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.referer is not None:
            result['referer'] = self.referer
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_all_files is not None:
            result['share_all_files'] = self.share_all_files
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        self.drive_file_list = []
        if m.get('drive_file_list') is not None:
            for k in m.get('drive_file_list'):
                temp_model = ShareFile()
                self.drive_file_list.append(temp_model.from_map(k))
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('enable_file_changed_notify') is not None:
            self.enable_file_changed_notify = m.get('enable_file_changed_notify')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_list') is not None:
            self.file_id_list = m.get('file_id_list')
        if m.get('file_path_list') is not None:
            self.file_path_list = m.get('file_path_list')
        if m.get('filter_group') is not None:
            self.filter_group = m.get('filter_group')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_all_files') is not None:
            self.share_all_files = m.get('share_all_files')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class CreateShareRequest(TeaModel):
    """
    create share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        drive_id: str = None,
        expiration: str = None,
        owner: str = None,
        owner_type: str = None,
        permissions: List[str] = None,
        share_file_id: str = None,
        share_file_path: str = None,
        share_name: str = None,
        share_policy: List[SharePermissionPolicy] = None,
        status: str = None,
    ):
        self.httpheaders = httpheaders
        # description
        self.description = description
        # drive_id
        self.drive_id = drive_id
        # expiration
        self.expiration = expiration
        # owner
        self.owner = owner
        # owner_type
        self.owner_type = owner_type
        # permissions
        self.permissions = permissions
        # share_file_id
        self.share_file_id = share_file_id
        # share_file_path
        self.share_file_path = share_file_path
        # share_name
        self.share_name = share_name
        # share create policy
        # 
        # share_policy
        self.share_policy = share_policy
        # status
        self.status = status

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.owner, 'owner')
        if self.share_policy:
            for k in self.share_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.share_file_id is not None:
            result['share_file_id'] = self.share_file_id
        if self.share_file_path is not None:
            result['share_file_path'] = self.share_file_path
        if self.share_name is not None:
            result['share_name'] = self.share_name
        result['share_policy'] = []
        if self.share_policy is not None:
            for k in self.share_policy:
                result['share_policy'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('share_file_id') is not None:
            self.share_file_id = m.get('share_file_id')
        if m.get('share_file_path') is not None:
            self.share_file_path = m.get('share_file_path')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        self.share_policy = []
        if m.get('share_policy') is not None:
            for k in m.get('share_policy'):
                temp_model = SharePermissionPolicy()
                self.share_policy.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class CreateSimilarImageClusterTaskRequest(TeaModel):
    """
    create similar image cluster task request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class CreateStoryRequest(TeaModel):
    """
    # Create story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        address: Address = None,
        custom_id: str = None,
        custom_labels: dict = None,
        drive_id: str = None,
        max_image_count: int = None,
        min_image_count: int = None,
        story_end_time: str = None,
        story_id: str = None,
        story_name: str = None,
        story_start_time: str = None,
        story_sub_type: str = None,
        story_type: str = None,
    ):
        self.httpheaders = httpheaders
        self.address = address
        # custom_id
        self.custom_id = custom_id
        # custom_labels
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        # max_image_count
        self.max_image_count = max_image_count
        # min_image_count
        self.min_image_count = min_image_count
        # story_end_time
        self.story_end_time = story_end_time
        # story_id
        self.story_id = story_id
        # story_name
        self.story_name = story_name
        # story_start_time
        self.story_start_time = story_start_time
        # story_sub_type
        self.story_sub_type = story_sub_type
        # story_type
        self.story_type = story_type

    def validate(self):
        if self.address:
            self.address.validate()
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.story_type, 'story_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.address is not None:
            result['address'] = self.address.to_map()
        if self.custom_id is not None:
            result['custom_id'] = self.custom_id
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.max_image_count is not None:
            result['max_image_count'] = self.max_image_count
        if self.min_image_count is not None:
            result['min_image_count'] = self.min_image_count
        if self.story_end_time is not None:
            result['story_end_time'] = self.story_end_time
        if self.story_id is not None:
            result['story_id'] = self.story_id
        if self.story_name is not None:
            result['story_name'] = self.story_name
        if self.story_start_time is not None:
            result['story_start_time'] = self.story_start_time
        if self.story_sub_type is not None:
            result['story_sub_type'] = self.story_sub_type
        if self.story_type is not None:
            result['story_type'] = self.story_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('address') is not None:
            temp_model = Address()
            self.address = temp_model.from_map(m['address'])
        if m.get('custom_id') is not None:
            self.custom_id = m.get('custom_id')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('max_image_count') is not None:
            self.max_image_count = m.get('max_image_count')
        if m.get('min_image_count') is not None:
            self.min_image_count = m.get('min_image_count')
        if m.get('story_end_time') is not None:
            self.story_end_time = m.get('story_end_time')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        if m.get('story_name') is not None:
            self.story_name = m.get('story_name')
        if m.get('story_start_time') is not None:
            self.story_start_time = m.get('story_start_time')
        if m.get('story_sub_type') is not None:
            self.story_sub_type = m.get('story_sub_type')
        if m.get('story_type') is not None:
            self.story_type = m.get('story_type')
        return self


class CreateViewRequest(TeaModel):
    """
    Create view request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        description: str = None,
        name: str = None,
        owner: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # description
        self.description = description
        # name
        self.name = name
        # owner
        self.owner = owner
        # user_id
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.name, 'name')
        self.validate_required(self.owner, 'owner')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.owner is not None:
            result['owner'] = self.owner
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class CustomBenefitMetaRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enabled: bool = None,
    ):
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class DataBoxPrivileges(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        feature_attr_id: str = None,
        feature_id: str = None,
        quota: int = None,
    ):
        # feature_attr_id
        self.feature_attr_id = feature_attr_id
        # feature_id
        self.feature_id = feature_id
        # quota
        self.quota = quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feature_attr_id is not None:
            result['feature_attr_id'] = self.feature_attr_id
        if self.feature_id is not None:
            result['feature_id'] = self.feature_id
        if self.quota is not None:
            result['quota'] = self.quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('feature_attr_id') is not None:
            self.feature_attr_id = m.get('feature_attr_id')
        if m.get('feature_id') is not None:
            self.feature_id = m.get('feature_id')
        if m.get('quota') is not None:
            self.quota = m.get('quota')
        return self


class DefaultChangePasswordRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        encrypted_key: str = None,
        new_password: str = None,
        phone_number: str = None,
        phone_region: str = None,
        state: str = None,
    ):
        # App ID, 当前访问的App
        self.app_id = app_id
        # AES-256对称加密密钥，通过App公钥加密后传输
        self.encrypted_key = encrypted_key
        # 新密码，必须包含数字和字母，长度8-20个字符
        self.new_password = new_password
        # 手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region
        # 修改密码的临时授权码
        self.state = state

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.encrypted_key, 'encrypted_key')
        self.validate_required(self.new_password, 'new_password')
        self.validate_required(self.phone_number, 'phone_number')
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.encrypted_key is not None:
            result['encrypted_key'] = self.encrypted_key
        if self.new_password is not None:
            result['new_password'] = self.new_password
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('encrypted_key') is not None:
            self.encrypted_key = m.get('encrypted_key')
        if m.get('new_password') is not None:
            self.new_password = m.get('new_password')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class DefaultSetPasswordRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        encrypted_key: str = None,
        new_password: str = None,
        state: str = None,
    ):
        # App ID, 当前访问的App
        self.app_id = app_id
        # AES-256对称加密密钥，通过App公钥加密后传输
        self.encrypted_key = encrypted_key
        # 新密码，必须包含数字和字母，长度8-20个字符，使用AES-256对称加密后传输（CBC模式, 填充算法为PKCS7Padding，生成base64字符串）
        self.new_password = new_password
        # 修改密码的临时授权码
        self.state = state

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.encrypted_key, 'encrypted_key')
        self.validate_required(self.new_password, 'new_password')
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.encrypted_key is not None:
            result['encrypted_key'] = self.encrypted_key
        if self.new_password is not None:
            result['new_password'] = self.new_password
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('encrypted_key') is not None:
            self.encrypted_key = m.get('encrypted_key')
        if m.get('new_password') is not None:
            self.new_password = m.get('new_password')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class DeleteAppRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
    ):
        # App ID
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class DeleteBizCNameAndCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # api cname
        self.biz_cname = biz_cname
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # vpc
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class DeleteBizCNameCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cert_id: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cert id
        self.cert_id = cert_id
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_id is not None:
            result['cert_id'] = self.cert_id
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_id') is not None:
            self.cert_id = m.get('cert_id')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class DeleteDataCNameAndCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        data_cname: str = None,
        domain_id: str = None,
        location: str = None,
    ):
        # cn-shanghai data cname
        self.data_cname = data_cname
        # domain ID
        self.domain_id = domain_id
        # location
        self.location = location

    def validate(self):
        self.validate_required(self.data_cname, 'data_cname')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.location, 'location')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cname is not None:
            result['data_cname'] = self.data_cname
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.location is not None:
            result['location'] = self.location
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data_cname') is not None:
            self.data_cname = m.get('data_cname')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('location') is not None:
            self.location = m.get('location')
        return self


class DeleteDomainRequest(TeaModel):
    """
    delete domain request
    """
    def __init__(
        self,
        domain_id: str = None,
    ):
        # Domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class DeleteDriveRequest(TeaModel):
    """
    # Delete drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        force: bool = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # Drive ID
        self.drive_id = drive_id
        self.force = force
        # Subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.force is not None:
            result['force'] = self.force
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('force') is not None:
            self.force = m.get('force')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class DeleteDriveResponse(TeaModel):
    """
    delete drive response
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteFileRequest(TeaModel):
    """
    删除文件请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        check_folder_empty: bool = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        permanently: bool = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.check_folder_empty = check_folder_empty
        # drive_id
        self.drive_id = drive_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # permanently
        # type: false
        self.permanently = permanently
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.check_folder_empty is not None:
            result['check_folder_empty'] = self.check_folder_empty
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.permanently is not None:
            result['permanently'] = self.permanently
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('check_folder_empty') is not None:
            self.check_folder_empty = m.get('check_folder_empty')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('permanently') is not None:
            self.permanently = m.get('permanently')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class DeleteFileUserTagsRequest(TeaModel):
    """
    删除文件 user_tags 字段
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_id: str = None,
        key_list: List[str] = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # key_list
        self.key_list = key_list

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.key_list is not None:
            result['key_list'] = self.key_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('key_list') is not None:
            self.key_list = m.get('key_list')
        return self


class DeleteFileUserTagsResponse(TeaModel):
    """
    删除文件 user tags response
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class DeleteFilesRequest(TeaModel):
    """
    批量删除文件请求
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id_list: List[str] = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_id_list
        self.file_id_list = file_id_list
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id_list, 'file_id_list')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id_list is not None:
            result['file_id_list'] = self.file_id_list
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id_list') is not None:
            self.file_id_list = m.get('file_id_list')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class DeleteFilesResponse(TeaModel):
    """
    批量删除文件 response
    """
    def __init__(
        self,
        deleted_file_id_list: List[str] = None,
        domain_id: str = None,
        drive_id: str = None,
    ):
        # deleted_file_id_list
        self.deleted_file_id_list = deleted_file_id_list
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deleted_file_id_list is not None:
            result['deleted_file_id_list'] = self.deleted_file_id_list
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deleted_file_id_list') is not None:
            self.deleted_file_id_list = m.get('deleted_file_id_list')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class DeleteLocationDateClusterRequest(TeaModel):
    """
    delete locationCluster request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cluster_id: str = None,
        drive_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.cluster_id = cluster_id
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class DeleteRevisionRequest(TeaModel):
    """
    删除历史版本元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        revision_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # revision_id
        self.revision_id = revision_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.revision_id, 'revision_id')
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        return self


class DeleteShareRequest(TeaModel):
    """
    delete share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # share_id
        self.share_id = share_id

    def validate(self):
        self.validate_required(self.share_id, 'share_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class DeleteStoryRequest(TeaModel):
    """
    delete story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        story_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # story_id
        self.story_id = story_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.story_id, 'story_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class DeleteViewRequest(TeaModel):
    """
    Delete view request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class DeviceAuthorizeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        client_id: str = None,
        device_info: str = None,
        device_name: str = None,
        login_type: str = None,
        scope: List[str] = None,
    ):
        # Client ID, 此处填写创建App时返回的AppID
        self.client_id = client_id
        # 设备信息，用于用户识别设备
        self.device_info = device_info
        # 设备名，实现方需保证不同设备的设备名不重复（推荐用硬件名称+硬件型号作为设备名）
        self.device_name = device_name
        # 鉴权方式，目前支持ding,ram鉴权
        self.login_type = login_type
        # 申请的权限列表, 默认为所有权限
        self.scope = scope

    def validate(self):
        self.validate_required(self.client_id, 'client_id')
        self.validate_required(self.device_name, 'device_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientID'] = self.client_id
        if self.device_info is not None:
            result['DeviceInfo'] = self.device_info
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.login_type is not None:
            result['LoginType'] = self.login_type
        if self.scope is not None:
            result['Scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientID') is not None:
            self.client_id = m.get('ClientID')
        if m.get('DeviceInfo') is not None:
            self.device_info = m.get('DeviceInfo')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('LoginType') is not None:
            self.login_type = m.get('LoginType')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        return self


class DomainUpdateNameRequest(TeaModel):
    """
    domain update name request
    """
    def __init__(
        self,
        domain_id: str = None,
        name: str = None,
    ):
        # Domain ID
        self.domain_id = domain_id
        # Domain 名称
        self.name = name

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DownloadRequest(TeaModel):
    """
    下载文件请求body
    """
    def __init__(
        self,
        drive_id: str = None,
        file_id: str = None,
        image_thumbnail_process: str = None,
        office_thumbnail_process: str = None,
        revision_id: str = None,
        share_id: str = None,
        video_thumbnail_process: str = None,
        addition_data: dict = None,
        file_id_path: str = None,
        location: str = None,
        referer: str = None,
        sign_token: str = None,
    ):
        # drive id
        self.drive_id = drive_id
        # file id
        self.file_id = file_id
        # in: query
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # revision id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process
        # addition_data
        self.addition_data = addition_data
        self.file_id_path = file_id_path
        # location
        self.location = location
        self.referer = referer
        self.sign_token = sign_token

    def validate(self):
        self.validate_required(self.file_id, 'file_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['DriveID'] = self.drive_id
        if self.file_id is not None:
            result['FileID'] = self.file_id
        if self.image_thumbnail_process is not None:
            result['ImageThumbnailProcess'] = self.image_thumbnail_process
        if self.office_thumbnail_process is not None:
            result['OfficeThumbnailProcess'] = self.office_thumbnail_process
        if self.revision_id is not None:
            result['RevisionID'] = self.revision_id
        if self.share_id is not None:
            result['ShareID'] = self.share_id
        if self.video_thumbnail_process is not None:
            result['VideoThumbnailProcess'] = self.video_thumbnail_process
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.location is not None:
            result['location'] = self.location
        if self.referer is not None:
            result['referer'] = self.referer
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriveID') is not None:
            self.drive_id = m.get('DriveID')
        if m.get('FileID') is not None:
            self.file_id = m.get('FileID')
        if m.get('ImageThumbnailProcess') is not None:
            self.image_thumbnail_process = m.get('ImageThumbnailProcess')
        if m.get('OfficeThumbnailProcess') is not None:
            self.office_thumbnail_process = m.get('OfficeThumbnailProcess')
        if m.get('RevisionID') is not None:
            self.revision_id = m.get('RevisionID')
        if m.get('ShareID') is not None:
            self.share_id = m.get('ShareID')
        if m.get('VideoThumbnailProcess') is not None:
            self.video_thumbnail_process = m.get('VideoThumbnailProcess')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        return self


class FileAddPermissionRequest(TeaModel):
    """
    文件共享/授权请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        member_list: List[FilePermissionMember] = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 文件所属的drive_id
        self.drive_id = drive_id
        # 文件的file_id
        self.file_id = file_id
        # 被授权的用户或团队列表
        self.member_list = member_list
        # 文件所属的subdomain_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.member_list, 'member_list')
        if self.member_list:
            for k in self.member_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        result['member_list'] = []
        if self.member_list is not None:
            for k in self.member_list:
                result['member_list'].append(k.to_map() if k else None)
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        self.member_list = []
        if m.get('member_list') is not None:
            for k in m.get('member_list'):
                temp_model = FilePermissionMember()
                self.member_list.append(temp_model.from_map(k))
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class FileListInheritPermissionRequest(TeaModel):
    """
    查询文件继承的共享/授权列表请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 文件所属的drive_id
        self.drive_id = drive_id
        # 文件的file_id
        self.file_id = file_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.file_id, 'file_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class FileListPermissionRequest(TeaModel):
    """
    列举当前文件的共享/授权记录请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 文件所属的drive_id
        self.drive_id = drive_id
        # 文件的file_id
        self.file_id = file_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.file_id, 'file_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class FileListUserPermissionRequest(TeaModel):
    """
    查询用户所有的文件共享/授权列表请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.subdomain_id = subdomain_id
        # 选择查看自己的或团队的或所有的，默认自己的
        self.type = type
        # 需要查询的用户ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class FileRemovePermissionRequest(TeaModel):
    """
    取消文件共享/授权请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        member_list: List[FilePermissionMember] = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 文件所属的drive_id
        self.drive_id = drive_id
        # 文件的file_id
        self.file_id = file_id
        # 被取消授权的用户或团队列表
        self.member_list = member_list
        # 文件所属的subdomain_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.member_list, 'member_list')
        if self.member_list:
            for k in self.member_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        result['member_list'] = []
        if self.member_list is not None:
            for k in self.member_list:
                result['member_list'].append(k.to_map() if k else None)
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        self.member_list = []
        if m.get('member_list') is not None:
            for k in m.get('member_list'):
                temp_model = FilePermissionMember()
                self.member_list.append(temp_model.from_map(k))
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class FileStreamInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_md_5: str = None,
        part_info_list: List[UploadPartInfo] = None,
        pre_hash: str = None,
        proof_code: str = None,
        proof_version: str = None,
        size: int = None,
    ):
        # content_hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # ContentMd5
        self.content_md_5 = content_md_5
        # part_info_list
        self.part_info_list = part_info_list
        # pre_hash
        self.pre_hash = pre_hash
        # proof_code
        self.proof_code = proof_code
        # proof_version
        self.proof_version = proof_version
        # Size
        self.size = size

    def validate(self):
        self.validate_required(self.content_md_5, 'content_md_5')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        self.validate_required(self.size, 'size')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.pre_hash is not None:
            result['pre_hash'] = self.pre_hash
        if self.proof_code is not None:
            result['proof_code'] = self.proof_code
        if self.proof_version is not None:
            result['proof_version'] = self.proof_version
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('pre_hash') is not None:
            self.pre_hash = m.get('pre_hash')
        if m.get('proof_code') is not None:
            self.proof_code = m.get('proof_code')
        if m.get('proof_version') is not None:
            self.proof_version = m.get('proof_version')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class QueryRequestTimeRange(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        end: str = None,
        start: str = None,
    ):
        # end
        self.end = end
        # start
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['end'] = self.end
        if self.start is not None:
            result['start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('start') is not None:
            self.start = m.get('start')
        return self


class FindStoriesRequest(TeaModel):
    """
    find story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cover_image_thumbnail_process: str = None,
        cover_video_thumbnail_process: str = None,
        create_time_range: QueryRequestTimeRange = None,
        custom_labels: str = None,
        drive_id: str = None,
        face_group_ids: List[str] = None,
        limit: int = None,
        marker: str = None,
        order: str = None,
        sort: str = None,
        story_end_time_range: QueryRequestTimeRange = None,
        story_id: str = None,
        story_name: str = None,
        story_start_time_range: QueryRequestTimeRange = None,
        story_type: str = None,
        url_expire_sec: int = None,
        with_empty_stories: bool = None,
    ):
        self.httpheaders = httpheaders
        # cover_image_thumbnail_process
        self.cover_image_thumbnail_process = cover_image_thumbnail_process
        # cover_video_thumbnail_process
        self.cover_video_thumbnail_process = cover_video_thumbnail_process
        self.create_time_range = create_time_range
        # custom_labels
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        # face_group_ids
        self.face_group_ids = face_group_ids
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # order
        self.order = order
        # sort
        self.sort = sort
        self.story_end_time_range = story_end_time_range
        # story_id
        self.story_id = story_id
        # story_name
        self.story_name = story_name
        self.story_start_time_range = story_start_time_range
        # story_type
        self.story_type = story_type
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # with_empty_stories
        self.with_empty_stories = with_empty_stories

    def validate(self):
        if self.create_time_range:
            self.create_time_range.validate()
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.story_end_time_range:
            self.story_end_time_range.validate()
        if self.story_start_time_range:
            self.story_start_time_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cover_image_thumbnail_process is not None:
            result['cover_image_thumbnail_process'] = self.cover_image_thumbnail_process
        if self.cover_video_thumbnail_process is not None:
            result['cover_video_thumbnail_process'] = self.cover_video_thumbnail_process
        if self.create_time_range is not None:
            result['create_time_range'] = self.create_time_range.to_map()
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.face_group_ids is not None:
            result['face_group_ids'] = self.face_group_ids
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order is not None:
            result['order'] = self.order
        if self.sort is not None:
            result['sort'] = self.sort
        if self.story_end_time_range is not None:
            result['story_end_time_range'] = self.story_end_time_range.to_map()
        if self.story_id is not None:
            result['story_id'] = self.story_id
        if self.story_name is not None:
            result['story_name'] = self.story_name
        if self.story_start_time_range is not None:
            result['story_start_time_range'] = self.story_start_time_range.to_map()
        if self.story_type is not None:
            result['story_type'] = self.story_type
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.with_empty_stories is not None:
            result['with_empty_stories'] = self.with_empty_stories
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cover_image_thumbnail_process') is not None:
            self.cover_image_thumbnail_process = m.get('cover_image_thumbnail_process')
        if m.get('cover_video_thumbnail_process') is not None:
            self.cover_video_thumbnail_process = m.get('cover_video_thumbnail_process')
        if m.get('create_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.create_time_range = temp_model.from_map(m['create_time_range'])
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('face_group_ids') is not None:
            self.face_group_ids = m.get('face_group_ids')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('story_end_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.story_end_time_range = temp_model.from_map(m['story_end_time_range'])
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        if m.get('story_name') is not None:
            self.story_name = m.get('story_name')
        if m.get('story_start_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.story_start_time_range = temp_model.from_map(m['story_start_time_range'])
        if m.get('story_type') is not None:
            self.story_type = m.get('story_type')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('with_empty_stories') is not None:
            self.with_empty_stories = m.get('with_empty_stories')
        return self


class GetAccessTokenByLinkInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        extra: str = None,
        identity: str = None,
        type: str = None,
    ):
        self.httpheaders = httpheaders
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 认证类型
        self.type = type

    def validate(self):
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAppPublicKeyRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
    ):
        # App ID
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class GetAppRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
    ):
        # App ID
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class GetAsyncTaskRequest(TeaModel):
    """
    获取异步人去信息
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        async_task_id: str = None,
    ):
        self.httpheaders = httpheaders
        # async_task_id
        # type:string
        self.async_task_id = async_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        return self


class GetBizCNameInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class GetByLinkInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        custom_identity: str = None,
        extra: str = None,
        identity: str = None,
        type: str = None,
    ):
        self.httpheaders = httpheaders
        self.custom_identity = custom_identity
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 认证类型
        self.type = type

    def validate(self):
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.custom_identity is not None:
            result['custom_identity'] = self.custom_identity
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('custom_identity') is not None:
            self.custom_identity = m.get('custom_identity')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetCaptchaRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
    ):
        # App ID, 当前访问的App
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class GetCorsRuleListRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
    ):
        # domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class GetDataCNameInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
    ):
        # domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class GetDefaultDriveRequest(TeaModel):
    """
    # Get default drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # Subdomain ID
        self.subdomain_id = subdomain_id
        # 用户ID
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetDirSizeInfoResponse(TeaModel):
    """
    获取文件夹size信息
    """
    def __init__(
        self,
        dir_count: int = None,
        file_count: int = None,
        size: int = None,
    ):
        # dir_count
        self.dir_count = dir_count
        # file_count
        self.file_count = file_count
        # size
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dir_count is not None:
            result['dir_count'] = self.dir_count
        if self.file_count is not None:
            result['file_count'] = self.file_count
        if self.size is not None:
            result['size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dir_count') is not None:
            self.dir_count = m.get('dir_count')
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        if m.get('size') is not None:
            self.size = m.get('size')
        return self


class GetDomainRequest(TeaModel):
    """
    get domain request
    """
    def __init__(
        self,
        domain_id: str = None,
        fields: str = None,
        get_benefit: bool = None,
        get_quota_used: bool = None,
        get_share_detail: bool = None,
        merge_parent: bool = None,
    ):
        # Domain ID
        self.domain_id = domain_id
        # fields,需要获取的属性字段,英文逗号分隔,*表示获取所有fields支持的枚举属性字段,为空不获取任何枚举属性字段
        self.fields = fields
        self.get_benefit = get_benefit
        # 是否获取 quota 使用情况
        self.get_quota_used = get_quota_used
        # 是否获取share/share_link详情
        self.get_share_detail = get_share_detail
        # 是否 merge parent 配置
        self.merge_parent = merge_parent

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.get_benefit is not None:
            result['get_benefit'] = self.get_benefit
        if self.get_quota_used is not None:
            result['get_quota_used'] = self.get_quota_used
        if self.get_share_detail is not None:
            result['get_share_detail'] = self.get_share_detail
        if self.merge_parent is not None:
            result['merge_parent'] = self.merge_parent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('get_benefit') is not None:
            self.get_benefit = m.get('get_benefit')
        if m.get('get_quota_used') is not None:
            self.get_quota_used = m.get('get_quota_used')
        if m.get('get_share_detail') is not None:
            self.get_share_detail = m.get('get_share_detail')
        if m.get('merge_parent') is not None:
            self.merge_parent = m.get('merge_parent')
        return self


class GetDownloadUrlRequest(TeaModel):
    """
    获取文件下载地址的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_id: str = None,
        file_id_path: str = None,
        file_name: str = None,
        location: str = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
        sign_token: str = None,
        static_url: bool = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # file_name
        self.file_name = file_name
        # location
        self.location = location
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        self.static_url = static_url

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 115200)
            self.validate_minimum(self.expire_sec, 'expire_sec', 1)
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.file_name is not None:
            self.validate_max_length(self.file_name, 'file_name', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.location is not None:
            result['location'] = self.location
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.static_url is not None:
            result['static_url'] = self.static_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('static_url') is not None:
            self.static_url = m.get('static_url')
        return self


class GetDriveDataProcessTemplateRequest(TeaModel):
    """
    get drive data process template request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class GetDriveRequest(TeaModel):
    """
    # Get drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # Drive ID
        self.drive_id = drive_id
        # Subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetFaceGroupInfoRequest(TeaModel):
    """
    # Get face group info request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        group_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # group_id 列举人脸分组接口中获取
        self.group_id = group_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.group_id, 'group_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        return self


class GetFileByPathRequest(TeaModel):
    """
    根据路径获取 File 接口 body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_path: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        sign_token: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        self.sign_token = sign_token
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class GetFileFaceGroupsRequest(TeaModel):
    """
    获取文件人脸分组列表请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        filter: str = None,
    ):
        self.httpheaders = httpheaders
        self.drive_id = drive_id
        self.file_id = file_id
        self.filter = filter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.filter is not None:
            result['filter'] = self.filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        return self


class GetFileRequest(TeaModel):
    """
    获取文件元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        fields: str = None,
        file_id: str = None,
        file_id_path: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        location: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
        sign_token: str = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # location
        self.location = location
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        self.thumbnail_processes = thumbnail_processes
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.location is not None:
            result['location'] = self.location
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class GetImageCountRequest(TeaModel):
    """
    # Get photo count request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        return self


class GetLastCursorRequest(TeaModel):
    """
    获取最新游标
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        sync_root_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # sync_root_id
        self.sync_root_id = sync_root_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.sync_root_id is not None:
            result['sync_root_id'] = self.sync_root_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('sync_root_id') is not None:
            self.sync_root_id = m.get('sync_root_id')
        return self


class GetLinkInfoByUserIDRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # user ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetMediaPlayURLRequest(TeaModel):
    """
    get_media_play_url request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class GetOfficeEditUrlOption(TeaModel):
    """
    GetOfficeEditUrlOption 权限控制
    """
    def __init__(
        self,
        copy: bool = None,
        print: bool = None,
        readonly: bool = None,
    ):
        # Copy
        self.copy = copy
        self.print = print
        self.readonly = readonly

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copy is not None:
            result['copy'] = self.copy
        if self.print is not None:
            result['print'] = self.print
        if self.readonly is not None:
            result['readonly'] = self.readonly
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('copy') is not None:
            self.copy = m.get('copy')
        if m.get('print') is not None:
            self.print = m.get('print')
        if m.get('readonly') is not None:
            self.readonly = m.get('readonly')
        return self


class GetOfficeEditUrlWatermark(TeaModel):
    """
    GetOfficeEditUrlWatermark 水印配置
    """
    def __init__(
        self,
        fillstyle: str = None,
        font: str = None,
        horizontal: int = None,
        rotate: float = None,
        type: int = None,
        value: str = None,
        vertical: int = None,
    ):
        # FillStyle
        self.fillstyle = fillstyle
        # Font
        self.font = font
        # Horizontal
        self.horizontal = horizontal
        # Rotate
        self.rotate = rotate
        # Type
        self.type = type
        # Value
        self.value = value
        # Vertical
        self.vertical = vertical

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fillstyle is not None:
            result['fillstyle'] = self.fillstyle
        if self.font is not None:
            result['font'] = self.font
        if self.horizontal is not None:
            result['horizontal'] = self.horizontal
        if self.rotate is not None:
            result['rotate'] = self.rotate
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.vertical is not None:
            result['vertical'] = self.vertical
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fillstyle') is not None:
            self.fillstyle = m.get('fillstyle')
        if m.get('font') is not None:
            self.font = m.get('font')
        if m.get('horizontal') is not None:
            self.horizontal = m.get('horizontal')
        if m.get('rotate') is not None:
            self.rotate = m.get('rotate')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('vertical') is not None:
            self.vertical = m.get('vertical')
        return self


class GetOfficeEditUrlRequest(TeaModel):
    """
    获取office文档在线编辑地址
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_id: str = None,
        option: GetOfficeEditUrlOption = None,
        revision_id: str = None,
        share_id: str = None,
        watermark: GetOfficeEditUrlWatermark = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.option = option
        # revision_id
        self.revision_id = revision_id
        # share_id
        # example
        self.share_id = share_id
        self.watermark = watermark

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.option:
            self.option.validate()
        if self.watermark:
            self.watermark.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.option is not None:
            result['option'] = self.option.to_map()
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.watermark is not None:
            result['watermark'] = self.watermark.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('option') is not None:
            temp_model = GetOfficeEditUrlOption()
            self.option = temp_model.from_map(m['option'])
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('watermark') is not None:
            temp_model = GetOfficeEditUrlWatermark()
            self.watermark = temp_model.from_map(m['watermark'])
        return self


class GetOfficePreviewUrlOption(TeaModel):
    """
    GetOfficePreviewUrlOption 权限控制
    """
    def __init__(
        self,
        copy: bool = None,
        print: bool = None,
    ):
        self.copy = copy
        self.print = print

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copy is not None:
            result['copy'] = self.copy
        if self.print is not None:
            result['print'] = self.print
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('copy') is not None:
            self.copy = m.get('copy')
        if m.get('print') is not None:
            self.print = m.get('print')
        return self


class GetOfficePreviewUrlRequest(TeaModel):
    """
    获取office文档预览地址
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        allow_copy: bool = None,
        drive_id: str = None,
        file_id: str = None,
        language: str = None,
        option: GetOfficePreviewUrlOption = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # allow_copy
        # default true
        self.allow_copy = allow_copy
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # language
        self.language = language
        self.option = option
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.option:
            self.option.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.allow_copy is not None:
            result['allow_copy'] = self.allow_copy
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.language is not None:
            result['language'] = self.language
        if self.option is not None:
            result['option'] = self.option.to_map()
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('allow_copy') is not None:
            self.allow_copy = m.get('allow_copy')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('option') is not None:
            temp_model = GetOfficePreviewUrlOption()
            self.option = temp_model.from_map(m['option'])
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class GetPublicKeyRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class GetRPVerifyInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        need_identity_info: bool = None,
        user_id: str = None,
    ):
        # Need Identity Info, 是否获取脱敏的身份信息
        self.need_identity_info = need_identity_info
        # User ID, 当前访问的用户
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.need_identity_info is not None:
            result['need_identity_info'] = self.need_identity_info
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('need_identity_info') is not None:
            self.need_identity_info = m.get('need_identity_info')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetRPVerifyResultRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        during_verify_process: bool = None,
        user_id: str = None,
    ):
        # During Verify Process, 是否在实人认证流程中调用
        self.during_verify_process = during_verify_process
        # User ID, 当前访问的用户
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.during_verify_process is not None:
            result['during_verify_process'] = self.during_verify_process
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('during_verify_process') is not None:
            self.during_verify_process = m.get('during_verify_process')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetRPVerifyTokenRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        user_id: str = None,
    ):
        # User ID, 当前访问的用户
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetRevisionRequest(TeaModel):
    """
    获取版本
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        fields: str = None,
        file_id: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        location: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        revision_id: str = None,
        sign_token: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        # file_id
        self.file_id = file_id
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # location
        self.location = location
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        self.sign_token = sign_token
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.revision_id, 'revision_id')
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.location is not None:
            result['location'] = self.location
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class GetShareLinkByAnonymousRequest(TeaModel):
    """
    get_share_link_by_anonymous request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # share_id
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class GetShareLinkDownloadURLRequest(TeaModel):
    """
    获取分享中文件下载地址的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_id: str = None,
        file_id_path: str = None,
        get_audio_play_info: bool = None,
        get_streams_url: bool = None,
        get_video_play_info: bool = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        location: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id is optional
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # get_audio_play_info
        self.get_audio_play_info = get_audio_play_info
        # get_streams_url
        self.get_streams_url = get_streams_url
        # get_video_play_info
        self.get_video_play_info = get_video_play_info
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # location
        self.location = location
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # share_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 600)
            self.validate_minimum(self.expire_sec, 'expire_sec', 1)
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.share_id, 'share_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.get_audio_play_info is not None:
            result['get_audio_play_info'] = self.get_audio_play_info
        if self.get_streams_url is not None:
            result['get_streams_url'] = self.get_streams_url
        if self.get_video_play_info is not None:
            result['get_video_play_info'] = self.get_video_play_info
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.location is not None:
            result['location'] = self.location
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('get_audio_play_info') is not None:
            self.get_audio_play_info = m.get('get_audio_play_info')
        if m.get('get_streams_url') is not None:
            self.get_streams_url = m.get('get_streams_url')
        if m.get('get_video_play_info') is not None:
            self.get_video_play_info = m.get('get_video_play_info')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class GetShareLinkIDRequest(TeaModel):
    """
    get_share_id request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_msg: str = None,
    ):
        self.httpheaders = httpheaders
        # share_msg
        self.share_msg = share_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_msg is not None:
            result['share_msg'] = self.share_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_msg') is not None:
            self.share_msg = m.get('share_msg')
        return self


class GetShareLinkRequest(TeaModel):
    """
    get_share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # share_id
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class GetShareLinkTokenRequest(TeaModel):
    """
    get_share_token request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        check_share_pwd: bool = None,
        expire_sec: int = None,
        nvc_param: str = None,
        referer: str = None,
        share_id: str = None,
        share_pwd: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # check_share_pwd, effective for creator, admin or aksk only
        self.check_share_pwd = check_share_pwd
        # expire_sec
        self.expire_sec = expire_sec
        # nvc_param
        self.nvc_param = nvc_param
        self.referer = referer
        # share_id
        self.share_id = share_id
        # share_pwd
        self.share_pwd = share_pwd

    def validate(self):
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 7200)
            self.validate_minimum(self.expire_sec, 'expire_sec', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.check_share_pwd is not None:
            result['check_share_pwd'] = self.check_share_pwd
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.nvc_param is not None:
            result['nvc_param'] = self.nvc_param
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('check_share_pwd') is not None:
            self.check_share_pwd = m.get('check_share_pwd')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('nvc_param') is not None:
            self.nvc_param = m.get('nvc_param')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        return self


class GetShareRequest(TeaModel):
    """
    get share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # share_id
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class GetStoryRequest(TeaModel):
    """
    # Get story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cover_image_thumbnail_process: str = None,
        cover_video_thumbnail_process: str = None,
        drive_id: str = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        office_thumbnail_process: str = None,
        story_id: str = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # cover_image_thumbnail_process
        self.cover_image_thumbnail_process = cover_image_thumbnail_process
        # cover_video_thumbnail_process
        self.cover_video_thumbnail_process = cover_video_thumbnail_process
        # drive_id
        self.drive_id = drive_id
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # story_id
        self.story_id = story_id
        self.thumbnail_processes = thumbnail_processes
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.story_id, 'story_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cover_image_thumbnail_process is not None:
            result['cover_image_thumbnail_process'] = self.cover_image_thumbnail_process
        if self.cover_video_thumbnail_process is not None:
            result['cover_video_thumbnail_process'] = self.cover_video_thumbnail_process
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.story_id is not None:
            result['story_id'] = self.story_id
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cover_image_thumbnail_process') is not None:
            self.cover_image_thumbnail_process = m.get('cover_image_thumbnail_process')
        if m.get('cover_video_thumbnail_process') is not None:
            self.cover_video_thumbnail_process = m.get('cover_video_thumbnail_process')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class GetSubdomainMgmtRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        get_share_detail: bool = None,
        subdomain_id: str = None,
    ):
        # 用以唯一标识domain
        self.domain_id = domain_id
        # 是否获取share/share_link详情
        self.get_share_detail = get_share_detail
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.get_share_detail is not None:
            result['get_share_detail'] = self.get_share_detail
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('get_share_detail') is not None:
            self.get_share_detail = m.get('get_share_detail')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetTaskStatusRequest(TeaModel):
    """
    get task status request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        task_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        self.task_id = task_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.task_id is not None:
            result['task_id'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        return self


class GetUploadUrlRequest(TeaModel):
    """
    获取文件上传URL
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        content_md_5: str = None,
        drive_id: str = None,
        file_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # content_md5
        self.content_md_5 = content_md_5
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # upload_part_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.content_md_5 is not None:
            self.validate_max_length(self.content_md_5, 'content_md_5', 32)
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        self.validate_required(self.upload_id, 'upload_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class GetVideoPreviewSpriteURLRequest(TeaModel):
    """
    获取视频雪碧图地址的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_id: str = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
        sign_token: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_id
        self.file_id = file_id
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 14400)
            self.validate_minimum(self.expire_sec, 'expire_sec', 1)
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        return self


class GetVideoPreviewURLRequest(TeaModel):
    """
    获取视频文件播放地址的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        audio_template_id: str = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_id: str = None,
        referer: str = None,
        revision_id: str = None,
        share_id: str = None,
        sign_token: str = None,
        template_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # audio_template_id
        self.audio_template_id = audio_template_id
        # drive_id
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_id
        self.file_id = file_id
        self.referer = referer
        # revision_id
        self.revision_id = revision_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # template_id
        self.template_id = template_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 14400)
            self.validate_minimum(self.expire_sec, 'expire_sec', 1)
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.audio_template_id is not None:
            result['audio_template_id'] = self.audio_template_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.template_id is not None:
            result['template_id'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('audio_template_id') is not None:
            self.audio_template_id = m.get('audio_template_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        return self


class GetViewFileRequest(TeaModel):
    """
    get file from view
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        self.drive_id = drive_id
        self.file_id = file_id
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class GetViewRequest(TeaModel):
    """
    Get view request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class HostingCompleteFileRequest(TeaModel):
    """
    complete file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        crc_64hash: str = None,
        drive_id: str = None,
        file_path: str = None,
        forbid_overwrite: bool = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # crc64_hash
        self.crc_64hash = crc_64hash
        # drive_id
        self.drive_id = drive_id
        self.file_path = file_path
        # forbid_overwrite
        # type: boolean
        self.forbid_overwrite = forbid_overwrite
        # part_info_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.forbid_overwrite is not None:
            result['forbid_overwrite'] = self.forbid_overwrite
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('forbid_overwrite') is not None:
            self.forbid_overwrite = m.get('forbid_overwrite')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class HostingCompleteFileResponse(TeaModel):
    """
    complete file response
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_path: str = None,
        name: str = None,
        parent_file_path: str = None,
        share_id: str = None,
        size: int = None,
        status: str = None,
        thumbnail: str = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc
        self.crc = crc
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_path
        self.file_path = file_path
        # name
        self.name = name
        # parent_file_id
        self.parent_file_path = parent_file_path
        # share_id
        self.share_id = share_id
        # Size
        self.size = size
        # status
        self.status = status
        # thumbnail
        self.thumbnail = thumbnail
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_path is not None:
            self.validate_max_length(self.parent_file_path, 'parent_file_path', 50)
            self.validate_pattern(self.parent_file_path, 'parent_file_path', '[a-z0-9]{1,50}')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc is not None:
            result['crc'] = self.crc
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc') is not None:
            self.crc = m.get('crc')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HostingCopyFileRequest(TeaModel):
    """
    copy file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        drive_id: str = None,
        file_path: str = None,
        new_name: str = None,
        overwrite: bool = None,
        referer: str = None,
        share_id: str = None,
        to_drive_id: str = None,
        to_parent_file_path: str = None,
        to_share_id: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # new_name
        self.new_name = new_name
        # overwrite
        # type: boolean
        self.overwrite = overwrite
        self.referer = referer
        # share_id
        self.share_id = share_id
        # to_drive_id
        self.to_drive_id = to_drive_id
        # to_parent_file_path
        self.to_parent_file_path = to_parent_file_path
        # share_id
        self.to_share_id = to_share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.new_name is not None:
            self.validate_max_length(self.new_name, 'new_name', 1024)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        if self.to_drive_id is not None:
            self.validate_pattern(self.to_drive_id, 'to_drive_id', '[0-9]+')
        self.validate_required(self.to_parent_file_path, 'to_parent_file_path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.overwrite is not None:
            result['overwrite'] = self.overwrite
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_drive_id is not None:
            result['to_drive_id'] = self.to_drive_id
        if self.to_parent_file_path is not None:
            result['to_parent_file_path'] = self.to_parent_file_path
        if self.to_share_id is not None:
            result['to_share_id'] = self.to_share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('overwrite') is not None:
            self.overwrite = m.get('overwrite')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_drive_id') is not None:
            self.to_drive_id = m.get('to_drive_id')
        if m.get('to_parent_file_path') is not None:
            self.to_parent_file_path = m.get('to_parent_file_path')
        if m.get('to_share_id') is not None:
            self.to_share_id = m.get('to_share_id')
        return self


class HostingCopyFileResponse(TeaModel):
    """
    文件拷贝 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_path: str = None,
        share_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # drive_id
        self.share_id = share_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z-]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[a-z0-9A-Z]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingCreateFileRequest(TeaModel):
    """
    create file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        content_md_5: str = None,
        content_type: str = None,
        drive_id: str = None,
        forbid_overwrite: bool = None,
        name: str = None,
        parent_file_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        size: int = None,
        type: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # ContentMd5
        self.content_md_5 = content_md_5
        # ContentType
        self.content_type = content_type
        # drive_id
        self.drive_id = drive_id
        # forbid_overwrite
        # type: boolean
        self.forbid_overwrite = forbid_overwrite
        # Name
        self.name = name
        # parent_file_path
        self.parent_file_path = parent_file_path
        # part_info_list
        self.part_info_list = part_info_list
        # share_id
        self.share_id = share_id
        # Size
        self.size = size
        # Type
        self.type = type

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)
        self.validate_required(self.parent_file_path, 'parent_file_path')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.forbid_overwrite is not None:
            result['forbid_overwrite'] = self.forbid_overwrite
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('forbid_overwrite') is not None:
            self.forbid_overwrite = m.get('forbid_overwrite')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class HostingCreateFileResponse(TeaModel):
    """
    Create file response
    """
    def __init__(
        self,
        domain_id: str = None,
        drive_id: str = None,
        file_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        type: str = None,
        upload_id: str = None,
    ):
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # part_info_list
        self.part_info_list = part_info_list
        # share_id
        self.share_id = share_id
        # type
        self.type = type
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_max_length(self.domain_id, 'domain_id', 50)
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9]{1,50}')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.type is not None:
            result['type'] = self.type
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class HostingDeleteFileRequest(TeaModel):
    """
    删除文件请求
    """
    def __init__(
        self,
        drive_id: str = None,
        file_path: str = None,
        permanently: bool = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # permanently
        # type: false
        self.permanently = permanently
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.permanently is not None:
            result['permanently'] = self.permanently
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('permanently') is not None:
            self.permanently = m.get('permanently')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingDeleteFileResponse(TeaModel):
    """
    删除文件 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_path: str = None,
        share_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[a-z0-9A-Z]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingDeleteFilesResponse(TeaModel):
    """
    批量删除文件 response
    """
    def __init__(
        self,
        deleted_file_id_list: List[str] = None,
        domain_id: str = None,
        drive_id: str = None,
        share_id: str = None,
    ):
        # deleted_file_id_list
        self.deleted_file_id_list = deleted_file_id_list
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deleted_file_id_list is not None:
            result['deleted_file_id_list'] = self.deleted_file_id_list
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deleted_file_id_list') is not None:
            self.deleted_file_id_list = m.get('deleted_file_id_list')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingGetDownloadUrlRequest(TeaModel):
    """
    获取文件下载地址的请求body
    """
    def __init__(
        self,
        addition_data: dict = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_name: str = None,
        file_path: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_name
        self.file_name = file_name
        # file_path
        self.file_path = file_path
        self.referer = referer
        # share_id
        self.share_id = share_id
        self.sign_token = sign_token

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 115200)
            self.validate_minimum(self.expire_sec, 'expire_sec', 10)
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        return self


class HostingGetDownloadUrlResponse(TeaModel):
    """
    获取download url response
    """
    def __init__(
        self,
        expiration: str = None,
        method: str = None,
        url: str = None,
    ):
        # expiration
        self.expiration = expiration
        # method
        self.method = method
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HostingGetFileRequest(TeaModel):
    """
    获取文件元数据
    """
    def __init__(
        self,
        addition_data: dict = None,
        drive_id: str = None,
        file_path: str = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        office_thumbnail_process: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_path = file_path
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.referer = referer
        # share_id
        self.share_id = share_id
        self.sign_token = sign_token
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class HostingGetFileResponse(TeaModel):
    """
    获取文件元数据response
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_path: str = None,
        name: str = None,
        parent_file_path: str = None,
        share_id: str = None,
        size: int = None,
        status: str = None,
        thumbnail: str = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_path
        self.file_path = file_path
        # name
        self.name = name
        # parent_file_id
        self.parent_file_path = parent_file_path
        # share_id
        self.share_id = share_id
        # Size
        self.size = size
        # status
        self.status = status
        # thumbnail
        self.thumbnail = thumbnail
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_path is not None:
            self.validate_max_length(self.parent_file_path, 'parent_file_path', 50)
            self.validate_pattern(self.parent_file_path, 'parent_file_path', '[a-z0-9]{1,50}')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HostingGetSecureUrlRequest(TeaModel):
    """
    获取文件安全地址的请求body
    """
    def __init__(
        self,
        drive_id: str = None,
        expire_sec: int = None,
        file_path: str = None,
        secure_ip: str = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # expire_sec 单位秒
        self.expire_sec = expire_sec
        # file_path
        self.file_path = file_path
        # secure_ip
        self.secure_ip = secure_ip
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.secure_ip is not None:
            result['secure_ip'] = self.secure_ip
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('secure_ip') is not None:
            self.secure_ip = m.get('secure_ip')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingGetSecureUrlResponse(TeaModel):
    """
    获取secure url response
    """
    def __init__(
        self,
        expiration: str = None,
        url: str = None,
    ):
        # expiration
        self.expiration = expiration
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HostingGetUploadUrlRequest(TeaModel):
    """
    获取文件上传URL
    """
    def __init__(
        self,
        content_md_5: str = None,
        drive_id: str = None,
        file_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # content_md5
        self.content_md_5 = content_md_5
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # upload_part_list
        self.part_info_list = part_info_list
        # share_id
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.content_md_5 is not None:
            self.validate_max_length(self.content_md_5, 'content_md_5', 32)
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        self.validate_required(self.upload_id, 'upload_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class HostingGetUploadUrlResponse(TeaModel):
    """
    Get UploadUrl Response
    """
    def __init__(
        self,
        create_at: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        upload_id: str = None,
    ):
        # created_at
        self.create_at = create_at
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # part_info_list
        self.part_info_list = part_info_list
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_at is not None:
            result['create_at'] = self.create_at
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('create_at') is not None:
            self.create_at = m.get('create_at')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class HostingListFileRequest(TeaModel):
    """
    list file request
    """
    def __init__(
        self,
        addition_data: dict = None,
        drive_id: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        parent_file_path: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # ParentFilePath
        self.parent_file_path = parent_file_path
        self.referer = referer
        # share_id
        self.share_id = share_id
        self.sign_token = sign_token
        self.thumbnail_processes = thumbnail_processes
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)
        self.validate_required(self.parent_file_path, 'parent_file_path')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class HostingListFileResponse(TeaModel):
    """
    List file response
    """
    def __init__(
        self,
        items: List[BaseHostingFileResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseHostingFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class HostingListUploadedPartRequest(TeaModel):
    """
    列举uploadID对应的已上传分片
    """
    def __init__(
        self,
        drive_id: str = None,
        file_path: str = None,
        limit: int = None,
        part_number_marker: int = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # limit
        self.limit = limit
        # part_number_marker
        self.part_number_marker = part_number_marker
        # share_id
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 1000)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.part_number_marker is not None:
            self.validate_minimum(self.part_number_marker, 'part_number_marker', 1)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.limit is not None:
            result['limit'] = self.limit
        if self.part_number_marker is not None:
            result['part_number_marker'] = self.part_number_marker
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('part_number_marker') is not None:
            self.part_number_marker = m.get('part_number_marker')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class HostingListUploadedPartResponse(TeaModel):
    """
    获取签名 response
    """
    def __init__(
        self,
        file_path: str = None,
        next_part_number_marker: str = None,
        upload_id: str = None,
        uploaded_parts: List[UploadPartInfo] = None,
    ):
        # file_path
        self.file_path = file_path
        # next_part_number_marker
        self.next_part_number_marker = next_part_number_marker
        # upload_id
        self.upload_id = upload_id
        # uploaded_parts
        self.uploaded_parts = uploaded_parts

    def validate(self):
        if self.uploaded_parts:
            for k in self.uploaded_parts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.next_part_number_marker is not None:
            result['next_part_number_marker'] = self.next_part_number_marker
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        result['uploaded_parts'] = []
        if self.uploaded_parts is not None:
            for k in self.uploaded_parts:
                result['uploaded_parts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('next_part_number_marker') is not None:
            self.next_part_number_marker = m.get('next_part_number_marker')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        self.uploaded_parts = []
        if m.get('uploaded_parts') is not None:
            for k in m.get('uploaded_parts'):
                temp_model = UploadPartInfo()
                self.uploaded_parts.append(temp_model.from_map(k))
        return self


class HostingMoveFileRequest(TeaModel):
    """
    文件移动请求
    """
    def __init__(
        self,
        drive_id: str = None,
        file_path: str = None,
        new_name: str = None,
        overwrite: bool = None,
        share_id: str = None,
        to_parent_file_path: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # new_name
        self.new_name = new_name
        # overwrite
        # type: boolean
        self.overwrite = overwrite
        # share_id
        self.share_id = share_id
        # file_path
        self.to_parent_file_path = to_parent_file_path

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.overwrite is not None:
            result['overwrite'] = self.overwrite
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_parent_file_path is not None:
            result['to_parent_file_path'] = self.to_parent_file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('overwrite') is not None:
            self.overwrite = m.get('overwrite')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_parent_file_path') is not None:
            self.to_parent_file_path = m.get('to_parent_file_path')
        return self


class HostingMoveFileResponse(TeaModel):
    """
    文件移动 response
    """
    def __init__(
        self,
        async_task_id: str = None,
        domain_id: str = None,
        drive_id: str = None,
        file_path: str = None,
        share_id: str = None,
    ):
        # async_task_id
        self.async_task_id = async_task_id
        # domain_id
        self.domain_id = domain_id
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # drive_id
        self.share_id = share_id

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z-]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[a-z0-9A-Z]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingSearchFileResponse(TeaModel):
    """
    search file response
    """
    def __init__(
        self,
        items: List[BaseHostingFileResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseHostingFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class HostingUpdateFileMetaResponse(TeaModel):
    """
    更新文件元数据 response
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        content_type: str = None,
        crc_64hash: str = None,
        created_at: str = None,
        description: str = None,
        domain_id: str = None,
        download_url: str = None,
        drive_id: str = None,
        file_extension: str = None,
        file_path: str = None,
        name: str = None,
        parent_file_path: str = None,
        share_id: str = None,
        size: int = None,
        status: str = None,
        thumbnail: str = None,
        trashed_at: str = None,
        type: str = None,
        updated_at: str = None,
        upload_id: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_type
        self.content_type = content_type
        # crc64_hash
        self.crc_64hash = crc_64hash
        # created_at
        self.created_at = created_at
        # description
        self.description = description
        # domain_id
        self.domain_id = domain_id
        # download_url
        self.download_url = download_url
        # drive_id
        self.drive_id = drive_id
        # file_extension
        self.file_extension = file_extension
        # file_path
        self.file_path = file_path
        # name
        self.name = name
        # parent_file_id
        self.parent_file_path = parent_file_path
        # share_id
        self.share_id = share_id
        # Size
        self.size = size
        # status
        self.status = status
        # thumbnail
        self.thumbnail = thumbnail
        # trashed_at
        self.trashed_at = trashed_at
        # type
        self.type = type
        # updated_at
        self.updated_at = updated_at
        # upload_id
        self.upload_id = upload_id
        # url
        self.url = url

    def validate(self):
        if self.domain_id is not None:
            self.validate_pattern(self.domain_id, 'domain_id', '[a-z0-9A-Z]+')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_pattern(self.name, 'name', '[a-zA-Z0-9.-]{1,1000}')
        if self.parent_file_path is not None:
            self.validate_max_length(self.parent_file_path, 'parent_file_path', 50)
            self.validate_pattern(self.parent_file_path, 'parent_file_path', '[a-z0-9]{1,50}')
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9]+')
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_extension is not None:
            result['file_extension'] = self.file_extension
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.trashed_at is not None:
            result['trashed_at'] = self.trashed_at
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_extension') is not None:
            self.file_extension = m.get('file_extension')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('trashed_at') is not None:
            self.trashed_at = m.get('trashed_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HostingVideoDRMLicenseRequest(TeaModel):
    """
    获取视频DRM License
    """
    def __init__(
        self,
        drm_type: str = None,
        license_request: str = None,
    ):
        # drmType
        self.drm_type = drm_type
        # licenseRequest
        self.license_request = license_request

    def validate(self):
        self.validate_required(self.drm_type, 'drm_type')
        self.validate_required(self.license_request, 'license_request')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drm_type is not None:
            result['drmType'] = self.drm_type
        if self.license_request is not None:
            result['licenseRequest'] = self.license_request
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drmType') is not None:
            self.drm_type = m.get('drmType')
        if m.get('licenseRequest') is not None:
            self.license_request = m.get('licenseRequest')
        return self


class HostingVideoDRMLicenseResponse(TeaModel):
    """
    DRM License response
    """
    def __init__(
        self,
        data: str = None,
        device_info: str = None,
        states: int = None,
    ):
        # drm_data
        self.data = data
        # device_info
        self.device_info = device_info
        # states
        self.states = states

    def validate(self):
        self.validate_required(self.data, 'data')
        self.validate_required(self.device_info, 'device_info')
        self.validate_required(self.states, 'states')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.device_info is not None:
            result['device_info'] = self.device_info
        if self.states is not None:
            result['states'] = self.states
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('device_info') is not None:
            self.device_info = m.get('device_info')
        if m.get('states') is not None:
            self.states = m.get('states')
        return self


class HostingVideoDefinitionRequest(TeaModel):
    """
    获取视频分辨率列表
    """
    def __init__(
        self,
        drive_id: str = None,
        file_path: str = None,
        protection_scheme: str = None,
        share_id: str = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # protection_scheme
        self.protection_scheme = protection_scheme
        # share_id
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.protection_scheme is not None:
            result['protection_scheme'] = self.protection_scheme
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('protection_scheme') is not None:
            self.protection_scheme = m.get('protection_scheme')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class HostingVideoDefinitionResponse(TeaModel):
    """
    转码接口response
    """
    def __init__(
        self,
        definition_list: List[str] = None,
        frame_rate: str = None,
    ):
        # definition_list
        self.definition_list = definition_list
        # frame_rate
        self.frame_rate = frame_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition_list is not None:
            result['definition_list'] = self.definition_list
        if self.frame_rate is not None:
            result['frame_rate'] = self.frame_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('definition_list') is not None:
            self.definition_list = m.get('definition_list')
        if m.get('frame_rate') is not None:
            self.frame_rate = m.get('frame_rate')
        return self


class HostingVideoM3U8Request(TeaModel):
    """
    获取视频的m3u8文件
    """
    def __init__(
        self,
        definition: str = None,
        drive_id: str = None,
        expire_sec: int = None,
        file_path: str = None,
        protection_scheme: str = None,
        share_id: str = None,
        sign_token: str = None,
    ):
        # definition
        self.definition = definition
        # drive_id
        self.drive_id = drive_id
        # expire_sec
        self.expire_sec = expire_sec
        # file_path
        self.file_path = file_path
        # protection_scheme
        self.protection_scheme = protection_scheme
        # share_id
        self.share_id = share_id
        # sign_token
        self.sign_token = sign_token

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.expire_sec is not None:
            self.validate_maximum(self.expire_sec, 'expire_sec', 86400)
            self.validate_minimum(self.expire_sec, 'expire_sec', 60)
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')
        self.validate_required(self.sign_token, 'sign_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['definition'] = self.definition
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.expire_sec is not None:
            result['expire_sec'] = self.expire_sec
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.protection_scheme is not None:
            result['protection_scheme'] = self.protection_scheme
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('definition') is not None:
            self.definition = m.get('definition')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('expire_sec') is not None:
            self.expire_sec = m.get('expire_sec')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('protection_scheme') is not None:
            self.protection_scheme = m.get('protection_scheme')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        return self


class HostingVideoTranscodeRequest(TeaModel):
    """
    启动视频转码请求
    """
    def __init__(
        self,
        drive_id: str = None,
        file_path: str = None,
        hls_time: int = None,
        protection_scheme: str = None,
        remarks: str = None,
        share_id: str = None,
        transcode: bool = None,
    ):
        # drive_id
        self.drive_id = drive_id
        # file_path
        self.file_path = file_path
        # hls_time
        self.hls_time = hls_time
        # protection_scheme
        self.protection_scheme = protection_scheme
        # remarks
        self.remarks = remarks
        # share_id
        self.share_id = share_id
        # transcode
        self.transcode = transcode

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_path, 'file_path')
        if self.file_path is not None:
            self.validate_max_length(self.file_path, 'file_path', 1000)
        if self.share_id is not None:
            self.validate_pattern(self.share_id, 'share_id', '[0-9a-zA-Z-]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_path is not None:
            result['file_path'] = self.file_path
        if self.hls_time is not None:
            result['hls_time'] = self.hls_time
        if self.protection_scheme is not None:
            result['protection_scheme'] = self.protection_scheme
        if self.remarks is not None:
            result['remarks'] = self.remarks
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.transcode is not None:
            result['transcode'] = self.transcode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        if m.get('hls_time') is not None:
            self.hls_time = m.get('hls_time')
        if m.get('protection_scheme') is not None:
            self.protection_scheme = m.get('protection_scheme')
        if m.get('remarks') is not None:
            self.remarks = m.get('remarks')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('transcode') is not None:
            self.transcode = m.get('transcode')
        return self


class HostingVideoTranscodeResponse(TeaModel):
    """
    转码接口response
    """
    def __init__(
        self,
        definition_list: List[str] = None,
        duration: int = None,
        hls_time: int = None,
    ):
        # definition_list
        self.definition_list = definition_list
        # duration
        self.duration = duration
        # hls_time
        self.hls_time = hls_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition_list is not None:
            result['definition_list'] = self.definition_list
        if self.duration is not None:
            result['duration'] = self.duration
        if self.hls_time is not None:
            result['hls_time'] = self.hls_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('definition_list') is not None:
            self.definition_list = m.get('definition_list')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('hls_time') is not None:
            self.hls_time = m.get('hls_time')
        return self


class IDPermission(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        action_list: List[ActionItem] = None,
        collection: str = None,
        condition: Condition = None,
        created_at: int = None,
        deleted: str = None,
        disinherit_sub_group: bool = None,
        domain_id: str = None,
        effect: str = None,
        expire_time: int = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
        roles: List[str] = None,
        sequence_number: int = None,
        updated_at: int = None,
        updated_by: str = None,
        user_tags: List[str] = None,
    ):
        self.action_list = action_list
        self.collection = collection
        self.condition = condition
        self.created_at = created_at
        self.deleted = deleted
        self.disinherit_sub_group = disinherit_sub_group
        self.domain_id = domain_id
        self.effect = effect
        self.expire_time = expire_time
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type
        self.roles = roles
        self.sequence_number = sequence_number
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.user_tags = user_tags

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionList'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['ActionList'].append(k.to_map() if k else None)
        if self.collection is not None:
            result['Collection'] = self.collection
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.created_at is not None:
            result['CreatedAt'] = self.created_at
        if self.deleted is not None:
            result['Deleted'] = self.deleted
        if self.disinherit_sub_group is not None:
            result['DisinheritSubGroup'] = self.disinherit_sub_group
        if self.domain_id is not None:
            result['DomainID'] = self.domain_id
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.identity_id is not None:
            result['IdentityID'] = self.identity_id
        if self.identity_type is not None:
            result['IdentityType'] = self.identity_type
        if self.resource is not None:
            result['Resource'] = self.resource
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.sequence_number is not None:
            result['SequenceNumber'] = self.sequence_number
        if self.updated_at is not None:
            result['UpdatedAt'] = self.updated_at
        if self.updated_by is not None:
            result['UpdatedBy'] = self.updated_by
        if self.user_tags is not None:
            result['UserTags'] = self.user_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_list = []
        if m.get('ActionList') is not None:
            for k in m.get('ActionList'):
                temp_model = ActionItem()
                self.action_list.append(temp_model.from_map(k))
        if m.get('Collection') is not None:
            self.collection = m.get('Collection')
        if m.get('Condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('CreatedAt') is not None:
            self.created_at = m.get('CreatedAt')
        if m.get('Deleted') is not None:
            self.deleted = m.get('Deleted')
        if m.get('DisinheritSubGroup') is not None:
            self.disinherit_sub_group = m.get('DisinheritSubGroup')
        if m.get('DomainID') is not None:
            self.domain_id = m.get('DomainID')
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('IdentityID') is not None:
            self.identity_id = m.get('IdentityID')
        if m.get('IdentityType') is not None:
            self.identity_type = m.get('IdentityType')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('SequenceNumber') is not None:
            self.sequence_number = m.get('SequenceNumber')
        if m.get('UpdatedAt') is not None:
            self.updated_at = m.get('UpdatedAt')
        if m.get('UpdatedBy') is not None:
            self.updated_by = m.get('UpdatedBy')
        if m.get('UserTags') is not None:
            self.user_tags = m.get('UserTags')
        return self


class ListAppsRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        limit: int = None,
        marker: str = None,
    ):
        # 返回结果数据
        self.limit = limit
        # 下次查询游标
        self.marker = marker

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListByAnonymousRequest(TeaModel):
    """
    list_file_by_anonymous request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        parent_file_id: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # parent_file_id
        self.parent_file_id = parent_file_id
        self.referer = referer
        # share_id
        self.share_id = share_id
        self.sign_token = sign_token
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        self.validate_required(self.share_id, 'share_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListDomainsRequest(TeaModel):
    """
    list domain request
    """
    def __init__(
        self,
        limit: int = None,
        marker: str = None,
        parent_domain_id: str = None,
    ):
        # 分页大小
        self.limit = limit
        # 查询游标
        self.marker = marker
        self.parent_domain_id = parent_domain_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        return self


class ListDriveRequest(TeaModel):
    """
    # List drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        owner: str = None,
        owner_type: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 每页大小限制
        self.limit = limit
        # 翻页标记, 接口返回的标记值
        self.marker = marker
        # 所属者
        self.owner = owner
        # owner_type
        # 所述者类型
        self.owner_type = owner_type
        # Subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListFileActivityRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_id: str = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # DriveID
        self.drive_id = drive_id
        # FileID
        self.file_id = file_id
        # Limit, default
        self.limit = limit
        # Marker
        self.marker = marker

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListFileByCustomIndexKeyRequest(TeaModel):
    """
    列举文件
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        starred: bool = None,
        addition_data: dict = None,
        category: str = None,
        custom_index_key: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        fields: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_direction: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        status: str = None,
        thumbnail_processes: dict = None,
        type: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # starred
        self.starred = starred
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # custom_index_key
        self.custom_index_key = custom_index_key
        # drive_id
        self.drive_id = drive_id
        # encrypt_mode
        self.encrypt_mode = encrypt_mode
        # fields
        self.fields = fields
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_direction
        self.order_direction = order_direction
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # status
        self.status = status
        self.thumbnail_processes = thumbnail_processes
        # type
        self.type = type
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.custom_index_key, 'custom_index_key')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.starred is not None:
            result['Starred'] = self.starred
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.custom_index_key is not None:
            result['custom_index_key'] = self.custom_index_key
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.fields is not None:
            result['fields'] = self.fields
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.type is not None:
            result['type'] = self.type
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('Starred') is not None:
            self.starred = m.get('Starred')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('custom_index_key') is not None:
            self.custom_index_key = m.get('custom_index_key')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListFileDeltaRequest(TeaModel):
    """
    获取增量文件操作记录
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cursor: str = None,
        disable_characteristic_hash: bool = None,
        drive_id: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        office_thumbnail_process: str = None,
        sync_root_id: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # cursor 游标
        self.cursor = cursor
        # disable_characteristic_hash
        # default false
        self.disable_characteristic_hash = disable_characteristic_hash
        # drive_id
        self.drive_id = drive_id
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        # default 100
        self.limit = limit
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # sync_root_id
        self.sync_root_id = sync_root_id
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cursor is not None:
            result['cursor'] = self.cursor
        if self.disable_characteristic_hash is not None:
            result['disable_characteristic_hash'] = self.disable_characteristic_hash
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.sync_root_id is not None:
            result['sync_root_id'] = self.sync_root_id
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cursor') is not None:
            self.cursor = m.get('cursor')
        if m.get('disable_characteristic_hash') is not None:
            self.disable_characteristic_hash = m.get('disable_characteristic_hash')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('sync_root_id') is not None:
            self.sync_root_id = m.get('sync_root_id')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListFileInRecycleBinRequest(TeaModel):
    """
    列举回收站
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        starred: bool = None,
        addition_data: dict = None,
        all: bool = None,
        category: str = None,
        drive_id: str = None,
        fields: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        order_direction: str = None,
        parent_file_id: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        status: str = None,
        thumbnail_processes: dict = None,
        type: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # starred
        self.starred = starred
        # addition_data
        self.addition_data = addition_data
        # all
        self.all = all
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # ParentFileID
        self.parent_file_id = parent_file_id
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # status
        self.status = status
        self.thumbnail_processes = thumbnail_processes
        # type
        self.type = type
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.starred is not None:
            result['Starred'] = self.starred
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.all is not None:
            result['all'] = self.all
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.type is not None:
            result['type'] = self.type
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('Starred') is not None:
            self.starred = m.get('Starred')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('all') is not None:
            self.all = m.get('all')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListFileInRecycleBinResponse(TeaModel):
    """
    ListFileInRecycleBinResponse
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListFileRequest(TeaModel):
    """
    列举文件
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        all: bool = None,
        category: str = None,
        drive_id: str = None,
        fields: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        location: str = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        order_direction: str = None,
        parent_file_id: str = None,
        parent_file_id_path: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        starred: bool = None,
        status: str = None,
        thumbnail_processes: dict = None,
        type: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # all
        self.all = all
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # location
        self.location = location
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # ParentFileID
        self.parent_file_id = parent_file_id
        self.parent_file_id_path = parent_file_id_path
        self.referer = referer
        # share_id, either share_id or drive_id is required
        self.share_id = share_id
        self.sign_token = sign_token
        # starred
        self.starred = starred
        # status
        self.status = status
        self.thumbnail_processes = thumbnail_processes
        # type
        self.type = type
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 0)
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9.-_]{1,50}')
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.all is not None:
            result['all'] = self.all
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.location is not None:
            result['location'] = self.location
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.parent_file_id_path is not None:
            result['parent_file_id_path'] = self.parent_file_id_path
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.starred is not None:
            result['starred'] = self.starred
        if self.status is not None:
            result['status'] = self.status
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.type is not None:
            result['type'] = self.type
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('all') is not None:
            self.all = m.get('all')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('parent_file_id_path') is not None:
            self.parent_file_id_path = m.get('parent_file_id_path')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListFileViewsRequest(TeaModel):
    """
    list file view ids
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.category = category
        self.drive_id = drive_id
        self.file_id = file_id
        # user_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ListImageAddressGroupsRequest(TeaModel):
    """
    # List image address groups request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        image_thumbnail_process: str = None,
        limit: int = None,
        marker: str = None,
        return_total_count: bool = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # 每页大小限制
        self.limit = limit
        # 翻页标记
        self.marker = marker
        # ReturnTotalCount 是否返回分组总数
        self.return_total_count = return_total_count
        # video_thumbnail_process
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListImageFaceGroupsRequest(TeaModel):
    """
    # List image face groups request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        limit: int = None,
        marker: str = None,
        remarks: str = None,
        return_total_count: bool = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # 每页大小限制
        self.limit = limit
        # 翻页标记
        self.marker = marker
        self.remarks = remarks
        # ReturnTotalCount 是否返回分组总数
        self.return_total_count = return_total_count

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.remarks is not None:
            result['remarks'] = self.remarks
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('remarks') is not None:
            self.remarks = m.get('remarks')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        return self


class ListImageTagsRequest(TeaModel):
    """
    # List image tags request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        image_thumbnail_process: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListMangeSharingFileRequest(TeaModel):
    """
    列举用户管理的共享文件列表
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        creator_list: List[str] = None,
        limit: int = None,
        marker: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 查询的用户列表，传入用户ID列表，不传默认查询所有有权限管理的共享
        self.creator_list = creator_list
        # 查询返回的记录数
        self.limit = limit
        # 上次查询返回的游标
        self.marker = marker
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.limit, 'limit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.creator_list is not None:
            result['creator_list'] = self.creator_list
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('creator_list') is not None:
            self.creator_list = m.get('creator_list')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListMyDriveRequest(TeaModel):
    """
    # List my drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # 每页大小限制
        self.limit = limit
        # 翻页标记, 接口返回的标记值
        self.marker = marker

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListReceivedFileRequest(TeaModel):
    """
    列举当前用户收到的共享文件列表
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 查询返回的记录数
        self.limit = limit
        # 上次查询返回的游标
        self.marker = marker
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.limit, 'limit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListRevisionRequest(TeaModel):
    """
    列举版本
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        fields: str = None,
        file_id: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        location: str = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        query: str = None,
        referer: str = None,
        sign_token: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        # file_id
        self.file_id = file_id
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # location
        self.location = location
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # query
        self.query = query
        self.referer = referer
        self.sign_token = sign_token
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.location is not None:
            result['location'] = self.location
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.query is not None:
            result['query'] = self.query
        if self.referer is not None:
            result['referer'] = self.referer
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class ListShareLinkRequest(TeaModel):
    """
    list_share_link request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        creator: str = None,
        include_cancelled: bool = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        order_direction: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # creator
        self.creator = creator
        # include_cancelled
        self.include_cancelled = include_cancelled
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # view_id
        self.view_id = view_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.creator is not None:
            result['creator'] = self.creator
        if self.include_cancelled is not None:
            result['include_cancelled'] = self.include_cancelled
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('include_cancelled') is not None:
            self.include_cancelled = m.get('include_cancelled')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class ListShareRequest(TeaModel):
    """
    list share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        creator: str = None,
        drive_id: str = None,
        limit: int = None,
        marker: str = None,
        owner: str = None,
        owner_type: str = None,
        share_file_path: str = None,
    ):
        self.httpheaders = httpheaders
        # creator
        self.creator = creator
        self.drive_id = drive_id
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # Owner
        self.owner = owner
        # owner_type
        self.owner_type = owner_type
        # share_file_path
        self.share_file_path = share_file_path

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.creator is not None:
            result['creator'] = self.creator
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.share_file_path is not None:
            result['share_file_path'] = self.share_file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('share_file_path') is not None:
            self.share_file_path = m.get('share_file_path')
        return self


class ListSharingFileRequest(TeaModel):
    """
    列举当前用户共享的文件列表
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 查询返回的记录数
        self.limit = limit
        # 上次查询返回的游标
        self.marker = marker
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.limit, 'limit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListStoreFileRequest(TeaModel):
    """
    list store file
    """
    def __init__(
        self,
        limit: int = None,
        marker: str = None,
        parent_file_path: str = None,
        store_id: str = None,
        type: str = None,
    ):
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # parent_file_path
        self.parent_file_path = parent_file_path
        # store_id
        self.store_id = store_id
        # type
        self.type = type

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 1000)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class StoreFile(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        name: str = None,
        parent_file_path: str = None,
        store_id: str = None,
        type: str = None,
    ):
        self.domain_id = domain_id
        self.name = name
        self.parent_file_path = parent_file_path
        self.store_id = store_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.name is not None:
            result['name'] = self.name
        if self.parent_file_path is not None:
            result['parent_file_path'] = self.parent_file_path
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_file_path') is not None:
            self.parent_file_path = m.get('parent_file_path')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListStoreFileResponse(TeaModel):
    """
    List storage file
    """
    def __init__(
        self,
        items: List[StoreFile] = None,
        next_marker: str = None,
    ):
        # items
        # file list
        self.items = items
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = StoreFile()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListStoreRequest(TeaModel):
    """
    list storage file
    """
    def __init__(
        self,
        domain_id: str = None,
    ):
        # domain_id
        self.domain_id = domain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class StoreItemResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        accelerate_endpoint: str = None,
        base_path: str = None,
        bucket: str = None,
        cdn_endpoint: str = None,
        cdn_ratelimit_disable: bool = None,
        cdn_timelimit: str = None,
        cdn_url_auth_key: str = None,
        customized_accelerate_endpoint: str = None,
        customized_cdn_endpoint: str = None,
        customized_endpoint: str = None,
        customized_internal_endpoint: str = None,
        domain_id: str = None,
        endpoint: str = None,
        enet_endpoint: str = None,
        enet_percent_config: WhitePercentConfig = None,
        internal_endpoint: str = None,
        location: str = None,
        ownership: str = None,
        policy: str = None,
        role_arn: str = None,
        store_id: str = None,
        type: str = None,
    ):
        # 全球加速地址
        self.accelerate_endpoint = accelerate_endpoint
        # 存储公共前缀
        self.base_path = base_path
        # bucket名称
        self.bucket = bucket
        # 内容分发地址
        self.cdn_endpoint = cdn_endpoint
        # 命中限速用户时是否关闭CDN地址返回
        self.cdn_ratelimit_disable = cdn_ratelimit_disable
        # CDN时间控制
        self.cdn_timelimit = cdn_timelimit
        # CDN鉴权key
        self.cdn_url_auth_key = cdn_url_auth_key
        # 自定义全球加速地址
        self.customized_accelerate_endpoint = customized_accelerate_endpoint
        # 自定义内容分发地址
        self.customized_cdn_endpoint = customized_cdn_endpoint
        # 自定义Public访问地址
        self.customized_endpoint = customized_endpoint
        # 自定义vpc访问地址
        self.customized_internal_endpoint = customized_internal_endpoint
        self.domain_id = domain_id
        # Public访问地址
        self.endpoint = endpoint
        # 冷流地址
        self.enet_endpoint = enet_endpoint
        self.enet_percent_config = enet_percent_config
        # vpc访问地址
        self.internal_endpoint = internal_endpoint
        # 地点
        self.location = location
        # 存储归属，system表示系统提供，custom表示使用自己的存储
        self.ownership = ownership
        # Policy授权,system类型store会将bucket权限授予当前云账号
        self.policy = policy
        # 访问Bucket的角色ARN
        self.role_arn = role_arn
        # store ID
        self.store_id = store_id
        # 存储类型，当前只支持oss
        self.type = type

    def validate(self):
        self.validate_required(self.bucket, 'bucket')
        self.validate_required(self.endpoint, 'endpoint')
        if self.enet_percent_config:
            self.enet_percent_config.validate()
        self.validate_required(self.ownership, 'ownership')
        self.validate_required(self.policy, 'policy')
        self.validate_required(self.store_id, 'store_id')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accelerate_endpoint is not None:
            result['accelerate_endpoint'] = self.accelerate_endpoint
        if self.base_path is not None:
            result['base_path'] = self.base_path
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.cdn_endpoint is not None:
            result['cdn_endpoint'] = self.cdn_endpoint
        if self.cdn_ratelimit_disable is not None:
            result['cdn_ratelimit_disable'] = self.cdn_ratelimit_disable
        if self.cdn_timelimit is not None:
            result['cdn_timelimit'] = self.cdn_timelimit
        if self.cdn_url_auth_key is not None:
            result['cdn_url_auth_key'] = self.cdn_url_auth_key
        if self.customized_accelerate_endpoint is not None:
            result['customized_accelerate_endpoint'] = self.customized_accelerate_endpoint
        if self.customized_cdn_endpoint is not None:
            result['customized_cdn_endpoint'] = self.customized_cdn_endpoint
        if self.customized_endpoint is not None:
            result['customized_endpoint'] = self.customized_endpoint
        if self.customized_internal_endpoint is not None:
            result['customized_internal_endpoint'] = self.customized_internal_endpoint
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.enet_endpoint is not None:
            result['enet_endpoint'] = self.enet_endpoint
        if self.enet_percent_config is not None:
            result['enet_percent_config'] = self.enet_percent_config.to_map()
        if self.internal_endpoint is not None:
            result['internal_endpoint'] = self.internal_endpoint
        if self.location is not None:
            result['location'] = self.location
        if self.ownership is not None:
            result['ownership'] = self.ownership
        if self.policy is not None:
            result['policy'] = self.policy
        if self.role_arn is not None:
            result['role_arn'] = self.role_arn
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accelerate_endpoint') is not None:
            self.accelerate_endpoint = m.get('accelerate_endpoint')
        if m.get('base_path') is not None:
            self.base_path = m.get('base_path')
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('cdn_endpoint') is not None:
            self.cdn_endpoint = m.get('cdn_endpoint')
        if m.get('cdn_ratelimit_disable') is not None:
            self.cdn_ratelimit_disable = m.get('cdn_ratelimit_disable')
        if m.get('cdn_timelimit') is not None:
            self.cdn_timelimit = m.get('cdn_timelimit')
        if m.get('cdn_url_auth_key') is not None:
            self.cdn_url_auth_key = m.get('cdn_url_auth_key')
        if m.get('customized_accelerate_endpoint') is not None:
            self.customized_accelerate_endpoint = m.get('customized_accelerate_endpoint')
        if m.get('customized_cdn_endpoint') is not None:
            self.customized_cdn_endpoint = m.get('customized_cdn_endpoint')
        if m.get('customized_endpoint') is not None:
            self.customized_endpoint = m.get('customized_endpoint')
        if m.get('customized_internal_endpoint') is not None:
            self.customized_internal_endpoint = m.get('customized_internal_endpoint')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('enet_endpoint') is not None:
            self.enet_endpoint = m.get('enet_endpoint')
        if m.get('enet_percent_config') is not None:
            temp_model = WhitePercentConfig()
            self.enet_percent_config = temp_model.from_map(m['enet_percent_config'])
        if m.get('internal_endpoint') is not None:
            self.internal_endpoint = m.get('internal_endpoint')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('ownership') is not None:
            self.ownership = m.get('ownership')
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        if m.get('role_arn') is not None:
            self.role_arn = m.get('role_arn')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListStoreResponse(TeaModel):
    """
    List storage
    """
    def __init__(
        self,
        items: List[StoreItemResponse] = None,
    ):
        # items
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = StoreItemResponse()
                self.items.append(temp_model.from_map(k))
        return self


class ListStoresRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
    ):
        # domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class ListUploadedPartRequest(TeaModel):
    """
    列举uploadID对应的已上传分片
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        limit: int = None,
        part_number_marker: int = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # limit
        self.limit = limit
        # part_number_marker
        self.part_number_marker = part_number_marker
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 1000)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.part_number_marker is not None:
            self.validate_minimum(self.part_number_marker, 'part_number_marker', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.limit is not None:
            result['limit'] = self.limit
        if self.part_number_marker is not None:
            result['part_number_marker'] = self.part_number_marker
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('part_number_marker') is not None:
            self.part_number_marker = m.get('part_number_marker')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class ListViewFilesRequest(TeaModel):
    """
    list view file
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        fields: str = None,
        filter: str = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        order_direction: str = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        user_id: str = None,
        video_thumbnail_process: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        self.fields = fields
        self.filter = filter
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        self.limit = limit
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.order_by = order_by
        self.order_direction = order_direction
        self.thumbnail_processes = thumbnail_processes
        self.url_expire_sec = url_expire_sec
        # user_id
        self.user_id = user_id
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.fields is not None:
            result['fields'] = self.fields
        if self.filter is not None:
            result['filter'] = self.filter
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class ListViewsRequest(TeaModel):
    """
    List views request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        order_direction: str = None,
        owner: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # 每页大小限制
        self.limit = limit
        # marker
        self.marker = marker
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # owner
        self.owner = owner
        # user_id
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.category, 'category')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)
        self.validate_required(self.owner, 'owner')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.owner is not None:
            result['owner'] = self.owner
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class LoginByCodeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        access_token: str = None,
        app_id: str = None,
        auth_code: str = None,
        type: str = None,
    ):
        # 鉴权后返回的accessToken，淘宝登录需要此字段
        self.access_token = access_token
        # App ID, 当前访问的App
        self.app_id = app_id
        # 鉴权后返回的AuthCode，支付宝登录需要此字段
        self.auth_code = auth_code
        # 鉴权类型，淘宝、支付宝
        self.type = type

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['access_token'] = self.access_token
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.auth_code is not None:
            result['auth_code'] = self.auth_code
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_token') is not None:
            self.access_token = m.get('access_token')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('auth_code') is not None:
            self.auth_code = m.get('auth_code')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class LoginRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        auto_register: bool = None,
        captcha_id: str = None,
        captcha_text: str = None,
        email: str = None,
        encrypted_key: str = None,
        nvc_param: str = None,
        password: str = None,
        phone_number: str = None,
        phone_region: str = None,
        sms_code: str = None,
        sms_code_id: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # 是否自动注册用户，使用密码登录此参数不生效
        self.auto_register = auto_register
        # 图片验证码ID, 密码登录需要此参数
        self.captcha_id = captcha_id
        # 用户输入的验证码值, 密码登录需要此参数
        self.captcha_text = captcha_text
        # 邮箱
        self.email = email
        # AES-256对称加密密钥，通过App公钥加密后传输
        self.encrypted_key = encrypted_key
        # 环境参数
        self.nvc_param = nvc_param
        # 登录密码, 传入此参数则忽略短信验证码，不传此参数则默认使用短信登录。
        self.password = password
        # 待发送验证短信的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region
        # 短信验证码内容，使用密码登录此参数不生效
        self.sms_code = sms_code
        # 短信验证码ID，使用密码登录此参数不生效
        self.sms_code_id = sms_code_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.nvc_param, 'nvc_param')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.auto_register is not None:
            result['auto_register'] = self.auto_register
        if self.captcha_id is not None:
            result['captcha_id'] = self.captcha_id
        if self.captcha_text is not None:
            result['captcha_text'] = self.captcha_text
        if self.email is not None:
            result['email'] = self.email
        if self.encrypted_key is not None:
            result['encrypted_key'] = self.encrypted_key
        if self.nvc_param is not None:
            result['nvc_param'] = self.nvc_param
        if self.password is not None:
            result['password'] = self.password
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.sms_code is not None:
            result['sms_code'] = self.sms_code
        if self.sms_code_id is not None:
            result['sms_code_id'] = self.sms_code_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('auto_register') is not None:
            self.auto_register = m.get('auto_register')
        if m.get('captcha_id') is not None:
            self.captcha_id = m.get('captcha_id')
        if m.get('captcha_text') is not None:
            self.captcha_text = m.get('captcha_text')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('encrypted_key') is not None:
            self.encrypted_key = m.get('encrypted_key')
        if m.get('nvc_param') is not None:
            self.nvc_param = m.get('nvc_param')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('sms_code') is not None:
            self.sms_code = m.get('sms_code')
        if m.get('sms_code_id') is not None:
            self.sms_code_id = m.get('sms_code_id')
        return self


class LogoutRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        back_url: str = None,
        client_id: str = None,
        login_type: str = None,
    ):
        # 登出之后的跳转地址，默认跳转到App的域名下
        self.back_url = back_url
        # Client ID, 此处填写创建App时返回的AppID
        self.client_id = client_id
        # 用户自定义字段，会在鉴权成功后的callback带回
        self.login_type = login_type

    def validate(self):
        self.validate_required(self.client_id, 'client_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.back_url is not None:
            result['BackUrl'] = self.back_url
        if self.client_id is not None:
            result['ClientID'] = self.client_id
        if self.login_type is not None:
            result['LoginType'] = self.login_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackUrl') is not None:
            self.back_url = m.get('BackUrl')
        if m.get('ClientID') is not None:
            self.client_id = m.get('ClientID')
        if m.get('LoginType') is not None:
            self.login_type = m.get('LoginType')
        return self


class MergeFaceGroupRequest(TeaModel):
    """
    # Merge face group request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        from_group_id: str = None,
        from_group_ids: List[str] = None,
        to_group_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # from_group_id
        self.from_group_id = from_group_id
        # from_group_ids
        self.from_group_ids = from_group_ids
        # to_group_id
        self.to_group_id = to_group_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.from_group_ids, 'from_group_ids')
        self.validate_required(self.to_group_id, 'to_group_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.from_group_id is not None:
            result['from_group_id'] = self.from_group_id
        if self.from_group_ids is not None:
            result['from_group_ids'] = self.from_group_ids
        if self.to_group_id is not None:
            result['to_group_id'] = self.to_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('from_group_id') is not None:
            self.from_group_id = m.get('from_group_id')
        if m.get('from_group_ids') is not None:
            self.from_group_ids = m.get('from_group_ids')
        if m.get('to_group_id') is not None:
            self.to_group_id = m.get('to_group_id')
        return self


class MoveFileRequest(TeaModel):
    """
    文件移动请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        auto_rename: bool = None,
        category_list: List[str] = None,
        check_name_mode: str = None,
        drive_id: str = None,
        file_id: str = None,
        file_id_path: str = None,
        new_name: str = None,
        share_id: str = None,
        to_drive_id: str = None,
        to_parent_file_id: str = None,
        to_share_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.auto_rename = auto_rename
        self.category_list = category_list
        # check_name_mode
        self.check_name_mode = check_name_mode
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # new_name
        self.new_name = new_name
        self.share_id = share_id
        # to_drive_id
        self.to_drive_id = to_drive_id
        # to_parent_file_id
        self.to_parent_file_id = to_parent_file_id
        self.to_share_id = to_share_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.new_name is not None:
            self.validate_max_length(self.new_name, 'new_name', 1024)
        if self.to_drive_id is not None:
            self.validate_pattern(self.to_drive_id, 'to_drive_id', '[0-9]+')
        self.validate_required(self.to_parent_file_id, 'to_parent_file_id')
        if self.to_parent_file_id is not None:
            self.validate_max_length(self.to_parent_file_id, 'to_parent_file_id', 50)
        if self.to_share_id is not None:
            self.validate_pattern(self.to_share_id, 'to_share_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.auto_rename is not None:
            result['auto_rename'] = self.auto_rename
        if self.category_list is not None:
            result['category_list'] = self.category_list
        if self.check_name_mode is not None:
            result['check_name_mode'] = self.check_name_mode
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.new_name is not None:
            result['new_name'] = self.new_name
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.to_drive_id is not None:
            result['to_drive_id'] = self.to_drive_id
        if self.to_parent_file_id is not None:
            result['to_parent_file_id'] = self.to_parent_file_id
        if self.to_share_id is not None:
            result['to_share_id'] = self.to_share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('auto_rename') is not None:
            self.auto_rename = m.get('auto_rename')
        if m.get('category_list') is not None:
            self.category_list = m.get('category_list')
        if m.get('check_name_mode') is not None:
            self.check_name_mode = m.get('check_name_mode')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('new_name') is not None:
            self.new_name = m.get('new_name')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('to_drive_id') is not None:
            self.to_drive_id = m.get('to_drive_id')
        if m.get('to_parent_file_id') is not None:
            self.to_parent_file_id = m.get('to_parent_file_id')
        if m.get('to_share_id') is not None:
            self.to_share_id = m.get('to_share_id')
        return self


class NameCheckResult(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        exist_file_id: str = None,
        exist_file_type: str = None,
    ):
        self.exist_file_id = exist_file_id
        self.exist_file_type = exist_file_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exist_file_id is not None:
            result['exist_file_id'] = self.exist_file_id
        if self.exist_file_type is not None:
            result['exist_file_type'] = self.exist_file_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('exist_file_id') is not None:
            self.exist_file_id = m.get('exist_file_id')
        if m.get('exist_file_type') is not None:
            self.exist_file_type = m.get('exist_file_type')
        return self


class ParseKeywordsRequest(TeaModel):
    """
    # Parse keywords request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        keywords: str = None,
    ):
        self.httpheaders = httpheaders
        self.keywords = keywords

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.keywords is not None:
            result['keywords'] = self.keywords
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        return self


class Permission(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        action_list: List[ActionItem] = None,
        collection: str = None,
        condition: Condition = None,
        created_at: int = None,
        deleted: str = None,
        domain_id: str = None,
        effect: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
        sequence_number: int = None,
        updated_at: int = None,
        updated_by: str = None,
        user_tags: List[str] = None,
    ):
        self.action_list = action_list
        self.collection = collection
        self.condition = condition
        self.created_at = created_at
        self.deleted = deleted
        self.domain_id = domain_id
        self.effect = effect
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type
        self.sequence_number = sequence_number
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.user_tags = user_tags

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActionList'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['ActionList'].append(k.to_map() if k else None)
        if self.collection is not None:
            result['Collection'] = self.collection
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.created_at is not None:
            result['CreatedAt'] = self.created_at
        if self.deleted is not None:
            result['Deleted'] = self.deleted
        if self.domain_id is not None:
            result['DomainID'] = self.domain_id
        if self.effect is not None:
            result['Effect'] = self.effect
        if self.identity_id is not None:
            result['IdentityID'] = self.identity_id
        if self.identity_type is not None:
            result['IdentityType'] = self.identity_type
        if self.resource is not None:
            result['Resource'] = self.resource
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.sequence_number is not None:
            result['SequenceNumber'] = self.sequence_number
        if self.updated_at is not None:
            result['UpdatedAt'] = self.updated_at
        if self.updated_by is not None:
            result['UpdatedBy'] = self.updated_by
        if self.user_tags is not None:
            result['UserTags'] = self.user_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.action_list = []
        if m.get('ActionList') is not None:
            for k in m.get('ActionList'):
                temp_model = ActionItem()
                self.action_list.append(temp_model.from_map(k))
        if m.get('Collection') is not None:
            self.collection = m.get('Collection')
        if m.get('Condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('CreatedAt') is not None:
            self.created_at = m.get('CreatedAt')
        if m.get('Deleted') is not None:
            self.deleted = m.get('Deleted')
        if m.get('DomainID') is not None:
            self.domain_id = m.get('DomainID')
        if m.get('Effect') is not None:
            self.effect = m.get('Effect')
        if m.get('IdentityID') is not None:
            self.identity_id = m.get('IdentityID')
        if m.get('IdentityType') is not None:
            self.identity_type = m.get('IdentityType')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SequenceNumber') is not None:
            self.sequence_number = m.get('SequenceNumber')
        if m.get('UpdatedAt') is not None:
            self.updated_at = m.get('UpdatedAt')
        if m.get('UpdatedBy') is not None:
            self.updated_by = m.get('UpdatedBy')
        if m.get('UserTags') is not None:
            self.user_tags = m.get('UserTags')
        return self


class PlayMediaRequest(TeaModel):
    """
    play_media request
    """
    def __init__(
        self,
        auth_key: str = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        # auth_key
        self.auth_key = auth_key
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        self.validate_required(self.auth_key, 'auth_key')
        if self.auth_key is not None:
            self.validate_pattern(self.auth_key, 'auth_key', '[a-z0-9]+')
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.drive_id is not None:
            result['DriveID'] = self.drive_id
        if self.file_id is not None:
            result['FileID'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('DriveID') is not None:
            self.drive_id = m.get('DriveID')
        if m.get('FileID') is not None:
            self.file_id = m.get('FileID')
        return self


class PreCreateCheckResponse(TeaModel):
    """
    Pre_create_check response
    """
    def __init__(
        self,
        name_check_result: NameCheckResult = None,
        result_code: str = None,
    ):
        self.name_check_result = name_check_result
        # result_code
        self.result_code = result_code

    def validate(self):
        if self.name_check_result:
            self.name_check_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_check_result is not None:
            result['name_check_result'] = self.name_check_result.to_map()
        if self.result_code is not None:
            result['result_code'] = self.result_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name_check_result') is not None:
            temp_model = NameCheckResult()
            self.name_check_result = temp_model.from_map(m['name_check_result'])
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        return self


class PreHashCheckSuccessResponse(TeaModel):
    """
    Pre hash check Response
    """
    def __init__(
        self,
        code: str = None,
        file_name: str = None,
        message: str = None,
        parent_file_id: str = None,
        pre_hash: str = None,
    ):
        # code
        self.code = code
        # file_name
        self.file_name = file_name
        # message
        self.message = message
        # parent_file_id
        self.parent_file_id = parent_file_id
        # pre_hash
        self.pre_hash = pre_hash

    def validate(self):
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.message is not None:
            result['message'] = self.message
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.pre_hash is not None:
            result['pre_hash'] = self.pre_hash
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('pre_hash') is not None:
            self.pre_hash = m.get('pre_hash')
        return self


class PutFileUserTagsRequest(TeaModel):
    """
    更新文件 user_tags 字段
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_id: str = None,
        user_tags: List[UserTag] = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # user_tags
        self.user_tags = user_tags

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.user_tags:
            for k in self.user_tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        result['user_tags'] = []
        if self.user_tags is not None:
            for k in self.user_tags:
                result['user_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        self.user_tags = []
        if m.get('user_tags') is not None:
            for k in m.get('user_tags'):
                temp_model = UserTag()
                self.user_tags.append(temp_model.from_map(k))
        return self


class QueryLocationDateClustersRequest(TeaModel):
    """
    query locationCluster request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        address: Address = None,
        cluster_id: str = None,
        create_time_range: QueryRequestTimeRange = None,
        custom_labels: str = None,
        drive_id: str = None,
        end_time_range: QueryRequestTimeRange = None,
        levels: List[str] = None,
        limit: int = None,
        marker: str = None,
        order: str = None,
        sort: str = None,
        start_time_range: QueryRequestTimeRange = None,
        title: str = None,
        update_time_range: QueryRequestTimeRange = None,
    ):
        self.httpheaders = httpheaders
        self.address = address
        self.cluster_id = cluster_id
        self.create_time_range = create_time_range
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        self.end_time_range = end_time_range
        self.levels = levels
        self.limit = limit
        self.marker = marker
        self.order = order
        self.sort = sort
        self.start_time_range = start_time_range
        self.title = title
        self.update_time_range = update_time_range

    def validate(self):
        if self.address:
            self.address.validate()
        if self.create_time_range:
            self.create_time_range.validate()
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.end_time_range:
            self.end_time_range.validate()
        if self.start_time_range:
            self.start_time_range.validate()
        if self.update_time_range:
            self.update_time_range.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.address is not None:
            result['address'] = self.address.to_map()
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.create_time_range is not None:
            result['create_time_range'] = self.create_time_range.to_map()
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.end_time_range is not None:
            result['end_time_range'] = self.end_time_range.to_map()
        if self.levels is not None:
            result['levels'] = self.levels
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order is not None:
            result['order'] = self.order
        if self.sort is not None:
            result['sort'] = self.sort
        if self.start_time_range is not None:
            result['start_time_range'] = self.start_time_range.to_map()
        if self.title is not None:
            result['title'] = self.title
        if self.update_time_range is not None:
            result['update_time_range'] = self.update_time_range.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('address') is not None:
            temp_model = Address()
            self.address = temp_model.from_map(m['address'])
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('create_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.create_time_range = temp_model.from_map(m['create_time_range'])
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('end_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.end_time_range = temp_model.from_map(m['end_time_range'])
        if m.get('levels') is not None:
            self.levels = m.get('levels')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('start_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.start_time_range = temp_model.from_map(m['start_time_range'])
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('update_time_range') is not None:
            temp_model = QueryRequestTimeRange()
            self.update_time_range = temp_model.from_map(m['update_time_range'])
        return self


class QuerySimilarImageClusterRequest(TeaModel):
    """
    query similar image clusters request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        image_thumbnail_process: str = None,
        limit: int = None,
        marker: str = None,
        order: str = None,
        thumbnail_processes: dict = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        self.image_thumbnail_process = image_thumbnail_process
        self.limit = limit
        self.marker = marker
        self.order = order
        self.thumbnail_processes = thumbnail_processes

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order is not None:
            result['order'] = self.order
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        return self


class RPVerifyBaseRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        user_id: str = None,
    ):
        # User ID, 当前访问的用户
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class VerifyTokenResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        token: str = None,
        ttl: int = None,
        url: str = None,
    ):
        # 实人认证的Token
        self.token = token
        # 实人认证token有效秒数，如1800
        self.ttl = ttl
        # 实人认证的URL，包含Token
        self.url = url

    def validate(self):
        self.validate_required(self.token, 'token')
        self.validate_required(self.ttl, 'ttl')
        self.validate_required(self.url, 'url')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.token is not None:
            result['token'] = self.token
        if self.ttl is not None:
            result['ttl'] = self.ttl
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('ttl') is not None:
            self.ttl = m.get('ttl')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class RPVerifyTokenResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        need_rp_verify: bool = None,
        verify_token: VerifyTokenResponse = None,
    ):
        # 是否需要实人认证，如果用户已通过认证，或者未开启实人认证，返回false
        self.need_rp_verify = need_rp_verify
        self.verify_token = verify_token

    def validate(self):
        self.validate_required(self.need_rp_verify, 'need_rp_verify')
        self.validate_required(self.verify_token, 'verify_token')
        if self.verify_token:
            self.verify_token.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.need_rp_verify is not None:
            result['need_rp_verify'] = self.need_rp_verify
        if self.verify_token is not None:
            result['verify_token'] = self.verify_token.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('need_rp_verify') is not None:
            self.need_rp_verify = m.get('need_rp_verify')
        if m.get('verify_token') is not None:
            temp_model = VerifyTokenResponse()
            self.verify_token = temp_model.from_map(m['verify_token'])
        return self


class RateLimit(TeaModel):
    """
    下载限速配置
    """
    def __init__(
        self,
        part_size: int = None,
        part_speed: int = None,
    ):
        self.part_size = part_size
        self.part_speed = part_speed

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.part_size is not None:
            result['part_size'] = self.part_size
        if self.part_speed is not None:
            result['part_speed'] = self.part_speed
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('part_size') is not None:
            self.part_size = m.get('part_size')
        if m.get('part_speed') is not None:
            self.part_speed = m.get('part_speed')
        return self


class RefreshOfficeEditTokenRequest(TeaModel):
    """
    刷新office文档在线编辑凭证
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        location: str = None,
        office_access_token: str = None,
        office_refresh_token: str = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # location
        self.location = location
        # AccessToken
        self.office_access_token = office_access_token
        # RefreshToken
        self.office_refresh_token = office_refresh_token
        # share_id
        # example
        self.share_id = share_id

    def validate(self):
        self.validate_required(self.office_access_token, 'office_access_token')
        self.validate_required(self.office_refresh_token, 'office_refresh_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.location is not None:
            result['location'] = self.location
        if self.office_access_token is not None:
            result['office_access_token'] = self.office_access_token
        if self.office_refresh_token is not None:
            result['office_refresh_token'] = self.office_refresh_token
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('office_access_token') is not None:
            self.office_access_token = m.get('office_access_token')
        if m.get('office_refresh_token') is not None:
            self.office_refresh_token = m.get('office_refresh_token')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class RegisterRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        email: str = None,
        nvc_param: str = None,
        phone_number: str = None,
        phone_region: str = None,
        sms_code: str = None,
        sms_code_id: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # 邮箱
        self.email = email
        # 环境参数
        self.nvc_param = nvc_param
        # 待发送验证短信的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region
        # 短信验证码内容
        self.sms_code = sms_code
        # 短信验证码ID
        self.sms_code_id = sms_code_id

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.nvc_param, 'nvc_param')
        self.validate_required(self.sms_code, 'sms_code')
        self.validate_required(self.sms_code_id, 'sms_code_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.email is not None:
            result['email'] = self.email
        if self.nvc_param is not None:
            result['nvc_param'] = self.nvc_param
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.sms_code is not None:
            result['sms_code'] = self.sms_code
        if self.sms_code_id is not None:
            result['sms_code_id'] = self.sms_code_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('nvc_param') is not None:
            self.nvc_param = m.get('nvc_param')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('sms_code') is not None:
            self.sms_code = m.get('sms_code')
        if m.get('sms_code_id') is not None:
            self.sms_code_id = m.get('sms_code_id')
        return self


class RemoveStoreRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        store_id: str = None,
    ):
        # domain ID
        self.domain_id = domain_id
        # store ID
        self.store_id = store_id

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.store_id, 'store_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.store_id is not None:
            result['store_id'] = self.store_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        return self


class RemoveStoryFilesRequest(TeaModel):
    """
    remove story files request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        files: List[StoryFile] = None,
        story_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        self.files = files
        # story_id
        self.story_id = story_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.files:
            for k in self.files:
                if k:
                    k.validate()
        self.validate_required(self.story_id, 'story_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        result['files'] = []
        if self.files is not None:
            for k in self.files:
                result['files'].append(k.to_map() if k else None)
        if self.story_id is not None:
            result['story_id'] = self.story_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        self.files = []
        if m.get('files') is not None:
            for k in m.get('files'):
                temp_model = StoryFile()
                self.files.append(temp_model.from_map(k))
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        return self


class RemoveViewFileRequest(TeaModel):
    """
    remove file from view
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        drive_id: str = None,
        file_id: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        self.drive_id = drive_id
        self.file_id = file_id
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class ReportMediaPlayEventRequest(TeaModel):
    """
    report_media_play_event request
    """
    def __init__(
        self,
        duration: int = None,
        error: str = None,
        file_id: str = None,
        player_version: str = None,
        sub_type: str = None,
        template_id: str = None,
        wait_count: int = None,
    ):
        # duration
        self.duration = duration
        # error
        self.error = error
        # file_id
        self.file_id = file_id
        # player_version
        self.player_version = player_version
        # sub_type
        self.sub_type = sub_type
        # template_id
        self.template_id = template_id
        # wait_count
        self.wait_count = wait_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.error is not None:
            result['error'] = self.error
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.player_version is not None:
            result['player_version'] = self.player_version
        if self.sub_type is not None:
            result['sub_type'] = self.sub_type
        if self.template_id is not None:
            result['template_id'] = self.template_id
        if self.wait_count is not None:
            result['wait_count'] = self.wait_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('error') is not None:
            self.error = m.get('error')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('player_version') is not None:
            self.player_version = m.get('player_version')
        if m.get('sub_type') is not None:
            self.sub_type = m.get('sub_type')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        if m.get('wait_count') is not None:
            self.wait_count = m.get('wait_count')
        return self


class ReportShareLinkEventRequest(TeaModel):
    """
    report_share_link_event request
    """
    def __init__(
        self,
        share_id: str = None,
        sub_type: str = None,
    ):
        # share_id
        self.share_id = share_id
        # sub_type
        self.sub_type = sub_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sub_type is not None:
            result['sub_type'] = self.sub_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sub_type') is not None:
            self.sub_type = m.get('sub_type')
        return self


class ReportShareLinkAccessEventRequest(TeaModel):
    """
    report_share_link_access_event request
    """
    def __init__(
        self,
        share_id: str = None,
        sub_type: str = None,
    ):
        # share_id
        self.share_id = share_id
        # sub_type
        self.sub_type = sub_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sub_type is not None:
            result['sub_type'] = self.sub_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sub_type') is not None:
            self.sub_type = m.get('sub_type')
        return self


class ReportEventRequest(TeaModel):
    """
    report_event request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        event_type: str = None,
        media_play: ReportMediaPlayEventRequest = None,
        share_link: ReportShareLinkEventRequest = None,
        share_link_access: ReportShareLinkAccessEventRequest = None,
    ):
        self.httpheaders = httpheaders
        # event_type
        self.event_type = event_type
        self.media_play = media_play
        self.share_link = share_link
        self.share_link_access = share_link_access

    def validate(self):
        if self.media_play:
            self.media_play.validate()
        if self.share_link:
            self.share_link.validate()
        if self.share_link_access:
            self.share_link_access.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.event_type is not None:
            result['event_type'] = self.event_type
        if self.media_play is not None:
            result['media_play'] = self.media_play.to_map()
        if self.share_link is not None:
            result['share_link'] = self.share_link.to_map()
        if self.share_link_access is not None:
            result['share_link_access'] = self.share_link_access.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('event_type') is not None:
            self.event_type = m.get('event_type')
        if m.get('media_play') is not None:
            temp_model = ReportMediaPlayEventRequest()
            self.media_play = temp_model.from_map(m['media_play'])
        if m.get('share_link') is not None:
            temp_model = ReportShareLinkEventRequest()
            self.share_link = temp_model.from_map(m['share_link'])
        if m.get('share_link_access') is not None:
            temp_model = ReportShareLinkAccessEventRequest()
            self.share_link_access = temp_model.from_map(m['share_link_access'])
        return self


class RestoreFileRequest(TeaModel):
    """
    恢复文件请求，支持批量
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        return self


class RestoreRevisionRequest(TeaModel):
    """
    还原历史版本元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        file_id: str = None,
        revision_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # revision_id
        self.revision_id = revision_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        self.validate_required(self.revision_id, 'revision_id')
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        return self


class RevokeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        refresh_token: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # refresh token, 登录时返回的
        self.refresh_token = refresh_token

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.refresh_token, 'refresh_token')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.refresh_token is not None:
            result['refresh_token'] = self.refresh_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('refresh_token') is not None:
            self.refresh_token = m.get('refresh_token')
        return self


class ScanFileMetaRequest(TeaModel):
    """
    全量获取file元信息的请求body
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        drive_id: str = None,
        fields: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # category
        self.category = category
        # drive_id
        self.drive_id = drive_id
        # fields
        self.fields = fields
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 5000)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fields is not None:
            result['fields'] = self.fields
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class SearchDomainsRequest(TeaModel):
    """
    search domain request
    """
    def __init__(
        self,
        instance_id: str = None,
        limit: int = None,
        marker: str = None,
        name: str = None,
        order_by: str = None,
        service_code: str = None,
    ):
        # 通过购买的实例ID搜索domain
        self.instance_id = instance_id
        # 分页大小
        self.limit = limit
        # 查询游标
        self.marker = marker
        # domain名称，模糊匹配
        self.name = name
        # 排序规则
        self.order_by = order_by
        # 通过不同ServiceCode搜索
        self.service_code = service_code

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['instance_id'] = self.instance_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.name is not None:
            result['name'] = self.name
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.service_code is not None:
            result['service_code'] = self.service_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('instance_id') is not None:
            self.instance_id = m.get('instance_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('service_code') is not None:
            self.service_code = m.get('service_code')
        return self


class SearchDriveRequest(TeaModel):
    """
    # Search drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        drive_name: str = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        order_direction: str = None,
        owner: str = None,
        owner_type: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.category = category
        # Drive Fuzz Name
        self.drive_name = drive_name
        # 每页大小限制
        self.limit = limit
        # 翻页标记, 接口返回的标记值
        self.marker = marker
        self.order_by = order_by
        self.order_direction = order_direction
        # 所属者
        self.owner = owner
        # owner_type
        # 所述者类型
        self.owner_type = owner_type
        # Subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.owner is not None:
            result['owner'] = self.owner
        if self.owner_type is not None:
            result['owner_type'] = self.owner_type
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('owner_type') is not None:
            self.owner_type = m.get('owner_type')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SearchFileFpRefsRequest(TeaModel):
    """
    search file request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        file_revision_id: str = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # file_revision_id
        self.file_revision_id = file_revision_id
        # marker
        self.marker = marker

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.file_revision_id, 'file_revision_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_revision_id is not None:
            result['file_revision_id'] = self.file_revision_id
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_revision_id') is not None:
            self.file_revision_id = m.get('file_revision_id')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class SearchFileRequest(TeaModel):
    """
    搜索文件元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        drive_id: str = None,
        drive_id_list: List[str] = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        location: str = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        query: str = None,
        recursive: bool = None,
        referer: str = None,
        return_total_count: bool = None,
        sign_token: str = None,
        system_folders: List[str] = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # drive_id
        self.drive_id = drive_id
        # drive_ids
        self.drive_id_list = drive_id_list
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # location
        self.location = location
        # Marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_by
        self.order_by = order_by
        # query
        self.query = query
        self.recursive = recursive
        # referer
        self.referer = referer
        # return_total_count 是否返回查询总数
        self.return_total_count = return_total_count
        # sign_token
        self.sign_token = sign_token
        # system_folders
        self.system_folders = system_folders
        self.thumbnail_processes = thumbnail_processes
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.drive_id_list is not None:
            result['drive_id_list'] = self.drive_id_list
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.location is not None:
            result['location'] = self.location
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        if self.recursive is not None:
            result['recursive'] = self.recursive
        if self.referer is not None:
            result['referer'] = self.referer
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.system_folders is not None:
            result['system_folders'] = self.system_folders
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('drive_id_list') is not None:
            self.drive_id_list = m.get('drive_id_list')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('recursive') is not None:
            self.recursive = m.get('recursive')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('system_folders') is not None:
            self.system_folders = m.get('system_folders')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class SearchImageAddressGroupsRequest(TeaModel):
    """
    # Search image address groups request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        address_level: str = None,
        address_names: List[str] = None,
        br_geo_point: str = None,
        drive_id: str = None,
        image_thumbnail_process: str = None,
        tl_geo_point: str = None,
        video_thumbnail_process: str = None,
    ):
        self.httpheaders = httpheaders
        # 查询的地点级别
        self.address_level = address_level
        # 查询的地点数组
        self.address_names = address_names
        # br_geo_point
        self.br_geo_point = br_geo_point
        # drive_id
        self.drive_id = drive_id
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # tl_geo_point
        self.tl_geo_point = tl_geo_point
        # video_thumbnail_process
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.address_level is not None:
            result['address_level'] = self.address_level
        if self.address_names is not None:
            result['address_names'] = self.address_names
        if self.br_geo_point is not None:
            result['br_geo_point'] = self.br_geo_point
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.tl_geo_point is not None:
            result['tl_geo_point'] = self.tl_geo_point
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('address_level') is not None:
            self.address_level = m.get('address_level')
        if m.get('address_names') is not None:
            self.address_names = m.get('address_names')
        if m.get('br_geo_point') is not None:
            self.br_geo_point = m.get('br_geo_point')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('tl_geo_point') is not None:
            self.tl_geo_point = m.get('tl_geo_point')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class SearchShareLinkRequest(TeaModel):
    """
    search_share_link request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        categories: List[str] = None,
        creators: List[str] = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        order_direction: str = None,
        query: str = None,
        return_total_count: bool = None,
    ):
        self.httpheaders = httpheaders
        # categories
        self.categories = categories
        # creators
        self.creators = creators
        # limit
        self.limit = limit
        # marker
        self.marker = marker
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # query
        self.query = query
        # return_total_count 是否返回查询总数
        self.return_total_count = return_total_count

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.categories is not None:
            result['categories'] = self.categories
        if self.creators is not None:
            result['creators'] = self.creators
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.query is not None:
            result['query'] = self.query
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        if m.get('creators') is not None:
            self.creators = m.get('creators')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        return self


class SearchViewFilesRequest(TeaModel):
    """
    search view file
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        fields: str = None,
        filter: str = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        order_direction: str = None,
        query: str = None,
        return_total_count: bool = None,
        thumbnail_processes: dict = None,
        url_expire_sec: int = None,
        user_id: str = None,
        video_thumbnail_process: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        self.fields = fields
        self.filter = filter
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        self.limit = limit
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        self.order_by = order_by
        self.order_direction = order_direction
        # query
        self.query = query
        # return_total_count 是否返回查询总数
        self.return_total_count = return_total_count
        self.thumbnail_processes = thumbnail_processes
        self.url_expire_sec = url_expire_sec
        # user_id
        self.user_id = user_id
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.fields is not None:
            result['fields'] = self.fields
        if self.filter is not None:
            result['filter'] = self.filter
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.query is not None:
            result['query'] = self.query
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        if self.thumbnail_processes is not None:
            result['thumbnail_processes'] = self.thumbnail_processes
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        if m.get('thumbnail_processes') is not None:
            self.thumbnail_processes = m.get('thumbnail_processes')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class SearchViewsRequest(TeaModel):
    """
    Search view request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        limit: int = None,
        marker: str = None,
        name: str = None,
        order_by: str = None,
        order_direction: str = None,
        owner: str = None,
        return_total_count: bool = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # 每页大小限制
        self.limit = limit
        # marker
        self.marker = marker
        # name
        self.name = name
        # order_by
        self.order_by = order_by
        # order_direction
        self.order_direction = order_direction
        # owner
        self.owner = owner
        # return_total_count 是否返回查询总数
        self.return_total_count = return_total_count
        # user_id
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.category, 'category')
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.name is not None:
            result['name'] = self.name
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.owner is not None:
            result['owner'] = self.owner
        if self.return_total_count is not None:
            result['return_total_count'] = self.return_total_count
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('return_total_count') is not None:
            self.return_total_count = m.get('return_total_count')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class SendSmsCodeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        captcha_id: str = None,
        captcha_text: str = None,
        email: str = None,
        language: str = None,
        nvc_param: str = None,
        phone_number: str = None,
        phone_region: str = None,
        type: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # 图片验证码ID
        self.captcha_id = captcha_id
        # 用户输入的验证码值
        self.captcha_text = captcha_text
        # 邮箱
        self.email = email
        # 发短信的语言
        self.language = language
        # 环境参数
        self.nvc_param = nvc_param
        # 待发送验证短信的手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region
        # 验证码用途, 可下发: login、register、change_password
        self.type = type

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.nvc_param, 'nvc_param')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.captcha_id is not None:
            result['captcha_id'] = self.captcha_id
        if self.captcha_text is not None:
            result['captcha_text'] = self.captcha_text
        if self.email is not None:
            result['email'] = self.email
        if self.language is not None:
            result['language'] = self.language
        if self.nvc_param is not None:
            result['nvc_param'] = self.nvc_param
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('captcha_id') is not None:
            self.captcha_id = m.get('captcha_id')
        if m.get('captcha_text') is not None:
            self.captcha_text = m.get('captcha_text')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('nvc_param') is not None:
            self.nvc_param = m.get('nvc_param')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class SetAppPublicKeyRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        public_key: str = None,
    ):
        # App ID
        self.app_id = app_id
        # RSA加密算法的公钥, PEM格式
        self.public_key = public_key

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.public_key, 'public_key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.public_key is not None:
            result['public_key'] = self.public_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('public_key') is not None:
            self.public_key = m.get('public_key')
        return self


class SetBizCNameCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cert_id: str = None,
        biz_cname: str = None,
        cert_body: str = None,
        cert_name: str = None,
        cert_privatekey: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        self.cert_id = cert_id
        # biz cname
        self.biz_cname = biz_cname
        # cert body
        self.cert_body = cert_body
        # cert name
        self.cert_name = cert_name
        # cert privatekey
        self.cert_privatekey = cert_privatekey
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # biz cname
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.cert_body, 'cert_body')
        self.validate_required(self.cert_name, 'cert_name')
        self.validate_required(self.cert_privatekey, 'cert_privatekey')
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertID'] = self.cert_id
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_body is not None:
            result['cert_body'] = self.cert_body
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cert_privatekey is not None:
            result['cert_privatekey'] = self.cert_privatekey
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertID') is not None:
            self.cert_id = m.get('CertID')
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_body') is not None:
            self.cert_body = m.get('cert_body')
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cert_privatekey') is not None:
            self.cert_privatekey = m.get('cert_privatekey')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class SetBizCNameRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # biz cname
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.biz_cname, 'biz_cname')
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class SetCorsRuleListRequest(TeaModel):
    """
    list cors rule request
    """
    def __init__(
        self,
        cors_rule_list: List[CorsRule] = None,
        domain_id: str = None,
    ):
        # cors rule list
        self.cors_rule_list = cors_rule_list
        # domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.cors_rule_list, 'cors_rule_list')
        if self.cors_rule_list:
            for k in self.cors_rule_list:
                if k:
                    k.validate()
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['cors_rule_list'] = []
        if self.cors_rule_list is not None:
            for k in self.cors_rule_list:
                result['cors_rule_list'].append(k.to_map() if k else None)
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cors_rule_list = []
        if m.get('cors_rule_list') is not None:
            for k in m.get('cors_rule_list'):
                temp_model = CorsRule()
                self.cors_rule_list.append(temp_model.from_map(k))
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class SetDataCNameRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        data_cname: str = None,
        domain_id: str = None,
        location: str = None,
    ):
        # cn-shanghai data cname
        self.data_cname = data_cname
        # domain ID
        self.domain_id = domain_id
        # location
        self.location = location

    def validate(self):
        self.validate_required(self.data_cname, 'data_cname')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.location, 'location')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cname is not None:
            result['data_cname'] = self.data_cname
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.location is not None:
            result['location'] = self.location
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data_cname') is not None:
            self.data_cname = m.get('data_cname')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('location') is not None:
            self.location = m.get('location')
        return self


class SetShareLinkStatusRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        enabled: bool = None,
    ):
        # domain ID
        self.domain_id = domain_id
        # enabled
        self.enabled = enabled

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.enabled, 'enabled')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class SetShareStatusRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        enabled: bool = None,
    ):
        # domain ID
        self.domain_id = domain_id
        # enabled
        self.enabled = enabled

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.enabled, 'enabled')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class ShareLinkCountResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        access_count: int = None,
        download_count: int = None,
        preview_count: int = None,
        report_count: int = None,
        save_count: int = None,
        video_preview_count: int = None,
    ):
        # access_count
        self.access_count = access_count
        # 下载次数
        self.download_count = download_count
        # preview_count
        self.preview_count = preview_count
        # 举报次数
        self.report_count = report_count
        # 转存次数
        self.save_count = save_count
        # 音视频播放次数
        self.video_preview_count = video_preview_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['access_count'] = self.access_count
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('access_count') is not None:
            self.access_count = m.get('access_count')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        return self


class ShareLinkPermissionResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        creatable: bool = None,
        creatable_file_id_list: List[str] = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_limit: int = None,
        office_editable: bool = None,
        preview_limit: int = None,
        require_login: bool = None,
        save_download_limit: int = None,
        save_limit: int = None,
    ):
        # 允许上传
        self.creatable = creatable
        # 允许上传的目录列表
        self.creatable_file_id_list = creatable_file_id_list
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 分享下载次数限制
        self.download_limit = download_limit
        # 允许在线编辑文档
        self.office_editable = office_editable
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.creatable_file_id_list is not None:
            result['creatable_file_id_list'] = self.creatable_file_id_list
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('creatable_file_id_list') is not None:
            self.creatable_file_id_list = m.get('creatable_file_id_list')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        return self


class SimpleQuery(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        field: str = None,
        operation: str = None,
        sub_queries: List['SimpleQuery'] = None,
        value: str = None,
    ):
        self.field = field
        self.operation = operation
        self.sub_queries = sub_queries
        self.value = value

    def validate(self):
        if self.sub_queries:
            for k in self.sub_queries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.operation is not None:
            result['operation'] = self.operation
        result['sub_queries'] = []
        if self.sub_queries is not None:
            for k in self.sub_queries:
                result['sub_queries'].append(k.to_map() if k else None)
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('operation') is not None:
            self.operation = m.get('operation')
        self.sub_queries = []
        if m.get('sub_queries') is not None:
            for k in m.get('sub_queries'):
                temp_model = SimpleQuery()
                self.sub_queries.append(temp_model.from_map(k))
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class SimpleQueryRequest(TeaModel):
    """
    simple query request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        aggregations: List[Aggregation] = None,
        drive_id: str = None,
        limit: int = None,
        marker: str = None,
        order: str = None,
        query: SimpleQuery = None,
        sort: str = None,
    ):
        self.httpheaders = httpheaders
        self.aggregations = aggregations
        # drive_id
        self.drive_id = drive_id
        self.limit = limit
        self.marker = marker
        self.order = order
        self.query = query
        self.sort = sort

    def validate(self):
        if self.aggregations:
            for k in self.aggregations:
                if k:
                    k.validate()
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.query:
            self.query.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        result['aggregations'] = []
        if self.aggregations is not None:
            for k in self.aggregations:
                result['aggregations'].append(k.to_map() if k else None)
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order is not None:
            result['order'] = self.order
        if self.query is not None:
            result['query'] = self.query.to_map()
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        self.aggregations = []
        if m.get('aggregations') is not None:
            for k in m.get('aggregations'):
                temp_model = Aggregation()
                self.aggregations.append(temp_model.from_map(k))
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('query') is not None:
            temp_model = SimpleQuery()
            self.query = temp_model.from_map(m['query'])
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class SimpleStreamInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        content_hash: str = None,
        content_hash_name: str = None,
        crc_64hash: str = None,
        download_url: str = None,
        size: int = None,
        thumbnail: str = None,
        url: str = None,
    ):
        # Content Hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # crc64_hash
        self.crc_64hash = crc_64hash
        # download_url
        self.download_url = download_url
        # size
        self.size = size
        # thumbnail
        self.thumbnail = thumbnail
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.size is not None:
            result['size'] = self.size
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class StreamUploadInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        location: str = None,
        part_info_list: List[UploadPartInfo] = None,
        pre_rapid_upload: bool = None,
        rapid_upload: bool = None,
        upload_id: str = None,
    ):
        # location
        self.location = location
        # part_info_list
        self.part_info_list = part_info_list
        # pre_rapid_upload
        # type: boolean
        self.pre_rapid_upload = pre_rapid_upload
        # rapid_upload
        # type: boolean
        self.rapid_upload = rapid_upload
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.location is not None:
            result['location'] = self.location
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.pre_rapid_upload is not None:
            result['pre_rapid_upload'] = self.pre_rapid_upload
        if self.rapid_upload is not None:
            result['rapid_upload'] = self.rapid_upload
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('location') is not None:
            self.location = m.get('location')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('pre_rapid_upload') is not None:
            self.pre_rapid_upload = m.get('pre_rapid_upload')
        if m.get('rapid_upload') is not None:
            self.rapid_upload = m.get('rapid_upload')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class SubdomainDeleteBizCNameAndCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # api cname
        self.biz_cname = biz_cname
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # vpc
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SubdomainDeleteBizCNameCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cert_id: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cert id
        self.cert_id = cert_id
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_id is not None:
            result['cert_id'] = self.cert_id
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_id') is not None:
            self.cert_id = m.get('cert_id')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SubdomainGetBizCNameInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SubdomainSetBizCNameCertRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cert_id: str = None,
        biz_cname: str = None,
        cert_body: str = None,
        cert_name: str = None,
        cert_privatekey: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        self.cert_id = cert_id
        # biz cname
        self.biz_cname = biz_cname
        # cert body
        self.cert_body = cert_body
        # cert name
        self.cert_name = cert_name
        # cert privatekey
        self.cert_privatekey = cert_privatekey
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # biz cname
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.cert_body, 'cert_body')
        self.validate_required(self.cert_name, 'cert_name')
        self.validate_required(self.cert_privatekey, 'cert_privatekey')
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_id is not None:
            result['CertID'] = self.cert_id
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_body is not None:
            result['cert_body'] = self.cert_body
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cert_privatekey is not None:
            result['cert_privatekey'] = self.cert_privatekey
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertID') is not None:
            self.cert_id = m.get('CertID')
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_body') is not None:
            self.cert_body = m.get('cert_body')
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cert_privatekey') is not None:
            self.cert_privatekey = m.get('cert_privatekey')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SubdomainSetBizCNameRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # biz cname
        self.is_vpc = is_vpc
        # domain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.biz_cname, 'biz_cname')
        self.validate_required(self.cname_type, 'cname_type')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class TokenRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        assertion: str = None,
        client_id: str = None,
        client_secret: str = None,
        code: str = None,
        device_code: str = None,
        grant_type: str = None,
        redirect_uri: str = None,
        refresh_token: str = None,
        sub_domain_id: str = None,
    ):
        # JWT方式授权需要传此参数，传入JWT签名的声明，用于更换accessToken
        self.assertion = assertion
        # Client ID, 此处填写创建App时返回的AppID
        self.client_id = client_id
        # Client ID, 此处填写创建App时返回的AppSecret
        self.client_secret = client_secret
        # 认证后回调参数中的code
        self.code = code
        # OAuth2.0 device flow换取token参数
        self.device_code = device_code
        # 通过code获取accessToken或者通过refresh_token获取accessToken
        self.grant_type = grant_type
        # 回调地址, 此处填写创建App时填写的回调地址，OAuth方式登录时需要传入
        self.redirect_uri = redirect_uri
        # 刷新accessToken使用的refreshToken
        self.refresh_token = refresh_token
        # SubDomainID
        self.sub_domain_id = sub_domain_id

    def validate(self):
        self.validate_required(self.client_id, 'client_id')
        self.validate_required(self.client_secret, 'client_secret')
        self.validate_required(self.grant_type, 'grant_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assertion is not None:
            result['Assertion'] = self.assertion
        if self.client_id is not None:
            result['ClientID'] = self.client_id
        if self.client_secret is not None:
            result['ClientSecret'] = self.client_secret
        if self.code is not None:
            result['Code'] = self.code
        if self.device_code is not None:
            result['DeviceCode'] = self.device_code
        if self.grant_type is not None:
            result['GrantType'] = self.grant_type
        if self.redirect_uri is not None:
            result['RedirectUri'] = self.redirect_uri
        if self.refresh_token is not None:
            result['RefreshToken'] = self.refresh_token
        if self.sub_domain_id is not None:
            result['SubDomainID'] = self.sub_domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Assertion') is not None:
            self.assertion = m.get('Assertion')
        if m.get('ClientID') is not None:
            self.client_id = m.get('ClientID')
        if m.get('ClientSecret') is not None:
            self.client_secret = m.get('ClientSecret')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceCode') is not None:
            self.device_code = m.get('DeviceCode')
        if m.get('GrantType') is not None:
            self.grant_type = m.get('GrantType')
        if m.get('RedirectUri') is not None:
            self.redirect_uri = m.get('RedirectUri')
        if m.get('RefreshToken') is not None:
            self.refresh_token = m.get('RefreshToken')
        if m.get('SubDomainID') is not None:
            self.sub_domain_id = m.get('SubDomainID')
        return self


class TrashFileRequest(TeaModel):
    """
    删除文件请求，支持批量
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        check_folder_empty: bool = None,
        drive_id: str = None,
        file_id: str = None,
        share_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.check_folder_empty = check_folder_empty
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # share_id, either share_id or drive_id is required
        self.share_id = share_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.check_folder_empty is not None:
            result['check_folder_empty'] = self.check_folder_empty
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.share_id is not None:
            result['share_id'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('check_folder_empty') is not None:
            self.check_folder_empty = m.get('check_folder_empty')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        return self


class UCCompleteFileRequest(TeaModel):
    """
    UCCompleteFileRequest complete with store exist
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        crc_64hash: str = None,
        drive_id: str = None,
        file_id: str = None,
        last_revision_id: str = None,
        part_info_list: List[UploadPartInfo] = None,
        share_id: str = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # crc64_hash
        self.crc_64hash = crc_64hash
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        self.last_revision_id = last_revision_id
        # part_info_list
        self.part_info_list = part_info_list
        self.share_id = share_id
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.crc_64hash is not None:
            result['crc64_hash'] = self.crc_64hash
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.last_revision_id is not None:
            result['last_revision_id'] = self.last_revision_id
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('crc64_hash') is not None:
            self.crc_64hash = m.get('crc64_hash')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('last_revision_id') is not None:
            self.last_revision_id = m.get('last_revision_id')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class UCCreateFileRequest(TeaModel):
    """
    UCCreateFileRequest create file with signature
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        auto_rename: bool = None,
        callback: CcpCallback = None,
        category: str = None,
        check_name_mode: str = None,
        check_parent_file_id_path: str = None,
        content_hash: str = None,
        content_hash_mutable: bool = None,
        content_hash_name: str = None,
        content_md_5: str = None,
        content_type: str = None,
        create_reason: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_type: str = None,
        date: str = None,
        description: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        file_id: str = None,
        force_upload_to_location: bool = None,
        headers: dict = None,
        hidden: bool = None,
        image_media_metadata: ImageMediaMetadata = None,
        labels: List[str] = None,
        last_revision_id: str = None,
        last_updated_at: str = None,
        local_created_at: str = None,
        local_modified_at: str = None,
        location: str = None,
        meta: str = None,
        name: str = None,
        need_merge_period_revision: bool = None,
        overwrite: bool = None,
        parallel_upload: bool = None,
        parameters: dict = None,
        parent_file_id: str = None,
        parent_file_id_path: str = None,
        part_info_list: List[UploadPartInfo] = None,
        pre_hash: str = None,
        proof_code: str = None,
        proof_seed: str = None,
        proof_version: str = None,
        share_id: str = None,
        size: int = None,
        streams_info: dict = None,
        type: str = None,
        upload_type: str = None,
        user_meta: str = None,
        user_tags: List[UserTag] = None,
        video_media_metadata: VideoMediaMetadata = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        self.auto_rename = auto_rename
        self.callback = callback
        # category
        self.category = category
        # check_name_mode
        self.check_name_mode = check_name_mode
        self.check_parent_file_id_path = check_parent_file_id_path
        # content_hash
        self.content_hash = content_hash
        # content_hash_mutable
        self.content_hash_mutable = content_hash_mutable
        # content_hash_name
        self.content_hash_name = content_hash_name
        # ContentMd5
        self.content_md_5 = content_md_5
        # ContentType
        self.content_type = content_type
        self.create_reason = create_reason
        self.custom_field_1 = custom_field_1
        self.custom_field_2 = custom_field_2
        self.custom_type = custom_type
        # date
        self.date = date
        # description
        self.description = description
        # drive_id
        self.drive_id = drive_id
        self.encrypt_mode = encrypt_mode
        # file_id
        self.file_id = file_id
        # force_upload_to_location
        self.force_upload_to_location = force_upload_to_location
        # headers
        self.headers = headers
        # hidden
        self.hidden = hidden
        self.image_media_metadata = image_media_metadata
        # labels
        self.labels = labels
        self.last_revision_id = last_revision_id
        # last_updated_at
        self.last_updated_at = last_updated_at
        # local_created_at
        self.local_created_at = local_created_at
        self.local_modified_at = local_modified_at
        # location
        self.location = location
        self.meta = meta
        # Name
        self.name = name
        self.need_merge_period_revision = need_merge_period_revision
        # overwrite
        self.overwrite = overwrite
        self.parallel_upload = parallel_upload
        # parameters
        self.parameters = parameters
        # parent_file_id
        self.parent_file_id = parent_file_id
        self.parent_file_id_path = parent_file_id_path
        # part_info_list
        self.part_info_list = part_info_list
        # pre_hash
        self.pre_hash = pre_hash
        # proof_code
        self.proof_code = proof_code
        # proof_seed
        self.proof_seed = proof_seed
        # proof_version
        self.proof_version = proof_version
        # share_id
        # example
        self.share_id = share_id
        # Size
        self.size = size
        # streams_info
        self.streams_info = streams_info
        # Type
        self.type = type
        # upload_type
        self.upload_type = upload_type
        # user_meta
        self.user_meta = user_meta
        # user_tags
        self.user_tags = user_tags
        self.video_media_metadata = video_media_metadata

    def validate(self):
        if self.callback:
            self.callback.validate()
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        if self.image_media_metadata:
            self.image_media_metadata.validate()
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)
        self.validate_required(self.parent_file_id, 'parent_file_id')
        if self.parent_file_id is not None:
            self.validate_max_length(self.parent_file_id, 'parent_file_id', 50)
            self.validate_pattern(self.parent_file_id, 'parent_file_id', '[a-z0-9]{1,50}')
        if self.part_info_list:
            for k in self.part_info_list:
                if k:
                    k.validate()
        if self.size is not None:
            self.validate_minimum(self.size, 'size', 0)
        self.validate_required(self.type, 'type')
        if self.user_tags:
            for k in self.user_tags:
                if k:
                    k.validate()
        if self.video_media_metadata:
            self.video_media_metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.auto_rename is not None:
            result['auto_rename'] = self.auto_rename
        if self.callback is not None:
            result['callback'] = self.callback.to_map()
        if self.category is not None:
            result['category'] = self.category
        if self.check_name_mode is not None:
            result['check_name_mode'] = self.check_name_mode
        if self.check_parent_file_id_path is not None:
            result['check_parent_file_id_path'] = self.check_parent_file_id_path
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_mutable is not None:
            result['content_hash_mutable'] = self.content_hash_mutable
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.create_reason is not None:
            result['create_reason'] = self.create_reason
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.date is not None:
            result['date'] = self.date
        if self.description is not None:
            result['description'] = self.description
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.force_upload_to_location is not None:
            result['force_upload_to_location'] = self.force_upload_to_location
        if self.headers is not None:
            result['headers'] = self.headers
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.image_media_metadata is not None:
            result['image_media_metadata'] = self.image_media_metadata.to_map()
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_revision_id is not None:
            result['last_revision_id'] = self.last_revision_id
        if self.last_updated_at is not None:
            result['last_updated_at'] = self.last_updated_at
        if self.local_created_at is not None:
            result['local_created_at'] = self.local_created_at
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.location is not None:
            result['location'] = self.location
        if self.meta is not None:
            result['meta'] = self.meta
        if self.name is not None:
            result['name'] = self.name
        if self.need_merge_period_revision is not None:
            result['need_merge_period_revision'] = self.need_merge_period_revision
        if self.overwrite is not None:
            result['overwrite'] = self.overwrite
        if self.parallel_upload is not None:
            result['parallel_upload'] = self.parallel_upload
        if self.parameters is not None:
            result['parameters'] = self.parameters
        if self.parent_file_id is not None:
            result['parent_file_id'] = self.parent_file_id
        if self.parent_file_id_path is not None:
            result['parent_file_id_path'] = self.parent_file_id_path
        result['part_info_list'] = []
        if self.part_info_list is not None:
            for k in self.part_info_list:
                result['part_info_list'].append(k.to_map() if k else None)
        if self.pre_hash is not None:
            result['pre_hash'] = self.pre_hash
        if self.proof_code is not None:
            result['proof_code'] = self.proof_code
        if self.proof_seed is not None:
            result['proof_seed'] = self.proof_seed
        if self.proof_version is not None:
            result['proof_version'] = self.proof_version
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.size is not None:
            result['size'] = self.size
        if self.streams_info is not None:
            result['streams_info'] = self.streams_info
        if self.type is not None:
            result['type'] = self.type
        if self.upload_type is not None:
            result['upload_type'] = self.upload_type
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        result['user_tags'] = []
        if self.user_tags is not None:
            for k in self.user_tags:
                result['user_tags'].append(k.to_map() if k else None)
        if self.video_media_metadata is not None:
            result['video_media_metadata'] = self.video_media_metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('auto_rename') is not None:
            self.auto_rename = m.get('auto_rename')
        if m.get('callback') is not None:
            temp_model = CcpCallback()
            self.callback = temp_model.from_map(m['callback'])
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('check_name_mode') is not None:
            self.check_name_mode = m.get('check_name_mode')
        if m.get('check_parent_file_id_path') is not None:
            self.check_parent_file_id_path = m.get('check_parent_file_id_path')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_mutable') is not None:
            self.content_hash_mutable = m.get('content_hash_mutable')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('create_reason') is not None:
            self.create_reason = m.get('create_reason')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('force_upload_to_location') is not None:
            self.force_upload_to_location = m.get('force_upload_to_location')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('image_media_metadata') is not None:
            temp_model = ImageMediaMetadata()
            self.image_media_metadata = temp_model.from_map(m['image_media_metadata'])
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('last_revision_id') is not None:
            self.last_revision_id = m.get('last_revision_id')
        if m.get('last_updated_at') is not None:
            self.last_updated_at = m.get('last_updated_at')
        if m.get('local_created_at') is not None:
            self.local_created_at = m.get('local_created_at')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('need_merge_period_revision') is not None:
            self.need_merge_period_revision = m.get('need_merge_period_revision')
        if m.get('overwrite') is not None:
            self.overwrite = m.get('overwrite')
        if m.get('parallel_upload') is not None:
            self.parallel_upload = m.get('parallel_upload')
        if m.get('parameters') is not None:
            self.parameters = m.get('parameters')
        if m.get('parent_file_id') is not None:
            self.parent_file_id = m.get('parent_file_id')
        if m.get('parent_file_id_path') is not None:
            self.parent_file_id_path = m.get('parent_file_id_path')
        self.part_info_list = []
        if m.get('part_info_list') is not None:
            for k in m.get('part_info_list'):
                temp_model = UploadPartInfo()
                self.part_info_list.append(temp_model.from_map(k))
        if m.get('pre_hash') is not None:
            self.pre_hash = m.get('pre_hash')
        if m.get('proof_code') is not None:
            self.proof_code = m.get('proof_code')
        if m.get('proof_seed') is not None:
            self.proof_seed = m.get('proof_seed')
        if m.get('proof_version') is not None:
            self.proof_version = m.get('proof_version')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('streams_info') is not None:
            self.streams_info = m.get('streams_info')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upload_type') is not None:
            self.upload_type = m.get('upload_type')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        self.user_tags = []
        if m.get('user_tags') is not None:
            for k in m.get('user_tags'):
                temp_model = UserTag()
                self.user_tags.append(temp_model.from_map(k))
        if m.get('video_media_metadata') is not None:
            temp_model = VideoMediaMetadata()
            self.video_media_metadata = temp_model.from_map(m['video_media_metadata'])
        return self


class UCFileGetSignatureRequest(TeaModel):
    """
    UCFileGetSignatureRequest get file upload signature
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        action: str = None,
        bucket: str = None,
        content_md_5: str = None,
        content_type: str = None,
        date: str = None,
        drive_id: str = None,
        headers: dict = None,
        object_key: str = None,
        parameters: dict = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # action
        self.action = action
        # bucket
        self.bucket = bucket
        # content_md5
        self.content_md_5 = content_md_5
        # content_type
        self.content_type = content_type
        # date
        self.date = date
        # drive_id
        self.drive_id = drive_id
        # headers
        self.headers = headers
        # object_key
        self.object_key = object_key
        # parameters
        self.parameters = parameters
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.action is not None:
            result['action'] = self.action
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.date is not None:
            result['date'] = self.date
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.headers is not None:
            result['headers'] = self.headers
        if self.object_key is not None:
            result['object_key'] = self.object_key
        if self.parameters is not None:
            result['parameters'] = self.parameters
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        if m.get('parameters') is not None:
            self.parameters = m.get('parameters')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class UCGetObjectInfoByObjectKeyRequest(TeaModel):
    """
    UCGetObjectInfoByObjectKeyRequest
    """
    def __init__(
        self,
        object_key: str = None,
    ):
        self.object_key = object_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.object_key is not None:
            result['object_key'] = self.object_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('object_key') is not None:
            self.object_key = m.get('object_key')
        return self


class UCGetObjectInfoBySha1Request(TeaModel):
    """
    UCGetObjectInfoBySha1Request
    """
    def __init__(
        self,
        sha_1: str = None,
    ):
        self.sha_1 = sha_1

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sha_1 is not None:
            result['sha1'] = self.sha_1
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sha1') is not None:
            self.sha_1 = m.get('sha1')
        return self


class UCUpdateUploadContentHashRequest(TeaModel):
    """
    UCUpdateUploadContentHashRequest update upload info
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        content_hash: str = None,
        content_hash_name: str = None,
        content_md_5: str = None,
        drive_id: str = None,
        file_id: str = None,
        overwrite: bool = None,
        size: int = None,
        upload_id: str = None,
    ):
        self.httpheaders = httpheaders
        # content_hash
        self.content_hash = content_hash
        # content_hash_name
        self.content_hash_name = content_hash_name
        # content_md5
        self.content_md_5 = content_md_5
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # overwrite
        self.overwrite = overwrite
        # size
        self.size = size
        # upload_id
        self.upload_id = upload_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.content_hash is not None:
            result['content_hash'] = self.content_hash
        if self.content_hash_name is not None:
            result['content_hash_name'] = self.content_hash_name
        if self.content_md_5 is not None:
            result['content_md5'] = self.content_md_5
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.overwrite is not None:
            result['overwrite'] = self.overwrite
        if self.size is not None:
            result['size'] = self.size
        if self.upload_id is not None:
            result['upload_id'] = self.upload_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('content_hash') is not None:
            self.content_hash = m.get('content_hash')
        if m.get('content_hash_name') is not None:
            self.content_hash_name = m.get('content_hash_name')
        if m.get('content_md5') is not None:
            self.content_md_5 = m.get('content_md5')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('overwrite') is not None:
            self.overwrite = m.get('overwrite')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('upload_id') is not None:
            self.upload_id = m.get('upload_id')
        return self


class UnAssignFaceGroupItemRequest(TeaModel):
    """
    # Unassign facegroup item request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        face_group_id: str = None,
        file_id: str = None,
        group_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # face_group_id
        self.face_group_id = face_group_id
        # file_id
        self.file_id = file_id
        # group_id 列举人脸分组接口中获取
        self.group_id = group_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.face_group_id is not None:
            result['face_group_id'] = self.face_group_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('face_group_id') is not None:
            self.face_group_id = m.get('face_group_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        return self


class UnionAuthentication(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        authentication_type: str = None,
        created_at: int = None,
        extra: str = None,
        identity: str = None,
        status: str = None,
        union_id: str = None,
    ):
        self.authentication_type = authentication_type
        self.created_at = created_at
        self.extra = extra
        self.identity = identity
        self.status = status
        self.union_id = union_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication_type is not None:
            result['AuthenticationType'] = self.authentication_type
        if self.created_at is not None:
            result['CreatedAt'] = self.created_at
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.status is not None:
            result['Status'] = self.status
        if self.union_id is not None:
            result['UnionID'] = self.union_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthenticationType') is not None:
            self.authentication_type = m.get('AuthenticationType')
        if m.get('CreatedAt') is not None:
            self.created_at = m.get('CreatedAt')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UnionID') is not None:
            self.union_id = m.get('UnionID')
        return self


class UnionDomainUserBind(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        authentication_type: str = None,
        domain_id: str = None,
        extra: str = None,
        identity: str = None,
        union_id: str = None,
        user_id: str = None,
    ):
        self.authentication_type = authentication_type
        self.domain_id = domain_id
        self.extra = extra
        self.identity = identity
        self.union_id = union_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication_type is not None:
            result['AuthenticationType'] = self.authentication_type
        if self.domain_id is not None:
            result['DomainID'] = self.domain_id
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.union_id is not None:
            result['UnionID'] = self.union_id
        if self.user_id is not None:
            result['UserID'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthenticationType') is not None:
            self.authentication_type = m.get('AuthenticationType')
        if m.get('DomainID') is not None:
            self.domain_id = m.get('DomainID')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('UnionID') is not None:
            self.union_id = m.get('UnionID')
        if m.get('UserID') is not None:
            self.user_id = m.get('UserID')
        return self


class UpdateAppRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        description: str = None,
        logo: str = None,
        redirect_uri: str = None,
        scope: List[str] = None,
        type: str = None,
    ):
        # App ID
        self.app_id = app_id
        # App名称
        self.app_name = app_name
        # App描述
        self.description = description
        # App图标
        self.logo = logo
        # App回调地址
        self.redirect_uri = redirect_uri
        # App权限列表
        self.scope = scope
        # App类型
        self.type = type

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        if self.app_name is not None:
            self.validate_max_length(self.app_name, 'app_name', 128)
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.description is not None:
            result['description'] = self.description
        if self.logo is not None:
            result['logo'] = self.logo
        if self.redirect_uri is not None:
            result['redirect_uri'] = self.redirect_uri
        if self.scope is not None:
            result['scope'] = self.scope
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('logo') is not None:
            self.logo = m.get('logo')
        if m.get('redirect_uri') is not None:
            self.redirect_uri = m.get('redirect_uri')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateDomainRequest(TeaModel):
    """
    update domain request
    """
    def __init__(
        self,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        custom_benefits: dict = None,
        data_hash_name: str = None,
        description: str = None,
        domain_id: str = None,
        domain_name: str = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        get_benefit: bool = None,
        group_single_drive_enabled: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        init_drive_store_id: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        sharable: bool = None,
        size_quota: int = None,
        status: int = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
    ):
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 启用钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 启用 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        self.custom_benefits = custom_benefits
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        # Domain 描述
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Domain 名称
        self.domain_name = domain_name
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        self.get_benefit = get_benefit
        # 单团队单drive
        self.group_single_drive_enabled = group_single_drive_enabled
        # 开启自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # 自动初始化 Drive 使用 Store ID
        self.init_drive_store_id = init_drive_store_id
        self.published_app_access_strategy = published_app_access_strategy
        # 开启分享
        self.sharable = sharable
        # 逻辑空间quota，默认为-1，无限制，单位为字节
        self.size_quota = size_quota
        # 状态
        self.status = status
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，默认为-1，无限制
        self.user_count_quota = user_count_quota
        # 单用户单drive
        self.user_single_drive_enabled = user_single_drive_enabled

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.custom_benefits is not None:
            result['custom_benefits'] = self.custom_benefits
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.get_benefit is not None:
            result['get_benefit'] = self.get_benefit
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.init_drive_store_id is not None:
            result['init_drive_store_id'] = self.init_drive_store_id
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.status is not None:
            result['status'] = self.status
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('custom_benefits') is not None:
            self.custom_benefits = m.get('custom_benefits')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('get_benefit') is not None:
            self.get_benefit = m.get('get_benefit')
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('init_drive_store_id') is not None:
            self.init_drive_store_id = m.get('init_drive_store_id')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        return self


class UpdateDriveDataProcessTemplateRequest(TeaModel):
    """
    update drive data process template request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        template_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        self.template_id = template_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.template_id is not None:
            result['template_id'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('template_id') is not None:
            self.template_id = m.get('template_id')
        return self


class UpdateDriveRequest(TeaModel):
    """
    # Update drive request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        description: str = None,
        drive_id: str = None,
        drive_name: str = None,
        encrypt_data_access: bool = None,
        encrypt_mode: str = None,
        status: str = None,
        subdomain_id: str = None,
        total_size: int = None,
    ):
        self.httpheaders = httpheaders
        self.category = category
        # 描述信息
        self.description = description
        # Drive ID
        self.drive_id = drive_id
        # Drive 名称
        self.drive_name = drive_name
        # 授权访问加密数据
        self.encrypt_data_access = encrypt_data_access
        # 加密模式
        self.encrypt_mode = encrypt_mode
        # 状态
        self.status = status
        # Subdomain ID
        self.subdomain_id = subdomain_id
        # 总大小,单位Byte [如果设置 -1 代表不限制]
        self.total_size = total_size

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_name is not None:
            self.validate_max_length(self.drive_name, 'drive_name', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.description is not None:
            result['description'] = self.description
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.drive_name is not None:
            result['drive_name'] = self.drive_name
        if self.encrypt_data_access is not None:
            result['encrypt_data_access'] = self.encrypt_data_access
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('drive_name') is not None:
            self.drive_name = m.get('drive_name')
        if m.get('encrypt_data_access') is not None:
            self.encrypt_data_access = m.get('encrypt_data_access')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class UpdateFaceGroupInfoRequest(TeaModel):
    """
    # Update face group info request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        group_cover_face_id: str = None,
        group_id: str = None,
        group_name: str = None,
        remarks: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # group_cover_face_id
        self.group_cover_face_id = group_cover_face_id
        # group_id 列举人脸分组接口中获取
        self.group_id = group_id
        # group_name
        self.group_name = group_name
        # remarks
        self.remarks = remarks

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.group_id, 'group_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.group_cover_face_id is not None:
            result['group_cover_face_id'] = self.group_cover_face_id
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.remarks is not None:
            result['remarks'] = self.remarks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('group_cover_face_id') is not None:
            self.group_cover_face_id = m.get('group_cover_face_id')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('remarks') is not None:
            self.remarks = m.get('remarks')
        return self


class UpdateFileMetaRequest(TeaModel):
    """
    更新文件元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: dict = None,
        category: str = None,
        check_name_mode: str = None,
        custom_field_1: str = None,
        custom_field_2: str = None,
        custom_index_key: str = None,
        custom_type: str = None,
        description: str = None,
        drive_id: str = None,
        encrypt_mode: str = None,
        ex_fields_info: dict = None,
        file_id: str = None,
        file_id_path: str = None,
        hidden: bool = None,
        labels: List[str] = None,
        local_modified_at: str = None,
        meta: str = None,
        mime_extension: str = None,
        mime_type: str = None,
        name: str = None,
        referer: str = None,
        share_id: str = None,
        sign_token: str = None,
        starred: bool = None,
        taken_at: str = None,
        user_meta: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        self.category = category
        # check_name_mode
        self.check_name_mode = check_name_mode
        self.custom_field_1 = custom_field_1
        self.custom_field_2 = custom_field_2
        self.custom_index_key = custom_index_key
        self.custom_type = custom_type
        # description
        # type: string
        self.description = description
        # drive_id
        self.drive_id = drive_id
        self.encrypt_mode = encrypt_mode
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # file_id
        self.file_id = file_id
        self.file_id_path = file_id_path
        # hidden
        # type: boolean
        self.hidden = hidden
        # labels
        self.labels = labels
        self.local_modified_at = local_modified_at
        self.meta = meta
        self.mime_extension = mime_extension
        self.mime_type = mime_type
        # name
        self.name = name
        self.referer = referer
        self.share_id = share_id
        self.sign_token = sign_token
        # starred
        # type: boolean
        self.starred = starred
        self.taken_at = taken_at
        # user_meta
        self.user_meta = user_meta

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 1024)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.category is not None:
            result['category'] = self.category
        if self.check_name_mode is not None:
            result['check_name_mode'] = self.check_name_mode
        if self.custom_field_1 is not None:
            result['custom_field_1'] = self.custom_field_1
        if self.custom_field_2 is not None:
            result['custom_field_2'] = self.custom_field_2
        if self.custom_index_key is not None:
            result['custom_index_key'] = self.custom_index_key
        if self.custom_type is not None:
            result['custom_type'] = self.custom_type
        if self.description is not None:
            result['description'] = self.description
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.encrypt_mode is not None:
            result['encrypt_mode'] = self.encrypt_mode
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.file_id_path is not None:
            result['file_id_path'] = self.file_id_path
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.labels is not None:
            result['labels'] = self.labels
        if self.local_modified_at is not None:
            result['local_modified_at'] = self.local_modified_at
        if self.meta is not None:
            result['meta'] = self.meta
        if self.mime_extension is not None:
            result['mime_extension'] = self.mime_extension
        if self.mime_type is not None:
            result['mime_type'] = self.mime_type
        if self.name is not None:
            result['name'] = self.name
        if self.referer is not None:
            result['referer'] = self.referer
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.starred is not None:
            result['starred'] = self.starred
        if self.taken_at is not None:
            result['taken_at'] = self.taken_at
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('check_name_mode') is not None:
            self.check_name_mode = m.get('check_name_mode')
        if m.get('custom_field_1') is not None:
            self.custom_field_1 = m.get('custom_field_1')
        if m.get('custom_field_2') is not None:
            self.custom_field_2 = m.get('custom_field_2')
        if m.get('custom_index_key') is not None:
            self.custom_index_key = m.get('custom_index_key')
        if m.get('custom_type') is not None:
            self.custom_type = m.get('custom_type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('encrypt_mode') is not None:
            self.encrypt_mode = m.get('encrypt_mode')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('file_id_path') is not None:
            self.file_id_path = m.get('file_id_path')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('local_modified_at') is not None:
            self.local_modified_at = m.get('local_modified_at')
        if m.get('meta') is not None:
            self.meta = m.get('meta')
        if m.get('mime_extension') is not None:
            self.mime_extension = m.get('mime_extension')
        if m.get('mime_type') is not None:
            self.mime_type = m.get('mime_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('taken_at') is not None:
            self.taken_at = m.get('taken_at')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        return self


class UpdateLocationDateClusterRequest(TeaModel):
    """
    update locationCluster request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cluster_id: str = None,
        custom_labels: dict = None,
        drive_id: str = None,
        title: str = None,
    ):
        self.httpheaders = httpheaders
        self.cluster_id = cluster_id
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        self.title = title

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateRevisionRequest(TeaModel):
    """
    更新版本元数据
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_id: str = None,
        keep_forever: bool = None,
        referer: str = None,
        revision_description: str = None,
        revision_id: str = None,
        sign_token: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # keep_forever
        # type: boolean
        self.keep_forever = keep_forever
        self.referer = referer
        # revision_description
        # type: string
        self.revision_description = revision_description
        # revision_id
        self.revision_id = revision_id
        self.sign_token = sign_token

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.file_id, 'file_id')
        if self.file_id is not None:
            self.validate_max_length(self.file_id, 'file_id', 50)
            self.validate_pattern(self.file_id, 'file_id', '[a-z0-9.-_]{1,50}')
        if self.revision_description is not None:
            self.validate_max_length(self.revision_description, 'revision_description', 1024)
        self.validate_required(self.revision_id, 'revision_id')
        if self.revision_id is not None:
            self.validate_max_length(self.revision_id, 'revision_id', 50)
            self.validate_pattern(self.revision_id, 'revision_id', '[a-z0-9.-_]{1,50}')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.keep_forever is not None:
            result['keep_forever'] = self.keep_forever
        if self.referer is not None:
            result['referer'] = self.referer
        if self.revision_description is not None:
            result['revision_description'] = self.revision_description
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('keep_forever') is not None:
            self.keep_forever = m.get('keep_forever')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('revision_description') is not None:
            self.revision_description = m.get('revision_description')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        return self


class UpdateShareLinkPermissionRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        creatable: bool = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_limit: int = None,
        office_editable: bool = None,
        preview_limit: int = None,
        require_login: bool = None,
        save_download_limit: int = None,
        save_limit: int = None,
    ):
        # 允许上传
        self.creatable = creatable
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # 分享下载次数限制
        self.download_limit = download_limit
        # 允许在线编辑文档
        self.office_editable = office_editable
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        return self


class UpdateShareLinkRequest(TeaModel):
    """
    update_share_link request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        comments: str = None,
        creatable: bool = None,
        description: str = None,
        disable_download: bool = None,
        disable_preview: bool = None,
        disable_save: bool = None,
        disable_visible: bool = None,
        download_count: int = None,
        download_limit: int = None,
        enable_file_changed_notify: bool = None,
        expiration: str = None,
        is_subscribed: bool = None,
        num_of_subscribers: int = None,
        office_editable: bool = None,
        preview_count: int = None,
        preview_limit: int = None,
        report_count: int = None,
        require_login: bool = None,
        save_count: int = None,
        save_download_limit: int = None,
        save_limit: int = None,
        share_icon: str = None,
        share_id: str = None,
        share_name: str = None,
        share_pwd: str = None,
        status: str = None,
        video_preview_count: int = None,
    ):
        self.httpheaders = httpheaders
        # comments
        self.comments = comments
        # 允许上传
        self.creatable = creatable
        # description
        self.description = description
        # 禁止下载分享中的文件
        self.disable_download = disable_download
        # 禁止预览分享中的文件
        self.disable_preview = disable_preview
        # 禁止转存分享中的文件
        self.disable_save = disable_save
        # 分享中的文件不可见
        self.disable_visible = disable_visible
        # download_count
        self.download_count = download_count
        # 分享下载次数限制
        self.download_limit = download_limit
        # enable_file_changed_notify
        self.enable_file_changed_notify = enable_file_changed_notify
        # expiration
        self.expiration = expiration
        # is_subscribed
        self.is_subscribed = is_subscribed
        # num_of_subscribers
        self.num_of_subscribers = num_of_subscribers
        # 允许在线编辑文档
        self.office_editable = office_editable
        # preview_count
        self.preview_count = preview_count
        # 分享预览次数限制
        self.preview_limit = preview_limit
        # report_count
        self.report_count = report_count
        # 企业内(domain)登录后才允许使用分享
        self.require_login = require_login
        # save_count
        self.save_count = save_count
        # 分享转存和下载的总次数限制
        self.save_download_limit = save_download_limit
        # 分享转存次数限制
        self.save_limit = save_limit
        # share_icon
        self.share_icon = share_icon
        # share_id
        self.share_id = share_id
        # share_name
        self.share_name = share_name
        # share_pwd
        self.share_pwd = share_pwd
        # status
        self.status = status
        # video_preview_count
        self.video_preview_count = video_preview_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.comments is not None:
            result['comments'] = self.comments
        if self.creatable is not None:
            result['creatable'] = self.creatable
        if self.description is not None:
            result['description'] = self.description
        if self.disable_download is not None:
            result['disable_download'] = self.disable_download
        if self.disable_preview is not None:
            result['disable_preview'] = self.disable_preview
        if self.disable_save is not None:
            result['disable_save'] = self.disable_save
        if self.disable_visible is not None:
            result['disable_visible'] = self.disable_visible
        if self.download_count is not None:
            result['download_count'] = self.download_count
        if self.download_limit is not None:
            result['download_limit'] = self.download_limit
        if self.enable_file_changed_notify is not None:
            result['enable_file_changed_notify'] = self.enable_file_changed_notify
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.is_subscribed is not None:
            result['is_subscribed'] = self.is_subscribed
        if self.num_of_subscribers is not None:
            result['num_of_subscribers'] = self.num_of_subscribers
        if self.office_editable is not None:
            result['office_editable'] = self.office_editable
        if self.preview_count is not None:
            result['preview_count'] = self.preview_count
        if self.preview_limit is not None:
            result['preview_limit'] = self.preview_limit
        if self.report_count is not None:
            result['report_count'] = self.report_count
        if self.require_login is not None:
            result['require_login'] = self.require_login
        if self.save_count is not None:
            result['save_count'] = self.save_count
        if self.save_download_limit is not None:
            result['save_download_limit'] = self.save_download_limit
        if self.save_limit is not None:
            result['save_limit'] = self.save_limit
        if self.share_icon is not None:
            result['share_icon'] = self.share_icon
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_name is not None:
            result['share_name'] = self.share_name
        if self.share_pwd is not None:
            result['share_pwd'] = self.share_pwd
        if self.status is not None:
            result['status'] = self.status
        if self.video_preview_count is not None:
            result['video_preview_count'] = self.video_preview_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('comments') is not None:
            self.comments = m.get('comments')
        if m.get('creatable') is not None:
            self.creatable = m.get('creatable')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disable_download') is not None:
            self.disable_download = m.get('disable_download')
        if m.get('disable_preview') is not None:
            self.disable_preview = m.get('disable_preview')
        if m.get('disable_save') is not None:
            self.disable_save = m.get('disable_save')
        if m.get('disable_visible') is not None:
            self.disable_visible = m.get('disable_visible')
        if m.get('download_count') is not None:
            self.download_count = m.get('download_count')
        if m.get('download_limit') is not None:
            self.download_limit = m.get('download_limit')
        if m.get('enable_file_changed_notify') is not None:
            self.enable_file_changed_notify = m.get('enable_file_changed_notify')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('is_subscribed') is not None:
            self.is_subscribed = m.get('is_subscribed')
        if m.get('num_of_subscribers') is not None:
            self.num_of_subscribers = m.get('num_of_subscribers')
        if m.get('office_editable') is not None:
            self.office_editable = m.get('office_editable')
        if m.get('preview_count') is not None:
            self.preview_count = m.get('preview_count')
        if m.get('preview_limit') is not None:
            self.preview_limit = m.get('preview_limit')
        if m.get('report_count') is not None:
            self.report_count = m.get('report_count')
        if m.get('require_login') is not None:
            self.require_login = m.get('require_login')
        if m.get('save_count') is not None:
            self.save_count = m.get('save_count')
        if m.get('save_download_limit') is not None:
            self.save_download_limit = m.get('save_download_limit')
        if m.get('save_limit') is not None:
            self.save_limit = m.get('save_limit')
        if m.get('share_icon') is not None:
            self.share_icon = m.get('share_icon')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        if m.get('share_pwd') is not None:
            self.share_pwd = m.get('share_pwd')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('video_preview_count') is not None:
            self.video_preview_count = m.get('video_preview_count')
        return self


class UpdateShareRequest(TeaModel):
    """
    update share request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        expiration: str = None,
        permissions: List[str] = None,
        share_id: str = None,
        share_name: str = None,
        share_policy: List[SharePermissionPolicy] = None,
        status: str = None,
    ):
        self.httpheaders = httpheaders
        # description
        self.description = description
        # expiration
        self.expiration = expiration
        # permissions
        self.permissions = permissions
        # share_id
        self.share_id = share_id
        # share_name
        self.share_name = share_name
        # share_policy
        self.share_policy = share_policy
        # status
        self.status = status

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        self.validate_required(self.share_id, 'share_id')
        if self.share_policy:
            for k in self.share_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.expiration is not None:
            result['expiration'] = self.expiration
        if self.permissions is not None:
            result['permissions'] = self.permissions
        if self.share_id is not None:
            result['share_id'] = self.share_id
        if self.share_name is not None:
            result['share_name'] = self.share_name
        result['share_policy'] = []
        if self.share_policy is not None:
            for k in self.share_policy:
                result['share_policy'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('expiration') is not None:
            self.expiration = m.get('expiration')
        if m.get('permissions') is not None:
            self.permissions = m.get('permissions')
        if m.get('share_id') is not None:
            self.share_id = m.get('share_id')
        if m.get('share_name') is not None:
            self.share_name = m.get('share_name')
        self.share_policy = []
        if m.get('share_policy') is not None:
            for k in m.get('share_policy'):
                temp_model = SharePermissionPolicy()
                self.share_policy.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateStoryRequest(TeaModel):
    """
    # Update story request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        cover: StoryFile = None,
        custom_id: str = None,
        custom_labels: dict = None,
        drive_id: str = None,
        story_id: str = None,
        story_name: str = None,
    ):
        self.httpheaders = httpheaders
        self.cover = cover
        # custom_id
        self.custom_id = custom_id
        # custom_labels
        self.custom_labels = custom_labels
        # drive_id
        self.drive_id = drive_id
        # story_id
        self.story_id = story_id
        # story_name
        self.story_name = story_name

    def validate(self):
        if self.cover:
            self.cover.validate()
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')
        self.validate_required(self.story_id, 'story_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.cover is not None:
            result['cover'] = self.cover.to_map()
        if self.custom_id is not None:
            result['custom_id'] = self.custom_id
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.story_id is not None:
            result['story_id'] = self.story_id
        if self.story_name is not None:
            result['story_name'] = self.story_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('cover') is not None:
            temp_model = StoryFile()
            self.cover = temp_model.from_map(m['cover'])
        if m.get('custom_id') is not None:
            self.custom_id = m.get('custom_id')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('story_id') is not None:
            self.story_id = m.get('story_id')
        if m.get('story_name') is not None:
            self.story_name = m.get('story_name')
        return self


class UpdateSubdomainMgmtRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        description: str = None,
        domain_id: str = None,
        name: str = None,
        sharable: bool = None,
        share_link_enabled: bool = None,
        status: int = None,
        subdomain_id: str = None,
        total_size: int = None,
        used_size_refresh_interval: int = None,
        user_quota: int = None,
    ):
        # 描述
        self.description = description
        # 用以唯一标识subdomain
        self.domain_id = domain_id
        # 名称
        self.name = name
        # 是否开启了共享
        self.sharable = sharable
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 状态
        self.status = status
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id
        # 逻辑空间quota，-1表示无限制，单位为字节
        self.total_size = total_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，-1表示无限制
        self.user_quota = user_quota

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.name is not None:
            result['name'] = self.name
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_quota is not None:
            result['user_quota'] = self.user_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_quota') is not None:
            self.user_quota = m.get('user_quota')
        return self


class UpdateViewRequest(TeaModel):
    """
    Update view request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        category: str = None,
        description: str = None,
        ex_fields_info: dict = None,
        file_count: int = None,
        name: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        self.httpheaders = httpheaders
        # category
        self.category = category
        # description
        self.description = description
        # ex_fields_info
        self.ex_fields_info = ex_fields_info
        # description
        self.file_count = file_count
        # name
        self.name = name
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.category is not None:
            result['category'] = self.category
        if self.description is not None:
            result['description'] = self.description
        if self.ex_fields_info is not None:
            result['ex_fields_info'] = self.ex_fields_info
        if self.file_count is not None:
            result['file_count'] = self.file_count
        if self.name is not None:
            result['name'] = self.name
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ex_fields_info') is not None:
            self.ex_fields_info = m.get('ex_fields_info')
        if m.get('file_count') is not None:
            self.file_count = m.get('file_count')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class UrlInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        download_url: str = None,
        thumbnail: str = None,
        url: str = None,
    ):
        # download_url
        self.download_url = download_url
        # thumbnail
        self.thumbnail = thumbnail
        # url
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_url is not None:
            result['download_url'] = self.download_url
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('download_url') is not None:
            self.download_url = m.get('download_url')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UserAuthentication(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        authentication_type: str = None,
        created_at: int = None,
        detail: str = None,
        domain_id: str = None,
        extra: str = None,
        identity: str = None,
        last_login_time: int = None,
        status: str = None,
        user_id: str = None,
        subdomain_id: str = None,
    ):
        # 认证类型
        self.authentication_type = authentication_type
        # 创建时间
        self.created_at = created_at
        # 详情
        self.detail = detail
        # Domain ID
        self.domain_id = domain_id
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 最后登录时间
        self.last_login_time = last_login_time
        # 状态
        self.status = status
        # 用户ID
        self.user_id = user_id
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.authentication_type, 'authentication_type')
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.detail, 'detail')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.last_login_time, 'last_login_time')
        self.validate_required(self.status, 'status')
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication_type is not None:
            result['AuthenticationType'] = self.authentication_type
        if self.created_at is not None:
            result['CreatedAt'] = self.created_at
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.domain_id is not None:
            result['DomainID'] = self.domain_id
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.identity is not None:
            result['Identity'] = self.identity
        if self.last_login_time is not None:
            result['LastLoginTime'] = self.last_login_time
        if self.status is not None:
            result['Status'] = self.status
        if self.user_id is not None:
            result['UserID'] = self.user_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthenticationType') is not None:
            self.authentication_type = m.get('AuthenticationType')
        if m.get('CreatedAt') is not None:
            self.created_at = m.get('CreatedAt')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('DomainID') is not None:
            self.domain_id = m.get('DomainID')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('Identity') is not None:
            self.identity = m.get('Identity')
        if m.get('LastLoginTime') is not None:
            self.last_login_time = m.get('LastLoginTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserID') is not None:
            self.user_id = m.get('UserID')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class VerifyCodeRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        phone_number: str = None,
        phone_region: str = None,
        sms_code: str = None,
        sms_code_id: str = None,
        verify_type: str = None,
    ):
        self.httpheaders = httpheaders
        # App ID, 当前访问的App
        self.app_id = app_id
        # 手机号
        self.phone_number = phone_number
        # 国家编号，默认86，不需要填+号，直接填数字
        self.phone_region = phone_region
        # 短信验证码内容
        self.sms_code = sms_code
        # 短信验证码ID
        self.sms_code_id = sms_code_id
        # 需要被校验内容的类型
        self.verify_type = verify_type

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.phone_number, 'phone_number')
        self.validate_required(self.sms_code, 'sms_code')
        self.validate_required(self.sms_code_id, 'sms_code_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.sms_code is not None:
            result['sms_code'] = self.sms_code
        if self.sms_code_id is not None:
            result['sms_code_id'] = self.sms_code_id
        if self.verify_type is not None:
            result['verify_type'] = self.verify_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('sms_code') is not None:
            self.sms_code = m.get('sms_code')
        if m.get('sms_code_id') is not None:
            self.sms_code_id = m.get('sms_code_id')
        if m.get('verify_type') is not None:
            self.verify_type = m.get('verify_type')
        return self


class ViewFileBaseRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        category: str = None,
        drive_id: str = None,
        user_id: str = None,
        view_id: str = None,
    ):
        # category
        self.category = category
        self.drive_id = drive_id
        # user_id
        self.user_id = user_id
        # view_id
        self.view_id = view_id

    def validate(self):
        self.validate_required(self.category, 'category')
        self.validate_required(self.view_id, 'view_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.view_id is not None:
            result['view_id'] = self.view_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        return self


class AddStoreResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        accelerate_endpoint: str = None,
        base_path: str = None,
        bucket: str = None,
        cdn_endpoint: str = None,
        cdn_ratelimit_disable: bool = None,
        cdn_timelimit: str = None,
        cdn_url_auth_key: str = None,
        customized_accelerate_endpoint: str = None,
        customized_cdn_endpoint: str = None,
        customized_endpoint: str = None,
        customized_internal_endpoint: str = None,
        domain_id: str = None,
        endpoint: str = None,
        enet_endpoint: str = None,
        enet_percent_config: WhitePercentConfig = None,
        internal_endpoint: str = None,
        location: str = None,
        ownership: str = None,
        policy: str = None,
        role_arn: str = None,
        store_id: str = None,
        type: str = None,
    ):
        # 全球加速地址
        self.accelerate_endpoint = accelerate_endpoint
        # 存储公共前缀
        self.base_path = base_path
        # bucket名称
        self.bucket = bucket
        # 内容分发地址
        self.cdn_endpoint = cdn_endpoint
        # 命中限速用户时是否关闭CDN地址返回
        self.cdn_ratelimit_disable = cdn_ratelimit_disable
        # CDN时间控制
        self.cdn_timelimit = cdn_timelimit
        # CDN鉴权key
        self.cdn_url_auth_key = cdn_url_auth_key
        # 自定义全球加速地址
        self.customized_accelerate_endpoint = customized_accelerate_endpoint
        # 自定义内容分发地址
        self.customized_cdn_endpoint = customized_cdn_endpoint
        # 自定义Public访问地址
        self.customized_endpoint = customized_endpoint
        # 自定义vpc访问地址
        self.customized_internal_endpoint = customized_internal_endpoint
        # domain ID
        self.domain_id = domain_id
        # Public访问地址
        self.endpoint = endpoint
        # 冷流地址
        self.enet_endpoint = enet_endpoint
        self.enet_percent_config = enet_percent_config
        # vpc访问地址
        self.internal_endpoint = internal_endpoint
        # 地点
        self.location = location
        # 存储归属，system表示系统提供，custom表示使用自己的存储
        self.ownership = ownership
        # Policy授权,system类型store会将bucket权限授予当前云账号
        self.policy = policy
        # 访问Bucket的角色ARN
        self.role_arn = role_arn
        # store ID
        self.store_id = store_id
        # 存储类型，当前只支持oss
        self.type = type

    def validate(self):
        self.validate_required(self.bucket, 'bucket')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.endpoint, 'endpoint')
        if self.enet_percent_config:
            self.enet_percent_config.validate()
        self.validate_required(self.ownership, 'ownership')
        self.validate_required(self.policy, 'policy')
        self.validate_required(self.store_id, 'store_id')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accelerate_endpoint is not None:
            result['accelerate_endpoint'] = self.accelerate_endpoint
        if self.base_path is not None:
            result['base_path'] = self.base_path
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.cdn_endpoint is not None:
            result['cdn_endpoint'] = self.cdn_endpoint
        if self.cdn_ratelimit_disable is not None:
            result['cdn_ratelimit_disable'] = self.cdn_ratelimit_disable
        if self.cdn_timelimit is not None:
            result['cdn_timelimit'] = self.cdn_timelimit
        if self.cdn_url_auth_key is not None:
            result['cdn_url_auth_key'] = self.cdn_url_auth_key
        if self.customized_accelerate_endpoint is not None:
            result['customized_accelerate_endpoint'] = self.customized_accelerate_endpoint
        if self.customized_cdn_endpoint is not None:
            result['customized_cdn_endpoint'] = self.customized_cdn_endpoint
        if self.customized_endpoint is not None:
            result['customized_endpoint'] = self.customized_endpoint
        if self.customized_internal_endpoint is not None:
            result['customized_internal_endpoint'] = self.customized_internal_endpoint
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.enet_endpoint is not None:
            result['enet_endpoint'] = self.enet_endpoint
        if self.enet_percent_config is not None:
            result['enet_percent_config'] = self.enet_percent_config.to_map()
        if self.internal_endpoint is not None:
            result['internal_endpoint'] = self.internal_endpoint
        if self.location is not None:
            result['location'] = self.location
        if self.ownership is not None:
            result['ownership'] = self.ownership
        if self.policy is not None:
            result['policy'] = self.policy
        if self.role_arn is not None:
            result['role_arn'] = self.role_arn
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accelerate_endpoint') is not None:
            self.accelerate_endpoint = m.get('accelerate_endpoint')
        if m.get('base_path') is not None:
            self.base_path = m.get('base_path')
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('cdn_endpoint') is not None:
            self.cdn_endpoint = m.get('cdn_endpoint')
        if m.get('cdn_ratelimit_disable') is not None:
            self.cdn_ratelimit_disable = m.get('cdn_ratelimit_disable')
        if m.get('cdn_timelimit') is not None:
            self.cdn_timelimit = m.get('cdn_timelimit')
        if m.get('cdn_url_auth_key') is not None:
            self.cdn_url_auth_key = m.get('cdn_url_auth_key')
        if m.get('customized_accelerate_endpoint') is not None:
            self.customized_accelerate_endpoint = m.get('customized_accelerate_endpoint')
        if m.get('customized_cdn_endpoint') is not None:
            self.customized_cdn_endpoint = m.get('customized_cdn_endpoint')
        if m.get('customized_endpoint') is not None:
            self.customized_endpoint = m.get('customized_endpoint')
        if m.get('customized_internal_endpoint') is not None:
            self.customized_internal_endpoint = m.get('customized_internal_endpoint')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('enet_endpoint') is not None:
            self.enet_endpoint = m.get('enet_endpoint')
        if m.get('enet_percent_config') is not None:
            temp_model = WhitePercentConfig()
            self.enet_percent_config = temp_model.from_map(m['enet_percent_config'])
        if m.get('internal_endpoint') is not None:
            self.internal_endpoint = m.get('internal_endpoint')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('ownership') is not None:
            self.ownership = m.get('ownership')
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        if m.get('role_arn') is not None:
            self.role_arn = m.get('role_arn')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AdminListStoresRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
    ):
        self.httpheaders = httpheaders

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        return self


class GrayscaleConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enabled: bool = None,
        percentage: int = None,
    ):
        self.enabled = enabled
        self.percentage = percentage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.percentage is not None:
            result['percentage'] = self.percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('percentage') is not None:
            self.percentage = m.get('percentage')
        return self


class WhitelistConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        drive_whitelist: List[str] = None,
        enabled: bool = None,
        whitelist: List[str] = None,
    ):
        self.drive_whitelist = drive_whitelist
        self.enabled = enabled
        self.whitelist = whitelist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drive_whitelist is not None:
            result['drive_whitelist'] = self.drive_whitelist
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.whitelist is not None:
            result['whitelist'] = self.whitelist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('drive_whitelist') is not None:
            self.drive_whitelist = m.get('drive_whitelist')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('whitelist') is not None:
            self.whitelist = m.get('whitelist')
        return self


class ApiConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        blacklist: List[str] = None,
        enabled: bool = None,
        grayscale_config: GrayscaleConfig = None,
        status: str = None,
        whitelist_config: WhitelistConfig = None,
    ):
        self.blacklist = blacklist
        self.enabled = enabled
        self.grayscale_config = grayscale_config
        self.status = status
        self.whitelist_config = whitelist_config

    def validate(self):
        if self.grayscale_config:
            self.grayscale_config.validate()
        if self.whitelist_config:
            self.whitelist_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.blacklist is not None:
            result['blacklist'] = self.blacklist
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.grayscale_config is not None:
            result['grayscale_config'] = self.grayscale_config.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.whitelist_config is not None:
            result['whitelist_config'] = self.whitelist_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('blacklist') is not None:
            self.blacklist = m.get('blacklist')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('grayscale_config') is not None:
            temp_model = GrayscaleConfig()
            self.grayscale_config = temp_model.from_map(m['grayscale_config'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('whitelist_config') is not None:
            temp_model = WhitelistConfig()
            self.whitelist_config = temp_model.from_map(m['whitelist_config'])
        return self


class AppConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        allow_upload_custom_file_ext_list: List[str] = None,
        allow_upload_file_category_list: List[str] = None,
        audio_play_enable: bool = None,
        black_admin_menu_items: str = None,
        custom_account_identity_base_64: bool = None,
        default_url_expire_sec: int = None,
        disable_client_builder: bool = None,
        disable_group: bool = None,
        enable_edit_file_with_create_perm: bool = None,
        enable_hidden_file: bool = None,
        enable_share_link_count_limit: bool = None,
        enable_sse_oss: bool = None,
        enable_transfer_acceleration: bool = None,
        enable_update_share_link_by_admin: bool = None,
        hidden_switch_user_role_entry: bool = None,
        hide_admin_entry: bool = None,
        hide_client_download_entry: bool = None,
        hide_drive_file_entry: bool = None,
        hide_logout_entry: bool = None,
        hide_share_admin_entry: bool = None,
        hide_sharelink_login: bool = None,
        hide_user_entry: bool = None,
        mount_app_enable: bool = None,
        same_name_file_upload_mode: str = None,
        share_hide_disabled_user: bool = None,
        share_link_disable_download: bool = None,
        share_link_disable_upload: bool = None,
        share_link_login_access_only: bool = None,
        show_customized_login_config: bool = None,
        single_file_upload_size_limit: int = None,
        sync_app_enable: bool = None,
        user_can_access_group_recycle_bin: bool = None,
        video_play_enable: bool = None,
        web_client_download_mode: str = None,
        web_version: str = None,
        white_admin_menu_items: str = None,
    ):
        self.allow_upload_custom_file_ext_list = allow_upload_custom_file_ext_list
        self.allow_upload_file_category_list = allow_upload_file_category_list
        self.audio_play_enable = audio_play_enable
        self.black_admin_menu_items = black_admin_menu_items
        self.custom_account_identity_base_64 = custom_account_identity_base_64
        self.default_url_expire_sec = default_url_expire_sec
        self.disable_client_builder = disable_client_builder
        self.disable_group = disable_group
        self.enable_edit_file_with_create_perm = enable_edit_file_with_create_perm
        self.enable_hidden_file = enable_hidden_file
        self.enable_share_link_count_limit = enable_share_link_count_limit
        self.enable_sse_oss = enable_sse_oss
        self.enable_transfer_acceleration = enable_transfer_acceleration
        self.enable_update_share_link_by_admin = enable_update_share_link_by_admin
        self.hidden_switch_user_role_entry = hidden_switch_user_role_entry
        self.hide_admin_entry = hide_admin_entry
        self.hide_client_download_entry = hide_client_download_entry
        self.hide_drive_file_entry = hide_drive_file_entry
        self.hide_logout_entry = hide_logout_entry
        self.hide_share_admin_entry = hide_share_admin_entry
        self.hide_sharelink_login = hide_sharelink_login
        self.hide_user_entry = hide_user_entry
        self.mount_app_enable = mount_app_enable
        self.same_name_file_upload_mode = same_name_file_upload_mode
        self.share_hide_disabled_user = share_hide_disabled_user
        self.share_link_disable_download = share_link_disable_download
        self.share_link_disable_upload = share_link_disable_upload
        self.share_link_login_access_only = share_link_login_access_only
        self.show_customized_login_config = show_customized_login_config
        self.single_file_upload_size_limit = single_file_upload_size_limit
        self.sync_app_enable = sync_app_enable
        self.user_can_access_group_recycle_bin = user_can_access_group_recycle_bin
        self.video_play_enable = video_play_enable
        self.web_client_download_mode = web_client_download_mode
        self.web_version = web_version
        self.white_admin_menu_items = white_admin_menu_items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_upload_custom_file_ext_list is not None:
            result['allow_upload_custom_file_ext_list'] = self.allow_upload_custom_file_ext_list
        if self.allow_upload_file_category_list is not None:
            result['allow_upload_file_category_list'] = self.allow_upload_file_category_list
        if self.audio_play_enable is not None:
            result['audio_play_enable'] = self.audio_play_enable
        if self.black_admin_menu_items is not None:
            result['black_admin_menu_items'] = self.black_admin_menu_items
        if self.custom_account_identity_base_64 is not None:
            result['custom_account_identity_base_64'] = self.custom_account_identity_base_64
        if self.default_url_expire_sec is not None:
            result['default_url_expire_sec'] = self.default_url_expire_sec
        if self.disable_client_builder is not None:
            result['disable_client_builder'] = self.disable_client_builder
        if self.disable_group is not None:
            result['disable_group'] = self.disable_group
        if self.enable_edit_file_with_create_perm is not None:
            result['enable_edit_file_with_create_perm'] = self.enable_edit_file_with_create_perm
        if self.enable_hidden_file is not None:
            result['enable_hidden_file'] = self.enable_hidden_file
        if self.enable_share_link_count_limit is not None:
            result['enable_share_link_count_limit'] = self.enable_share_link_count_limit
        if self.enable_sse_oss is not None:
            result['enable_sse_oss'] = self.enable_sse_oss
        if self.enable_transfer_acceleration is not None:
            result['enable_transfer_acceleration'] = self.enable_transfer_acceleration
        if self.enable_update_share_link_by_admin is not None:
            result['enable_update_share_link_by_admin'] = self.enable_update_share_link_by_admin
        if self.hidden_switch_user_role_entry is not None:
            result['hidden_switch_user_role_entry'] = self.hidden_switch_user_role_entry
        if self.hide_admin_entry is not None:
            result['hide_admin_entry'] = self.hide_admin_entry
        if self.hide_client_download_entry is not None:
            result['hide_client_download_entry'] = self.hide_client_download_entry
        if self.hide_drive_file_entry is not None:
            result['hide_drive_file_entry'] = self.hide_drive_file_entry
        if self.hide_logout_entry is not None:
            result['hide_logout_entry'] = self.hide_logout_entry
        if self.hide_share_admin_entry is not None:
            result['hide_share_admin_entry'] = self.hide_share_admin_entry
        if self.hide_sharelink_login is not None:
            result['hide_sharelink_login'] = self.hide_sharelink_login
        if self.hide_user_entry is not None:
            result['hide_user_entry'] = self.hide_user_entry
        if self.mount_app_enable is not None:
            result['mount_app_enable'] = self.mount_app_enable
        if self.same_name_file_upload_mode is not None:
            result['same_name_file_upload_mode'] = self.same_name_file_upload_mode
        if self.share_hide_disabled_user is not None:
            result['share_hide_disabled_user'] = self.share_hide_disabled_user
        if self.share_link_disable_download is not None:
            result['share_link_disable_download'] = self.share_link_disable_download
        if self.share_link_disable_upload is not None:
            result['share_link_disable_upload'] = self.share_link_disable_upload
        if self.share_link_login_access_only is not None:
            result['share_link_login_access_only'] = self.share_link_login_access_only
        if self.show_customized_login_config is not None:
            result['show_customized_login_config'] = self.show_customized_login_config
        if self.single_file_upload_size_limit is not None:
            result['single_file_upload_size_limit'] = self.single_file_upload_size_limit
        if self.sync_app_enable is not None:
            result['sync_app_enable'] = self.sync_app_enable
        if self.user_can_access_group_recycle_bin is not None:
            result['user_can_access_group_recycle_bin'] = self.user_can_access_group_recycle_bin
        if self.video_play_enable is not None:
            result['video_play_enable'] = self.video_play_enable
        if self.web_client_download_mode is not None:
            result['web_client_download_mode'] = self.web_client_download_mode
        if self.web_version is not None:
            result['web_version'] = self.web_version
        if self.white_admin_menu_items is not None:
            result['white_admin_menu_items'] = self.white_admin_menu_items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allow_upload_custom_file_ext_list') is not None:
            self.allow_upload_custom_file_ext_list = m.get('allow_upload_custom_file_ext_list')
        if m.get('allow_upload_file_category_list') is not None:
            self.allow_upload_file_category_list = m.get('allow_upload_file_category_list')
        if m.get('audio_play_enable') is not None:
            self.audio_play_enable = m.get('audio_play_enable')
        if m.get('black_admin_menu_items') is not None:
            self.black_admin_menu_items = m.get('black_admin_menu_items')
        if m.get('custom_account_identity_base_64') is not None:
            self.custom_account_identity_base_64 = m.get('custom_account_identity_base_64')
        if m.get('default_url_expire_sec') is not None:
            self.default_url_expire_sec = m.get('default_url_expire_sec')
        if m.get('disable_client_builder') is not None:
            self.disable_client_builder = m.get('disable_client_builder')
        if m.get('disable_group') is not None:
            self.disable_group = m.get('disable_group')
        if m.get('enable_edit_file_with_create_perm') is not None:
            self.enable_edit_file_with_create_perm = m.get('enable_edit_file_with_create_perm')
        if m.get('enable_hidden_file') is not None:
            self.enable_hidden_file = m.get('enable_hidden_file')
        if m.get('enable_share_link_count_limit') is not None:
            self.enable_share_link_count_limit = m.get('enable_share_link_count_limit')
        if m.get('enable_sse_oss') is not None:
            self.enable_sse_oss = m.get('enable_sse_oss')
        if m.get('enable_transfer_acceleration') is not None:
            self.enable_transfer_acceleration = m.get('enable_transfer_acceleration')
        if m.get('enable_update_share_link_by_admin') is not None:
            self.enable_update_share_link_by_admin = m.get('enable_update_share_link_by_admin')
        if m.get('hidden_switch_user_role_entry') is not None:
            self.hidden_switch_user_role_entry = m.get('hidden_switch_user_role_entry')
        if m.get('hide_admin_entry') is not None:
            self.hide_admin_entry = m.get('hide_admin_entry')
        if m.get('hide_client_download_entry') is not None:
            self.hide_client_download_entry = m.get('hide_client_download_entry')
        if m.get('hide_drive_file_entry') is not None:
            self.hide_drive_file_entry = m.get('hide_drive_file_entry')
        if m.get('hide_logout_entry') is not None:
            self.hide_logout_entry = m.get('hide_logout_entry')
        if m.get('hide_share_admin_entry') is not None:
            self.hide_share_admin_entry = m.get('hide_share_admin_entry')
        if m.get('hide_sharelink_login') is not None:
            self.hide_sharelink_login = m.get('hide_sharelink_login')
        if m.get('hide_user_entry') is not None:
            self.hide_user_entry = m.get('hide_user_entry')
        if m.get('mount_app_enable') is not None:
            self.mount_app_enable = m.get('mount_app_enable')
        if m.get('same_name_file_upload_mode') is not None:
            self.same_name_file_upload_mode = m.get('same_name_file_upload_mode')
        if m.get('share_hide_disabled_user') is not None:
            self.share_hide_disabled_user = m.get('share_hide_disabled_user')
        if m.get('share_link_disable_download') is not None:
            self.share_link_disable_download = m.get('share_link_disable_download')
        if m.get('share_link_disable_upload') is not None:
            self.share_link_disable_upload = m.get('share_link_disable_upload')
        if m.get('share_link_login_access_only') is not None:
            self.share_link_login_access_only = m.get('share_link_login_access_only')
        if m.get('show_customized_login_config') is not None:
            self.show_customized_login_config = m.get('show_customized_login_config')
        if m.get('single_file_upload_size_limit') is not None:
            self.single_file_upload_size_limit = m.get('single_file_upload_size_limit')
        if m.get('sync_app_enable') is not None:
            self.sync_app_enable = m.get('sync_app_enable')
        if m.get('user_can_access_group_recycle_bin') is not None:
            self.user_can_access_group_recycle_bin = m.get('user_can_access_group_recycle_bin')
        if m.get('video_play_enable') is not None:
            self.video_play_enable = m.get('video_play_enable')
        if m.get('web_client_download_mode') is not None:
            self.web_client_download_mode = m.get('web_client_download_mode')
        if m.get('web_version') is not None:
            self.web_version = m.get('web_version')
        if m.get('white_admin_menu_items') is not None:
            self.white_admin_menu_items = m.get('white_admin_menu_items')
        return self


class ArchiveConfig(TeaModel):
    """
    ArchiveConfig 在线解压配置（可选配置，默认开启，未配置的role默认为AliyunPDSCloudUncompressRole）
    """
    def __init__(
        self,
        archive_files_max_size: int = None,
        enabled: bool = None,
        role: str = None,
        uncompress_file_max_size: int = None,
    ):
        self.archive_files_max_size = archive_files_max_size
        self.enabled = enabled
        self.role = role
        self.uncompress_file_max_size = uncompress_file_max_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_files_max_size is not None:
            result['archive_files_max_size'] = self.archive_files_max_size
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.role is not None:
            result['role'] = self.role
        if self.uncompress_file_max_size is not None:
            result['uncompress_file_max_size'] = self.uncompress_file_max_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archive_files_max_size') is not None:
            self.archive_files_max_size = m.get('archive_files_max_size')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('uncompress_file_max_size') is not None:
            self.uncompress_file_max_size = m.get('uncompress_file_max_size')
        return self


class AssignRoleSettingDetail(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        manage_resource_id: str = None,
        manage_resource_name: str = None,
        manage_resource_type: str = None,
        role_id: str = None,
    ):
        # manage_resource_id
        self.manage_resource_id = manage_resource_id
        # manage_resource_name
        self.manage_resource_name = manage_resource_name
        # manage_resource_type
        self.manage_resource_type = manage_resource_type
        # role_id
        self.role_id = role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.manage_resource_id is not None:
            result['manage_resource_id'] = self.manage_resource_id
        if self.manage_resource_name is not None:
            result['manage_resource_name'] = self.manage_resource_name
        if self.manage_resource_type is not None:
            result['manage_resource_type'] = self.manage_resource_type
        if self.role_id is not None:
            result['role_id'] = self.role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('manage_resource_id') is not None:
            self.manage_resource_id = m.get('manage_resource_id')
        if m.get('manage_resource_name') is not None:
            self.manage_resource_name = m.get('manage_resource_name')
        if m.get('manage_resource_type') is not None:
            self.manage_resource_type = m.get('manage_resource_type')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        return self


class AsyncTaskResponse(TeaModel):
    """
    Get AsyncTask Response
    """
    def __init__(
        self,
        async_task_id: str = None,
        created_at: int = None,
        err_code: int = None,
        message: str = None,
        state: str = None,
        type: str = None,
    ):
        # async_task_id
        # type:string
        self.async_task_id = async_task_id
        # created_at
        self.created_at = created_at
        # err_code
        self.err_code = err_code
        # message
        self.message = message
        # state
        self.state = state
        # type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['async_task_id'] = self.async_task_id
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.err_code is not None:
            result['err_code'] = self.err_code
        if self.message is not None:
            result['message'] = self.message
        if self.state is not None:
            result['state'] = self.state
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('async_task_id') is not None:
            self.async_task_id = m.get('async_task_id')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('err_code') is not None:
            self.err_code = m.get('err_code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AuditLogConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        active_log_keep_days: int = None,
        enabled: bool = None,
        redirect_enabled: bool = None,
    ):
        self.active_log_keep_days = active_log_keep_days
        self.enabled = enabled
        self.redirect_enabled = redirect_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_log_keep_days is not None:
            result['active_log_keep_days'] = self.active_log_keep_days
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.redirect_enabled is not None:
            result['redirect_enabled'] = self.redirect_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('active_log_keep_days') is not None:
            self.active_log_keep_days = m.get('active_log_keep_days')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('redirect_enabled') is not None:
            self.redirect_enabled = m.get('redirect_enabled')
        return self


class BaseAuditLogRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        order_by: str = None,
        query: str = None,
    ):
        # order_by
        self.order_by = order_by
        # query
        self.query = query

    def validate(self):
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        return self


class DomainSuperAdminConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        extra: str = None,
        identity: str = None,
        phone_number: str = None,
        phone_region: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.extra = extra
        self.identity = identity
        self.phone_number = phone_number
        self.phone_region = phone_region
        self.type = type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.phone_number is not None:
            result['phone_number'] = self.phone_number
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('phone_number') is not None:
            self.phone_number = m.get('phone_number')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class BaseStoreInfoResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bucket: str = None,
        customized_endpoint: str = None,
        endpoint: str = None,
        ownership: str = None,
        store_id: str = None,
        transfer_acc_enabled: bool = None,
        type: str = None,
    ):
        # bucket名称
        self.bucket = bucket
        # 自定义Public访问地址
        self.customized_endpoint = customized_endpoint
        # Public访问地址
        self.endpoint = endpoint
        # 存储归属，system表示系统提供，custom表示使用自己的存储
        self.ownership = ownership
        # store ID
        self.store_id = store_id
        # 是否开启传输加速
        self.transfer_acc_enabled = transfer_acc_enabled
        # 存储类型，当前只支持oss
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['bucket'] = self.bucket
        if self.customized_endpoint is not None:
            result['customized_endpoint'] = self.customized_endpoint
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.ownership is not None:
            result['ownership'] = self.ownership
        if self.store_id is not None:
            result['store_id'] = self.store_id
        if self.transfer_acc_enabled is not None:
            result['transfer_acc_enabled'] = self.transfer_acc_enabled
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bucket') is not None:
            self.bucket = m.get('bucket')
        if m.get('customized_endpoint') is not None:
            self.customized_endpoint = m.get('customized_endpoint')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('ownership') is not None:
            self.ownership = m.get('ownership')
        if m.get('store_id') is not None:
            self.store_id = m.get('store_id')
        if m.get('transfer_acc_enabled') is not None:
            self.transfer_acc_enabled = m.get('transfer_acc_enabled')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DomainEndpointsResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        api_endpoint: str = None,
        api_vpc_endpoint: str = None,
        app_endpoint: str = None,
        auth_endpoint: str = None,
        mgmt_endpoint: str = None,
        store_list: List[BaseStoreInfoResponse] = None,
        va_store_list: List[BaseStoreInfoResponse] = None,
        web_office_endpoint_list: List[str] = None,
    ):
        self.api_endpoint = api_endpoint
        self.api_vpc_endpoint = api_vpc_endpoint
        self.app_endpoint = app_endpoint
        self.auth_endpoint = auth_endpoint
        self.mgmt_endpoint = mgmt_endpoint
        self.store_list = store_list
        self.va_store_list = va_store_list
        self.web_office_endpoint_list = web_office_endpoint_list

    def validate(self):
        if self.store_list:
            for k in self.store_list:
                if k:
                    k.validate()
        if self.va_store_list:
            for k in self.va_store_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_endpoint is not None:
            result['api_endpoint'] = self.api_endpoint
        if self.api_vpc_endpoint is not None:
            result['api_vpc_endpoint'] = self.api_vpc_endpoint
        if self.app_endpoint is not None:
            result['app_endpoint'] = self.app_endpoint
        if self.auth_endpoint is not None:
            result['auth_endpoint'] = self.auth_endpoint
        if self.mgmt_endpoint is not None:
            result['mgmt_endpoint'] = self.mgmt_endpoint
        result['store_list'] = []
        if self.store_list is not None:
            for k in self.store_list:
                result['store_list'].append(k.to_map() if k else None)
        result['va_store_list'] = []
        if self.va_store_list is not None:
            for k in self.va_store_list:
                result['va_store_list'].append(k.to_map() if k else None)
        if self.web_office_endpoint_list is not None:
            result['web_office_endpoint_list'] = self.web_office_endpoint_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_endpoint') is not None:
            self.api_endpoint = m.get('api_endpoint')
        if m.get('api_vpc_endpoint') is not None:
            self.api_vpc_endpoint = m.get('api_vpc_endpoint')
        if m.get('app_endpoint') is not None:
            self.app_endpoint = m.get('app_endpoint')
        if m.get('auth_endpoint') is not None:
            self.auth_endpoint = m.get('auth_endpoint')
        if m.get('mgmt_endpoint') is not None:
            self.mgmt_endpoint = m.get('mgmt_endpoint')
        self.store_list = []
        if m.get('store_list') is not None:
            for k in m.get('store_list'):
                temp_model = BaseStoreInfoResponse()
                self.store_list.append(temp_model.from_map(k))
        self.va_store_list = []
        if m.get('va_store_list') is not None:
            for k in m.get('va_store_list'):
                temp_model = BaseStoreInfoResponse()
                self.va_store_list.append(temp_model.from_map(k))
        if m.get('web_office_endpoint_list') is not None:
            self.web_office_endpoint_list = m.get('web_office_endpoint_list')
        return self


class GroupConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        auto_add_root_group_enabled: bool = None,
        max_level: int = None,
        root_group_id: str = None,
    ):
        self.auto_add_root_group_enabled = auto_add_root_group_enabled
        self.max_level = max_level
        self.root_group_id = root_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_add_root_group_enabled is not None:
            result['auto_add_root_group_enabled'] = self.auto_add_root_group_enabled
        if self.max_level is not None:
            result['max_level'] = self.max_level
        if self.root_group_id is not None:
            result['root_group_id'] = self.root_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auto_add_root_group_enabled') is not None:
            self.auto_add_root_group_enabled = m.get('auto_add_root_group_enabled')
        if m.get('max_level') is not None:
            self.max_level = m.get('max_level')
        if m.get('root_group_id') is not None:
            self.root_group_id = m.get('root_group_id')
        return self


class BaseMultiRevisionConfigResponse(TeaModel):
    """
    base multi revision config response
    """
    def __init__(
        self,
        enabled: bool = None,
        revision_count: int = None,
        revision_merge_enabled: bool = None,
        revision_recycle_period: int = None,
    ):
        self.enabled = enabled
        self.revision_count = revision_count
        self.revision_merge_enabled = revision_merge_enabled
        self.revision_recycle_period = revision_recycle_period

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.revision_count is not None:
            result['revision_count'] = self.revision_count
        if self.revision_merge_enabled is not None:
            result['revision_merge_enabled'] = self.revision_merge_enabled
        if self.revision_recycle_period is not None:
            result['revision_recycle_period'] = self.revision_recycle_period
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('revision_count') is not None:
            self.revision_count = m.get('revision_count')
        if m.get('revision_merge_enabled') is not None:
            self.revision_merge_enabled = m.get('revision_merge_enabled')
        if m.get('revision_recycle_period') is not None:
            self.revision_recycle_period = m.get('revision_recycle_period')
        return self


class OfficeEditConfig(TeaModel):
    """
    OfficeEditConfig 文档编辑配置
    """
    def __init__(
        self,
        cross_region_pds_endpoint: str = None,
        disable_print: bool = None,
        enabled: bool = None,
        encode_user_id: bool = None,
        role: str = None,
    ):
        self.cross_region_pds_endpoint = cross_region_pds_endpoint
        self.disable_print = disable_print
        self.enabled = enabled
        self.encode_user_id = encode_user_id
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cross_region_pds_endpoint is not None:
            result['cross_region_pds_endpoint'] = self.cross_region_pds_endpoint
        if self.disable_print is not None:
            result['disable_print'] = self.disable_print
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.encode_user_id is not None:
            result['encode_user_id'] = self.encode_user_id
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cross_region_pds_endpoint') is not None:
            self.cross_region_pds_endpoint = m.get('cross_region_pds_endpoint')
        if m.get('disable_print') is not None:
            self.disable_print = m.get('disable_print')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('encode_user_id') is not None:
            self.encode_user_id = m.get('encode_user_id')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class OfficePreviewConfig(TeaModel):
    """
    OfficePreviewConfig 文档预览配置
    """
    def __init__(
        self,
        disable_print: bool = None,
        enabled: bool = None,
    ):
        self.disable_print = disable_print
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_print is not None:
            result['disable_print'] = self.disable_print
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable_print') is not None:
            self.disable_print = m.get('disable_print')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class RecycleBinConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        auto_delete_enabled: bool = None,
        auto_delete_keep_second: int = None,
        delete_trash_normal_file_disabled: bool = None,
    ):
        self.auto_delete_enabled = auto_delete_enabled
        self.auto_delete_keep_second = auto_delete_keep_second
        self.delete_trash_normal_file_disabled = delete_trash_normal_file_disabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_delete_enabled is not None:
            result['auto_delete_enabled'] = self.auto_delete_enabled
        if self.auto_delete_keep_second is not None:
            result['auto_delete_keep_second'] = self.auto_delete_keep_second
        if self.delete_trash_normal_file_disabled is not None:
            result['delete_trash_normal_file_disabled'] = self.delete_trash_normal_file_disabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auto_delete_enabled') is not None:
            self.auto_delete_enabled = m.get('auto_delete_enabled')
        if m.get('auto_delete_keep_second') is not None:
            self.auto_delete_keep_second = m.get('auto_delete_keep_second')
        if m.get('delete_trash_normal_file_disabled') is not None:
            self.delete_trash_normal_file_disabled = m.get('delete_trash_normal_file_disabled')
        return self


class RoleConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        default_group_drive_inherit_sub_group: bool = None,
        default_group_drive_role: str = None,
        disabled_admin_file_permission: bool = None,
        enabled: bool = None,
        enabled_admin_delete_personal_file_permission: bool = None,
        enabled_admin_personal_file_permission: bool = None,
    ):
        self.default_group_drive_inherit_sub_group = default_group_drive_inherit_sub_group
        self.default_group_drive_role = default_group_drive_role
        self.disabled_admin_file_permission = disabled_admin_file_permission
        self.enabled = enabled
        self.enabled_admin_delete_personal_file_permission = enabled_admin_delete_personal_file_permission
        self.enabled_admin_personal_file_permission = enabled_admin_personal_file_permission

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_group_drive_inherit_sub_group is not None:
            result['default_group_drive_inherit_sub_group'] = self.default_group_drive_inherit_sub_group
        if self.default_group_drive_role is not None:
            result['default_group_drive_role'] = self.default_group_drive_role
        if self.disabled_admin_file_permission is not None:
            result['disabled_admin_file_permission'] = self.disabled_admin_file_permission
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.enabled_admin_delete_personal_file_permission is not None:
            result['enabled_admin_delete_personal_file_permission'] = self.enabled_admin_delete_personal_file_permission
        if self.enabled_admin_personal_file_permission is not None:
            result['enabled_admin_personal_file_permission'] = self.enabled_admin_personal_file_permission
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_group_drive_inherit_sub_group') is not None:
            self.default_group_drive_inherit_sub_group = m.get('default_group_drive_inherit_sub_group')
        if m.get('default_group_drive_role') is not None:
            self.default_group_drive_role = m.get('default_group_drive_role')
        if m.get('disabled_admin_file_permission') is not None:
            self.disabled_admin_file_permission = m.get('disabled_admin_file_permission')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('enabled_admin_delete_personal_file_permission') is not None:
            self.enabled_admin_delete_personal_file_permission = m.get('enabled_admin_delete_personal_file_permission')
        if m.get('enabled_admin_personal_file_permission') is not None:
            self.enabled_admin_personal_file_permission = m.get('enabled_admin_personal_file_permission')
        return self


class SubdomainConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enable_root_domain_create_resource: bool = None,
        enabled: bool = None,
        independent_store_count_quota: int = None,
        subdomain_count_quota: int = None,
        version: str = None,
    ):
        self.enable_root_domain_create_resource = enable_root_domain_create_resource
        self.enabled = enabled
        self.independent_store_count_quota = independent_store_count_quota
        self.subdomain_count_quota = subdomain_count_quota
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_root_domain_create_resource is not None:
            result['enable_root_domain_create_resource'] = self.enable_root_domain_create_resource
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.independent_store_count_quota is not None:
            result['independent_store_count_quota'] = self.independent_store_count_quota
        if self.subdomain_count_quota is not None:
            result['subdomain_count_quota'] = self.subdomain_count_quota
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable_root_domain_create_resource') is not None:
            self.enable_root_domain_create_resource = m.get('enable_root_domain_create_resource')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('independent_store_count_quota') is not None:
            self.independent_store_count_quota = m.get('independent_store_count_quota')
        if m.get('subdomain_count_quota') is not None:
            self.subdomain_count_quota = m.get('subdomain_count_quota')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class VideoPreviewAppConfig(TeaModel):
    """
    if OnlineVideoTranscodeEnable then do video_preview play  // 如果是离线转码, 那么用OfflineVideoTranscodeEnable代替, 音频类似
    else if appConfig.VideoPlayEnable then do source file play // 音频用AudioPlayEnable代替
    else notify user the function not support
    """
    def __init__(
        self,
        offline_audio_transcode_enable: bool = None,
        offline_video_transcode_enable: bool = None,
        online_audio_transcode_enable: bool = None,
        online_video_transcode_enable: bool = None,
    ):
        self.offline_audio_transcode_enable = offline_audio_transcode_enable
        self.offline_video_transcode_enable = offline_video_transcode_enable
        self.online_audio_transcode_enable = online_audio_transcode_enable
        self.online_video_transcode_enable = online_video_transcode_enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.offline_audio_transcode_enable is not None:
            result['offline_audio_transcode_enable'] = self.offline_audio_transcode_enable
        if self.offline_video_transcode_enable is not None:
            result['offline_video_transcode_enable'] = self.offline_video_transcode_enable
        if self.online_audio_transcode_enable is not None:
            result['online_audio_transcode_enable'] = self.online_audio_transcode_enable
        if self.online_video_transcode_enable is not None:
            result['online_video_transcode_enable'] = self.online_video_transcode_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('offline_audio_transcode_enable') is not None:
            self.offline_audio_transcode_enable = m.get('offline_audio_transcode_enable')
        if m.get('offline_video_transcode_enable') is not None:
            self.offline_video_transcode_enable = m.get('offline_video_transcode_enable')
        if m.get('online_audio_transcode_enable') is not None:
            self.online_audio_transcode_enable = m.get('online_audio_transcode_enable')
        if m.get('online_video_transcode_enable') is not None:
            self.online_video_transcode_enable = m.get('online_video_transcode_enable')
        return self


class VideoPreviewAudioTemplate(TeaModel):
    """
    音频转码模板
    """
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channel: int = None,
        audio_codec: str = None,
        audio_output_ext: str = None,
        audio_sample_rate: int = None,
        audio_template_id: str = None,
    ):
        self.audio_bitrate = audio_bitrate
        self.audio_channel = audio_channel
        self.audio_codec = audio_codec
        self.audio_output_ext = audio_output_ext
        self.audio_sample_rate = audio_sample_rate
        self.audio_template_id = audio_template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['audio_bitrate'] = self.audio_bitrate
        if self.audio_channel is not None:
            result['audio_channel'] = self.audio_channel
        if self.audio_codec is not None:
            result['audio_codec'] = self.audio_codec
        if self.audio_output_ext is not None:
            result['audio_output_ext'] = self.audio_output_ext
        if self.audio_sample_rate is not None:
            result['audio_sample_rate'] = self.audio_sample_rate
        if self.audio_template_id is not None:
            result['audio_template_id'] = self.audio_template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_bitrate') is not None:
            self.audio_bitrate = m.get('audio_bitrate')
        if m.get('audio_channel') is not None:
            self.audio_channel = m.get('audio_channel')
        if m.get('audio_codec') is not None:
            self.audio_codec = m.get('audio_codec')
        if m.get('audio_output_ext') is not None:
            self.audio_output_ext = m.get('audio_output_ext')
        if m.get('audio_sample_rate') is not None:
            self.audio_sample_rate = m.get('audio_sample_rate')
        if m.get('audio_template_id') is not None:
            self.audio_template_id = m.get('audio_template_id')
        return self


class VideoPreviewAudioConfig(TeaModel):
    """
    音频转码配置
    """
    def __init__(
        self,
        support_ext: List[str] = None,
        template: List[VideoPreviewAudioTemplate] = None,
    ):
        self.support_ext = support_ext
        self.template = template

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.support_ext is not None:
            result['support_ext'] = self.support_ext
        result['template'] = []
        if self.template is not None:
            for k in self.template:
                result['template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('support_ext') is not None:
            self.support_ext = m.get('support_ext')
        self.template = []
        if m.get('template') is not None:
            for k in m.get('template'):
                temp_model = VideoPreviewAudioTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class VideoPreviewThumbnailConfig(TeaModel):
    """
    截图配置
    """
    def __init__(
        self,
        skip_begin_percent: str = None,
        skip_begin_sec: float = None,
    ):
        self.skip_begin_percent = skip_begin_percent
        self.skip_begin_sec = skip_begin_sec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.skip_begin_percent is not None:
            result['skip_begin_percent'] = self.skip_begin_percent
        if self.skip_begin_sec is not None:
            result['skip_begin_sec'] = self.skip_begin_sec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('skip_begin_percent') is not None:
            self.skip_begin_percent = m.get('skip_begin_percent')
        if m.get('skip_begin_sec') is not None:
            self.skip_begin_sec = m.get('skip_begin_sec')
        return self


class VideoPreviewAutoCategoryConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        default_audio_category: str = None,
        default_video_category: str = None,
    ):
        self.default_audio_category = default_audio_category
        self.default_video_category = default_video_category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_audio_category is not None:
            result['default_audio_category'] = self.default_audio_category
        if self.default_video_category is not None:
            result['default_video_category'] = self.default_video_category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_audio_category') is not None:
            self.default_audio_category = m.get('default_audio_category')
        if m.get('default_video_category') is not None:
            self.default_video_category = m.get('default_video_category')
        return self


class VideoPreviewBackupConfig(TeaModel):
    """
    转码备份配置（当前仅运维会用到）
    """
    def __init__(
        self,
        count_once: int = None,
        store: Store = None,
        store_id_map: dict = None,
    ):
        self.count_once = count_once
        self.store = store
        self.store_id_map = store_id_map

    def validate(self):
        if self.store:
            self.store.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count_once is not None:
            result['count_once'] = self.count_once
        if self.store is not None:
            result['store'] = self.store.to_map()
        if self.store_id_map is not None:
            result['store_id_map'] = self.store_id_map
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count_once') is not None:
            self.count_once = m.get('count_once')
        if m.get('store') is not None:
            temp_model = Store()
            self.store = temp_model.from_map(m['store'])
        if m.get('store_id_map') is not None:
            self.store_id_map = m.get('store_id_map')
        return self


class VideoPreviewCdnConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        cache_store: Store = None,
        enable_m3u_8cache: bool = None,
        enabled: bool = None,
        gray_config: ApiConfig = None,
    ):
        self.cache_store = cache_store
        self.enable_m3u_8cache = enable_m3u_8cache
        self.enabled = enabled
        self.gray_config = gray_config

    def validate(self):
        if self.cache_store:
            self.cache_store.validate()
        if self.gray_config:
            self.gray_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cache_store is not None:
            result['cache_store'] = self.cache_store.to_map()
        if self.enable_m3u_8cache is not None:
            result['enable_m3u8_cache'] = self.enable_m3u_8cache
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.gray_config is not None:
            result['gray_config'] = self.gray_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cache_store') is not None:
            temp_model = Store()
            self.cache_store = temp_model.from_map(m['cache_store'])
        if m.get('enable_m3u8_cache') is not None:
            self.enable_m3u_8cache = m.get('enable_m3u8_cache')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('gray_config') is not None:
            temp_model = ApiConfig()
            self.gray_config = temp_model.from_map(m['gray_config'])
        return self


class VideoPreviewDrmConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        region: str = None,
    ):
        self.region = region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region is not None:
            result['region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('region') is not None:
            self.region = m.get('region')
        return self


class VideoPreviewEnableConfig(TeaModel):
    """
    转码子开关配置
    """
    def __init__(
        self,
        disable_offline_audio_transcode: bool = None,
        disable_offline_video_transcode: bool = None,
        enable_role_chain: bool = None,
        enable_transcode_when_play: bool = None,
        enable_transcode_when_uploaded: bool = None,
    ):
        self.disable_offline_audio_transcode = disable_offline_audio_transcode
        self.disable_offline_video_transcode = disable_offline_video_transcode
        self.enable_role_chain = enable_role_chain
        # Deprecated, 后续通过 VideoPreviewNeedTranscodeErrorMap 来判断是否允许重新转码
        self.enable_transcode_when_play = enable_transcode_when_play
        self.enable_transcode_when_uploaded = enable_transcode_when_uploaded

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_offline_audio_transcode is not None:
            result['disable_offline_audio_transcode'] = self.disable_offline_audio_transcode
        if self.disable_offline_video_transcode is not None:
            result['disable_offline_video_transcode'] = self.disable_offline_video_transcode
        if self.enable_role_chain is not None:
            result['enable_role_chain'] = self.enable_role_chain
        if self.enable_transcode_when_play is not None:
            result['enable_transcode_when_play'] = self.enable_transcode_when_play
        if self.enable_transcode_when_uploaded is not None:
            result['enable_transcode_when_uploaded'] = self.enable_transcode_when_uploaded
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable_offline_audio_transcode') is not None:
            self.disable_offline_audio_transcode = m.get('disable_offline_audio_transcode')
        if m.get('disable_offline_video_transcode') is not None:
            self.disable_offline_video_transcode = m.get('disable_offline_video_transcode')
        if m.get('enable_role_chain') is not None:
            self.enable_role_chain = m.get('enable_role_chain')
        if m.get('enable_transcode_when_play') is not None:
            self.enable_transcode_when_play = m.get('enable_transcode_when_play')
        if m.get('enable_transcode_when_uploaded') is not None:
            self.enable_transcode_when_uploaded = m.get('enable_transcode_when_uploaded')
        return self


class VideoPreviewHlsSignParamsConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        disable_headers: bool = None,
        enabled: bool = None,
        gray_config: ApiConfig = None,
    ):
        self.disable_headers = disable_headers
        self.enabled = enabled
        self.gray_config = gray_config

    def validate(self):
        if self.gray_config:
            self.gray_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_headers is not None:
            result['disable_headers'] = self.disable_headers
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.gray_config is not None:
            result['gray_config'] = self.gray_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable_headers') is not None:
            self.disable_headers = m.get('disable_headers')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('gray_config') is not None:
            temp_model = ApiConfig()
            self.gray_config = temp_model.from_map(m['gray_config'])
        return self


class VideoPreviewLiveTranscodingEnableConfig(TeaModel):
    """
    实时转码子开关配置
    """
    def __init__(
        self,
        disable_live_transcode: bool = None,
        drop_file_created_event: bool = None,
        enable_dump_old_m3u_8task_info: bool = None,
        enable_ignore_copied_file: bool = None,
    ):
        self.disable_live_transcode = disable_live_transcode
        self.drop_file_created_event = drop_file_created_event
        self.enable_dump_old_m3u_8task_info = enable_dump_old_m3u_8task_info
        self.enable_ignore_copied_file = enable_ignore_copied_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable_live_transcode is not None:
            result['disable_live_transcode'] = self.disable_live_transcode
        if self.drop_file_created_event is not None:
            result['drop_file_created_event'] = self.drop_file_created_event
        if self.enable_dump_old_m3u_8task_info is not None:
            result['enable_dump_old_m3u8_task_info'] = self.enable_dump_old_m3u_8task_info
        if self.enable_ignore_copied_file is not None:
            result['enable_ignore_copied_file'] = self.enable_ignore_copied_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable_live_transcode') is not None:
            self.disable_live_transcode = m.get('disable_live_transcode')
        if m.get('drop_file_created_event') is not None:
            self.drop_file_created_event = m.get('drop_file_created_event')
        if m.get('enable_dump_old_m3u8_task_info') is not None:
            self.enable_dump_old_m3u_8task_info = m.get('enable_dump_old_m3u8_task_info')
        if m.get('enable_ignore_copied_file') is not None:
            self.enable_ignore_copied_file = m.get('enable_ignore_copied_file')
        return self


class VideoPreviewLiveTranscodingRefTaskConfig(TeaModel):
    """
    实时转码refTask配置
    """
    def __init__(
        self,
        duration: float = None,
        enabled: bool = None,
    ):
        self.duration = duration
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['duration'] = self.duration
        if self.enabled is not None:
            result['enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        return self


class VideoPreviewLiveTranscodingSubtitleConfig(TeaModel):
    """
    实时转码字幕配置
    """
    def __init__(
        self,
        enabled: bool = None,
        extract_format: str = None,
        subtitle_lang_list: List[str] = None,
    ):
        self.enabled = enabled
        self.extract_format = extract_format
        self.subtitle_lang_list = subtitle_lang_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.extract_format is not None:
            result['extract_format'] = self.extract_format
        if self.subtitle_lang_list is not None:
            result['subtitle_lang_list'] = self.subtitle_lang_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('extract_format') is not None:
            self.extract_format = m.get('extract_format')
        if m.get('subtitle_lang_list') is not None:
            self.subtitle_lang_list = m.get('subtitle_lang_list')
        return self


class VideoPreviewLiveTranscodingConfig(TeaModel):
    """
    实时转码配置
    """
    def __init__(
        self,
        current_version: int = None,
        deprecated_version: int = None,
        detail_count_limit: int = None,
        enable_config: VideoPreviewLiveTranscodingEnableConfig = None,
        enabled: bool = None,
        ignore_template_list: List[str] = None,
        leading_prefix: str = None,
        m_3u_8file_prefix: str = None,
        media_duration_limit: float = None,
        ref_task_config: VideoPreviewLiveTranscodingRefTaskConfig = None,
        segment: int = None,
        subtitle_config: VideoPreviewLiveTranscodingSubtitleConfig = None,
        template_list: List[str] = None,
        template_list_sorted: List[str] = None,
        template_name_map: dict = None,
        ts_count_when_init_m3u_8: int = None,
        ts_count_when_ts_404: int = None,
        ts_file_prefix: str = None,
    ):
        self.current_version = current_version
        self.deprecated_version = deprecated_version
        self.detail_count_limit = detail_count_limit
        self.enable_config = enable_config
        self.enabled = enabled
        self.ignore_template_list = ignore_template_list
        self.leading_prefix = leading_prefix
        self.m_3u_8file_prefix = m_3u_8file_prefix
        self.media_duration_limit = media_duration_limit
        self.ref_task_config = ref_task_config
        self.segment = segment
        self.subtitle_config = subtitle_config
        self.template_list = template_list
        self.template_list_sorted = template_list_sorted
        self.template_name_map = template_name_map
        # Mode              string   `json:"mode"`               // 默认media模式
        # 以下几个count需要根据task的status和stage来判断, 当前实时转码的状态
        self.ts_count_when_init_m3u_8 = ts_count_when_init_m3u_8
        self.ts_count_when_ts_404 = ts_count_when_ts_404
        self.ts_file_prefix = ts_file_prefix

    def validate(self):
        if self.enable_config:
            self.enable_config.validate()
        if self.ref_task_config:
            self.ref_task_config.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_version is not None:
            result['current_version'] = self.current_version
        if self.deprecated_version is not None:
            result['deprecated_version'] = self.deprecated_version
        if self.detail_count_limit is not None:
            result['detail_count_limit'] = self.detail_count_limit
        if self.enable_config is not None:
            result['enable_config'] = self.enable_config.to_map()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.ignore_template_list is not None:
            result['ignore_template_list'] = self.ignore_template_list
        if self.leading_prefix is not None:
            result['leading_prefix'] = self.leading_prefix
        if self.m_3u_8file_prefix is not None:
            result['m3u8_file_prefix'] = self.m_3u_8file_prefix
        if self.media_duration_limit is not None:
            result['media_duration_limit'] = self.media_duration_limit
        if self.ref_task_config is not None:
            result['ref_task_config'] = self.ref_task_config.to_map()
        if self.segment is not None:
            result['segment'] = self.segment
        if self.subtitle_config is not None:
            result['subtitle_config'] = self.subtitle_config.to_map()
        if self.template_list is not None:
            result['template_list'] = self.template_list
        if self.template_list_sorted is not None:
            result['template_list_sorted'] = self.template_list_sorted
        if self.template_name_map is not None:
            result['template_name_map'] = self.template_name_map
        if self.ts_count_when_init_m3u_8 is not None:
            result['ts_count_when_init_m3u8'] = self.ts_count_when_init_m3u_8
        if self.ts_count_when_ts_404 is not None:
            result['ts_count_when_ts_404'] = self.ts_count_when_ts_404
        if self.ts_file_prefix is not None:
            result['ts_file_prefix'] = self.ts_file_prefix
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current_version') is not None:
            self.current_version = m.get('current_version')
        if m.get('deprecated_version') is not None:
            self.deprecated_version = m.get('deprecated_version')
        if m.get('detail_count_limit') is not None:
            self.detail_count_limit = m.get('detail_count_limit')
        if m.get('enable_config') is not None:
            temp_model = VideoPreviewLiveTranscodingEnableConfig()
            self.enable_config = temp_model.from_map(m['enable_config'])
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('ignore_template_list') is not None:
            self.ignore_template_list = m.get('ignore_template_list')
        if m.get('leading_prefix') is not None:
            self.leading_prefix = m.get('leading_prefix')
        if m.get('m3u8_file_prefix') is not None:
            self.m_3u_8file_prefix = m.get('m3u8_file_prefix')
        if m.get('media_duration_limit') is not None:
            self.media_duration_limit = m.get('media_duration_limit')
        if m.get('ref_task_config') is not None:
            temp_model = VideoPreviewLiveTranscodingRefTaskConfig()
            self.ref_task_config = temp_model.from_map(m['ref_task_config'])
        if m.get('segment') is not None:
            self.segment = m.get('segment')
        if m.get('subtitle_config') is not None:
            temp_model = VideoPreviewLiveTranscodingSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['subtitle_config'])
        if m.get('template_list') is not None:
            self.template_list = m.get('template_list')
        if m.get('template_list_sorted') is not None:
            self.template_list_sorted = m.get('template_list_sorted')
        if m.get('template_name_map') is not None:
            self.template_name_map = m.get('template_name_map')
        if m.get('ts_count_when_init_m3u8') is not None:
            self.ts_count_when_init_m3u_8 = m.get('ts_count_when_init_m3u8')
        if m.get('ts_count_when_ts_404') is not None:
            self.ts_count_when_ts_404 = m.get('ts_count_when_ts_404')
        if m.get('ts_file_prefix') is not None:
            self.ts_file_prefix = m.get('ts_file_prefix')
        return self


class VideoPreviewQuickVideoInitialTsConfig(TeaModel):
    """
    快速起播配置
    """
    def __init__(
        self,
        initial_duration: float = None,
        initial_ts_list: List[int] = None,
    ):
        self.initial_duration = initial_duration
        self.initial_ts_list = initial_ts_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.initial_duration is not None:
            result['initial_duration'] = self.initial_duration
        if self.initial_ts_list is not None:
            result['initial_ts_list'] = self.initial_ts_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('initial_duration') is not None:
            self.initial_duration = m.get('initial_duration')
        if m.get('initial_ts_list') is not None:
            self.initial_ts_list = m.get('initial_ts_list')
        return self


class VideoPreviewQuickVideoConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        current_version: int = None,
        deprecated_version: int = None,
        enable_config: VideoPreviewLiveTranscodingEnableConfig = None,
        enabled: bool = None,
        initial_ts_config: VideoPreviewQuickVideoInitialTsConfig = None,
        leading_prefix: str = None,
        m_3u_8file_prefix: str = None,
        segment: int = None,
        subtitle_config: VideoPreviewLiveTranscodingSubtitleConfig = None,
        template_list: List[str] = None,
        template_name_map: dict = None,
        ts_count_when_ts_404: int = None,
    ):
        self.current_version = current_version
        self.deprecated_version = deprecated_version
        self.enable_config = enable_config
        self.enabled = enabled
        self.initial_ts_config = initial_ts_config
        self.leading_prefix = leading_prefix
        self.m_3u_8file_prefix = m_3u_8file_prefix
        self.segment = segment
        self.subtitle_config = subtitle_config
        self.template_list = template_list
        self.template_name_map = template_name_map
        self.ts_count_when_ts_404 = ts_count_when_ts_404

    def validate(self):
        if self.enable_config:
            self.enable_config.validate()
        if self.initial_ts_config:
            self.initial_ts_config.validate()
        if self.subtitle_config:
            self.subtitle_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_version is not None:
            result['current_version'] = self.current_version
        if self.deprecated_version is not None:
            result['deprecated_version'] = self.deprecated_version
        if self.enable_config is not None:
            result['enable_config'] = self.enable_config.to_map()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.initial_ts_config is not None:
            result['initial_ts_config'] = self.initial_ts_config.to_map()
        if self.leading_prefix is not None:
            result['leading_prefix'] = self.leading_prefix
        if self.m_3u_8file_prefix is not None:
            result['m3u8_file_prefix'] = self.m_3u_8file_prefix
        if self.segment is not None:
            result['segment'] = self.segment
        if self.subtitle_config is not None:
            result['subtitle_config'] = self.subtitle_config.to_map()
        if self.template_list is not None:
            result['template_list'] = self.template_list
        if self.template_name_map is not None:
            result['template_name_map'] = self.template_name_map
        if self.ts_count_when_ts_404 is not None:
            result['ts_count_when_ts_404'] = self.ts_count_when_ts_404
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current_version') is not None:
            self.current_version = m.get('current_version')
        if m.get('deprecated_version') is not None:
            self.deprecated_version = m.get('deprecated_version')
        if m.get('enable_config') is not None:
            temp_model = VideoPreviewLiveTranscodingEnableConfig()
            self.enable_config = temp_model.from_map(m['enable_config'])
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('initial_ts_config') is not None:
            temp_model = VideoPreviewQuickVideoInitialTsConfig()
            self.initial_ts_config = temp_model.from_map(m['initial_ts_config'])
        if m.get('leading_prefix') is not None:
            self.leading_prefix = m.get('leading_prefix')
        if m.get('m3u8_file_prefix') is not None:
            self.m_3u_8file_prefix = m.get('m3u8_file_prefix')
        if m.get('segment') is not None:
            self.segment = m.get('segment')
        if m.get('subtitle_config') is not None:
            temp_model = VideoPreviewLiveTranscodingSubtitleConfig()
            self.subtitle_config = temp_model.from_map(m['subtitle_config'])
        if m.get('template_list') is not None:
            self.template_list = m.get('template_list')
        if m.get('template_name_map') is not None:
            self.template_name_map = m.get('template_name_map')
        if m.get('ts_count_when_ts_404') is not None:
            self.ts_count_when_ts_404 = m.get('ts_count_when_ts_404')
        return self


class VideoPreviewRateLimitConfig(TeaModel):
    """
    转码文件下载限速配置
    """
    def __init__(
        self,
        rate_limit: int = None,
    ):
        self.rate_limit = rate_limit

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rate_limit is not None:
            result['rate_limit'] = self.rate_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('rate_limit') is not None:
            self.rate_limit = m.get('rate_limit')
        return self


class VideoPreviewAutoScaleConfig(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        enabled: bool = None,
        max_length: int = None,
    ):
        self.enabled = enabled
        self.max_length = max_length

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.max_length is not None:
            result['max_length'] = self.max_length
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('max_length') is not None:
            self.max_length = m.get('max_length')
        return self


class VideoPreviewSpriteIntervalConfig(TeaModel):
    """
    雪碧图抓图间隔配置。如果配置异常，默认以1%抓图
    """
    def __init__(
        self,
        default_interval: str = None,
        grab_interval_list: List[str] = None,
        upper_limit_list: List[int] = None,
    ):
        self.default_interval = default_interval
        self.grab_interval_list = grab_interval_list
        self.upper_limit_list = upper_limit_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_interval is not None:
            result['default_interval'] = self.default_interval
        if self.grab_interval_list is not None:
            result['grab_interval_list'] = self.grab_interval_list
        if self.upper_limit_list is not None:
            result['upper_limit_list'] = self.upper_limit_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_interval') is not None:
            self.default_interval = m.get('default_interval')
        if m.get('grab_interval_list') is not None:
            self.grab_interval_list = m.get('grab_interval_list')
        if m.get('upper_limit_list') is not None:
            self.upper_limit_list = m.get('upper_limit_list')
        return self


class VideoPreviewSpriteConfig(TeaModel):
    """
    视频雪碧图配置
    """
    def __init__(
        self,
        auto_scale: VideoPreviewAutoScaleConfig = None,
        col: int = None,
        frame_height: int = None,
        frame_width: int = None,
        interval: VideoPreviewSpriteIntervalConfig = None,
        row: int = None,
    ):
        self.auto_scale = auto_scale
        self.col = col
        self.frame_height = frame_height
        self.frame_width = frame_width
        self.interval = interval
        self.row = row

    def validate(self):
        if self.auto_scale:
            self.auto_scale.validate()
        if self.interval:
            self.interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_scale is not None:
            result['auto_scale'] = self.auto_scale.to_map()
        if self.col is not None:
            result['col'] = self.col
        if self.frame_height is not None:
            result['frame_height'] = self.frame_height
        if self.frame_width is not None:
            result['frame_width'] = self.frame_width
        if self.interval is not None:
            result['interval'] = self.interval.to_map()
        if self.row is not None:
            result['row'] = self.row
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auto_scale') is not None:
            temp_model = VideoPreviewAutoScaleConfig()
            self.auto_scale = temp_model.from_map(m['auto_scale'])
        if m.get('col') is not None:
            self.col = m.get('col')
        if m.get('frame_height') is not None:
            self.frame_height = m.get('frame_height')
        if m.get('frame_width') is not None:
            self.frame_width = m.get('frame_width')
        if m.get('interval') is not None:
            temp_model = VideoPreviewSpriteIntervalConfig()
            self.interval = temp_model.from_map(m['interval'])
        if m.get('row') is not None:
            self.row = m.get('row')
        return self


class VideoPreviewTemplatePolicyAliyundriveConfig(TeaModel):
    """
    目前只提供一定的参数化即可, 因为太参数化会让整个代码逻辑过于复杂, 容易留下 bug
    通过 hotfix 升级后台任务实现定制策略优化
    """
    def __init__(
        self,
        pre_transcode_begin_duration: int = None,
    ):
        self.pre_transcode_begin_duration = pre_transcode_begin_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_transcode_begin_duration is not None:
            result['pre_transcode_begin_duration'] = self.pre_transcode_begin_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pre_transcode_begin_duration') is not None:
            self.pre_transcode_begin_duration = m.get('pre_transcode_begin_duration')
        return self


class VideoPreviewTemplatePolicyConfig(TeaModel):
    """
    转码模板选择策略配置
    """
    def __init__(
        self,
        aliyundrive_config: VideoPreviewTemplatePolicyAliyundriveConfig = None,
        policy: str = None,
    ):
        self.aliyundrive_config = aliyundrive_config
        self.policy = policy

    def validate(self):
        if self.aliyundrive_config:
            self.aliyundrive_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyundrive_config is not None:
            result['aliyundrive_config'] = self.aliyundrive_config.to_map()
        if self.policy is not None:
            result['policy'] = self.policy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyundrive_config') is not None:
            temp_model = VideoPreviewTemplatePolicyAliyundriveConfig()
            self.aliyundrive_config = temp_model.from_map(m['aliyundrive_config'])
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        return self


class VideoPreviewM3U8Config(TeaModel):
    """
    hls配置
    """
    def __init__(
        self,
        hls_time: int = None,
    ):
        self.hls_time = hls_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hls_time is not None:
            result['hls_time'] = self.hls_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hls_time') is not None:
            self.hls_time = m.get('hls_time')
        return self


class VideoPreviewVideoTemplate(TeaModel):
    """
    视频转码模板
    """
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channel: int = None,
        audio_codec: str = None,
        audio_sample_rate: int = None,
        height: int = None,
        keep_original: bool = None,
        video_bitrate: int = None,
        video_codec: str = None,
        video_frame_rate: int = None,
        video_output_ext: str = None,
        video_template_id: str = None,
        width: int = None,
    ):
        self.audio_bitrate = audio_bitrate
        self.audio_channel = audio_channel
        self.audio_codec = audio_codec
        self.audio_sample_rate = audio_sample_rate
        self.height = height
        self.keep_original = keep_original
        self.video_bitrate = video_bitrate
        self.video_codec = video_codec
        self.video_frame_rate = video_frame_rate
        self.video_output_ext = video_output_ext
        self.video_template_id = video_template_id
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['audio_bitrate'] = self.audio_bitrate
        if self.audio_channel is not None:
            result['audio_channel'] = self.audio_channel
        if self.audio_codec is not None:
            result['audio_codec'] = self.audio_codec
        if self.audio_sample_rate is not None:
            result['audio_sample_rate'] = self.audio_sample_rate
        if self.height is not None:
            result['height'] = self.height
        if self.keep_original is not None:
            result['keep_original'] = self.keep_original
        if self.video_bitrate is not None:
            result['video_bitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['video_codec'] = self.video_codec
        if self.video_frame_rate is not None:
            result['video_frame_rate'] = self.video_frame_rate
        if self.video_output_ext is not None:
            result['video_output_ext'] = self.video_output_ext
        if self.video_template_id is not None:
            result['video_template_id'] = self.video_template_id
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_bitrate') is not None:
            self.audio_bitrate = m.get('audio_bitrate')
        if m.get('audio_channel') is not None:
            self.audio_channel = m.get('audio_channel')
        if m.get('audio_codec') is not None:
            self.audio_codec = m.get('audio_codec')
        if m.get('audio_sample_rate') is not None:
            self.audio_sample_rate = m.get('audio_sample_rate')
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('keep_original') is not None:
            self.keep_original = m.get('keep_original')
        if m.get('video_bitrate') is not None:
            self.video_bitrate = m.get('video_bitrate')
        if m.get('video_codec') is not None:
            self.video_codec = m.get('video_codec')
        if m.get('video_frame_rate') is not None:
            self.video_frame_rate = m.get('video_frame_rate')
        if m.get('video_output_ext') is not None:
            self.video_output_ext = m.get('video_output_ext')
        if m.get('video_template_id') is not None:
            self.video_template_id = m.get('video_template_id')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoPreviewVideoConfig(TeaModel):
    """
    视频转码配置
    """
    def __init__(
        self,
        default_output_ext: str = None,
        fix_resolution: bool = None,
        keep_original: bool = None,
        m_3u_8config: VideoPreviewM3U8Config = None,
        protection_system: str = None,
        support_ext: List[str] = None,
        template: List[VideoPreviewVideoTemplate] = None,
    ):
        self.default_output_ext = default_output_ext
        self.fix_resolution = fix_resolution
        self.keep_original = keep_original
        self.m_3u_8config = m_3u_8config
        self.protection_system = protection_system
        self.support_ext = support_ext
        self.template = template

    def validate(self):
        if self.m_3u_8config:
            self.m_3u_8config.validate()
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_output_ext is not None:
            result['default_output_ext'] = self.default_output_ext
        if self.fix_resolution is not None:
            result['fix_resolution'] = self.fix_resolution
        if self.keep_original is not None:
            result['keep_original'] = self.keep_original
        if self.m_3u_8config is not None:
            result['m3u8_config'] = self.m_3u_8config.to_map()
        if self.protection_system is not None:
            result['protection_system'] = self.protection_system
        if self.support_ext is not None:
            result['support_ext'] = self.support_ext
        result['template'] = []
        if self.template is not None:
            for k in self.template:
                result['template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_output_ext') is not None:
            self.default_output_ext = m.get('default_output_ext')
        if m.get('fix_resolution') is not None:
            self.fix_resolution = m.get('fix_resolution')
        if m.get('keep_original') is not None:
            self.keep_original = m.get('keep_original')
        if m.get('m3u8_config') is not None:
            temp_model = VideoPreviewM3U8Config()
            self.m_3u_8config = temp_model.from_map(m['m3u8_config'])
        if m.get('protection_system') is not None:
            self.protection_system = m.get('protection_system')
        if m.get('support_ext') is not None:
            self.support_ext = m.get('support_ext')
        self.template = []
        if m.get('template') is not None:
            for k in m.get('template'):
                temp_model = VideoPreviewVideoTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class VideoPreviewVideoFilterConfig(TeaModel):
    """
    转码源过滤配置（TODO: 未完整测试）
    同时满足以下所有null条件，则不触发转码。如果没有配置任何条件，那么不触发过滤
    """
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channel: int = None,
        audio_codec_list: List[str] = None,
        audio_sample_rate: int = None,
        bitrate: int = None,
        duration: int = None,
        height: int = None,
        pixel: int = None,
        size: int = None,
        video_bitrate: int = None,
        video_codec_list: List[str] = None,
        video_frame_rate: int = None,
        width: int = None,
    ):
        self.audio_bitrate = audio_bitrate
        self.audio_channel = audio_channel
        # 音频信息过滤
        self.audio_codec_list = audio_codec_list
        self.audio_sample_rate = audio_sample_rate
        self.bitrate = bitrate
        # 综合信息过滤
        self.duration = duration
        self.height = height
        self.pixel = pixel
        self.size = size
        self.video_bitrate = video_bitrate
        # 视频信息过滤
        self.video_codec_list = video_codec_list
        self.video_frame_rate = video_frame_rate
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['audio_bitrate'] = self.audio_bitrate
        if self.audio_channel is not None:
            result['audio_channel'] = self.audio_channel
        if self.audio_codec_list is not None:
            result['audio_codec_list'] = self.audio_codec_list
        if self.audio_sample_rate is not None:
            result['audio_sample_rate'] = self.audio_sample_rate
        if self.bitrate is not None:
            result['bitrate'] = self.bitrate
        if self.duration is not None:
            result['duration'] = self.duration
        if self.height is not None:
            result['height'] = self.height
        if self.pixel is not None:
            result['pixel'] = self.pixel
        if self.size is not None:
            result['size'] = self.size
        if self.video_bitrate is not None:
            result['video_bitrate'] = self.video_bitrate
        if self.video_codec_list is not None:
            result['video_codec_list'] = self.video_codec_list
        if self.video_frame_rate is not None:
            result['video_frame_rate'] = self.video_frame_rate
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_bitrate') is not None:
            self.audio_bitrate = m.get('audio_bitrate')
        if m.get('audio_channel') is not None:
            self.audio_channel = m.get('audio_channel')
        if m.get('audio_codec_list') is not None:
            self.audio_codec_list = m.get('audio_codec_list')
        if m.get('audio_sample_rate') is not None:
            self.audio_sample_rate = m.get('audio_sample_rate')
        if m.get('bitrate') is not None:
            self.bitrate = m.get('bitrate')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('pixel') is not None:
            self.pixel = m.get('pixel')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('video_bitrate') is not None:
            self.video_bitrate = m.get('video_bitrate')
        if m.get('video_codec_list') is not None:
            self.video_codec_list = m.get('video_codec_list')
        if m.get('video_frame_rate') is not None:
            self.video_frame_rate = m.get('video_frame_rate')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class VideoPreviewConfig(TeaModel):
    """
    转码配置
    """
    def __init__(
        self,
        audio_config: VideoPreviewAudioConfig = None,
        audio_template_list: List[str] = None,
        audio_thumbnail: VideoPreviewThumbnailConfig = None,
        auto_category_config: VideoPreviewAutoCategoryConfig = None,
        backup_config: VideoPreviewBackupConfig = None,
        cdn_config: VideoPreviewCdnConfig = None,
        drm_config: VideoPreviewDrmConfig = None,
        enable_config: VideoPreviewEnableConfig = None,
        enabled: bool = None,
        hls_sign_params_config: VideoPreviewHlsSignParamsConfig = None,
        live_transcoding_config: VideoPreviewLiveTranscodingConfig = None,
        quick_video_config: VideoPreviewQuickVideoConfig = None,
        rate_limit_config: VideoPreviewRateLimitConfig = None,
        sprite: VideoPreviewSpriteConfig = None,
        store: Store = None,
        store_id_map: dict = None,
        template_list: List[str] = None,
        template_name_map: dict = None,
        template_policy_config: VideoPreviewTemplatePolicyConfig = None,
        thumbnail: VideoPreviewThumbnailConfig = None,
        video_config: VideoPreviewVideoConfig = None,
        video_filter_config: VideoPreviewVideoFilterConfig = None,
    ):
        self.audio_config = audio_config
        self.audio_template_list = audio_template_list
        self.audio_thumbnail = audio_thumbnail
        self.auto_category_config = auto_category_config
        self.backup_config = backup_config
        self.cdn_config = cdn_config
        self.drm_config = drm_config
        self.enable_config = enable_config
        self.enabled = enabled
        self.hls_sign_params_config = hls_sign_params_config
        self.live_transcoding_config = live_transcoding_config
        self.quick_video_config = quick_video_config
        self.rate_limit_config = rate_limit_config
        self.sprite = sprite
        self.store = store
        self.store_id_map = store_id_map
        self.template_list = template_list
        self.template_name_map = template_name_map
        self.template_policy_config = template_policy_config
        self.thumbnail = thumbnail
        self.video_config = video_config
        self.video_filter_config = video_filter_config

    def validate(self):
        if self.audio_config:
            self.audio_config.validate()
        if self.audio_thumbnail:
            self.audio_thumbnail.validate()
        if self.auto_category_config:
            self.auto_category_config.validate()
        if self.backup_config:
            self.backup_config.validate()
        if self.cdn_config:
            self.cdn_config.validate()
        if self.drm_config:
            self.drm_config.validate()
        if self.enable_config:
            self.enable_config.validate()
        if self.hls_sign_params_config:
            self.hls_sign_params_config.validate()
        if self.live_transcoding_config:
            self.live_transcoding_config.validate()
        if self.quick_video_config:
            self.quick_video_config.validate()
        if self.rate_limit_config:
            self.rate_limit_config.validate()
        if self.sprite:
            self.sprite.validate()
        if self.store:
            self.store.validate()
        if self.template_policy_config:
            self.template_policy_config.validate()
        if self.thumbnail:
            self.thumbnail.validate()
        if self.video_config:
            self.video_config.validate()
        if self.video_filter_config:
            self.video_filter_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_config is not None:
            result['audio_config'] = self.audio_config.to_map()
        if self.audio_template_list is not None:
            result['audio_template_list'] = self.audio_template_list
        if self.audio_thumbnail is not None:
            result['audio_thumbnail'] = self.audio_thumbnail.to_map()
        if self.auto_category_config is not None:
            result['auto_category_config'] = self.auto_category_config.to_map()
        if self.backup_config is not None:
            result['backup_config'] = self.backup_config.to_map()
        if self.cdn_config is not None:
            result['cdn_config'] = self.cdn_config.to_map()
        if self.drm_config is not None:
            result['drm_config'] = self.drm_config.to_map()
        if self.enable_config is not None:
            result['enable_config'] = self.enable_config.to_map()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.hls_sign_params_config is not None:
            result['hls_sign_params_config'] = self.hls_sign_params_config.to_map()
        if self.live_transcoding_config is not None:
            result['live_transcoding_config'] = self.live_transcoding_config.to_map()
        if self.quick_video_config is not None:
            result['quick_video_config'] = self.quick_video_config.to_map()
        if self.rate_limit_config is not None:
            result['rate_limit_config'] = self.rate_limit_config.to_map()
        if self.sprite is not None:
            result['sprite'] = self.sprite.to_map()
        if self.store is not None:
            result['store'] = self.store.to_map()
        if self.store_id_map is not None:
            result['store_id_map'] = self.store_id_map
        if self.template_list is not None:
            result['template_list'] = self.template_list
        if self.template_name_map is not None:
            result['template_name_map'] = self.template_name_map
        if self.template_policy_config is not None:
            result['template_policy_config'] = self.template_policy_config.to_map()
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail.to_map()
        if self.video_config is not None:
            result['video_config'] = self.video_config.to_map()
        if self.video_filter_config is not None:
            result['video_filter_config'] = self.video_filter_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_config') is not None:
            temp_model = VideoPreviewAudioConfig()
            self.audio_config = temp_model.from_map(m['audio_config'])
        if m.get('audio_template_list') is not None:
            self.audio_template_list = m.get('audio_template_list')
        if m.get('audio_thumbnail') is not None:
            temp_model = VideoPreviewThumbnailConfig()
            self.audio_thumbnail = temp_model.from_map(m['audio_thumbnail'])
        if m.get('auto_category_config') is not None:
            temp_model = VideoPreviewAutoCategoryConfig()
            self.auto_category_config = temp_model.from_map(m['auto_category_config'])
        if m.get('backup_config') is not None:
            temp_model = VideoPreviewBackupConfig()
            self.backup_config = temp_model.from_map(m['backup_config'])
        if m.get('cdn_config') is not None:
            temp_model = VideoPreviewCdnConfig()
            self.cdn_config = temp_model.from_map(m['cdn_config'])
        if m.get('drm_config') is not None:
            temp_model = VideoPreviewDrmConfig()
            self.drm_config = temp_model.from_map(m['drm_config'])
        if m.get('enable_config') is not None:
            temp_model = VideoPreviewEnableConfig()
            self.enable_config = temp_model.from_map(m['enable_config'])
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('hls_sign_params_config') is not None:
            temp_model = VideoPreviewHlsSignParamsConfig()
            self.hls_sign_params_config = temp_model.from_map(m['hls_sign_params_config'])
        if m.get('live_transcoding_config') is not None:
            temp_model = VideoPreviewLiveTranscodingConfig()
            self.live_transcoding_config = temp_model.from_map(m['live_transcoding_config'])
        if m.get('quick_video_config') is not None:
            temp_model = VideoPreviewQuickVideoConfig()
            self.quick_video_config = temp_model.from_map(m['quick_video_config'])
        if m.get('rate_limit_config') is not None:
            temp_model = VideoPreviewRateLimitConfig()
            self.rate_limit_config = temp_model.from_map(m['rate_limit_config'])
        if m.get('sprite') is not None:
            temp_model = VideoPreviewSpriteConfig()
            self.sprite = temp_model.from_map(m['sprite'])
        if m.get('store') is not None:
            temp_model = Store()
            self.store = temp_model.from_map(m['store'])
        if m.get('store_id_map') is not None:
            self.store_id_map = m.get('store_id_map')
        if m.get('template_list') is not None:
            self.template_list = m.get('template_list')
        if m.get('template_name_map') is not None:
            self.template_name_map = m.get('template_name_map')
        if m.get('template_policy_config') is not None:
            temp_model = VideoPreviewTemplatePolicyConfig()
            self.template_policy_config = temp_model.from_map(m['template_policy_config'])
        if m.get('thumbnail') is not None:
            temp_model = VideoPreviewThumbnailConfig()
            self.thumbnail = temp_model.from_map(m['thumbnail'])
        if m.get('video_config') is not None:
            temp_model = VideoPreviewVideoConfig()
            self.video_config = temp_model.from_map(m['video_config'])
        if m.get('video_filter_config') is not None:
            temp_model = VideoPreviewVideoFilterConfig()
            self.video_filter_config = temp_model.from_map(m['video_filter_config'])
        return self


class BaseWatermarkConfigResponse(TeaModel):
    """
    base watermark config response
    """
    def __init__(
        self,
        bold: bool = None,
        display_access_user_name: bool = None,
        display_custom_text: str = None,
        display_share_link_creator_name: bool = None,
        enable_doc_preview: bool = None,
        enable_on_preview: bool = None,
        fill_style: str = None,
        font: str = None,
        horizontal: int = None,
        rotate: int = None,
        size: int = None,
        vertical: int = None,
    ):
        self.bold = bold
        self.display_access_user_name = display_access_user_name
        self.display_custom_text = display_custom_text
        self.display_share_link_creator_name = display_share_link_creator_name
        self.enable_doc_preview = enable_doc_preview
        self.enable_on_preview = enable_on_preview
        self.fill_style = fill_style
        self.font = font
        self.horizontal = horizontal
        self.rotate = rotate
        self.size = size
        self.vertical = vertical

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bold is not None:
            result['bold'] = self.bold
        if self.display_access_user_name is not None:
            result['display_access_user_name'] = self.display_access_user_name
        if self.display_custom_text is not None:
            result['display_custom_text'] = self.display_custom_text
        if self.display_share_link_creator_name is not None:
            result['display_shareLink_creator_name'] = self.display_share_link_creator_name
        if self.enable_doc_preview is not None:
            result['enable_doc_preview'] = self.enable_doc_preview
        if self.enable_on_preview is not None:
            result['enable_on_preview'] = self.enable_on_preview
        if self.fill_style is not None:
            result['fill_style'] = self.fill_style
        if self.font is not None:
            result['font'] = self.font
        if self.horizontal is not None:
            result['horizontal'] = self.horizontal
        if self.rotate is not None:
            result['rotate'] = self.rotate
        if self.size is not None:
            result['size'] = self.size
        if self.vertical is not None:
            result['vertical'] = self.vertical
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bold') is not None:
            self.bold = m.get('bold')
        if m.get('display_access_user_name') is not None:
            self.display_access_user_name = m.get('display_access_user_name')
        if m.get('display_custom_text') is not None:
            self.display_custom_text = m.get('display_custom_text')
        if m.get('display_shareLink_creator_name') is not None:
            self.display_share_link_creator_name = m.get('display_shareLink_creator_name')
        if m.get('enable_doc_preview') is not None:
            self.enable_doc_preview = m.get('enable_doc_preview')
        if m.get('enable_on_preview') is not None:
            self.enable_on_preview = m.get('enable_on_preview')
        if m.get('fill_style') is not None:
            self.fill_style = m.get('fill_style')
        if m.get('font') is not None:
            self.font = m.get('font')
        if m.get('horizontal') is not None:
            self.horizontal = m.get('horizontal')
        if m.get('rotate') is not None:
            self.rotate = m.get('rotate')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('vertical') is not None:
            self.vertical = m.get('vertical')
        return self


class BaseDomainResponse(TeaModel):
    """
    base domain response
    """
    def __init__(
        self,
        api_cname: str = None,
        app_cname: str = None,
        app_config: AppConfig = None,
        archive_config: ArchiveConfig = None,
        archive_files_enable: bool = None,
        audit_log_config: AuditLogConfig = None,
        auth_cname: str = None,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        benefits: dict = None,
        created_at: str = None,
        data_hash_name: str = None,
        default_super_admin_config: DomainSuperAdminConfig = None,
        description: str = None,
        domain_id: str = None,
        domain_name: str = None,
        endpoints: DomainEndpointsResponse = None,
        enterprise_customized_login: bool = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        expire_time: int = None,
        file_category: dict = None,
        group_config: GroupConfig = None,
        group_single_drive_enabled: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        init_drive_store_id: str = None,
        mode: str = None,
        multi_revision_config: BaseMultiRevisionConfigResponse = None,
        office_edit_config: OfficeEditConfig = None,
        office_preview_config: OfficePreviewConfig = None,
        parallel_upload_enabled: bool = None,
        parent_domain_id: str = None,
        path_type: str = None,
        prepaid_package: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        recycle_bin_config: RecycleBinConfig = None,
        role_config: RoleConfig = None,
        service_code: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        size_quota: int = None,
        size_quota_used: int = None,
        spi_instance_id: str = None,
        status: int = None,
        store_level: str = None,
        store_region_list: List[str] = None,
        subdomain_config: SubdomainConfig = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
        video_preview_app_config: VideoPreviewAppConfig = None,
        video_preview_config: VideoPreviewConfig = None,
        watermark_config: BaseWatermarkConfigResponse = None,
    ):
        # Domain APICName
        self.api_cname = api_cname
        # Domain AppCName
        self.app_cname = app_cname
        self.app_config = app_config
        self.archive_config = archive_config
        # 打包下载配置
        self.archive_files_enable = archive_files_enable
        self.audit_log_config = audit_log_config
        # Domain AuthCName
        self.auth_cname = auth_cname
        # 登录相关信息
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 是否开启了钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 是否开启了 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        self.benefits = benefits
        # Domain 创建时间
        self.created_at = created_at
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        self.default_super_admin_config = default_super_admin_config
        # Domain 描述
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Domain 描述
        self.domain_name = domain_name
        self.endpoints = endpoints
        # 企业文件管理专属登录开关
        self.enterprise_customized_login = enterprise_customized_login
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        # 预付费domain过期时间
        self.expire_time = expire_time
        self.file_category = file_category
        self.group_config = group_config
        self.group_single_drive_enabled = group_single_drive_enabled
        # 是否开启了自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # 自动初始化 Drive 所用 Store ID
        self.init_drive_store_id = init_drive_store_id
        # Domain 类型
        self.mode = mode
        self.multi_revision_config = multi_revision_config
        self.office_edit_config = office_edit_config
        self.office_preview_config = office_preview_config
        self.parallel_upload_enabled = parallel_upload_enabled
        # Parent Domain ID
        self.parent_domain_id = parent_domain_id
        # Domain 类型
        self.path_type = path_type
        # 预付费套餐
        self.prepaid_package = prepaid_package
        self.published_app_access_strategy = published_app_access_strategy
        self.recycle_bin_config = recycle_bin_config
        self.role_config = role_config
        # Domain ServiceCode
        self.service_code = service_code
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 容量配额
        self.size_quota = size_quota
        self.size_quota_used = size_quota_used
        # SPI 实例 id
        self.spi_instance_id = spi_instance_id
        # domain状态：创建中，正常，已过期
        self.status = status
        # 存储级别
        self.store_level = store_level
        # 存储 Region 列表
        self.store_region_list = store_region_list
        self.subdomain_config = subdomain_config
        # Domain 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数配额
        self.user_count_quota = user_count_quota
        # user和group只能有一个drive的开关
        self.user_single_drive_enabled = user_single_drive_enabled
        self.video_preview_app_config = video_preview_app_config
        self.video_preview_config = video_preview_config
        self.watermark_config = watermark_config

    def validate(self):
        if self.app_config:
            self.app_config.validate()
        if self.archive_config:
            self.archive_config.validate()
        if self.audit_log_config:
            self.audit_log_config.validate()
        if self.default_super_admin_config:
            self.default_super_admin_config.validate()
        if self.endpoints:
            self.endpoints.validate()
        if self.group_config:
            self.group_config.validate()
        if self.multi_revision_config:
            self.multi_revision_config.validate()
        if self.office_edit_config:
            self.office_edit_config.validate()
        if self.office_preview_config:
            self.office_preview_config.validate()
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()
        if self.recycle_bin_config:
            self.recycle_bin_config.validate()
        if self.role_config:
            self.role_config.validate()
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        if self.subdomain_config:
            self.subdomain_config.validate()
        if self.video_preview_app_config:
            self.video_preview_app_config.validate()
        if self.video_preview_config:
            self.video_preview_config.validate()
        if self.watermark_config:
            self.watermark_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_cname is not None:
            result['api_cname'] = self.api_cname
        if self.app_cname is not None:
            result['app_cname'] = self.app_cname
        if self.app_config is not None:
            result['app_config'] = self.app_config.to_map()
        if self.archive_config is not None:
            result['archive_config'] = self.archive_config.to_map()
        if self.archive_files_enable is not None:
            result['archive_files_enable'] = self.archive_files_enable
        if self.audit_log_config is not None:
            result['audit_log_config'] = self.audit_log_config.to_map()
        if self.auth_cname is not None:
            result['auth_cname'] = self.auth_cname
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.benefits is not None:
            result['benefits'] = self.benefits
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.default_super_admin_config is not None:
            result['default_super_admin_config'] = self.default_super_admin_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.endpoints is not None:
            result['endpoints'] = self.endpoints.to_map()
        if self.enterprise_customized_login is not None:
            result['enterprise_customized_login'] = self.enterprise_customized_login
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.file_category is not None:
            result['file_category'] = self.file_category
        if self.group_config is not None:
            result['group_config'] = self.group_config.to_map()
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.init_drive_store_id is not None:
            result['init_drive_store_id'] = self.init_drive_store_id
        if self.mode is not None:
            result['mode'] = self.mode
        if self.multi_revision_config is not None:
            result['multi_revision_config'] = self.multi_revision_config.to_map()
        if self.office_edit_config is not None:
            result['office_edit_config'] = self.office_edit_config.to_map()
        if self.office_preview_config is not None:
            result['office_preview_config'] = self.office_preview_config.to_map()
        if self.parallel_upload_enabled is not None:
            result['parallel_upload_enabled'] = self.parallel_upload_enabled
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        if self.path_type is not None:
            result['path_type'] = self.path_type
        if self.prepaid_package is not None:
            result['prepaid_package'] = self.prepaid_package
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.recycle_bin_config is not None:
            result['recycle_bin_config'] = self.recycle_bin_config.to_map()
        if self.role_config is not None:
            result['role_config'] = self.role_config.to_map()
        if self.service_code is not None:
            result['service_code'] = self.service_code
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.size_quota_used is not None:
            result['size_quota_used'] = self.size_quota_used
        if self.spi_instance_id is not None:
            result['spi_instance_id'] = self.spi_instance_id
        if self.status is not None:
            result['status'] = self.status
        if self.store_level is not None:
            result['store_level'] = self.store_level
        if self.store_region_list is not None:
            result['store_region_list'] = self.store_region_list
        if self.subdomain_config is not None:
            result['subdomain_config'] = self.subdomain_config.to_map()
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        if self.video_preview_app_config is not None:
            result['video_preview_app_config'] = self.video_preview_app_config.to_map()
        if self.video_preview_config is not None:
            result['video_preview_config'] = self.video_preview_config.to_map()
        if self.watermark_config is not None:
            result['watermark_config'] = self.watermark_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_cname') is not None:
            self.api_cname = m.get('api_cname')
        if m.get('app_cname') is not None:
            self.app_cname = m.get('app_cname')
        if m.get('app_config') is not None:
            temp_model = AppConfig()
            self.app_config = temp_model.from_map(m['app_config'])
        if m.get('archive_config') is not None:
            temp_model = ArchiveConfig()
            self.archive_config = temp_model.from_map(m['archive_config'])
        if m.get('archive_files_enable') is not None:
            self.archive_files_enable = m.get('archive_files_enable')
        if m.get('audit_log_config') is not None:
            temp_model = AuditLogConfig()
            self.audit_log_config = temp_model.from_map(m['audit_log_config'])
        if m.get('auth_cname') is not None:
            self.auth_cname = m.get('auth_cname')
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('benefits') is not None:
            self.benefits = m.get('benefits')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('default_super_admin_config') is not None:
            temp_model = DomainSuperAdminConfig()
            self.default_super_admin_config = temp_model.from_map(m['default_super_admin_config'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('endpoints') is not None:
            temp_model = DomainEndpointsResponse()
            self.endpoints = temp_model.from_map(m['endpoints'])
        if m.get('enterprise_customized_login') is not None:
            self.enterprise_customized_login = m.get('enterprise_customized_login')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('file_category') is not None:
            self.file_category = m.get('file_category')
        if m.get('group_config') is not None:
            temp_model = GroupConfig()
            self.group_config = temp_model.from_map(m['group_config'])
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('init_drive_store_id') is not None:
            self.init_drive_store_id = m.get('init_drive_store_id')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('multi_revision_config') is not None:
            temp_model = BaseMultiRevisionConfigResponse()
            self.multi_revision_config = temp_model.from_map(m['multi_revision_config'])
        if m.get('office_edit_config') is not None:
            temp_model = OfficeEditConfig()
            self.office_edit_config = temp_model.from_map(m['office_edit_config'])
        if m.get('office_preview_config') is not None:
            temp_model = OfficePreviewConfig()
            self.office_preview_config = temp_model.from_map(m['office_preview_config'])
        if m.get('parallel_upload_enabled') is not None:
            self.parallel_upload_enabled = m.get('parallel_upload_enabled')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        if m.get('path_type') is not None:
            self.path_type = m.get('path_type')
        if m.get('prepaid_package') is not None:
            self.prepaid_package = m.get('prepaid_package')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('recycle_bin_config') is not None:
            temp_model = RecycleBinConfig()
            self.recycle_bin_config = temp_model.from_map(m['recycle_bin_config'])
        if m.get('role_config') is not None:
            temp_model = RoleConfig()
            self.role_config = temp_model.from_map(m['role_config'])
        if m.get('service_code') is not None:
            self.service_code = m.get('service_code')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('size_quota_used') is not None:
            self.size_quota_used = m.get('size_quota_used')
        if m.get('spi_instance_id') is not None:
            self.spi_instance_id = m.get('spi_instance_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_level') is not None:
            self.store_level = m.get('store_level')
        if m.get('store_region_list') is not None:
            self.store_region_list = m.get('store_region_list')
        if m.get('subdomain_config') is not None:
            temp_model = SubdomainConfig()
            self.subdomain_config = temp_model.from_map(m['subdomain_config'])
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        if m.get('video_preview_app_config') is not None:
            temp_model = VideoPreviewAppConfig()
            self.video_preview_app_config = temp_model.from_map(m['video_preview_app_config'])
        if m.get('video_preview_config') is not None:
            temp_model = VideoPreviewConfig()
            self.video_preview_config = temp_model.from_map(m['video_preview_config'])
        if m.get('watermark_config') is not None:
            temp_model = BaseWatermarkConfigResponse()
            self.watermark_config = temp_model.from_map(m['watermark_config'])
        return self


class BaseIdentityBenefitPkgDeliveryInfoRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        amount: int = None,
        delivery_id: str = None,
        expire_time: int = None,
    ):
        # 权益包数量
        self.amount = amount
        # 权益下发的唯一标识
        self.delivery_id = delivery_id
        # 权益包超期时间的时间戳，单位为毫秒
        self.expire_time = expire_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['amount'] = self.amount
        if self.delivery_id is not None:
            result['delivery_id'] = self.delivery_id
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('amount') is not None:
            self.amount = m.get('amount')
        if m.get('delivery_id') is not None:
            self.delivery_id = m.get('delivery_id')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        return self


class BaseIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        domain_id: str = None,
        identity_id: str = None,
        identity_type: str = None,
    ):
        # domain ID
        self.domain_id = domain_id
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type

    def validate(self):
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        return self


class BenefitMeta(TeaModel):
    """
    权益元数据
    """
    def __init__(
        self,
        config: str = None,
        enabled: bool = None,
        quota: int = None,
    ):
        self.config = config
        self.enabled = enabled
        self.quota = quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['config'] = self.config
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.quota is not None:
            result['quota'] = self.quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('quota') is not None:
            self.quota = m.get('quota')
        return self


class CNameStatus(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        bingding_state: str = None,
        legal_state: str = None,
        remark: str = None,
    ):
        # binding state
        self.bingding_state = bingding_state
        # legal state
        self.legal_state = legal_state
        # remark
        self.remark = remark

    def validate(self):
        self.validate_required(self.bingding_state, 'bingding_state')
        self.validate_required(self.legal_state, 'legal_state')
        self.validate_required(self.remark, 'remark')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bingding_state is not None:
            result['bingding_state'] = self.bingding_state
        if self.legal_state is not None:
            result['legal_state'] = self.legal_state
        if self.remark is not None:
            result['remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bingding_state') is not None:
            self.bingding_state = m.get('bingding_state')
        if m.get('legal_state') is not None:
            self.legal_state = m.get('legal_state')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        return self


class CreateDomainResponse(TeaModel):
    """
    create domain response
    """
    def __init__(
        self,
        api_cname: str = None,
        app_cname: str = None,
        app_config: AppConfig = None,
        archive_config: ArchiveConfig = None,
        archive_files_enable: bool = None,
        audit_log_config: AuditLogConfig = None,
        auth_cname: str = None,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        benefits: dict = None,
        created_at: str = None,
        data_hash_name: str = None,
        default_super_admin_config: DomainSuperAdminConfig = None,
        description: str = None,
        domain_id: str = None,
        domain_name: str = None,
        endpoints: DomainEndpointsResponse = None,
        enterprise_customized_login: bool = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        expire_time: int = None,
        file_category: dict = None,
        group_config: GroupConfig = None,
        group_single_drive_enabled: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        init_drive_store_id: str = None,
        mode: str = None,
        multi_revision_config: BaseMultiRevisionConfigResponse = None,
        office_edit_config: OfficeEditConfig = None,
        office_preview_config: OfficePreviewConfig = None,
        parallel_upload_enabled: bool = None,
        parent_domain_id: str = None,
        path_type: str = None,
        prepaid_package: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        recycle_bin_config: RecycleBinConfig = None,
        role_config: RoleConfig = None,
        service_code: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        size_quota: int = None,
        size_quota_used: int = None,
        spi_instance_id: str = None,
        status: int = None,
        store_level: str = None,
        store_region_list: List[str] = None,
        subdomain_config: SubdomainConfig = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
        video_preview_app_config: VideoPreviewAppConfig = None,
        video_preview_config: VideoPreviewConfig = None,
        watermark_config: BaseWatermarkConfigResponse = None,
    ):
        # Domain APICName
        self.api_cname = api_cname
        # Domain AppCName
        self.app_cname = app_cname
        self.app_config = app_config
        self.archive_config = archive_config
        # 打包下载配置
        self.archive_files_enable = archive_files_enable
        self.audit_log_config = audit_log_config
        # Domain AuthCName
        self.auth_cname = auth_cname
        # 登录相关信息
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 是否开启了钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 是否开启了 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        self.benefits = benefits
        # Domain 创建时间
        self.created_at = created_at
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        self.default_super_admin_config = default_super_admin_config
        # Domain 描述
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Domain 描述
        self.domain_name = domain_name
        self.endpoints = endpoints
        # 企业文件管理专属登录开关
        self.enterprise_customized_login = enterprise_customized_login
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        # 预付费domain过期时间
        self.expire_time = expire_time
        self.file_category = file_category
        self.group_config = group_config
        self.group_single_drive_enabled = group_single_drive_enabled
        # 是否开启了自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # 自动初始化 Drive 所用 Store ID
        self.init_drive_store_id = init_drive_store_id
        # Domain 类型
        self.mode = mode
        self.multi_revision_config = multi_revision_config
        self.office_edit_config = office_edit_config
        self.office_preview_config = office_preview_config
        self.parallel_upload_enabled = parallel_upload_enabled
        # Parent Domain ID
        self.parent_domain_id = parent_domain_id
        # Domain 类型
        self.path_type = path_type
        # 预付费套餐
        self.prepaid_package = prepaid_package
        self.published_app_access_strategy = published_app_access_strategy
        self.recycle_bin_config = recycle_bin_config
        self.role_config = role_config
        # Domain ServiceCode
        self.service_code = service_code
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 容量配额
        self.size_quota = size_quota
        self.size_quota_used = size_quota_used
        # SPI 实例 id
        self.spi_instance_id = spi_instance_id
        # domain状态：创建中，正常，已过期
        self.status = status
        # 存储级别
        self.store_level = store_level
        # 存储 Region 列表
        self.store_region_list = store_region_list
        self.subdomain_config = subdomain_config
        # Domain 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数配额
        self.user_count_quota = user_count_quota
        # user和group只能有一个drive的开关
        self.user_single_drive_enabled = user_single_drive_enabled
        self.video_preview_app_config = video_preview_app_config
        self.video_preview_config = video_preview_config
        self.watermark_config = watermark_config

    def validate(self):
        if self.app_config:
            self.app_config.validate()
        if self.archive_config:
            self.archive_config.validate()
        if self.audit_log_config:
            self.audit_log_config.validate()
        if self.default_super_admin_config:
            self.default_super_admin_config.validate()
        if self.endpoints:
            self.endpoints.validate()
        if self.group_config:
            self.group_config.validate()
        if self.multi_revision_config:
            self.multi_revision_config.validate()
        if self.office_edit_config:
            self.office_edit_config.validate()
        if self.office_preview_config:
            self.office_preview_config.validate()
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()
        if self.recycle_bin_config:
            self.recycle_bin_config.validate()
        if self.role_config:
            self.role_config.validate()
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        if self.subdomain_config:
            self.subdomain_config.validate()
        if self.video_preview_app_config:
            self.video_preview_app_config.validate()
        if self.video_preview_config:
            self.video_preview_config.validate()
        if self.watermark_config:
            self.watermark_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_cname is not None:
            result['api_cname'] = self.api_cname
        if self.app_cname is not None:
            result['app_cname'] = self.app_cname
        if self.app_config is not None:
            result['app_config'] = self.app_config.to_map()
        if self.archive_config is not None:
            result['archive_config'] = self.archive_config.to_map()
        if self.archive_files_enable is not None:
            result['archive_files_enable'] = self.archive_files_enable
        if self.audit_log_config is not None:
            result['audit_log_config'] = self.audit_log_config.to_map()
        if self.auth_cname is not None:
            result['auth_cname'] = self.auth_cname
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.benefits is not None:
            result['benefits'] = self.benefits
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.default_super_admin_config is not None:
            result['default_super_admin_config'] = self.default_super_admin_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.endpoints is not None:
            result['endpoints'] = self.endpoints.to_map()
        if self.enterprise_customized_login is not None:
            result['enterprise_customized_login'] = self.enterprise_customized_login
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.file_category is not None:
            result['file_category'] = self.file_category
        if self.group_config is not None:
            result['group_config'] = self.group_config.to_map()
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.init_drive_store_id is not None:
            result['init_drive_store_id'] = self.init_drive_store_id
        if self.mode is not None:
            result['mode'] = self.mode
        if self.multi_revision_config is not None:
            result['multi_revision_config'] = self.multi_revision_config.to_map()
        if self.office_edit_config is not None:
            result['office_edit_config'] = self.office_edit_config.to_map()
        if self.office_preview_config is not None:
            result['office_preview_config'] = self.office_preview_config.to_map()
        if self.parallel_upload_enabled is not None:
            result['parallel_upload_enabled'] = self.parallel_upload_enabled
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        if self.path_type is not None:
            result['path_type'] = self.path_type
        if self.prepaid_package is not None:
            result['prepaid_package'] = self.prepaid_package
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.recycle_bin_config is not None:
            result['recycle_bin_config'] = self.recycle_bin_config.to_map()
        if self.role_config is not None:
            result['role_config'] = self.role_config.to_map()
        if self.service_code is not None:
            result['service_code'] = self.service_code
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.size_quota_used is not None:
            result['size_quota_used'] = self.size_quota_used
        if self.spi_instance_id is not None:
            result['spi_instance_id'] = self.spi_instance_id
        if self.status is not None:
            result['status'] = self.status
        if self.store_level is not None:
            result['store_level'] = self.store_level
        if self.store_region_list is not None:
            result['store_region_list'] = self.store_region_list
        if self.subdomain_config is not None:
            result['subdomain_config'] = self.subdomain_config.to_map()
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        if self.video_preview_app_config is not None:
            result['video_preview_app_config'] = self.video_preview_app_config.to_map()
        if self.video_preview_config is not None:
            result['video_preview_config'] = self.video_preview_config.to_map()
        if self.watermark_config is not None:
            result['watermark_config'] = self.watermark_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_cname') is not None:
            self.api_cname = m.get('api_cname')
        if m.get('app_cname') is not None:
            self.app_cname = m.get('app_cname')
        if m.get('app_config') is not None:
            temp_model = AppConfig()
            self.app_config = temp_model.from_map(m['app_config'])
        if m.get('archive_config') is not None:
            temp_model = ArchiveConfig()
            self.archive_config = temp_model.from_map(m['archive_config'])
        if m.get('archive_files_enable') is not None:
            self.archive_files_enable = m.get('archive_files_enable')
        if m.get('audit_log_config') is not None:
            temp_model = AuditLogConfig()
            self.audit_log_config = temp_model.from_map(m['audit_log_config'])
        if m.get('auth_cname') is not None:
            self.auth_cname = m.get('auth_cname')
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('benefits') is not None:
            self.benefits = m.get('benefits')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('default_super_admin_config') is not None:
            temp_model = DomainSuperAdminConfig()
            self.default_super_admin_config = temp_model.from_map(m['default_super_admin_config'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('endpoints') is not None:
            temp_model = DomainEndpointsResponse()
            self.endpoints = temp_model.from_map(m['endpoints'])
        if m.get('enterprise_customized_login') is not None:
            self.enterprise_customized_login = m.get('enterprise_customized_login')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('file_category') is not None:
            self.file_category = m.get('file_category')
        if m.get('group_config') is not None:
            temp_model = GroupConfig()
            self.group_config = temp_model.from_map(m['group_config'])
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('init_drive_store_id') is not None:
            self.init_drive_store_id = m.get('init_drive_store_id')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('multi_revision_config') is not None:
            temp_model = BaseMultiRevisionConfigResponse()
            self.multi_revision_config = temp_model.from_map(m['multi_revision_config'])
        if m.get('office_edit_config') is not None:
            temp_model = OfficeEditConfig()
            self.office_edit_config = temp_model.from_map(m['office_edit_config'])
        if m.get('office_preview_config') is not None:
            temp_model = OfficePreviewConfig()
            self.office_preview_config = temp_model.from_map(m['office_preview_config'])
        if m.get('parallel_upload_enabled') is not None:
            self.parallel_upload_enabled = m.get('parallel_upload_enabled')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        if m.get('path_type') is not None:
            self.path_type = m.get('path_type')
        if m.get('prepaid_package') is not None:
            self.prepaid_package = m.get('prepaid_package')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('recycle_bin_config') is not None:
            temp_model = RecycleBinConfig()
            self.recycle_bin_config = temp_model.from_map(m['recycle_bin_config'])
        if m.get('role_config') is not None:
            temp_model = RoleConfig()
            self.role_config = temp_model.from_map(m['role_config'])
        if m.get('service_code') is not None:
            self.service_code = m.get('service_code')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('size_quota_used') is not None:
            self.size_quota_used = m.get('size_quota_used')
        if m.get('spi_instance_id') is not None:
            self.spi_instance_id = m.get('spi_instance_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_level') is not None:
            self.store_level = m.get('store_level')
        if m.get('store_region_list') is not None:
            self.store_region_list = m.get('store_region_list')
        if m.get('subdomain_config') is not None:
            temp_model = SubdomainConfig()
            self.subdomain_config = temp_model.from_map(m['subdomain_config'])
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        if m.get('video_preview_app_config') is not None:
            temp_model = VideoPreviewAppConfig()
            self.video_preview_app_config = temp_model.from_map(m['video_preview_app_config'])
        if m.get('video_preview_config') is not None:
            temp_model = VideoPreviewConfig()
            self.video_preview_config = temp_model.from_map(m['video_preview_config'])
        if m.get('watermark_config') is not None:
            temp_model = BaseWatermarkConfigResponse()
            self.watermark_config = temp_model.from_map(m['watermark_config'])
        return self


class CreateIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    create identity to benefit pkg mapping request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        amount: int = None,
        benefit_pkg_id: str = None,
        custom_benefit_meta: dict = None,
        delivery_id: str = None,
        domain_id: str = None,
        expire_time: int = None,
        identity_id: str = None,
        identity_type: str = None,
        nonce_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 权益包数量
        self.amount = amount
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # 实体权益包关联的自定义Meta
        self.custom_benefit_meta = custom_benefit_meta
        # 权益下发的唯一标识
        self.delivery_id = delivery_id
        # domain ID
        self.domain_id = domain_id
        # 权益包超期时间的时间戳，单位为毫秒
        self.expire_time = expire_time
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type
        # nonce ID
        self.nonce_id = nonce_id

    def validate(self):
        self.validate_required(self.benefit_pkg_id, 'benefit_pkg_id')
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.amount is not None:
            result['amount'] = self.amount
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.custom_benefit_meta is not None:
            result['custom_benefit_meta'] = self.custom_benefit_meta
        if self.delivery_id is not None:
            result['delivery_id'] = self.delivery_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.nonce_id is not None:
            result['nonce_id'] = self.nonce_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('amount') is not None:
            self.amount = m.get('amount')
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('custom_benefit_meta') is not None:
            self.custom_benefit_meta = m.get('custom_benefit_meta')
        if m.get('delivery_id') is not None:
            self.delivery_id = m.get('delivery_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('nonce_id') is not None:
            self.nonce_id = m.get('nonce_id')
        return self


class CreateSubdomainRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        group_single_drive_enabled: bool = None,
        name: str = None,
        total_size: int = None,
        used_size_refresh_interval: int = None,
        user_quota: int = None,
        user_single_drive_enabled: bool = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # 单团队单drive
        self.group_single_drive_enabled = group_single_drive_enabled
        # 名称，注意该字段会校验重名的subdomain
        self.name = name
        # 逻辑空间quota，默认为-1，无限制，单位为字节
        self.total_size = total_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，默认为-1，无限制
        self.user_quota = user_quota
        # 单用户单drive
        self.user_single_drive_enabled = user_single_drive_enabled

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.name is not None:
            result['name'] = self.name
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_quota is not None:
            result['user_quota'] = self.user_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_quota') is not None:
            self.user_quota = m.get('user_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        return self


class CustomBenefitMeta(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        config: str = None,
        cover_lower_level: bool = None,
        enabled: bool = None,
        quota: int = None,
    ):
        self.config = config
        self.cover_lower_level = cover_lower_level
        self.enabled = enabled
        self.quota = quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['config'] = self.config
        if self.cover_lower_level is not None:
            result['cover_lower_level'] = self.cover_lower_level
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.quota is not None:
            result['quota'] = self.quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('cover_lower_level') is not None:
            self.cover_lower_level = m.get('cover_lower_level')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('quota') is not None:
            self.quota = m.get('quota')
        return self


class DataCName(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        data_cname: str = None,
        location: str = None,
    ):
        # datacname
        self.data_cname = data_cname
        # data location
        self.location = location

    def validate(self):
        self.validate_required(self.data_cname, 'data_cname')
        self.validate_required(self.location, 'location')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cname is not None:
            result['data_cname'] = self.data_cname
        if self.location is not None:
            result['location'] = self.location
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data_cname') is not None:
            self.data_cname = m.get('data_cname')
        if m.get('location') is not None:
            self.location = m.get('location')
        return self


class DeleteIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    delete identity to benefit pkg mapping request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        benefit_pkg_id: str = None,
        domain_id: str = None,
        identity_id: str = None,
        identity_type: str = None,
    ):
        self.httpheaders = httpheaders
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # domain ID
        self.domain_id = domain_id
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type

    def validate(self):
        self.validate_required(self.benefit_pkg_id, 'benefit_pkg_id')
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        return self


class DeleteSubdomainRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class DomainCNameResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        data_cname_list: List[DataCName] = None,
        domain_id: str = None,
    ):
        # data cname list
        self.data_cname_list = data_cname_list
        # domain ID
        self.domain_id = domain_id

    def validate(self):
        self.validate_required(self.data_cname_list, 'data_cname_list')
        if self.data_cname_list:
            for k in self.data_cname_list:
                if k:
                    k.validate()
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data_cname_list'] = []
        if self.data_cname_list is not None:
            for k in self.data_cname_list:
                result['data_cname_list'].append(k.to_map() if k else None)
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_cname_list = []
        if m.get('data_cname_list') is not None:
            for k in m.get('data_cname_list'):
                temp_model = DataCName()
                self.data_cname_list.append(temp_model.from_map(k))
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class DomainGetRequest(TeaModel):
    """
    domain get request
    """
    def __init__(
        self,
        fields: str = None,
        get_share_detail: bool = None,
        merge_parent: bool = None,
    ):
        # fields,需要获取的属性字段,英文逗号分隔,*表示获取所有fields支持的枚举属性字段,为空不获取任何枚举属性字段
        self.fields = fields
        # 是否获取share/share_link详情
        self.get_share_detail = get_share_detail
        # 是否 merge parent 配置
        self.merge_parent = merge_parent

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fields is not None:
            result['fields'] = self.fields
        if self.get_share_detail is not None:
            result['get_share_detail'] = self.get_share_detail
        if self.merge_parent is not None:
            result['merge_parent'] = self.merge_parent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('get_share_detail') is not None:
            self.get_share_detail = m.get('get_share_detail')
        if m.get('merge_parent') is not None:
            self.merge_parent = m.get('merge_parent')
        return self


class ExportAuditLogRequest(TeaModel):
    """
    导出审计日志request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        file_name: str = None,
        language: str = None,
        order_by: str = None,
        query: str = None,
    ):
        self.httpheaders = httpheaders
        # file_name
        self.file_name = file_name
        # language
        self.language = language
        # order_by
        self.order_by = order_by
        # query
        self.query = query

    def validate(self):
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.file_name is not None:
            result['file_name'] = self.file_name
        if self.language is not None:
            result['language'] = self.language
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('file_name') is not None:
            self.file_name = m.get('file_name')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        return self


class GetAppPublicKeyResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        app_id: str = None,
        public_key: str = None,
    ):
        # App ID
        self.app_id = app_id
        # RSA加密算法的公钥, PEM格式
        self.public_key = public_key

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.public_key, 'public_key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.public_key is not None:
            result['public_key'] = self.public_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('public_key') is not None:
            self.public_key = m.get('public_key')
        return self


class GetAppResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        ali_owner_id: str = None,
        app_id: str = None,
        app_name: str = None,
        app_secret: str = None,
        created_at: str = None,
        description: str = None,
        logo: str = None,
        provider: str = None,
        redirect_uri: str = None,
        scope: List[str] = None,
        screenshots: List[str] = None,
        stage: str = None,
        type: str = None,
        updated_at: str = None,
    ):
        # App 拥有者
        self.ali_owner_id = ali_owner_id
        # App ID
        self.app_id = app_id
        # App名称
        self.app_name = app_name
        # App 秘钥
        self.app_secret = app_secret
        # App 创建时间
        self.created_at = created_at
        # App描述
        self.description = description
        # App图标
        self.logo = logo
        # App 提供方
        self.provider = provider
        # App回调地址
        self.redirect_uri = redirect_uri
        # App权限列表
        self.scope = scope
        # App 屏幕截图
        self.screenshots = screenshots
        # App 当前阶段
        self.stage = stage
        # App类型
        self.type = type
        # App 修改时间
        self.updated_at = updated_at

    def validate(self):
        self.validate_required(self.ali_owner_id, 'ali_owner_id')
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.app_name, 'app_name')
        if self.app_name is not None:
            self.validate_max_length(self.app_name, 'app_name', 128)
            self.validate_pattern(self.app_name, 'app_name', '[0-9a-zA-Z]+')
        self.validate_required(self.app_secret, 'app_secret')
        self.validate_required(self.created_at, 'created_at')
        self.validate_required(self.description, 'description')
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 128)
        self.validate_required(self.logo, 'logo')
        self.validate_required(self.provider, 'provider')
        self.validate_required(self.redirect_uri, 'redirect_uri')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.screenshots, 'screenshots')
        self.validate_required(self.stage, 'stage')
        self.validate_required(self.type, 'type')
        self.validate_required(self.updated_at, 'updated_at')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_owner_id is not None:
            result['ali_owner_id'] = self.ali_owner_id
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.app_secret is not None:
            result['app_secret'] = self.app_secret
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.logo is not None:
            result['logo'] = self.logo
        if self.provider is not None:
            result['provider'] = self.provider
        if self.redirect_uri is not None:
            result['redirect_uri'] = self.redirect_uri
        if self.scope is not None:
            result['scope'] = self.scope
        if self.screenshots is not None:
            result['screenshots'] = self.screenshots
        if self.stage is not None:
            result['stage'] = self.stage
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ali_owner_id') is not None:
            self.ali_owner_id = m.get('ali_owner_id')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('app_secret') is not None:
            self.app_secret = m.get('app_secret')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('logo') is not None:
            self.logo = m.get('logo')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('redirect_uri') is not None:
            self.redirect_uri = m.get('redirect_uri')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('screenshots') is not None:
            self.screenshots = m.get('screenshots')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class GetBizCNameInfoResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cert_id: str = None,
        cert_name: str = None,
        cname_status: CNameStatus = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cert name
        self.cert_id = cert_id
        # cert name
        self.cert_name = cert_name
        self.cname_status = cname_status
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.cname_status:
            self.cname_status.validate()
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_id is not None:
            result['cert_id'] = self.cert_id
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cname_status is not None:
            result['cname_status'] = self.cname_status.to_map()
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_id') is not None:
            self.cert_id = m.get('cert_id')
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cname_status') is not None:
            temp_model = CNameStatus()
            self.cname_status = temp_model.from_map(m['cname_status'])
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetDomainResponse(TeaModel):
    """
    get domain response
    """
    def __init__(
        self,
        api_cname: str = None,
        app_cname: str = None,
        app_config: AppConfig = None,
        archive_config: ArchiveConfig = None,
        archive_files_enable: bool = None,
        audit_log_config: AuditLogConfig = None,
        auth_cname: str = None,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        benefits: dict = None,
        created_at: str = None,
        data_hash_name: str = None,
        default_super_admin_config: DomainSuperAdminConfig = None,
        description: str = None,
        domain_id: str = None,
        domain_name: str = None,
        endpoints: DomainEndpointsResponse = None,
        enterprise_customized_login: bool = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        expire_time: int = None,
        file_category: dict = None,
        group_config: GroupConfig = None,
        group_single_drive_enabled: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        init_drive_store_id: str = None,
        mode: str = None,
        multi_revision_config: BaseMultiRevisionConfigResponse = None,
        office_edit_config: OfficeEditConfig = None,
        office_preview_config: OfficePreviewConfig = None,
        parallel_upload_enabled: bool = None,
        parent_domain_id: str = None,
        path_type: str = None,
        prepaid_package: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        recycle_bin_config: RecycleBinConfig = None,
        role_config: RoleConfig = None,
        service_code: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        size_quota: int = None,
        size_quota_used: int = None,
        spi_instance_id: str = None,
        status: int = None,
        store_level: str = None,
        store_region_list: List[str] = None,
        subdomain_config: SubdomainConfig = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
        video_preview_app_config: VideoPreviewAppConfig = None,
        video_preview_config: VideoPreviewConfig = None,
        watermark_config: BaseWatermarkConfigResponse = None,
    ):
        # Domain APICName
        self.api_cname = api_cname
        # Domain AppCName
        self.app_cname = app_cname
        self.app_config = app_config
        self.archive_config = archive_config
        # 打包下载配置
        self.archive_files_enable = archive_files_enable
        self.audit_log_config = audit_log_config
        # Domain AuthCName
        self.auth_cname = auth_cname
        # 登录相关信息
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 是否开启了钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 是否开启了 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        self.benefits = benefits
        # Domain 创建时间
        self.created_at = created_at
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        self.default_super_admin_config = default_super_admin_config
        # Domain 描述
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Domain 描述
        self.domain_name = domain_name
        self.endpoints = endpoints
        # 企业文件管理专属登录开关
        self.enterprise_customized_login = enterprise_customized_login
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        # 预付费domain过期时间
        self.expire_time = expire_time
        self.file_category = file_category
        self.group_config = group_config
        self.group_single_drive_enabled = group_single_drive_enabled
        # 是否开启了自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # 自动初始化 Drive 所用 Store ID
        self.init_drive_store_id = init_drive_store_id
        # Domain 类型
        self.mode = mode
        self.multi_revision_config = multi_revision_config
        self.office_edit_config = office_edit_config
        self.office_preview_config = office_preview_config
        self.parallel_upload_enabled = parallel_upload_enabled
        # Parent Domain ID
        self.parent_domain_id = parent_domain_id
        # Domain 类型
        self.path_type = path_type
        # 预付费套餐
        self.prepaid_package = prepaid_package
        self.published_app_access_strategy = published_app_access_strategy
        self.recycle_bin_config = recycle_bin_config
        self.role_config = role_config
        # Domain ServiceCode
        self.service_code = service_code
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 容量配额
        self.size_quota = size_quota
        self.size_quota_used = size_quota_used
        # SPI 实例 id
        self.spi_instance_id = spi_instance_id
        # domain状态：创建中，正常，已过期
        self.status = status
        # 存储级别
        self.store_level = store_level
        # 存储 Region 列表
        self.store_region_list = store_region_list
        self.subdomain_config = subdomain_config
        # Domain 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数配额
        self.user_count_quota = user_count_quota
        # user和group只能有一个drive的开关
        self.user_single_drive_enabled = user_single_drive_enabled
        self.video_preview_app_config = video_preview_app_config
        self.video_preview_config = video_preview_config
        self.watermark_config = watermark_config

    def validate(self):
        if self.app_config:
            self.app_config.validate()
        if self.archive_config:
            self.archive_config.validate()
        if self.audit_log_config:
            self.audit_log_config.validate()
        if self.default_super_admin_config:
            self.default_super_admin_config.validate()
        if self.endpoints:
            self.endpoints.validate()
        if self.group_config:
            self.group_config.validate()
        if self.multi_revision_config:
            self.multi_revision_config.validate()
        if self.office_edit_config:
            self.office_edit_config.validate()
        if self.office_preview_config:
            self.office_preview_config.validate()
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()
        if self.recycle_bin_config:
            self.recycle_bin_config.validate()
        if self.role_config:
            self.role_config.validate()
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        if self.subdomain_config:
            self.subdomain_config.validate()
        if self.video_preview_app_config:
            self.video_preview_app_config.validate()
        if self.video_preview_config:
            self.video_preview_config.validate()
        if self.watermark_config:
            self.watermark_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_cname is not None:
            result['api_cname'] = self.api_cname
        if self.app_cname is not None:
            result['app_cname'] = self.app_cname
        if self.app_config is not None:
            result['app_config'] = self.app_config.to_map()
        if self.archive_config is not None:
            result['archive_config'] = self.archive_config.to_map()
        if self.archive_files_enable is not None:
            result['archive_files_enable'] = self.archive_files_enable
        if self.audit_log_config is not None:
            result['audit_log_config'] = self.audit_log_config.to_map()
        if self.auth_cname is not None:
            result['auth_cname'] = self.auth_cname
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.benefits is not None:
            result['benefits'] = self.benefits
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.default_super_admin_config is not None:
            result['default_super_admin_config'] = self.default_super_admin_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.endpoints is not None:
            result['endpoints'] = self.endpoints.to_map()
        if self.enterprise_customized_login is not None:
            result['enterprise_customized_login'] = self.enterprise_customized_login
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.file_category is not None:
            result['file_category'] = self.file_category
        if self.group_config is not None:
            result['group_config'] = self.group_config.to_map()
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.init_drive_store_id is not None:
            result['init_drive_store_id'] = self.init_drive_store_id
        if self.mode is not None:
            result['mode'] = self.mode
        if self.multi_revision_config is not None:
            result['multi_revision_config'] = self.multi_revision_config.to_map()
        if self.office_edit_config is not None:
            result['office_edit_config'] = self.office_edit_config.to_map()
        if self.office_preview_config is not None:
            result['office_preview_config'] = self.office_preview_config.to_map()
        if self.parallel_upload_enabled is not None:
            result['parallel_upload_enabled'] = self.parallel_upload_enabled
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        if self.path_type is not None:
            result['path_type'] = self.path_type
        if self.prepaid_package is not None:
            result['prepaid_package'] = self.prepaid_package
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.recycle_bin_config is not None:
            result['recycle_bin_config'] = self.recycle_bin_config.to_map()
        if self.role_config is not None:
            result['role_config'] = self.role_config.to_map()
        if self.service_code is not None:
            result['service_code'] = self.service_code
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.size_quota_used is not None:
            result['size_quota_used'] = self.size_quota_used
        if self.spi_instance_id is not None:
            result['spi_instance_id'] = self.spi_instance_id
        if self.status is not None:
            result['status'] = self.status
        if self.store_level is not None:
            result['store_level'] = self.store_level
        if self.store_region_list is not None:
            result['store_region_list'] = self.store_region_list
        if self.subdomain_config is not None:
            result['subdomain_config'] = self.subdomain_config.to_map()
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        if self.video_preview_app_config is not None:
            result['video_preview_app_config'] = self.video_preview_app_config.to_map()
        if self.video_preview_config is not None:
            result['video_preview_config'] = self.video_preview_config.to_map()
        if self.watermark_config is not None:
            result['watermark_config'] = self.watermark_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_cname') is not None:
            self.api_cname = m.get('api_cname')
        if m.get('app_cname') is not None:
            self.app_cname = m.get('app_cname')
        if m.get('app_config') is not None:
            temp_model = AppConfig()
            self.app_config = temp_model.from_map(m['app_config'])
        if m.get('archive_config') is not None:
            temp_model = ArchiveConfig()
            self.archive_config = temp_model.from_map(m['archive_config'])
        if m.get('archive_files_enable') is not None:
            self.archive_files_enable = m.get('archive_files_enable')
        if m.get('audit_log_config') is not None:
            temp_model = AuditLogConfig()
            self.audit_log_config = temp_model.from_map(m['audit_log_config'])
        if m.get('auth_cname') is not None:
            self.auth_cname = m.get('auth_cname')
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('benefits') is not None:
            self.benefits = m.get('benefits')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('default_super_admin_config') is not None:
            temp_model = DomainSuperAdminConfig()
            self.default_super_admin_config = temp_model.from_map(m['default_super_admin_config'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('endpoints') is not None:
            temp_model = DomainEndpointsResponse()
            self.endpoints = temp_model.from_map(m['endpoints'])
        if m.get('enterprise_customized_login') is not None:
            self.enterprise_customized_login = m.get('enterprise_customized_login')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('file_category') is not None:
            self.file_category = m.get('file_category')
        if m.get('group_config') is not None:
            temp_model = GroupConfig()
            self.group_config = temp_model.from_map(m['group_config'])
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('init_drive_store_id') is not None:
            self.init_drive_store_id = m.get('init_drive_store_id')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('multi_revision_config') is not None:
            temp_model = BaseMultiRevisionConfigResponse()
            self.multi_revision_config = temp_model.from_map(m['multi_revision_config'])
        if m.get('office_edit_config') is not None:
            temp_model = OfficeEditConfig()
            self.office_edit_config = temp_model.from_map(m['office_edit_config'])
        if m.get('office_preview_config') is not None:
            temp_model = OfficePreviewConfig()
            self.office_preview_config = temp_model.from_map(m['office_preview_config'])
        if m.get('parallel_upload_enabled') is not None:
            self.parallel_upload_enabled = m.get('parallel_upload_enabled')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        if m.get('path_type') is not None:
            self.path_type = m.get('path_type')
        if m.get('prepaid_package') is not None:
            self.prepaid_package = m.get('prepaid_package')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('recycle_bin_config') is not None:
            temp_model = RecycleBinConfig()
            self.recycle_bin_config = temp_model.from_map(m['recycle_bin_config'])
        if m.get('role_config') is not None:
            temp_model = RoleConfig()
            self.role_config = temp_model.from_map(m['role_config'])
        if m.get('service_code') is not None:
            self.service_code = m.get('service_code')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('size_quota_used') is not None:
            self.size_quota_used = m.get('size_quota_used')
        if m.get('spi_instance_id') is not None:
            self.spi_instance_id = m.get('spi_instance_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_level') is not None:
            self.store_level = m.get('store_level')
        if m.get('store_region_list') is not None:
            self.store_region_list = m.get('store_region_list')
        if m.get('subdomain_config') is not None:
            temp_model = SubdomainConfig()
            self.subdomain_config = temp_model.from_map(m['subdomain_config'])
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        if m.get('video_preview_app_config') is not None:
            temp_model = VideoPreviewAppConfig()
            self.video_preview_app_config = temp_model.from_map(m['video_preview_app_config'])
        if m.get('video_preview_config') is not None:
            temp_model = VideoPreviewConfig()
            self.video_preview_config = temp_model.from_map(m['video_preview_config'])
        if m.get('watermark_config') is not None:
            temp_model = BaseWatermarkConfigResponse()
            self.watermark_config = temp_model.from_map(m['watermark_config'])
        return self


class GetIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    get identity to benefit pkg mapping request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        benefit_pkg_id: str = None,
        domain_id: str = None,
        identity_id: str = None,
        identity_type: str = None,
    ):
        self.httpheaders = httpheaders
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # domain ID
        self.domain_id = domain_id
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type

    def validate(self):
        self.validate_required(self.benefit_pkg_id, 'benefit_pkg_id')
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        return self


class GetSubdomainRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetUserAccessTokenRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # subdomain ID
        self.subdomain_id = subdomain_id
        # 用户 ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ListAppsResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        items: List[GetAppResponse] = None,
        next_marker: str = None,
    ):
        # App 列表
        self.items = items
        # App 分批查询游标
        self.next_marker = next_marker

    def validate(self):
        self.validate_required(self.items, 'items')
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = GetAppResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListDomainCORSRuleResponse(TeaModel):
    """
    list domain cors response
    """
    def __init__(
        self,
        cors_rule_list: List[CorsRule] = None,
        domain_id: str = None,
    ):
        # cors rule 列表
        self.cors_rule_list = cors_rule_list
        # Domain ID
        self.domain_id = domain_id

    def validate(self):
        if self.cors_rule_list:
            for k in self.cors_rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['cors_rule_list'] = []
        if self.cors_rule_list is not None:
            for k in self.cors_rule_list:
                result['cors_rule_list'].append(k.to_map() if k else None)
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cors_rule_list = []
        if m.get('cors_rule_list') is not None:
            for k in m.get('cors_rule_list'):
                temp_model = CorsRule()
                self.cors_rule_list.append(temp_model.from_map(k))
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        return self


class ListDomainsResponse(TeaModel):
    """
    list domain response
    """
    def __init__(
        self,
        items: List[BaseDomainResponse] = None,
        next_marker: str = None,
    ):
        # domain 列表
        self.items = items
        # 下次分页查询游标
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseDomainResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ListIdentityBenefitPkgRequest(TeaModel):
    """
    List identity benefit package request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        benefit_id_list: List[str] = None,
        domain_id: str = None,
        identity_id: str = None,
        identity_type: str = None,
        include_benefit: bool = None,
        include_expired: bool = None,
    ):
        self.httpheaders = httpheaders
        # 查询特定的benefit ID，include_benefit为true时有效。 如果为空，不做任何过滤；如果不为空，只返回包含特定benefit ID的权益包；也只返回权益包中特定的权益信息。
        self.benefit_id_list = benefit_id_list
        # domain ID
        self.domain_id = domain_id
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type
        # 是否返回权益包中的权益，默认为false
        self.include_benefit = include_benefit
        # 是否返回已经超期的权益包，默认为false
        self.include_expired = include_expired

    def validate(self):
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.benefit_id_list is not None:
            result['benefit_id_list'] = self.benefit_id_list
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.include_benefit is not None:
            result['include_benefit'] = self.include_benefit
        if self.include_expired is not None:
            result['include_expired'] = self.include_expired
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('benefit_id_list') is not None:
            self.benefit_id_list = m.get('benefit_id_list')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('include_benefit') is not None:
            self.include_benefit = m.get('include_benefit')
        if m.get('include_expired') is not None:
            self.include_expired = m.get('include_expired')
        return self


class ListIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    list identity to benefit pkg mapping request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        domain_id: str = None,
        identity_id: str = None,
        identity_type: str = None,
        include_expired: bool = None,
    ):
        self.httpheaders = httpheaders
        # domain ID
        self.domain_id = domain_id
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type
        # 是否返回已经超期的权益包，默认为false
        self.include_expired = include_expired

    def validate(self):
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.include_expired is not None:
            result['include_expired'] = self.include_expired
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('include_expired') is not None:
            self.include_expired = m.get('include_expired')
        return self


class ListSubdomainsRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # 数量，默认为50
        self.limit = limit
        # 分页游标，可从 response 中获取
        self.marker = marker

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class SearchAuditLogRequest(TeaModel):
    """
    查询审计日志request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        query: str = None,
    ):
        self.httpheaders = httpheaders
        # limit
        self.limit = limit
        # Marker
        self.marker = marker
        # order_by
        self.order_by = order_by
        # query
        self.query = query

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        return self


class SetBizCNameCertResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cert_name: str = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        # cert name
        self.cert_name = cert_name
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc

    def validate(self):
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cert_name is not None:
            result['cert_name'] = self.cert_name
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cert_name') is not None:
            self.cert_name = m.get('cert_name')
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class SetBizCNameResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_status: CNameStatus = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        self.cname_status = cname_status
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc

    def validate(self):
        if self.cname_status:
            self.cname_status.validate()
        self.validate_required(self.domain_id, 'domain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_status is not None:
            result['cname_status'] = self.cname_status.to_map()
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_status') is not None:
            temp_model = CNameStatus()
            self.cname_status = temp_model.from_map(m['cname_status'])
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        return self


class SetDataCNameResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        data_cname: str = None,
        domain_id: str = None,
        location: str = None,
    ):
        # datacname
        self.data_cname = data_cname
        # domain ID
        self.domain_id = domain_id
        # data location
        self.location = location

    def validate(self):
        self.validate_required(self.data_cname, 'data_cname')
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.location, 'location')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_cname is not None:
            result['data_cname'] = self.data_cname
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.location is not None:
            result['location'] = self.location
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data_cname') is not None:
            self.data_cname = m.get('data_cname')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('location') is not None:
            self.location = m.get('location')
        return self


class SubdomainSetBizCNameResponse(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        biz_cname: str = None,
        cname_status: CNameStatus = None,
        cname_type: str = None,
        domain_id: str = None,
        is_vpc: bool = None,
        subdomain_id: str = None,
    ):
        # biz cname
        self.biz_cname = biz_cname
        self.cname_status = cname_status
        # cname type
        self.cname_type = cname_type
        # domain ID
        self.domain_id = domain_id
        # is vpc
        self.is_vpc = is_vpc
        # subdomain ID
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.cname_status:
            self.cname_status.validate()
        self.validate_required(self.domain_id, 'domain_id')
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_cname is not None:
            result['biz_cname'] = self.biz_cname
        if self.cname_status is not None:
            result['cname_status'] = self.cname_status.to_map()
        if self.cname_type is not None:
            result['cname_type'] = self.cname_type
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.is_vpc is not None:
            result['is_vpc'] = self.is_vpc
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_cname') is not None:
            self.biz_cname = m.get('biz_cname')
        if m.get('cname_status') is not None:
            temp_model = CNameStatus()
            self.cname_status = temp_model.from_map(m['cname_status'])
        if m.get('cname_type') is not None:
            self.cname_type = m.get('cname_type')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('is_vpc') is not None:
            self.is_vpc = m.get('is_vpc')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class UpdateBenefitToPkgMappingRequest(TeaModel):
    """
    update benefit to benefit package mapping request
    """
    def __init__(
        self,
        allow_config_by_tenant: bool = None,
        allow_config_by_user: bool = None,
        allow_show_to_tenant: bool = None,
        allow_show_to_user: bool = None,
        benefit_id: str = None,
        benefit_meta: BenefitMeta = None,
        benefit_pkg_id: str = None,
        name: str = None,
        user_meta: str = None,
    ):
        self.allow_config_by_tenant = allow_config_by_tenant
        self.allow_config_by_user = allow_config_by_user
        self.allow_show_to_tenant = allow_show_to_tenant
        self.allow_show_to_user = allow_show_to_user
        self.benefit_id = benefit_id
        self.benefit_meta = benefit_meta
        self.benefit_pkg_id = benefit_pkg_id
        self.name = name
        self.user_meta = user_meta

    def validate(self):
        if self.benefit_meta:
            self.benefit_meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_config_by_tenant is not None:
            result['allow_config_by_tenant'] = self.allow_config_by_tenant
        if self.allow_config_by_user is not None:
            result['allow_config_by_user'] = self.allow_config_by_user
        if self.allow_show_to_tenant is not None:
            result['allow_show_to_tenant'] = self.allow_show_to_tenant
        if self.allow_show_to_user is not None:
            result['allow_show_to_user'] = self.allow_show_to_user
        if self.benefit_id is not None:
            result['benefit_id'] = self.benefit_id
        if self.benefit_meta is not None:
            result['benefit_meta'] = self.benefit_meta.to_map()
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.name is not None:
            result['name'] = self.name
        if self.user_meta is not None:
            result['user_meta'] = self.user_meta
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allow_config_by_tenant') is not None:
            self.allow_config_by_tenant = m.get('allow_config_by_tenant')
        if m.get('allow_config_by_user') is not None:
            self.allow_config_by_user = m.get('allow_config_by_user')
        if m.get('allow_show_to_tenant') is not None:
            self.allow_show_to_tenant = m.get('allow_show_to_tenant')
        if m.get('allow_show_to_user') is not None:
            self.allow_show_to_user = m.get('allow_show_to_user')
        if m.get('benefit_id') is not None:
            self.benefit_id = m.get('benefit_id')
        if m.get('benefit_meta') is not None:
            temp_model = BenefitMeta()
            self.benefit_meta = temp_model.from_map(m['benefit_meta'])
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('user_meta') is not None:
            self.user_meta = m.get('user_meta')
        return self


class UpdateBenefitToPkgMappingResponse(TeaModel):
    """
    *\
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class UpdateDomainResponse(TeaModel):
    """
    create domain response
    """
    def __init__(
        self,
        api_cname: str = None,
        app_cname: str = None,
        app_config: AppConfig = None,
        archive_config: ArchiveConfig = None,
        archive_files_enable: bool = None,
        audit_log_config: AuditLogConfig = None,
        auth_cname: str = None,
        auth_config: dict = None,
        auth_dingding_app_id: str = None,
        auth_dingding_app_secret: str = None,
        auth_dingding_enable: bool = None,
        auth_ram_app_id: str = None,
        auth_ram_app_secret: str = None,
        auth_ram_enable: bool = None,
        benefits: dict = None,
        created_at: str = None,
        data_hash_name: str = None,
        default_super_admin_config: DomainSuperAdminConfig = None,
        description: str = None,
        domain_id: str = None,
        domain_name: str = None,
        endpoints: DomainEndpointsResponse = None,
        enterprise_customized_login: bool = None,
        event_filename_matches: str = None,
        event_mns_endpoint: str = None,
        event_mns_topic: str = None,
        event_names: List[str] = None,
        event_role_arn: str = None,
        expire_time: int = None,
        file_category: dict = None,
        group_config: GroupConfig = None,
        group_single_drive_enabled: bool = None,
        init_drive_enable: bool = None,
        init_drive_size: int = None,
        init_drive_store_id: str = None,
        mode: str = None,
        multi_revision_config: BaseMultiRevisionConfigResponse = None,
        office_edit_config: OfficeEditConfig = None,
        office_preview_config: OfficePreviewConfig = None,
        parallel_upload_enabled: bool = None,
        parent_domain_id: str = None,
        path_type: str = None,
        prepaid_package: str = None,
        published_app_access_strategy: AppAccessStrategy = None,
        recycle_bin_config: RecycleBinConfig = None,
        role_config: RoleConfig = None,
        service_code: str = None,
        sharable: bool = None,
        share_detail: ShareDetailResponse = None,
        share_link_detail: ShareLinkDetailResponse = None,
        share_link_enabled: bool = None,
        size_quota: int = None,
        size_quota_used: int = None,
        spi_instance_id: str = None,
        status: int = None,
        store_level: str = None,
        store_region_list: List[str] = None,
        subdomain_config: SubdomainConfig = None,
        updated_at: str = None,
        used_size: int = None,
        used_size_refresh_interval: int = None,
        user_count_quota: int = None,
        user_single_drive_enabled: bool = None,
        video_preview_app_config: VideoPreviewAppConfig = None,
        video_preview_config: VideoPreviewConfig = None,
        watermark_config: BaseWatermarkConfigResponse = None,
    ):
        # Domain APICName
        self.api_cname = api_cname
        # Domain AppCName
        self.app_cname = app_cname
        self.app_config = app_config
        self.archive_config = archive_config
        # 打包下载配置
        self.archive_files_enable = archive_files_enable
        self.audit_log_config = audit_log_config
        # Domain AuthCName
        self.auth_cname = auth_cname
        # 登录相关信息
        self.auth_config = auth_config
        # 钉钉 App Id
        self.auth_dingding_app_id = auth_dingding_app_id
        # 钉钉 App Secret
        self.auth_dingding_app_secret = auth_dingding_app_secret
        # 是否开启了钉钉认证
        self.auth_dingding_enable = auth_dingding_enable
        # RAM App Id
        self.auth_ram_app_id = auth_ram_app_id
        # RAM App Secret
        self.auth_ram_app_secret = auth_ram_app_secret
        # 是否开启了 RAM 认证
        self.auth_ram_enable = auth_ram_enable
        self.benefits = benefits
        # Domain 创建时间
        self.created_at = created_at
        # 数据 Hash 算法
        self.data_hash_name = data_hash_name
        self.default_super_admin_config = default_super_admin_config
        # Domain 描述
        self.description = description
        # Domain ID
        self.domain_id = domain_id
        # Domain 描述
        self.domain_name = domain_name
        self.endpoints = endpoints
        # 企业文件管理专属登录开关
        self.enterprise_customized_login = enterprise_customized_login
        # 事件通知 MNS 匹配文件名
        self.event_filename_matches = event_filename_matches
        # 事件通知 MNS Endpoint
        self.event_mns_endpoint = event_mns_endpoint
        # 事件通知 MNS Topic
        self.event_mns_topic = event_mns_topic
        # 事件名列表
        self.event_names = event_names
        # 事件通知 Role Arn
        self.event_role_arn = event_role_arn
        # 预付费domain过期时间
        self.expire_time = expire_time
        self.file_category = file_category
        self.group_config = group_config
        self.group_single_drive_enabled = group_single_drive_enabled
        # 是否开启了自动初始化 Drive
        self.init_drive_enable = init_drive_enable
        # 自动初始化 Drive 大小
        self.init_drive_size = init_drive_size
        # 自动初始化 Drive 所用 Store ID
        self.init_drive_store_id = init_drive_store_id
        # Domain 类型
        self.mode = mode
        self.multi_revision_config = multi_revision_config
        self.office_edit_config = office_edit_config
        self.office_preview_config = office_preview_config
        self.parallel_upload_enabled = parallel_upload_enabled
        # Parent Domain ID
        self.parent_domain_id = parent_domain_id
        # Domain 类型
        self.path_type = path_type
        # 预付费套餐
        self.prepaid_package = prepaid_package
        self.published_app_access_strategy = published_app_access_strategy
        self.recycle_bin_config = recycle_bin_config
        self.role_config = role_config
        # Domain ServiceCode
        self.service_code = service_code
        # 是否开启了共享
        self.sharable = sharable
        self.share_detail = share_detail
        self.share_link_detail = share_link_detail
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 容量配额
        self.size_quota = size_quota
        self.size_quota_used = size_quota_used
        # SPI 实例 id
        self.spi_instance_id = spi_instance_id
        # domain状态：创建中，正常，已过期
        self.status = status
        # 存储级别
        self.store_level = store_level
        # 存储 Region 列表
        self.store_region_list = store_region_list
        self.subdomain_config = subdomain_config
        # Domain 更新时间
        self.updated_at = updated_at
        # 逻辑空间使用量，单位为字节
        self.used_size = used_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数配额
        self.user_count_quota = user_count_quota
        # user和group只能有一个drive的开关
        self.user_single_drive_enabled = user_single_drive_enabled
        self.video_preview_app_config = video_preview_app_config
        self.video_preview_config = video_preview_config
        self.watermark_config = watermark_config

    def validate(self):
        if self.app_config:
            self.app_config.validate()
        if self.archive_config:
            self.archive_config.validate()
        if self.audit_log_config:
            self.audit_log_config.validate()
        if self.default_super_admin_config:
            self.default_super_admin_config.validate()
        if self.endpoints:
            self.endpoints.validate()
        if self.group_config:
            self.group_config.validate()
        if self.multi_revision_config:
            self.multi_revision_config.validate()
        if self.office_edit_config:
            self.office_edit_config.validate()
        if self.office_preview_config:
            self.office_preview_config.validate()
        if self.published_app_access_strategy:
            self.published_app_access_strategy.validate()
        if self.recycle_bin_config:
            self.recycle_bin_config.validate()
        if self.role_config:
            self.role_config.validate()
        if self.share_detail:
            self.share_detail.validate()
        if self.share_link_detail:
            self.share_link_detail.validate()
        if self.subdomain_config:
            self.subdomain_config.validate()
        if self.video_preview_app_config:
            self.video_preview_app_config.validate()
        if self.video_preview_config:
            self.video_preview_config.validate()
        if self.watermark_config:
            self.watermark_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_cname is not None:
            result['api_cname'] = self.api_cname
        if self.app_cname is not None:
            result['app_cname'] = self.app_cname
        if self.app_config is not None:
            result['app_config'] = self.app_config.to_map()
        if self.archive_config is not None:
            result['archive_config'] = self.archive_config.to_map()
        if self.archive_files_enable is not None:
            result['archive_files_enable'] = self.archive_files_enable
        if self.audit_log_config is not None:
            result['audit_log_config'] = self.audit_log_config.to_map()
        if self.auth_cname is not None:
            result['auth_cname'] = self.auth_cname
        if self.auth_config is not None:
            result['auth_config'] = self.auth_config
        if self.auth_dingding_app_id is not None:
            result['auth_dingding_app_id'] = self.auth_dingding_app_id
        if self.auth_dingding_app_secret is not None:
            result['auth_dingding_app_secret'] = self.auth_dingding_app_secret
        if self.auth_dingding_enable is not None:
            result['auth_dingding_enable'] = self.auth_dingding_enable
        if self.auth_ram_app_id is not None:
            result['auth_ram_app_id'] = self.auth_ram_app_id
        if self.auth_ram_app_secret is not None:
            result['auth_ram_app_secret'] = self.auth_ram_app_secret
        if self.auth_ram_enable is not None:
            result['auth_ram_enable'] = self.auth_ram_enable
        if self.benefits is not None:
            result['benefits'] = self.benefits
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.data_hash_name is not None:
            result['data_hash_name'] = self.data_hash_name
        if self.default_super_admin_config is not None:
            result['default_super_admin_config'] = self.default_super_admin_config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.domain_name is not None:
            result['domain_name'] = self.domain_name
        if self.endpoints is not None:
            result['endpoints'] = self.endpoints.to_map()
        if self.enterprise_customized_login is not None:
            result['enterprise_customized_login'] = self.enterprise_customized_login
        if self.event_filename_matches is not None:
            result['event_filename_matches'] = self.event_filename_matches
        if self.event_mns_endpoint is not None:
            result['event_mns_endpoint'] = self.event_mns_endpoint
        if self.event_mns_topic is not None:
            result['event_mns_topic'] = self.event_mns_topic
        if self.event_names is not None:
            result['event_names'] = self.event_names
        if self.event_role_arn is not None:
            result['event_role_arn'] = self.event_role_arn
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.file_category is not None:
            result['file_category'] = self.file_category
        if self.group_config is not None:
            result['group_config'] = self.group_config.to_map()
        if self.group_single_drive_enabled is not None:
            result['group_single_drive_enabled'] = self.group_single_drive_enabled
        if self.init_drive_enable is not None:
            result['init_drive_enable'] = self.init_drive_enable
        if self.init_drive_size is not None:
            result['init_drive_size'] = self.init_drive_size
        if self.init_drive_store_id is not None:
            result['init_drive_store_id'] = self.init_drive_store_id
        if self.mode is not None:
            result['mode'] = self.mode
        if self.multi_revision_config is not None:
            result['multi_revision_config'] = self.multi_revision_config.to_map()
        if self.office_edit_config is not None:
            result['office_edit_config'] = self.office_edit_config.to_map()
        if self.office_preview_config is not None:
            result['office_preview_config'] = self.office_preview_config.to_map()
        if self.parallel_upload_enabled is not None:
            result['parallel_upload_enabled'] = self.parallel_upload_enabled
        if self.parent_domain_id is not None:
            result['parent_domain_id'] = self.parent_domain_id
        if self.path_type is not None:
            result['path_type'] = self.path_type
        if self.prepaid_package is not None:
            result['prepaid_package'] = self.prepaid_package
        if self.published_app_access_strategy is not None:
            result['published_app_access_strategy'] = self.published_app_access_strategy.to_map()
        if self.recycle_bin_config is not None:
            result['recycle_bin_config'] = self.recycle_bin_config.to_map()
        if self.role_config is not None:
            result['role_config'] = self.role_config.to_map()
        if self.service_code is not None:
            result['service_code'] = self.service_code
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_detail is not None:
            result['share_detail'] = self.share_detail.to_map()
        if self.share_link_detail is not None:
            result['share_link_detail'] = self.share_link_detail.to_map()
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.size_quota is not None:
            result['size_quota'] = self.size_quota
        if self.size_quota_used is not None:
            result['size_quota_used'] = self.size_quota_used
        if self.spi_instance_id is not None:
            result['spi_instance_id'] = self.spi_instance_id
        if self.status is not None:
            result['status'] = self.status
        if self.store_level is not None:
            result['store_level'] = self.store_level
        if self.store_region_list is not None:
            result['store_region_list'] = self.store_region_list
        if self.subdomain_config is not None:
            result['subdomain_config'] = self.subdomain_config.to_map()
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.used_size is not None:
            result['used_size'] = self.used_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_count_quota is not None:
            result['user_count_quota'] = self.user_count_quota
        if self.user_single_drive_enabled is not None:
            result['user_single_drive_enabled'] = self.user_single_drive_enabled
        if self.video_preview_app_config is not None:
            result['video_preview_app_config'] = self.video_preview_app_config.to_map()
        if self.video_preview_config is not None:
            result['video_preview_config'] = self.video_preview_config.to_map()
        if self.watermark_config is not None:
            result['watermark_config'] = self.watermark_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_cname') is not None:
            self.api_cname = m.get('api_cname')
        if m.get('app_cname') is not None:
            self.app_cname = m.get('app_cname')
        if m.get('app_config') is not None:
            temp_model = AppConfig()
            self.app_config = temp_model.from_map(m['app_config'])
        if m.get('archive_config') is not None:
            temp_model = ArchiveConfig()
            self.archive_config = temp_model.from_map(m['archive_config'])
        if m.get('archive_files_enable') is not None:
            self.archive_files_enable = m.get('archive_files_enable')
        if m.get('audit_log_config') is not None:
            temp_model = AuditLogConfig()
            self.audit_log_config = temp_model.from_map(m['audit_log_config'])
        if m.get('auth_cname') is not None:
            self.auth_cname = m.get('auth_cname')
        if m.get('auth_config') is not None:
            self.auth_config = m.get('auth_config')
        if m.get('auth_dingding_app_id') is not None:
            self.auth_dingding_app_id = m.get('auth_dingding_app_id')
        if m.get('auth_dingding_app_secret') is not None:
            self.auth_dingding_app_secret = m.get('auth_dingding_app_secret')
        if m.get('auth_dingding_enable') is not None:
            self.auth_dingding_enable = m.get('auth_dingding_enable')
        if m.get('auth_ram_app_id') is not None:
            self.auth_ram_app_id = m.get('auth_ram_app_id')
        if m.get('auth_ram_app_secret') is not None:
            self.auth_ram_app_secret = m.get('auth_ram_app_secret')
        if m.get('auth_ram_enable') is not None:
            self.auth_ram_enable = m.get('auth_ram_enable')
        if m.get('benefits') is not None:
            self.benefits = m.get('benefits')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('data_hash_name') is not None:
            self.data_hash_name = m.get('data_hash_name')
        if m.get('default_super_admin_config') is not None:
            temp_model = DomainSuperAdminConfig()
            self.default_super_admin_config = temp_model.from_map(m['default_super_admin_config'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('domain_name') is not None:
            self.domain_name = m.get('domain_name')
        if m.get('endpoints') is not None:
            temp_model = DomainEndpointsResponse()
            self.endpoints = temp_model.from_map(m['endpoints'])
        if m.get('enterprise_customized_login') is not None:
            self.enterprise_customized_login = m.get('enterprise_customized_login')
        if m.get('event_filename_matches') is not None:
            self.event_filename_matches = m.get('event_filename_matches')
        if m.get('event_mns_endpoint') is not None:
            self.event_mns_endpoint = m.get('event_mns_endpoint')
        if m.get('event_mns_topic') is not None:
            self.event_mns_topic = m.get('event_mns_topic')
        if m.get('event_names') is not None:
            self.event_names = m.get('event_names')
        if m.get('event_role_arn') is not None:
            self.event_role_arn = m.get('event_role_arn')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('file_category') is not None:
            self.file_category = m.get('file_category')
        if m.get('group_config') is not None:
            temp_model = GroupConfig()
            self.group_config = temp_model.from_map(m['group_config'])
        if m.get('group_single_drive_enabled') is not None:
            self.group_single_drive_enabled = m.get('group_single_drive_enabled')
        if m.get('init_drive_enable') is not None:
            self.init_drive_enable = m.get('init_drive_enable')
        if m.get('init_drive_size') is not None:
            self.init_drive_size = m.get('init_drive_size')
        if m.get('init_drive_store_id') is not None:
            self.init_drive_store_id = m.get('init_drive_store_id')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('multi_revision_config') is not None:
            temp_model = BaseMultiRevisionConfigResponse()
            self.multi_revision_config = temp_model.from_map(m['multi_revision_config'])
        if m.get('office_edit_config') is not None:
            temp_model = OfficeEditConfig()
            self.office_edit_config = temp_model.from_map(m['office_edit_config'])
        if m.get('office_preview_config') is not None:
            temp_model = OfficePreviewConfig()
            self.office_preview_config = temp_model.from_map(m['office_preview_config'])
        if m.get('parallel_upload_enabled') is not None:
            self.parallel_upload_enabled = m.get('parallel_upload_enabled')
        if m.get('parent_domain_id') is not None:
            self.parent_domain_id = m.get('parent_domain_id')
        if m.get('path_type') is not None:
            self.path_type = m.get('path_type')
        if m.get('prepaid_package') is not None:
            self.prepaid_package = m.get('prepaid_package')
        if m.get('published_app_access_strategy') is not None:
            temp_model = AppAccessStrategy()
            self.published_app_access_strategy = temp_model.from_map(m['published_app_access_strategy'])
        if m.get('recycle_bin_config') is not None:
            temp_model = RecycleBinConfig()
            self.recycle_bin_config = temp_model.from_map(m['recycle_bin_config'])
        if m.get('role_config') is not None:
            temp_model = RoleConfig()
            self.role_config = temp_model.from_map(m['role_config'])
        if m.get('service_code') is not None:
            self.service_code = m.get('service_code')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_detail') is not None:
            temp_model = ShareDetailResponse()
            self.share_detail = temp_model.from_map(m['share_detail'])
        if m.get('share_link_detail') is not None:
            temp_model = ShareLinkDetailResponse()
            self.share_link_detail = temp_model.from_map(m['share_link_detail'])
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('size_quota') is not None:
            self.size_quota = m.get('size_quota')
        if m.get('size_quota_used') is not None:
            self.size_quota_used = m.get('size_quota_used')
        if m.get('spi_instance_id') is not None:
            self.spi_instance_id = m.get('spi_instance_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('store_level') is not None:
            self.store_level = m.get('store_level')
        if m.get('store_region_list') is not None:
            self.store_region_list = m.get('store_region_list')
        if m.get('subdomain_config') is not None:
            temp_model = SubdomainConfig()
            self.subdomain_config = temp_model.from_map(m['subdomain_config'])
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_count_quota') is not None:
            self.user_count_quota = m.get('user_count_quota')
        if m.get('user_single_drive_enabled') is not None:
            self.user_single_drive_enabled = m.get('user_single_drive_enabled')
        if m.get('video_preview_app_config') is not None:
            temp_model = VideoPreviewAppConfig()
            self.video_preview_app_config = temp_model.from_map(m['video_preview_app_config'])
        if m.get('video_preview_config') is not None:
            temp_model = VideoPreviewConfig()
            self.video_preview_config = temp_model.from_map(m['video_preview_config'])
        if m.get('watermark_config') is not None:
            temp_model = BaseWatermarkConfigResponse()
            self.watermark_config = temp_model.from_map(m['watermark_config'])
        return self


class UpdateIdentityToBenefitPkgMappingRequest(TeaModel):
    """
    update identity to benefit pkg mapping request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        amount: int = None,
        benefit_pkg_id: str = None,
        custom_benefit_meta: dict = None,
        delivery_id: str = None,
        domain_id: str = None,
        expire_time: int = None,
        identity_id: str = None,
        identity_type: str = None,
        nonce_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 权益包数量
        self.amount = amount
        # 权益包的唯一标识
        self.benefit_pkg_id = benefit_pkg_id
        # 实体权益包关联的自定义Meta
        self.custom_benefit_meta = custom_benefit_meta
        # 权益下发的唯一标识
        self.delivery_id = delivery_id
        # domain ID
        self.domain_id = domain_id
        # 权益包超期时间的时间戳，单位为毫秒
        self.expire_time = expire_time
        # 实体的唯一标识，如 userID
        self.identity_id = identity_id
        # 实体类型，当前支持user类型实体
        self.identity_type = identity_type
        # nonce ID
        self.nonce_id = nonce_id

    def validate(self):
        self.validate_required(self.benefit_pkg_id, 'benefit_pkg_id')
        self.validate_required(self.identity_id, 'identity_id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.amount is not None:
            result['amount'] = self.amount
        if self.benefit_pkg_id is not None:
            result['benefit_pkg_id'] = self.benefit_pkg_id
        if self.custom_benefit_meta is not None:
            result['custom_benefit_meta'] = self.custom_benefit_meta
        if self.delivery_id is not None:
            result['delivery_id'] = self.delivery_id
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        if self.expire_time is not None:
            result['expire_time'] = self.expire_time
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.nonce_id is not None:
            result['nonce_id'] = self.nonce_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('amount') is not None:
            self.amount = m.get('amount')
        if m.get('benefit_pkg_id') is not None:
            self.benefit_pkg_id = m.get('benefit_pkg_id')
        if m.get('custom_benefit_meta') is not None:
            self.custom_benefit_meta = m.get('custom_benefit_meta')
        if m.get('delivery_id') is not None:
            self.delivery_id = m.get('delivery_id')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        if m.get('expire_time') is not None:
            self.expire_time = m.get('expire_time')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('nonce_id') is not None:
            self.nonce_id = m.get('nonce_id')
        return self


class UpdateSubdomainRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        name: str = None,
        sharable: bool = None,
        share_link_enabled: bool = None,
        status: int = None,
        subdomain_id: str = None,
        total_size: int = None,
        used_size_refresh_interval: int = None,
        user_quota: int = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # 名称
        self.name = name
        # 是否开启了共享
        self.sharable = sharable
        # 是否开启了分享
        self.share_link_enabled = share_link_enabled
        # 状态
        self.status = status
        # 用以唯一标识subdomain
        self.subdomain_id = subdomain_id
        # 逻辑空间quota，-1表示无限制，单位为字节
        self.total_size = total_size
        # 逻辑空间刷新周期，单位：秒
        self.used_size_refresh_interval = used_size_refresh_interval
        # 用户数quota，-1表示无限制
        self.user_quota = user_quota

    def validate(self):
        self.validate_required(self.subdomain_id, 'subdomain_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.sharable is not None:
            result['sharable'] = self.sharable
        if self.share_link_enabled is not None:
            result['share_link_enabled'] = self.share_link_enabled
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.used_size_refresh_interval is not None:
            result['used_size_refresh_interval'] = self.used_size_refresh_interval
        if self.user_quota is not None:
            result['user_quota'] = self.user_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sharable') is not None:
            self.sharable = m.get('sharable')
        if m.get('share_link_enabled') is not None:
            self.share_link_enabled = m.get('share_link_enabled')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('used_size_refresh_interval') is not None:
            self.used_size_refresh_interval = m.get('used_size_refresh_interval')
        if m.get('user_quota') is not None:
            self.user_quota = m.get('user_quota')
        return self


class VideoPreviewAudio(TeaModel):
    """
    音频转码参数
    """
    def __init__(
        self,
        audio_bitrate: int = None,
        audio_channel: int = None,
        audio_codec: str = None,
        audio_sample_rate: int = None,
    ):
        self.audio_bitrate = audio_bitrate
        self.audio_channel = audio_channel
        self.audio_codec = audio_codec
        self.audio_sample_rate = audio_sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_bitrate is not None:
            result['audio_bitrate'] = self.audio_bitrate
        if self.audio_channel is not None:
            result['audio_channel'] = self.audio_channel
        if self.audio_codec is not None:
            result['audio_codec'] = self.audio_codec
        if self.audio_sample_rate is not None:
            result['audio_sample_rate'] = self.audio_sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('audio_bitrate') is not None:
            self.audio_bitrate = m.get('audio_bitrate')
        if m.get('audio_channel') is not None:
            self.audio_channel = m.get('audio_channel')
        if m.get('audio_codec') is not None:
            self.audio_codec = m.get('audio_codec')
        if m.get('audio_sample_rate') is not None:
            self.audio_sample_rate = m.get('audio_sample_rate')
        return self


class VideoPreviewVideo(TeaModel):
    """
    视频转码参数
    """
    def __init__(
        self,
        height: int = None,
        keep_original: bool = None,
        video_bitrate: int = None,
        video_codec: str = None,
        video_frame_rate: int = None,
        width: int = None,
    ):
        self.height = height
        self.keep_original = keep_original
        self.video_bitrate = video_bitrate
        self.video_codec = video_codec
        self.video_frame_rate = video_frame_rate
        self.width = width

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['height'] = self.height
        if self.keep_original is not None:
            result['keep_original'] = self.keep_original
        if self.video_bitrate is not None:
            result['video_bitrate'] = self.video_bitrate
        if self.video_codec is not None:
            result['video_codec'] = self.video_codec
        if self.video_frame_rate is not None:
            result['video_frame_rate'] = self.video_frame_rate
        if self.width is not None:
            result['width'] = self.width
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('height') is not None:
            self.height = m.get('height')
        if m.get('keep_original') is not None:
            self.keep_original = m.get('keep_original')
        if m.get('video_bitrate') is not None:
            self.video_bitrate = m.get('video_bitrate')
        if m.get('video_codec') is not None:
            self.video_codec = m.get('video_codec')
        if m.get('video_frame_rate') is not None:
            self.video_frame_rate = m.get('video_frame_rate')
        if m.get('width') is not None:
            self.width = m.get('width')
        return self


class WatermarkTextConfig(TeaModel):
    """
    WatermarkTextConfig 文字水印配置
    """
    def __init__(
        self,
        bold: bool = None,
        fill_style: str = None,
        font: str = None,
        horizontal: int = None,
        rotate: int = None,
        size: int = None,
        vertical: int = None,
    ):
        self.bold = bold
        self.fill_style = fill_style
        self.font = font
        self.horizontal = horizontal
        self.rotate = rotate
        self.size = size
        self.vertical = vertical

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bold is not None:
            result['bold'] = self.bold
        if self.fill_style is not None:
            result['fill_style'] = self.fill_style
        if self.font is not None:
            result['font'] = self.font
        if self.horizontal is not None:
            result['horizontal'] = self.horizontal
        if self.rotate is not None:
            result['rotate'] = self.rotate
        if self.size is not None:
            result['size'] = self.size
        if self.vertical is not None:
            result['vertical'] = self.vertical
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bold') is not None:
            self.bold = m.get('bold')
        if m.get('fill_style') is not None:
            self.fill_style = m.get('fill_style')
        if m.get('font') is not None:
            self.font = m.get('font')
        if m.get('horizontal') is not None:
            self.horizontal = m.get('horizontal')
        if m.get('rotate') is not None:
            self.rotate = m.get('rotate')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('vertical') is not None:
            self.vertical = m.get('vertical')
        return self


class PunishFileRequest(TeaModel):
    """
    处罚文件请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        action_code: str = None,
        drive_id: str = None,
        file_id: str = None,
        punish_reason: str = None,
    ):
        self.httpheaders = httpheaders
        self.action_code = action_code
        self.drive_id = drive_id
        self.file_id = file_id
        self.punish_reason = punish_reason

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.action_code is not None:
            result['action_code'] = self.action_code
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.punish_reason is not None:
            result['punish_reason'] = self.punish_reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('action_code') is not None:
            self.action_code = m.get('action_code')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('punish_reason') is not None:
            self.punish_reason = m.get('punish_reason')
        return self


class SearchViewFilesResponse(TeaModel):
    """
    search view files response
    """
    def __init__(
        self,
        items: List[ViewFileItem] = None,
        next_marker: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.next_marker = next_marker
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ViewFileItem()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class AddUserToSubdomainRequest(TeaModel):
    """
    # Add user to subdomain request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        role: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.role = role
        # subdomain id
        self.subdomain_id = subdomain_id
        # 用户 ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.role is not None:
            result['role'] = self.role
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class AssignRequest(TeaModel):
    """
    分配角色请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        disinherit_sub_group: bool = None,
        identity: Identity = None,
        manage_resource_id: str = None,
        manage_resource_type: str = None,
        role_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 子团队是否继承此权限
        self.disinherit_sub_group = disinherit_sub_group
        self.identity = identity
        # 管辖的资源ID
        self.manage_resource_id = manage_resource_id
        # 管辖的资源类型，目前只支持团队: IT_Group
        self.manage_resource_type = manage_resource_type
        # 授予的角色，目前支持：SystemGroupAdmin(团队管理员)
        self.role_id = role_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.disinherit_sub_group, 'disinherit_sub_group')
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.manage_resource_id, 'manage_resource_id')
        self.validate_required(self.manage_resource_type, 'manage_resource_type')
        self.validate_required(self.role_id, 'role_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.disinherit_sub_group is not None:
            result['disinherit_sub_group'] = self.disinherit_sub_group
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.manage_resource_id is not None:
            result['manage_resource_id'] = self.manage_resource_id
        if self.manage_resource_type is not None:
            result['manage_resource_type'] = self.manage_resource_type
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('disinherit_sub_group') is not None:
            self.disinherit_sub_group = m.get('disinherit_sub_group')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('manage_resource_id') is not None:
            self.manage_resource_id = m.get('manage_resource_id')
        if m.get('manage_resource_type') is not None:
            self.manage_resource_type = m.get('manage_resource_type')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class BaseActionItemRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        action: str = None,
    ):
        self.action = action

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        return self


class BaseGroupIDRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        group_id: str = None,
        subdomain_id: str = None,
    ):
        # group id
        self.group_id = group_id
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class BaseGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        description: str = None,
        group_name: str = None,
        is_root: bool = None,
    ):
        # 描述
        self.description = description
        # 名称
        self.group_name = group_name
        # 是否是根group
        self.is_root = is_root

    def validate(self):
        self.validate_required(self.group_name, 'group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_root is not None:
            result['is_root'] = self.is_root
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_root') is not None:
            self.is_root = m.get('is_root')
        return self


class BindDeviceRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        device_info: str = None,
        device_name: str = None,
        device_type: str = None,
        fs_type: str = None,
        manufacturer: str = None,
        total_size: int = None,
        used_size: int = None,
    ):
        self.httpheaders = httpheaders
        # device_info
        self.device_info = device_info
        # device_name
        self.device_name = device_name
        # device_type
        self.device_type = device_type
        # fs_type
        self.fs_type = fs_type
        # manufacturer
        self.manufacturer = manufacturer
        # total_size
        self.total_size = total_size
        # used_size
        self.used_size = used_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.device_info is not None:
            result['device_info'] = self.device_info
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.device_type is not None:
            result['device_type'] = self.device_type
        if self.fs_type is not None:
            result['fs_type'] = self.fs_type
        if self.manufacturer is not None:
            result['manufacturer'] = self.manufacturer
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.used_size is not None:
            result['used_size'] = self.used_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('device_info') is not None:
            self.device_info = m.get('device_info')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('device_type') is not None:
            self.device_type = m.get('device_type')
        if m.get('fs_type') is not None:
            self.fs_type = m.get('fs_type')
        if m.get('manufacturer') is not None:
            self.manufacturer = m.get('manufacturer')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('used_size') is not None:
            self.used_size = m.get('used_size')
        return self


class CancelAssignRequest(TeaModel):
    """
    取消角色请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        identity: Identity = None,
        manage_resource_id: str = None,
        manage_resource_type: str = None,
        role_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.identity = identity
        # 管辖的资源ID
        self.manage_resource_id = manage_resource_id
        # 管辖的资源类型，目前只支持团队: IT_Group
        self.manage_resource_type = manage_resource_type
        # 授予的角色，目前支持：SystemGroupAdmin(团队管理员)
        self.role_id = role_id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.manage_resource_id, 'manage_resource_id')
        self.validate_required(self.manage_resource_type, 'manage_resource_type')
        self.validate_required(self.role_id, 'role_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.manage_resource_id is not None:
            result['manage_resource_id'] = self.manage_resource_id
        if self.manage_resource_type is not None:
            result['manage_resource_type'] = self.manage_resource_type
        if self.role_id is not None:
            result['role_id'] = self.role_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('manage_resource_id') is not None:
            self.manage_resource_id = m.get('manage_resource_id')
        if m.get('manage_resource_type') is not None:
            self.manage_resource_type = m.get('manage_resource_type')
        if m.get('role_id') is not None:
            self.role_id = m.get('role_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class CreateGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        group_name: str = None,
        is_root: bool = None,
        parent_group_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # 名称
        self.group_name = group_name
        # 是否是根group
        self.is_root = is_root
        # parent group id
        self.parent_group_id = parent_group_id
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.group_name, 'group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_root is not None:
            result['is_root'] = self.is_root
        if self.parent_group_id is not None:
            result['parent_group_id'] = self.parent_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_root') is not None:
            self.is_root = m.get('is_root')
        if m.get('parent_group_id') is not None:
            self.parent_group_id = m.get('parent_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class CreateMembershipRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        group_id: str = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # group id
        self.group_id = group_id
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class CreatePermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        action_list: List[BaseActionItemRequest] = None,
        collection: str = None,
        condition: Condition = None,
        effect: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
        user_tags: List[str] = None,
    ):
        self.httpheaders = httpheaders
        self.action_list = action_list
        self.collection = collection
        self.condition = condition
        self.effect = effect
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type
        self.user_tags = user_tags

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        result['action_list'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['action_list'].append(k.to_map() if k else None)
        if self.collection is not None:
            result['collection'] = self.collection
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.effect is not None:
            result['effect'] = self.effect
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.resource is not None:
            result['resource'] = self.resource
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        self.action_list = []
        if m.get('action_list') is not None:
            for k in m.get('action_list'):
                temp_model = BaseActionItemRequest()
                self.action_list.append(temp_model.from_map(k))
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        return self


class CreateSyncMappingRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        addition_data: str = None,
        custom_meta: str = None,
        device_name: str = None,
        drive_id: str = None,
        file_id: str = None,
        fs_id: str = None,
        hidden: bool = None,
        local_path: str = None,
        name: str = None,
        sync_mode: str = None,
    ):
        self.httpheaders = httpheaders
        # addition_data
        self.addition_data = addition_data
        # custom_meta
        self.custom_meta = custom_meta
        # device_name
        self.device_name = device_name
        # drive_id
        self.drive_id = drive_id
        # file_id
        self.file_id = file_id
        # fs_id
        self.fs_id = fs_id
        # hidden
        self.hidden = hidden
        # local_path
        self.local_path = local_path
        # name
        self.name = name
        # sync_mode
        self.sync_mode = sync_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.custom_meta is not None:
            result['custom_meta'] = self.custom_meta
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.fs_id is not None:
            result['fs_id'] = self.fs_id
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.local_path is not None:
            result['local_path'] = self.local_path
        if self.name is not None:
            result['name'] = self.name
        if self.sync_mode is not None:
            result['sync_mode'] = self.sync_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('custom_meta') is not None:
            self.custom_meta = m.get('custom_meta')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('fs_id') is not None:
            self.fs_id = m.get('fs_id')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('local_path') is not None:
            self.local_path = m.get('local_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sync_mode') is not None:
            self.sync_mode = m.get('sync_mode')
        return self


class GroupInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        group_id: str = None,
        member_role: str = None,
    ):
        self.group_id = group_id
        # MemberRole 暂不对外，只作保留
        self.member_role = member_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_role is not None:
            result['member_role'] = self.member_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        return self


class CreateUserRequest(TeaModel):
    """
    # Create user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        avatar: str = None,
        default_location: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        email: str = None,
        expired_at: int = None,
        group_info_list: List[GroupInfo] = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        phone: str = None,
        phone_region: str = None,
        plain_password: str = None,
        role: str = None,
        status: str = None,
        subdomain_id: str = None,
        user_data: dict = None,
        user_id: str = None,
        user_name: str = None,
    ):
        self.httpheaders = httpheaders
        # 头像
        self.avatar = avatar
        # 用户默认地域
        self.default_location = default_location
        # 是否能自己修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 描述信息
        self.description = description
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.group_info_list = group_info_list
        # 下次登录后是否强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        # 电话号码
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户明文密码
        self.plain_password = plain_password
        # 角色
        self.role = role
        # 状态
        self.status = status
        # subdomain id
        self.subdomain_id = subdomain_id
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id
        # 用户名称
        self.user_name = user_name

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        if self.group_info_list:
            for k in self.group_info_list:
                if k:
                    k.validate()
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.default_location is not None:
            result['default_location'] = self.default_location
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        result['group_info_list'] = []
        if self.group_info_list is not None:
            for k in self.group_info_list:
                result['group_info_list'].append(k.to_map() if k else None)
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.plain_password is not None:
            result['plain_password'] = self.plain_password
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('default_location') is not None:
            self.default_location = m.get('default_location')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        self.group_info_list = []
        if m.get('group_info_list') is not None:
            for k in m.get('group_info_list'):
                temp_model = GroupInfo()
                self.group_info_list.append(temp_model.from_map(k))
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('plain_password') is not None:
            self.plain_password = m.get('plain_password')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class DeleteGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class DeleteMembershipRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # subdomain id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class DeletePermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        collection: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
    ):
        self.httpheaders = httpheaders
        self.collection = collection
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.collection is not None:
            result['collection'] = self.collection
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.resource is not None:
            result['resource'] = self.resource
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        return self


class DeleteSyncMappingRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        device_name: str = None,
        drive_id: str = None,
        fs_id: str = None,
        local_path: str = None,
        sync_mode: str = None,
        sync_root_id: str = None,
    ):
        self.httpheaders = httpheaders
        # device_name
        self.device_name = device_name
        # drive_id
        self.drive_id = drive_id
        # fs_id
        self.fs_id = fs_id
        # local_path
        self.local_path = local_path
        # sync_mode
        self.sync_mode = sync_mode
        # sync_root_id
        self.sync_root_id = sync_root_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.fs_id is not None:
            result['fs_id'] = self.fs_id
        if self.local_path is not None:
            result['local_path'] = self.local_path
        if self.sync_mode is not None:
            result['sync_mode'] = self.sync_mode
        if self.sync_root_id is not None:
            result['sync_root_id'] = self.sync_root_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('fs_id') is not None:
            self.fs_id = m.get('fs_id')
        if m.get('local_path') is not None:
            self.local_path = m.get('local_path')
        if m.get('sync_mode') is not None:
            self.sync_mode = m.get('sync_mode')
        if m.get('sync_root_id') is not None:
            self.sync_root_id = m.get('sync_root_id')
        return self


class DeleteUserRequest(TeaModel):
    """
    # Delete user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 用户 ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class DeleteUserResponse(TeaModel):
    """
    Delete user response
    """
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class GetAppDebugCmdRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
    ):
        self.httpheaders = httpheaders
        # app_id
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class GetGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetMembershipRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # subdomain id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GetPermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        collection: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
    ):
        self.httpheaders = httpheaders
        self.collection = collection
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.collection is not None:
            result['collection'] = self.collection
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.resource is not None:
            result['resource'] = self.resource
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        return self


class GetUserRequest(TeaModel):
    """
    # Get user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 用户 ID, 使用ak方式访问，该项必传, access_token访问如果不传，默认取自己的user信息
        # example
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class GroupExtraItem(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        created_at: int = None,
        creator: str = None,
        description: str = None,
        domain_id: str = None,
        drive_list: List[BaseDriveResponse] = None,
        group_id: str = None,
        group_name: str = None,
        is_sync: bool = None,
        permission: dict = None,
        updated_at: int = None,
    ):
        # created_at
        self.created_at = created_at
        # creator
        self.creator = creator
        # description
        self.description = description
        # domain id
        self.domain_id = domain_id
        self.drive_list = drive_list
        # group id
        self.group_id = group_id
        # group name
        self.group_name = group_name
        self.is_sync = is_sync
        self.permission = permission
        # updated_at
        self.updated_at = updated_at

    def validate(self):
        if self.drive_list:
            for k in self.drive_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.domain_id is not None:
            result['domain_id'] = self.domain_id
        result['drive_list'] = []
        if self.drive_list is not None:
            for k in self.drive_list:
                result['drive_list'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_sync is not None:
            result['is_sync'] = self.is_sync
        if self.permission is not None:
            result['permission'] = self.permission
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('domain_id') is not None:
            self.domain_id = m.get('domain_id')
        self.drive_list = []
        if m.get('drive_list') is not None:
            for k in m.get('drive_list'):
                temp_model = BaseDriveResponse()
                self.drive_list.append(temp_model.from_map(k))
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_sync') is not None:
            self.is_sync = m.get('is_sync')
        if m.get('permission') is not None:
            self.permission = m.get('permission')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        return self


class HasMemberRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # subdomain id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ImportUserRequest(TeaModel):
    """
    # Import user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        authentication_display_name: str = None,
        authentication_type: str = None,
        auto_create_drive: bool = None,
        custom_identity: str = None,
        deny_change_password_by_self: bool = None,
        drive_total_size: int = None,
        expired_at: int = None,
        extra: str = None,
        identity: str = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        parent_group_id: str = None,
        plain_password: str = None,
    ):
        self.httpheaders = httpheaders
        # 认证方式的显示名称
        self.authentication_display_name = authentication_display_name
        # 认证类型
        self.authentication_type = authentication_type
        # 自动创建空间
        self.auto_create_drive = auto_create_drive
        self.custom_identity = custom_identity
        # 是否能自己修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 空间大小
        self.drive_total_size = drive_total_size
        # 用户过期时间
        self.expired_at = expired_at
        # 额外的信息，比如type为mobile时，此字段为国家编号，不填默认86
        self.extra = extra
        # 唯一身份标识
        self.identity = identity
        # 下次登录后是否强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        # 加入到group
        self.parent_group_id = parent_group_id
        # 用户明文密码
        self.plain_password = plain_password

    def validate(self):
        self.validate_required(self.authentication_type, 'authentication_type')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.nick_name, 'nick_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.authentication_display_name is not None:
            result['authentication_display_name'] = self.authentication_display_name
        if self.authentication_type is not None:
            result['authentication_type'] = self.authentication_type
        if self.auto_create_drive is not None:
            result['auto_create_drive'] = self.auto_create_drive
        if self.custom_identity is not None:
            result['custom_identity'] = self.custom_identity
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.drive_total_size is not None:
            result['drive_total_size'] = self.drive_total_size
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        if self.extra is not None:
            result['extra'] = self.extra
        if self.identity is not None:
            result['identity'] = self.identity
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.parent_group_id is not None:
            result['parent_group_id'] = self.parent_group_id
        if self.plain_password is not None:
            result['plain_password'] = self.plain_password
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('authentication_display_name') is not None:
            self.authentication_display_name = m.get('authentication_display_name')
        if m.get('authentication_type') is not None:
            self.authentication_type = m.get('authentication_type')
        if m.get('auto_create_drive') is not None:
            self.auto_create_drive = m.get('auto_create_drive')
        if m.get('custom_identity') is not None:
            self.custom_identity = m.get('custom_identity')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('drive_total_size') is not None:
            self.drive_total_size = m.get('drive_total_size')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('parent_group_id') is not None:
            self.parent_group_id = m.get('parent_group_id')
        if m.get('plain_password') is not None:
            self.plain_password = m.get('plain_password')
        return self


class Int64Range(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        from_: int = None,
        to: int = None,
    ):
        self.from_ = from_
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class ListDeviceRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # limit
        self.limit = limit
        # marker
        self.marker = marker

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListDirectChildMembershipsRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        group_id: str = None,
        limit: int = None,
        marker: str = None,
        member_type: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # group id
        self.group_id = group_id
        # 分页获取的数量，默认为100
        self.limit = limit
        # 游标
        self.marker = marker
        # 角色，可选值，["", "user", "group"], ""表示获取所有类型
        self.member_type = member_type
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListDirectParentMembershipsRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 分页获取的数量，默认为100
        self.limit = limit
        # 游标
        self.marker = marker
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # subdomain id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class ListGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        extra_return_info: List[str] = None,
        limit: int = None,
        marker: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.extra_return_info = extra_return_info
        # 分页获取的数量，默认为100
        self.limit = limit
        # 游标
        self.marker = marker
        # 列举 subdomain 下的group
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.extra_return_info is not None:
            result['extra_return_info'] = self.extra_return_info
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('extra_return_info') is not None:
            self.extra_return_info = m.get('extra_return_info')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListIdentityRoleRequest(TeaModel):
    """
    列举用户或团队的角色列表请求
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        identity: Identity = None,
        include_group_role: bool = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.identity = identity
        # 是否包含所属父级团队的角色
        self.include_group_role = include_group_role
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.identity, 'identity')
        if self.identity:
            self.identity.validate()
        self.validate_required(self.include_group_role, 'include_group_role')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.identity is not None:
            result['identity'] = self.identity.to_map()
        if self.include_group_role is not None:
            result['include_group_role'] = self.include_group_role
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('identity') is not None:
            temp_model = Identity()
            self.identity = temp_model.from_map(m['identity'])
        if m.get('include_group_role') is not None:
            self.include_group_role = m.get('include_group_role')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ListPermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        collection: str = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        self.collection = collection
        self.limit = limit
        self.marker = marker

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.collection is not None:
            result['collection'] = self.collection
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListSyncMappingRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        sync_mode: str = None,
        device_name: str = None,
        limit: int = None,
        marker: str = None,
    ):
        self.httpheaders = httpheaders
        # SyncMode
        self.sync_mode = sync_mode
        # device_name
        self.device_name = device_name
        # limit
        self.limit = limit
        # marker
        self.marker = marker

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.sync_mode is not None:
            result['SyncMode'] = self.sync_mode
        if self.device_name is not None:
            result['device_name'] = self.device_name
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('SyncMode') is not None:
            self.sync_mode = m.get('SyncMode')
        if m.get('device_name') is not None:
            self.device_name = m.get('device_name')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        return self


class ListUserRequest(TeaModel):
    """
    # List user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        limit: int = None,
        marker: str = None,
        status: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 每页大小限制
        self.limit = limit
        # 翻页标记
        self.marker = marker
        # 用户状态
        # status: enabled
        self.status = status
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class MemberIDInfo(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        member_type: str = None,
        sub_group_id: str = None,
        user_id: str = None,
    ):
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class MigrateUserToSubdomainRequest(TeaModel):
    """
    MigrateUserToSubdomainRequest uc migrate user
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # subdomain_id
        self.subdomain_id = subdomain_id
        # user_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class RemoveUserFromSubdomainRequest(TeaModel):
    """
    # Remove user to subdomain request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # subdomain id
        self.subdomain_id = subdomain_id
        # 用户 ID
        self.user_id = user_id

    def validate(self):
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class RollbackUserFromSubdomainRequest(TeaModel):
    """
    RollbackUserFromSubdomainRequest uc migrate user
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # subdomain_id
        self.subdomain_id = subdomain_id
        # user_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class SearchGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        extra_return_info: List[str] = None,
        group_name: str = None,
        group_name_for_fuzzy: str = None,
        limit: int = None,
        marker: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        self.extra_return_info = extra_return_info
        # group_name
        self.group_name = group_name
        # group_name_for_fuzzy
        self.group_name_for_fuzzy = group_name_for_fuzzy
        # 分页获取的数量，默认为100
        self.limit = limit
        # 游标
        self.marker = marker
        # 列举 subdomain 下的group
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.extra_return_info is not None:
            result['extra_return_info'] = self.extra_return_info
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.group_name_for_fuzzy is not None:
            result['group_name_for_fuzzy'] = self.group_name_for_fuzzy
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('extra_return_info') is not None:
            self.extra_return_info = m.get('extra_return_info')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('group_name_for_fuzzy') is not None:
            self.group_name_for_fuzzy = m.get('group_name_for_fuzzy')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SearchPermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        collection: str = None,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        query: str = None,
    ):
        self.httpheaders = httpheaders
        self.collection = collection
        self.limit = limit
        self.marker = marker
        self.order_by = order_by
        self.query = query

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.collection is not None:
            result['collection'] = self.collection
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        return self


class SearchUserAndGroupRequest(TeaModel):
    """
    # Search user and group request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        identity_type_list: List[str] = None,
        limit: int = None,
        marker: str = None,
        name: str = None,
        name_for_fuzzy: str = None,
        status: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 搜索实体对象类型
        self.identity_type_list = identity_type_list
        # 每页大小限制
        self.limit = limit
        # 翻页标记
        self.marker = marker
        # 名称前缀搜索，Group名，或者用户昵称
        self.name = name
        # 名称模糊搜索，Group名，或者用户昵称
        self.name_for_fuzzy = name_for_fuzzy
        # 用户状态
        # status: enabled
        self.status = status
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.identity_type_list is not None:
            result['identity_type_list'] = self.identity_type_list
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.name is not None:
            result['name'] = self.name
        if self.name_for_fuzzy is not None:
            result['name_for_fuzzy'] = self.name_for_fuzzy
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('identity_type_list') is not None:
            self.identity_type_list = m.get('identity_type_list')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('name_for_fuzzy') is not None:
            self.name_for_fuzzy = m.get('name_for_fuzzy')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class SearchUserRequest(TeaModel):
    """
    # Search user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_status: str = None,
        email: str = None,
        expired_at_range: Int64Range = None,
        limit: int = None,
        marker: str = None,
        nick_name: str = None,
        nick_name_for_fuzzy: str = None,
        order_by: str = None,
        order_direction: str = None,
        phone: str = None,
        role: str = None,
        status: str = None,
        subdomain_id: str = None,
        user_name: str = None,
    ):
        self.httpheaders = httpheaders
        self.drive_status = drive_status
        # 邮箱
        self.email = email
        self.expired_at_range = expired_at_range
        # 每页大小限制
        self.limit = limit
        # 翻页标记
        self.marker = marker
        # 昵称
        self.nick_name = nick_name
        # 昵称-模糊搜索
        self.nick_name_for_fuzzy = nick_name_for_fuzzy
        self.order_by = order_by
        self.order_direction = order_direction
        # 电话号码
        self.phone = phone
        # 角色
        self.role = role
        # 状态
        self.status = status
        # subdomain id
        self.subdomain_id = subdomain_id
        # 用户名
        self.user_name = user_name

    def validate(self):
        if self.expired_at_range:
            self.expired_at_range.validate()
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 100)
            self.validate_minimum(self.limit, 'limit', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_status is not None:
            result['drive_status'] = self.drive_status
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at_range is not None:
            result['expired_at_range'] = self.expired_at_range.to_map()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.nick_name_for_fuzzy is not None:
            result['nick_name_for_fuzzy'] = self.nick_name_for_fuzzy
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        if self.phone is not None:
            result['phone'] = self.phone
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_name is not None:
            result['user_name'] = self.user_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_status') is not None:
            self.drive_status = m.get('drive_status')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at_range') is not None:
            temp_model = Int64Range()
            self.expired_at_range = temp_model.from_map(m['expired_at_range'])
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('nick_name_for_fuzzy') is not None:
            self.nick_name_for_fuzzy = m.get('nick_name_for_fuzzy')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_name') is not None:
            self.user_name = m.get('user_name')
        return self


class UpdateGroupRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        group_id: str = None,
        group_name: str = None,
        is_root: bool = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # group id
        self.group_id = group_id
        # 名称
        self.group_name = group_name
        # 是否是根group
        self.is_root = is_root
        # subdomain id
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.group_name, 'group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.is_root is not None:
            result['is_root'] = self.is_root
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('is_root') is not None:
            self.is_root = m.get('is_root')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class UpdateMembershipRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        description: str = None,
        group_id: str = None,
        member_role: str = None,
        member_type: str = None,
        sub_group_id: str = None,
        subdomain_id: str = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 描述
        self.description = description
        # group id
        self.group_id = group_id
        # 角色， member or admin
        self.member_role = member_role
        self.member_type = member_type
        self.sub_group_id = sub_group_id
        # subdomain id
        self.subdomain_id = subdomain_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.description is not None:
            result['description'] = self.description
        if self.group_id is not None:
            result['group_id'] = self.group_id
        if self.member_role is not None:
            result['member_role'] = self.member_role
        if self.member_type is not None:
            result['member_type'] = self.member_type
        if self.sub_group_id is not None:
            result['sub_group_id'] = self.sub_group_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        if m.get('member_role') is not None:
            self.member_role = m.get('member_role')
        if m.get('member_type') is not None:
            self.member_type = m.get('member_type')
        if m.get('sub_group_id') is not None:
            self.sub_group_id = m.get('sub_group_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class UpdatePermissionRequest(TeaModel):
    """
    request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        action_list: List[BaseActionItemRequest] = None,
        collection: str = None,
        condition: Condition = None,
        effect: str = None,
        identity_id: str = None,
        identity_type: str = None,
        resource: str = None,
        resource_type: str = None,
        user_tags: List[str] = None,
    ):
        self.httpheaders = httpheaders
        self.action_list = action_list
        self.collection = collection
        self.condition = condition
        self.effect = effect
        self.identity_id = identity_id
        self.identity_type = identity_type
        self.resource = resource
        self.resource_type = resource_type
        self.user_tags = user_tags

    def validate(self):
        if self.action_list:
            for k in self.action_list:
                if k:
                    k.validate()
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        result['action_list'] = []
        if self.action_list is not None:
            for k in self.action_list:
                result['action_list'].append(k.to_map() if k else None)
        if self.collection is not None:
            result['collection'] = self.collection
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.effect is not None:
            result['effect'] = self.effect
        if self.identity_id is not None:
            result['identity_id'] = self.identity_id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.resource is not None:
            result['resource'] = self.resource
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.user_tags is not None:
            result['user_tags'] = self.user_tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        self.action_list = []
        if m.get('action_list') is not None:
            for k in m.get('action_list'):
                temp_model = BaseActionItemRequest()
                self.action_list.append(temp_model.from_map(k))
        if m.get('collection') is not None:
            self.collection = m.get('collection')
        if m.get('condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('identity_id') is not None:
            self.identity_id = m.get('identity_id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('user_tags') is not None:
            self.user_tags = m.get('user_tags')
        return self


class UpdateUserRequest(TeaModel):
    """
    # Update user request
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        avatar: str = None,
        deny_change_password_by_self: bool = None,
        description: str = None,
        email: str = None,
        expired_at: int = None,
        group_info_list: List[GroupInfo] = None,
        need_change_password_next_login: bool = None,
        nick_name: str = None,
        phone: str = None,
        phone_region: str = None,
        plain_password: str = None,
        role: str = None,
        status: str = None,
        user_data: dict = None,
        user_id: str = None,
    ):
        self.httpheaders = httpheaders
        # 头像
        self.avatar = avatar
        # 是否能自己修改密码
        self.deny_change_password_by_self = deny_change_password_by_self
        # 描述信息
        self.description = description
        # 邮箱
        self.email = email
        # 用户过期时间
        self.expired_at = expired_at
        self.group_info_list = group_info_list
        # 下次登录后是否强制修改密码
        self.need_change_password_next_login = need_change_password_next_login
        # 昵称
        self.nick_name = nick_name
        # 电话号码
        self.phone = phone
        # 国家编码
        self.phone_region = phone_region
        # 用户明文密码
        self.plain_password = plain_password
        # 角色
        self.role = role
        # 状态
        self.status = status
        # 用户自定义数据，格式为json，可用于配置项、少量临时数据等存储，不超过1K
        self.user_data = user_data
        # 用户 ID
        self.user_id = user_id

    def validate(self):
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 1024)
        if self.group_info_list:
            for k in self.group_info_list:
                if k:
                    k.validate()
        self.validate_required(self.user_id, 'user_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.deny_change_password_by_self is not None:
            result['deny_change_password_by_self'] = self.deny_change_password_by_self
        if self.description is not None:
            result['description'] = self.description
        if self.email is not None:
            result['email'] = self.email
        if self.expired_at is not None:
            result['expired_at'] = self.expired_at
        result['group_info_list'] = []
        if self.group_info_list is not None:
            for k in self.group_info_list:
                result['group_info_list'].append(k.to_map() if k else None)
        if self.need_change_password_next_login is not None:
            result['need_change_password_next_login'] = self.need_change_password_next_login
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_region is not None:
            result['phone_region'] = self.phone_region
        if self.plain_password is not None:
            result['plain_password'] = self.plain_password
        if self.role is not None:
            result['role'] = self.role
        if self.status is not None:
            result['status'] = self.status
        if self.user_data is not None:
            result['user_data'] = self.user_data
        if self.user_id is not None:
            result['user_id'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('deny_change_password_by_self') is not None:
            self.deny_change_password_by_self = m.get('deny_change_password_by_self')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expired_at') is not None:
            self.expired_at = m.get('expired_at')
        self.group_info_list = []
        if m.get('group_info_list') is not None:
            for k in m.get('group_info_list'):
                temp_model = GroupInfo()
                self.group_info_list.append(temp_model.from_map(k))
        if m.get('need_change_password_next_login') is not None:
            self.need_change_password_next_login = m.get('need_change_password_next_login')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phone_region') is not None:
            self.phone_region = m.get('phone_region')
        if m.get('plain_password') is not None:
            self.plain_password = m.get('plain_password')
        if m.get('role') is not None:
            self.role = m.get('role')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('user_data') is not None:
            self.user_data = m.get('user_data')
        if m.get('user_id') is not None:
            self.user_id = m.get('user_id')
        return self


class UpgradeCheckAppRequest(TeaModel):
    """
    *\
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        app_id: str = None,
        arch: str = None,
        version: str = None,
    ):
        self.httpheaders = httpheaders
        # app_id
        self.app_id = app_id
        # arch
        self.arch = arch
        # version
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.arch is not None:
            result['arch'] = self.arch
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('arch') is not None:
            self.arch = m.get('arch')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetDomainSummaryRequest(TeaModel):
    """
    查询 domain 概况
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
    ):
        self.httpheaders = httpheaders

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        return self


class GetDriveUsedSizeRequest(TeaModel):
    """
    查询 Drive 使用空间
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        self.validate_required(self.drive_id, 'drive_id')
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetFileCountRequest(TeaModel):
    """
    查询 Domain 或 Drive 下文件数
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        drive_id: str = None,
        file_ext: str = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # drive_id
        self.drive_id = drive_id
        # file_ext
        self.file_ext = file_ext
        # subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        if self.drive_id is not None:
            self.validate_pattern(self.drive_id, 'drive_id', '[0-9]+')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.drive_id is not None:
            result['drive_id'] = self.drive_id
        if self.file_ext is not None:
            result['file_ext'] = self.file_ext
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('drive_id') is not None:
            self.drive_id = m.get('drive_id')
        if m.get('file_ext') is not None:
            self.file_ext = m.get('file_ext')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class GetSubdomainSummaryRequest(TeaModel):
    """
    查询 subdomain 概况
    """
    def __init__(
        self,
        httpheaders: Dict[str, str] = None,
        subdomain_id: str = None,
    ):
        self.httpheaders = httpheaders
        # subdomain
        self.subdomain_id = subdomain_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.httpheaders is not None:
            result['httpheaders'] = self.httpheaders
        if self.subdomain_id is not None:
            result['subdomain_id'] = self.subdomain_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('httpheaders') is not None:
            self.httpheaders = m.get('httpheaders')
        if m.get('subdomain_id') is not None:
            self.subdomain_id = m.get('subdomain_id')
        return self


class ClearAllRecycleBinRequest(TeaModel):
    """
    清理所有回收站文件元数据请求
    """
    def __init__(
        self,
        addition_data: dict = None,
        file_path_type: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        self.file_path_type = file_path_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        return self


class ClearAllRecycleBinResponse(TeaModel):
    """
    clear all recycle bin response
    """
    def __init__(
        self,
        items: List[ClearRecycleBinResponse] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ClearRecycleBinResponse()
                self.items.append(temp_model.from_map(k))
        return self


class SearchAllRecycleBinRequest(TeaModel):
    """
    搜索所有回收站文件元数据请求
    """
    def __init__(
        self,
        addition_data: dict = None,
        fields: str = None,
        file_path_type: str = None,
        image_cropping_aspect_ratios: List[str] = None,
        image_thumbnail_process: str = None,
        image_url_process: str = None,
        limit: int = None,
        location: str = None,
        marker: str = None,
        office_thumbnail_process: str = None,
        order_by: str = None,
        query: str = None,
        recursive: bool = None,
        referer: str = None,
        sign_token: str = None,
        url_expire_sec: int = None,
        video_thumbnail_process: str = None,
    ):
        # addition_data
        self.addition_data = addition_data
        # fields
        self.fields = fields
        self.file_path_type = file_path_type
        self.image_cropping_aspect_ratios = image_cropping_aspect_ratios
        # image_thumbnail_process
        self.image_thumbnail_process = image_thumbnail_process
        # image_url_process
        self.image_url_process = image_url_process
        # limit
        self.limit = limit
        # location
        self.location = location
        # Marker
        self.marker = marker
        # office_thumbnail_process
        self.office_thumbnail_process = office_thumbnail_process
        # order_by
        self.order_by = order_by
        # query
        self.query = query
        self.recursive = recursive
        # referer
        self.referer = referer
        # sign_token
        self.sign_token = sign_token
        # url_expire_sec
        self.url_expire_sec = url_expire_sec
        # video_thumbnail_process
        # type:string
        self.video_thumbnail_process = video_thumbnail_process

    def validate(self):
        if self.limit is not None:
            self.validate_maximum(self.limit, 'limit', 200)
            self.validate_minimum(self.limit, 'limit', 1)
        if self.query is not None:
            self.validate_max_length(self.query, 'query', 4096)
        if self.url_expire_sec is not None:
            self.validate_maximum(self.url_expire_sec, 'url_expire_sec', 14400)
            self.validate_minimum(self.url_expire_sec, 'url_expire_sec', 10)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_data is not None:
            result['addition_data'] = self.addition_data
        if self.fields is not None:
            result['fields'] = self.fields
        if self.file_path_type is not None:
            result['file_path_type'] = self.file_path_type
        if self.image_cropping_aspect_ratios is not None:
            result['image_cropping_aspect_ratios'] = self.image_cropping_aspect_ratios
        if self.image_thumbnail_process is not None:
            result['image_thumbnail_process'] = self.image_thumbnail_process
        if self.image_url_process is not None:
            result['image_url_process'] = self.image_url_process
        if self.limit is not None:
            result['limit'] = self.limit
        if self.location is not None:
            result['location'] = self.location
        if self.marker is not None:
            result['marker'] = self.marker
        if self.office_thumbnail_process is not None:
            result['office_thumbnail_process'] = self.office_thumbnail_process
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.query is not None:
            result['query'] = self.query
        if self.recursive is not None:
            result['recursive'] = self.recursive
        if self.referer is not None:
            result['referer'] = self.referer
        if self.sign_token is not None:
            result['sign_token'] = self.sign_token
        if self.url_expire_sec is not None:
            result['url_expire_sec'] = self.url_expire_sec
        if self.video_thumbnail_process is not None:
            result['video_thumbnail_process'] = self.video_thumbnail_process
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addition_data') is not None:
            self.addition_data = m.get('addition_data')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        if m.get('file_path_type') is not None:
            self.file_path_type = m.get('file_path_type')
        if m.get('image_cropping_aspect_ratios') is not None:
            self.image_cropping_aspect_ratios = m.get('image_cropping_aspect_ratios')
        if m.get('image_thumbnail_process') is not None:
            self.image_thumbnail_process = m.get('image_thumbnail_process')
        if m.get('image_url_process') is not None:
            self.image_url_process = m.get('image_url_process')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('location') is not None:
            self.location = m.get('location')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('office_thumbnail_process') is not None:
            self.office_thumbnail_process = m.get('office_thumbnail_process')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('recursive') is not None:
            self.recursive = m.get('recursive')
        if m.get('referer') is not None:
            self.referer = m.get('referer')
        if m.get('sign_token') is not None:
            self.sign_token = m.get('sign_token')
        if m.get('url_expire_sec') is not None:
            self.url_expire_sec = m.get('url_expire_sec')
        if m.get('video_thumbnail_process') is not None:
            self.video_thumbnail_process = m.get('video_thumbnail_process')
        return self


class SearchAllRecycleBinResponse(TeaModel):
    """
    search all recycle bin response
    """
    def __init__(
        self,
        items: List[BaseCCPFileResponse] = None,
        next_marker: str = None,
    ):
        # items
        self.items = items
        # next_marker
        self.next_marker = next_marker

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.next_marker is not None:
            result['next_marker'] = self.next_marker
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BaseCCPFileResponse()
                self.items.append(temp_model.from_map(k))
        if m.get('next_marker') is not None:
            self.next_marker = m.get('next_marker')
        return self


class ShareListReceivedRequest(TeaModel):
    """
    list received share request
    """
    def __init__(
        self,
        limit: int = None,
        marker: str = None,
        order_by: str = None,
        order_direction: str = None,
    ):
        self.limit = limit
        self.marker = marker
        self.order_by = order_by
        self.order_direction = order_direction

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limit is not None:
            result['limit'] = self.limit
        if self.marker is not None:
            result['marker'] = self.marker
        if self.order_by is not None:
            result['order_by'] = self.order_by
        if self.order_direction is not None:
            result['order_direction'] = self.order_direction
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('marker') is not None:
            self.marker = m.get('marker')
        if m.get('order_by') is not None:
            self.order_by = m.get('order_by')
        if m.get('order_direction') is not None:
            self.order_direction = m.get('order_direction')
        return self


